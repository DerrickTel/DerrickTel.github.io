<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【重识前端】暴走的异步编程 | Derrick</title><meta name="description" content="【重识前端】暴走的异步编程"><meta name="keywords" content="JavaScript"><meta name="author" content="Derrick"><meta name="copyright" content="Derrick"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【重识前端】暴走的异步编程"><meta name="twitter:description" content="【重识前端】暴走的异步编程"><meta name="twitter:image" content="http://derricktel.github.io/image/cover/web.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="【重识前端】暴走的异步编程"><meta property="og:url" content="http://derricktel.github.io/2020/08/28/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%9A%B4%E8%B5%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Derrick"><meta property="og:description" content="【重识前端】暴走的异步编程"><meta property="og:image" content="http://derricktel.github.io/image/cover/web.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://derricktel.github.io/2020/08/28/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%9A%B4%E8%B5%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><link rel="prev" title="【重识前端】redux源码阅读" href="http://derricktel.github.io/2020/09/11/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91redux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><link rel="next" title="【重识前端】深入内存世界" href="http://derricktel.github.io/2020/08/25/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步callback"><span class="toc-number">2.</span> <span class="toc-text">异步callback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发布-订阅模式"><span class="toc-number">3.</span> <span class="toc-text">发布-订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">4.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#回调救星"><span class="toc-number">4.1.</span> <span class="toc-text">回调救星</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#涉及面试题"><span class="toc-number">4.2.</span> <span class="toc-text">涉及面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#promise是什么？"><span class="toc-number">4.2.1.</span> <span class="toc-text">promise是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise解决了什么问题？"><span class="toc-number">4.2.2.</span> <span class="toc-text">promise解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#可读性"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">可读性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#信任问题"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">信任问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手撕A-规范的promise"><span class="toc-number">4.3.</span> <span class="toc-text">手撕A+规范的promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#支持异步"><span class="toc-number">4.3.1.</span> <span class="toc-text">支持异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式调用then"><span class="toc-number">4.3.2.</span> <span class="toc-text">链式调用then</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-number">5.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">6.</span> <span class="toc-text">async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-number">6.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">7.</span> <span class="toc-text">Reference</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/image/cover/web.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Derrick</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【重识前端】暴走的异步编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-28 22:47:09"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-02 17:12:43"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%87%8D%E6%8B%BE%E5%89%8D%E7%AB%AF/">重拾前端</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>
<p><a href="https://juejin.im/post/6850418113944420359" target="_blank" rel="noopener">【重识前端】原型/原型链和继承</a></p>
<p><a href="https://juejin.im/post/6850418117508759566" target="_blank" rel="noopener">【重识前端】闭包与模块</a></p>
<p><a href="https://juejin.im/post/6854573215658803208" target="_blank" rel="noopener">【重识前端】全面攻破this</a></p>
<p><a href="https://juejin.im/post/6859911609633767438" target="_blank" rel="noopener">【重识前端】一次搞定JavaScript的执行机制</a></p>
<p><a href="https://juejin.im/post/6860375101322461198" target="_blank" rel="noopener">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>
<p><a href="https://juejin.im/post/6865204092877144077" target="_blank" rel="noopener">【重识前端】深入内存世界</a></p>
<p><a href="https://juejin.im/post/6867814019055484942" target="_blank" rel="noopener">【重识前端】暴走的异步编程</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>老规矩，还是先了解一下什么是异步。异步其实是一个相对比较高级的一个概念。</p>
<p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p>
<p>如果说一个事情需要等待上一件事情做完才能做，但是他们之前又没有强耦合关系。这样就在那里干等就毫无意义。特别是现在计算机普遍都有多核CPU的时代。</p>
<p>举一个形象的🌰。</p>
<p>我们现在要去吃海底捞（海底捞打钱！），我们发现要排队，需要排2个小时左右，这个时候我们要干嘛？难道是干等吗？肯定不是！那样蠢蠢的硬等很呆，我们可能会拿出手机刷刷朋友圈，或者玩一把紧张刺激的王者荣耀又或者去看一场电影等等….在我们做这些事情的时候我们的排队并没有被耽误，甚至可以和服务员说快到了打个电话给我（这个是常见的callback方法，待会讨论）</p>
<blockquote>
<p>这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。</p>
</blockquote>
<p>本文总结了几个异步的方案，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。</p>
<h2 id="异步callback"><a href="#异步callback" class="headerlink" title="异步callback"></a>异步callback</h2><p>上来就是一个英俊的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response = fetch(<span class="string">'myImage.png'</span>);</span><br><span class="line"><span class="keyword">var</span> blob = response.blob();</span><br></pre></td></tr></table></figure>

<p>没有人可以完美预测到每种网络情况下这个response，是否可以完美获得fetch获得的内容，很有可能会报错。</p>
<p>这个时候我们的callback就✨bu ling bu ling的登场啦。</p>
<p>有些小伙伴可能觉得callback似乎和自己没有太大关系。。。emmmm….</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'You clicked me!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样呢？有没有感觉有点儿熟悉了，其他这个就相当于react中的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&#123;()</span> =&gt;</span>&#123;alert('You clicked me!');&#125;&#125;&gt;</span><br><span class="line">	点我  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是很熟悉，这个其实就是最常见的callback（回调函数）。</p>
<p>又或者比较常见的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	alert(<span class="string">'You clicked me!'</span>);</span><br><span class="line">&#125;，<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<p>很常见，大致意思就是2秒钟之后会回调一下这个匿名函数，虽然不一定会准确执行，这个涉及到事件循环，感兴趣的可以去找一下我前阵子写的事件循环😊。</p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>发布-订阅模式：又称为观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。</p>
<p>在写React的时候，有一个非常非常非常常见的🌰：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [derrick, setDerrick] = useState(<span class="number">0</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(derrick)</span><br><span class="line">  &#125;, [derrick])</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123;setDerrick(derrick+<span class="number">1</span>)&#125;&#125;&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>useEffect订阅了derrick这个变量的变化，然后监听到变化之后就会进行一次log，打印出derrick变量的值。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="回调救星"><a href="#回调救星" class="headerlink" title="回调救星"></a>回调救星</h3><p>之前介绍过回调函数这种异步编程。</p>
<p>加入我希望在A执行完之后执行B，然后执行C，然后执行D….最后执行Z</p>
<p>写出来的代码可能是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span> (<span class="params">name, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayhello(<span class="string">"first"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sayhello(<span class="string">"second"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    sayhello(<span class="string">"third"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>像本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复 杂的功能时，回调函数也会存在问题:若想让两个异步操作并行运行，并且在它们都结束后 提醒你，那该怎么做?若想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么 做?</p>
<p>在这些情况下，你需要追踪多个回调函数并做清理操作， 不过好在promise横空出世拯救了世界。</p>
<h3 id="涉及面试题"><a href="#涉及面试题" class="headerlink" title="涉及面试题"></a>涉及面试题</h3><blockquote>
<p>promise用过吗？请你介绍一下promise。</p>
</blockquote>
<p>其实这里很多同学可能就不知道怎么介绍了，可能只停留在怎么用。我们可以从几个方面来介绍。</p>
<ul>
<li>promise是什么？</li>
<li>promise解决了什么问题</li>
<li>promise的优缺点</li>
</ul>
<h4 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h4><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<h4 id="promise解决了什么问题？"><a href="#promise解决了什么问题？" class="headerlink" title="promise解决了什么问题？"></a>promise解决了什么问题？</h4><ol>
<li>解决可读性的问题</li>
<li>解决信任问题</li>
</ol>
<h5 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h5><p>可读性，之前的回调地狱promise就可以优雅的解决。(还有更加优雅的，待会会介绍。)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name);</span><br><span class="line">      resolve();　　<span class="comment">//在异步操作执行完后执行 resolve() 函数</span></span><br><span class="line">    &#125;, <span class="number">10000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sayhello(<span class="string">"first"</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sayhello(<span class="string">"second"</span>);　　<span class="comment">//仍然返回一个 Promise 对象</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sayhello(<span class="string">"third"</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h5><p>这个问题可以用promise的几个特点来解释：</p>
<blockquote>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</blockquote>
<p>由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信任问题演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        cb &amp;&amp; cb();</span><br><span class="line">        <span class="comment">//因为某些bug导致某个函数多执行了一次</span></span><br><span class="line">        cb &amp;&amp; cb();</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">            <span class="comment">//resolve成功调用一次之后，后面的不会再执行</span></span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,<span class="number">1000</span>);        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制反转。体现在对于函数的把控，比如this等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        cb &amp;&amp; cb.call(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;);<span class="comment">//执行回调，但是添油加醋</span></span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve();<span class="comment">//调用的resolve都是自己写的，改善了控制反转的问题</span></span><br><span class="line">        &#125;,<span class="number">1000</span>);        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手撕A-规范的promise"><a href="#手撕A-规范的promise" class="headerlink" title="手撕A+规范的promise"></a>手撕A+规范的promise</h3><blockquote>
<p>面试题：你知道promise的A+规范吗？（本人在浩鲸科技被问到的，当时答的支支吾吾。。。）</p>
</blockquote>
<p>我何止是知道，我甚至可以手写一个符合A+规范的promise！</p>
<p>A+规范快速入口，<a href="https://promisesaplus.com/" target="_blank" rel="noopener">点我</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>promise里面最难的就是then了，我们必须将这个方法写在他的原型链上面，并且他接受两个参数，一个是成功的回调，一个是失败的回调。</p>
<p>废话不多说，开冲！</p>
<h4 id="支持异步"><a href="#支持异步" class="headerlink" title="支持异步"></a>支持异步</h4><p>在此之前，我们需要加两个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>颜值高又细心的同学会发现，我多加了两个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储成功的回调</span></span><br><span class="line">self.onResolved = [];</span><br><span class="line"><span class="comment">// 存储失败的回调</span></span><br><span class="line">self.onRejected = [];</span><br></pre></td></tr></table></figure>

<p>这两个变量呢，也非常好理解，就是存储回调的。那么有一个非常非常重要的问题，我写的时候也困扰了好久，为什么一定要是一个数组呢？我存储为一个函数不行吗？到时候执行就行啦。。。</p>
<p>qs，和我想一样的帅哥靓女可能比较多。这里我统一回复：</p>
<p>假如说。以下的情况出现的话，咋办。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">4</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//4 res</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res1</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//4 res1</span></span><br><span class="line">    <span class="built_in">console</span>.log(res1, <span class="string">'res1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种情况出现，如果我们只是一个函数，那么我们的<code>console.log(res, &#39;res&#39;)</code>这辈子都无法问世，为什么？因为被后门的<code>console.log(res1, &#39;res&#39;)</code>给覆盖了呀。对不对，如果说这个<code>resolve</code>他延迟执行，这个时候我们需要做的是把<code>then</code>函数给保存下来，等到<code>resolve</code>被执行的时候，依次执行我们所有创建的<code>then</code>里面的回调函数。</p>
<p>听懂掌声！</p>
<p>没听懂的接着往下看，我们把剩余工作做完，然后举一个例子。马上就能明白了。</p>
<p>刚刚说到，我们补充两个变量，然后写下我们的<code>then</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    onRejected(self.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class="line">    self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们还需要在<code>resolve</code>或者<code>reject</code>的时候执行我们存储起来的这些函数。</p>
<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onResolved.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    onRejected(self.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class="line">    self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK。我们先试试我们自己写的promise。跑一下demo吧。为了给懒同学便捷的调试，直接CV下面就好啦。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onResolved.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    onRejected(self.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onFulfilled(self.value)</span><br><span class="line">    &#125;)</span><br><span class="line">    self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onRejected(self.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">4</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//4 res</span></span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res1</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//4 res1</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1, <span class="string">'res1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>嗯~如愿输出了，那回到刚刚的问题。我们把回调的地方不要用数组而用函数呢？不用同学们打字了，直接CV👇的代码就好了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onResolved.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    onRejected(self.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onFulfilled(self.value)</span><br><span class="line">    &#125;)</span><br><span class="line">    self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onRejected(self.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">4</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//4 res</span></span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">res1</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//4 res1</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1, <span class="string">'res1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>是不是只有<code>console.log(res1, &#39;res1&#39;)</code>啦？因为执行<code>then</code>的时候，我们的resolve还有没有被调用，如果我们有多个<code>then</code>的话，我们需要把他们存储起来，然后依次调用。所以我们需要用到数组，当然也可以是别的方法，核心思想就是把他们存起来，在需要调用的时候调用。</p>
<p>是不是很好理解？！！</p>
<p>听懂掌声！</p>
<p>而且A+也要求了。</p>
<blockquote>
<p><code>2.2.6:then</code> may be called multiple times on the same promise.</p>
<p>（promise 的 <code>then</code> 可以链式调用多次）</p>
<p>2.2.6.1：If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>
<p>（如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行）</p>
<p>2.2.6.2：If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>
<p>（如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行）</p>
</blockquote>
<p>我们对promise的理解更进一步了。记得把代码改回去，继续往下走。</p>
<p>刚刚我们的demo还不够鲁棒，而且我们的测试用例都是完美情况下。</p>
<p>接下来要剑走偏锋了。</p>
<blockquote>
<p>A+:</p>
<p>2.2.1：Both <code>onFulfilled</code> and <code>onRejected</code> are optional arguments:</p>
<p>（onFulfilled 和 onRejected 都是可选参数：）</p>
<p>2.2.1.1 If <code>onFulfilled</code> is not a function, it must be ignored.</p>
<p>（如果 onFulfilled 不是函数，它会被忽略）</p>
<p>2.2.1.2 If <code>onRejected</code> is not a function, it must be ignored.</p>
<p>（如果 onRejected 不是函数，它会被忽略）</p>
<p>2.2.7.2: If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>
<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>
</blockquote>
<p>所以我们首先要做的就是，把错误给提前捕获，然后丢给<code>reject</code></p>
<p>emmm….接下我贴代码都是一起贴了，因为我怕有同学会掉队，里面也会有相应的注释帮助会走神的同学跟紧这辆五菱宏光。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onResolved.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 捕获错误传给reject。法律规定！</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">  	executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="comment">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; onRejected(self.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">  <span class="comment">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onFulfilled(self.value)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      onRejected(self.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链式调用then"><a href="#链式调用then" class="headerlink" title="链式调用then"></a>链式调用then</h4><p>开始准备进入promise的难点以及核心点：链式调用。</p>
<blockquote>
<p>2.2.7：<code>then</code> must return a promise</p>
<p>（then 方法一定返回一个 promise）</p>
</blockquote>
<p>我们需要返回新的promise的话，可以简单实现，快速迭代。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.2.7.1：If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>.</p>
<p>（如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以[[Resolve]](promise2, x)` 处理解析）</p>
<p>2.2.7.2：If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>
<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>
<p>2.2.7.3：If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.</p>
<p>（如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value）</p>
<p>2.2.7.4：If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</p>
<p>（如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason）</p>
</blockquote>
<p>我们需要将返回内容promise化，需要对onFulfilled和onRejected进行错误处理，这个我们之前就处理过了，如果onFulfilled和onRejected没有传参就继续传递，原生🌰来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">.then(<span class="string">''</span>,<span class="string">''</span>)</span><br><span class="line">.then()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；要做的事情太多了，不当当是判断函数这种简单的判断了，所以我们要抽离一个新的函数来复用统一处理。因此我们进行如下完善：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="comment">// 存储成功的值</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储失败的值</span></span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存储成功的回调</span></span><br><span class="line">  self.onResolved = [];</span><br><span class="line">  <span class="comment">// 存储失败的回调</span></span><br><span class="line">  self.onRejected = [];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下成功的值</span></span><br><span class="line">      self.value = value</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onResolved.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 存下失败的值</span></span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 执行我们存储的函数;</span></span><br><span class="line">      self.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 捕获错误传给reject。法律规定！</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">  	executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, res, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果promise2和结果相同，就自己无限循环调用自己的then了，死亡循环。</span></span><br><span class="line">  <span class="comment">// 举个🌰：var a = function()&#123;return a&#125;，这个then又会自己无限触发。所以就玩完了。</span></span><br><span class="line">  <span class="keyword">if</span>(promise2 === res) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(</span><br><span class="line">    res !== <span class="literal">null</span> </span><br><span class="line">    &amp;&amp; (<span class="keyword">typeof</span> res === <span class="string">'object'</span>) || <span class="keyword">typeof</span> res === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 保存是否已经调用过函数。</span></span><br><span class="line">      <span class="comment">// 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.(如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）)</span></span><br><span class="line">      <span class="keyword">let</span> used = <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2.3.3.1：Let then be x.then. [3.5](把 x.then 赋值给 then 变量)</span></span><br><span class="line">      <span class="comment">// 可以提防有人恶搞。像👇</span></span><br><span class="line">      <span class="comment">// Object.defineProperty(Promise, 'then', &#123;</span></span><br><span class="line">      <span class="comment">//    get: function()&#123;</span></span><br><span class="line">      <span class="comment">//        throw Error('error')</span></span><br><span class="line">      <span class="comment">//    &#125;</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="comment">// 这样的话我们取值就会报错。</span></span><br><span class="line">      <span class="keyword">let</span> then = res.then;</span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise了   </span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          res, </span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 递归解析，直到不是一个promise为止</span></span><br><span class="line">            resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">        	&#125;,</span><br><span class="line">          reason =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(used) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used = <span class="literal">true</span>;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(used) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是函数或者对象也不为空就直接继续传递这个值。</span></span><br><span class="line">	  resolve(res);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 只有promise才可以持续的链式调用then,所以这里弄了一个新的promise</span></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> res = onFulfilled(self.value);</span><br><span class="line">      resolvePromise(promise2, res, resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> res = onRejected(self.reason);</span><br><span class="line">      resolvePromise(promise2, res, resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是pending应该存储当前的回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.onResolved.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = onFulfilled(self.value);</span><br><span class="line">      resolvePromise(promise2, res, resolve, reject);</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = onRejected(self.reason);</span><br><span class="line">      resolvePromise(promise2, res, resolve, reject);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote>
<p>面试题：介绍一下generator吧。</p>
</blockquote>
<p>很多小伙伴可能和我一样，只是会用，但是你硬要我介绍，那我咋搞？generator的拼写是g e n e r a t o r？</p>
<p>“哔………………………………”</p>
<p>其实我重温了一下阮老师的es6课程，发现可以从以下几个方面来介绍。</p>
<ul>
<li>形式上<ul>
<li>generator和普通的函数不同点在于，对一个<code>*</code>号，函数内部使用了yield表达式</li>
</ul>
</li>
<li>语法上<ul>
<li>Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。</li>
</ul>
</li>
<li>调用上<ul>
<li>普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。</li>
</ul>
</li>
</ul>
<p>其实我觉得，如果能把下面的这个案例弄清楚，generator就算过关了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>
<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>
<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>
<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>
</ul>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><blockquote>
<p>什么是async/await？</p>
</blockquote>
<p>其实就一句话：<strong>async 函数就是 Generator 函数的语法糖。</strong></p>
<p>generator：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Async:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>
<p>async对generator进行了以下三点的改进：</p>
<ol>
<li><strong>内置执行器。</strong> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
<li><strong>更好的语义。</strong> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
<li><strong>更广的适用性。</strong> co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
</ol>
<p>一个函数如果加上了async，那么就会默认返回一个promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/generator</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Derrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://derricktel.github.io/2020/08/28/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%9A%B4%E8%B5%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">http://derricktel.github.io/2020/08/28/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%9A%B4%E8%B5%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://derricktel.github.io" target="_blank">Derrick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/image/cover/github.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickWechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickAlipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/11/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91redux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><img class="prev_cover lazyload" data-src="/image/cover/web.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【重识前端】redux源码阅读</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/25/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/"><img class="next_cover lazyload" data-src="/image/cover/web.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【重识前端】深入内存世界</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/06/19/window-history-back-缓存-返回上级页面不刷新数据/" title="window.history.back(); 缓存 返回上级页面不刷新数据"><img class="relatedPosts_cover lazyload"data-src="/image/cover/history.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-19</div><div class="relatedPosts_title">window.history.back(); 缓存 返回上级页面不刷新数据</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/10/【重识前端】一次搞定事件循环/" title="【重识前端】一次搞定JavaScript的执行机制"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-10</div><div class="relatedPosts_title">【重识前端】一次搞定JavaScript的执行机制</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/16/【重识前端】全面攻破this/" title="【重识前端】全面攻破this"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-16</div><div class="relatedPosts_title">【重识前端】全面攻破this</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/15/【重识前端】闭包与模块/" title="【重识前端】闭包与模块"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">【重识前端】闭包与模块</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/13/【重识前端】原型原型链和继承/" title="【重识前端】原型/原型链和继承"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">【重识前端】原型/原型链和继承</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/25/【重识前端】深入内存世界/" title="【重识前端】深入内存世界"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-25</div><div class="relatedPosts_title">【重识前端】深入内存世界</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Derrick</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>
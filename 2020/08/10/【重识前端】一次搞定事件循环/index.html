<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【重识前端】一次搞定JavaScript的执行机制 | Derrick</title><meta name="description" content="【重识前端】一次搞定JavaScript的执行机制"><meta name="keywords" content="JavaScript"><meta name="author" content="Derrick"><meta name="copyright" content="Derrick"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【重识前端】一次搞定JavaScript的执行机制"><meta name="twitter:description" content="【重识前端】一次搞定JavaScript的执行机制"><meta name="twitter:image" content="http://derricktel.github.io/image/cover/web.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="【重识前端】一次搞定JavaScript的执行机制"><meta property="og:url" content="http://derricktel.github.io/2020/08/10/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"><meta property="og:site_name" content="Derrick"><meta property="og:description" content="【重识前端】一次搞定JavaScript的执行机制"><meta property="og:image" content="http://derricktel.github.io/image/cover/web.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://derricktel.github.io/2020/08/10/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"><link rel="prev" title="【重识前端】什么是BFC、IFC、GFC 和 FFC" href="http://derricktel.github.io/2020/08/12/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFBFC%E3%80%81IFC%E3%80%81GFC%20%E5%92%8C%20FFC/"><link rel="next" title="【重识前端】全面攻破this" href="http://derricktel.github.io/2020/07/16/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%85%A8%E9%9D%A2%E6%94%BB%E7%A0%B4this/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单线程的JS"><span class="toc-number">2.</span> <span class="toc-text">单线程的JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程和进程的爱恨纠葛"><span class="toc-number">2.1.</span> <span class="toc-text">线程和进程的爱恨纠葛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么JS是单线程？"><span class="toc-number">2.2.</span> <span class="toc-text">为什么JS是单线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器中的消息队列和事件循环"><span class="toc-number">3.</span> <span class="toc-text">浏览器中的消息队列和事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-number">3.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开始"><span class="toc-number">3.2.</span> <span class="toc-text">开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事先约定好的执行顺序"><span class="toc-number">3.2.1.</span> <span class="toc-text">事先约定好的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程运行中，处理突发事件"><span class="toc-number">3.2.2.</span> <span class="toc-text">线程运行中，处理突发事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理其他线程的任务"><span class="toc-number">3.2.3.</span> <span class="toc-text">处理其他线程的任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#退出主线程"><span class="toc-number">3.2.4.</span> <span class="toc-text">退出主线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程的缺点"><span class="toc-number">3.3.</span> <span class="toc-text">单线程的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何处理高优先级的任务"><span class="toc-number">3.3.1.</span> <span class="toc-text">如何处理高优先级的任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何处理调用时间过长的问题"><span class="toc-number">3.3.2.</span> <span class="toc-text">如何处理调用时间过长的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器是怎么实现setTimeout"><span class="toc-number">4.</span> <span class="toc-text">浏览器是怎么实现setTimeout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冷知识"><span class="toc-number">4.1.</span> <span class="toc-text">冷知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏任务和微任务"><span class="toc-number">5.</span> <span class="toc-text">宏任务和微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#宏任务"><span class="toc-number">5.1.</span> <span class="toc-text">宏任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#微任务"><span class="toc-number">5.2.</span> <span class="toc-text">微任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#期末考试"><span class="toc-number">6.</span> <span class="toc-text">期末考试</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/image/cover/web.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Derrick</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【重识前端】一次搞定JavaScript的执行机制</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-10 21:36:40"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-26 16:48:12"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%87%8D%E6%8B%BE%E5%89%8D%E7%AB%AF/">重拾前端</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>
<p><a href="https://juejin.im/post/6850418113944420359" target="_blank" rel="noopener">【重识前端】原型/原型链和继承</a></p>
<p><a href="https://juejin.im/post/6850418117508759566" target="_blank" rel="noopener">【重识前端】闭包与模块</a></p>
<p><a href="https://juejin.im/post/6854573215658803208" target="_blank" rel="noopener">【重识前端】全面攻破this</a></p>
<p><a href="https://juejin.im/post/6859911609633767438" target="_blank" rel="noopener">【重识前端】一次搞定JavaScript的执行机制</a></p>
<p><a href="https://juejin.im/post/6860375101322461198" target="_blank" rel="noopener">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>
<p><a href="https://juejin.im/post/6865204092877144077" target="_blank" rel="noopener">【重识前端】深入内存世界</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事件循环这个事情，其实在我们的工作中或多或少都会碰到，可能我们只是没有去认认真真的理解他，了解他而已。今天我们一起把事件循环吃透。</p>
<h2 id="单线程的JS"><a href="#单线程的JS" class="headerlink" title="单线程的JS"></a>单线程的JS</h2><p>其实，事件循环就是对于单线程的JS应运而生的。</p>
<ul>
<li>单线程？什么是线程，诶，我好像听过进程诶，他们两兄弟啥区别？</li>
<li>为什么js一定要单线程啊，我听说CPU不是有很多核吗？为什么不多线程？</li>
</ul>
<h3 id="线程和进程的爱恨纠葛"><a href="#线程和进程的爱恨纠葛" class="headerlink" title="线程和进程的爱恨纠葛"></a>线程和进程的爱恨纠葛</h3><p>这里我推荐阮一峰老师的一篇文章 </p>
<p><a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">点我学习</a></p>
<h3 id="为什么JS是单线程？"><a href="#为什么JS是单线程？" class="headerlink" title="为什么JS是单线程？"></a>为什么JS是单线程？</h3><blockquote>
<p>这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。</p>
</blockquote>
<h2 id="浏览器中的消息队列和事件循环"><a href="#浏览器中的消息队列和事件循环" class="headerlink" title="浏览器中的消息队列和事件循环"></a>浏览器中的消息队列和事件循环</h2><p>这里暂时只说浏览器中的循环事件循环，有关node的话可能有些细微的差别，不过底层的原理都是差不多的。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里主要是从一个设计者的角度来模拟，从零构建浏览器中的时间循环。为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="事先约定好的执行顺序"><a href="#事先约定好的执行顺序" class="headerlink" title="事先约定好的执行顺序"></a>事先约定好的执行顺序</h4><p>假如我有以下几个任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>+<span class="number">2</span>; <span class="comment">// 任务 1</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>/<span class="number">5</span>; <span class="comment">// 任务 2</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">7</span>*<span class="number">8</span>; <span class="comment">// 任务 3</span></span><br><span class="line"><span class="built_in">console</span>.log(num1, num2, num3)； <span class="comment">// 任务 4</span></span><br></pre></td></tr></table></figure>



<p>如果让我来设计，我就会有一个主线程，然后把他们按顺序排进去，然后顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">1</span>+<span class="number">2</span>; <span class="comment">// 任务 1</span></span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">20</span>/<span class="number">5</span>; <span class="comment">// 任务 2</span></span><br><span class="line">  <span class="keyword">var</span> num3 = <span class="number">7</span>*<span class="number">8</span>; <span class="comment">// 任务 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3)； <span class="comment">// 任务 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😯，我们已经设计了最简单的线程啦。</p>
<h4 id="线程运行中，处理突发事件"><a href="#线程运行中，处理突发事件" class="headerlink" title="线程运行中，处理突发事件"></a>线程运行中，处理突发事件</h4><p>很多时候，所有的任务不是之前就统一安排好的，比如⌨️的输入，🖱的点击等等。</p>
<p>如果想要在线程运行中可以很好的处理这些事件。就需要</p>
<p> ====&gt;事件循环。这里我们用while来实现简单的事件循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awaitt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, resolve);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> awaitt();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainThread();</span><br></pre></td></tr></table></figure>

<p>这样改版之后有了以下几点改进：</p>
<ul>
<li>引入了循环机制</li>
<li>引入事件，然后整个线程在运行的过程中，活了起来，不再是死的，运行完就滚蛋了的那种，有了交互了</li>
</ul>
<p>（🤫最简单的实现。。。别吐槽代码，都是最简单的实现和最简单的场景，助于理解而已。。。）</p>
<h4 id="处理其他线程的任务"><a href="#处理其他线程的任务" class="headerlink" title="处理其他线程的任务"></a>处理其他线程的任务</h4><p>上面的版本用了事件循环的方式来获取内部的事件，但是对于外部突发情况的事件是无法解决的。所以，我们需要升级~</p>
<p>那么怎么设计好一个线程模型呢？我们换个角度想想思路马上就出来了。</p>
<p>这些外部的任务，都是有先后顺序的，哪怕是都是突发情况。他们也是有先后顺序。</p>
<p>所以一个比较通用的模式就是</p>
<p>======&gt; 消息队列</p>
<blockquote>
<p>消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>
</blockquote>
<p>我们要完成以下几个操作：</p>
<ol>
<li>添加一个消息队列；</li>
<li>IO 线程中产生的新任务添加进消息队列尾部；</li>
<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrTask = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTask</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  arrTask.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  addTask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'other'</span>)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awaitt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(arrTask.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> task = arrTask.shift()</span><br><span class="line">        task()</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    	<span class="keyword">await</span> awaitt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line"></span><br><span class="line">mainThread();</span><br><span class="line">otherThread()</span><br></pre></td></tr></table></figure>



<p>我们用一个数组来模拟一个队列。</p>
<p>既基础了内部的任务，也处理了外部突发的任务</p>
<p>有任务进来， 就会执行任务。</p>
<h4 id="退出主线程"><a href="#退出主线程" class="headerlink" title="退出主线程"></a>退出主线程</h4><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrTask = []</span><br><span class="line"><span class="keyword">let</span> over = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTask</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  arrTask.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  addTask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'other'</span>)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awaitt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(arrTask.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> task = arrTask.shift()</span><br><span class="line">        task()</span><br><span class="line">        <span class="keyword">if</span>(!arrTask.length)&#123;</span><br><span class="line">          over = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(over)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">await</span> awaitt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line">addTask(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'in'</span>))</span><br><span class="line"></span><br><span class="line">mainThread();</span><br><span class="line">otherThread()</span><br></pre></td></tr></table></figure>



<h3 id="单线程的缺点"><a href="#单线程的缺点" class="headerlink" title="单线程的缺点"></a>单线程的缺点</h3><p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>
<h4 id="如何处理高优先级的任务"><a href="#如何处理高优先级的任务" class="headerlink" title="如何处理高优先级的任务"></a>如何处理高优先级的任务</h4><p>场景：</p>
<p>假如，我现在有一大串的任务在主线程上执行。</p>
<p>我的dom节点变化的时候，我需要发送请求或者提示一个<code>alert</code>之类的业务逻辑要执行。</p>
<p>现在可行的有两种方案：</p>
<ul>
<li>dom节点变化的话，我就停下现在正在运行的主线程上的任务，然后调用我需要执行的业务逻辑。这样确实具有实效性，但是！这样会使得当前任务的效率极度降低，比如我的dom节点变化200次，那岂不是当前的任务特别久了吗？</li>
<li>第二个方法就可以解决上述的问题：一旦dom节点有变化，哪怕是200000次变化，我都是将业务逻辑push到队列的尾部，这样就不会影响当前任务进行以及效率了。但是！这样的话我的实效性就莫得了。就莫得了。</li>
</ul>
<p>总结一下：其实就是实效性和任务效率的权衡问题罢了。</p>
<p>江江江~</p>
<p>微任务就应运而生啦。</p>
<p>加入我们把任务队列里面的每个任务都称作宏任务的话，每个宏任务里面都会包含一个微任务队列。每个宏任务结束之后，都回去清理一遍微任务队列里面的队列，这样的话既保护了实效性，也保护了任务的效率。</p>
<h4 id="如何处理调用时间过长的问题"><a href="#如何处理调用时间过长的问题" class="headerlink" title="如何处理调用时间过长的问题"></a>如何处理调用时间过长的问题</h4><p>我们都知道js是单线程的。如果现在在执行一个任务的情况下。其他任务就是要等待的。那么就会出现某个任务计算的周期特别长，导致别人都在等待。</p>
<p>👌，我们来验证一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">alter(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>下面的<code>alter</code>永远都不会执行了。因为<code>while</code>在工作，<code>alter</code>在等他把资源让出来。</p>
<p>假如说，我现在有一个动画要进行，但是运行完一帧之后，有一个极其复杂的计算，导致了我的动画不流畅，那么用户可能就会非常的烦。这不是我们希望看到的。</p>
<p>所以js有一个回调机制，到了特定的时间点了，回调一下，把动画的下一帧执行一下，然后继续当前的复杂计算。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>
<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>
<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>
<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>
<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</li>
</ul>
<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p>
<h2 id="浏览器是怎么实现setTimeout"><a href="#浏览器是怎么实现setTimeout" class="headerlink" title="浏览器是怎么实现setTimeout"></a>浏览器是怎么实现setTimeout</h2><p>要想知道浏览器是怎么实现的，我们先回顾一下，我们之前设计的那个事件循环系统：</p>
<p>有xx任务了，ok，我<code>push</code>到任务队列。以此循环。</p>
<p>所以我们写在<code>setTimeout</code>里面的函数执行其实也是一个任务，也是需要push到任务队列去的。</p>
<p>但是，我们的这个是其实是一个异步的函数，不能直接将整个函数push到队列中，否则的话我们的实效性就很有可能出错了，比如我希望他在24小时之后<code>alter</code>告诉我已经到了第二天了。他如果是直接push到任务队列，没有到第二天就会告诉我第二天到了，这不是让用户匪夷所思嘛。</p>
<p>所以肯定不是直接<code>push</code>的。那又是怎么弄得嘞？</p>
<p>你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>
<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p>
<p>我们把之前的事件循环模拟改一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mainTask = [</span><br><span class="line">  fn1,</span><br><span class="line">  fn2,</span><br><span class="line">  fn3,</span><br><span class="line">  ……</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setTimeoutTask = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSetTimeoutTask</span>(<span class="params">fn, timeout</span>)</span>&#123;</span><br><span class="line">  setTimeoutTask.push(&#123;</span><br><span class="line">    fn: fn,</span><br><span class="line">    id: <span class="built_in">Math</span>.random(),</span><br><span class="line">    useTime: timeout + ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runSetTimeoutTask ()&#123;</span><br><span class="line">  <span class="keyword">const</span> runList = []</span><br><span class="line">  setTimeoutTask.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 已经过了时间，或者刚刚好到时间的话就取出来。待会一起执行了</span></span><br><span class="line">    <span class="keyword">if</span>(item.useTime &lt;= ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</span><br><span class="line">      runList.push(item.fn) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span>(runList.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = runList.shift()</span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> task = arrTask.shift()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次执行完一个任务，都回去查找一下延迟队列里面有没有到点的函数</span></span><br><span class="line">    <span class="keyword">if</span>(setTimeoutTask.length) &#123;</span><br><span class="line">       runSetTimeoutTask()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainThread();</span><br></pre></td></tr></table></figure>

<p>所以这里我们会看到一个问题，那就是其实你到点了可能要不会立刻执行，必须等到之前的任务执行完了才轮到延迟队列的查询和执行。</p>
<p>我们代码中有一个彩蛋—-&gt; ID</p>
<p>这个ID有什么用？</p>
<p>就是用于<code>clearTimeout</code></p>
<p>直接传入ID，然后循环找到他，就可以直接从队列里面删掉就好了。</p>
<p>这里就不需要贴代码了吧？</p>
<h3 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h3><ul>
<li><strong>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</strong></li>
<li><strong>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</strong><ul>
<li>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</li>
</ul>
</li>
<li><strong>延时执行时间有最大值</strong><ul>
<li>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</li>
</ul>
</li>
<li><strong>使用 setTimeout 设置的回调函数中的 this 不符合直觉</strong><ul>
<li>这里可以看我之前的文章，有对this进行攻破</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>
<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>
</ul>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>其实通过之前的学习，我们对事件循环已经了解的差不多了，这里主要是更详细了解一下他们。</p>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务有哪些？</p>
<p>除了微任务的都是宏任务。。。</p>
<p>那么微任务有哪些？</p>
<p><code>Process.nextTick</code>、<code>Promise.then catch finally</code>(注意我不是说 Promise)、<code>MutationObserver</code>。</p>
<p>在之前的学习我们知道在宏任务结束之后，会去执行他自己当前的微任务队列。在这个微任务队列执行完成之后再去执行下一个宏任务。</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>异步函数有两种方式：</p>
<p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>
<p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的</strong>。</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
<h2 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<p>大家可以自己在浏览器里面试试吧。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Derrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://derricktel.github.io/2020/08/10/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">http://derricktel.github.io/2020/08/10/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://derricktel.github.io" target="_blank">Derrick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/image/cover/github.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickWechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickAlipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/12/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFBFC%E3%80%81IFC%E3%80%81GFC%20%E5%92%8C%20FFC/"><img class="prev_cover lazyload" data-src="/image/cover/web.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【重识前端】什么是BFC、IFC、GFC 和 FFC</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/16/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%85%A8%E9%9D%A2%E6%94%BB%E7%A0%B4this/"><img class="next_cover lazyload" data-src="/image/cover/web.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【重识前端】全面攻破this</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/06/19/window-history-back-缓存-返回上级页面不刷新数据/" title="window.history.back(); 缓存 返回上级页面不刷新数据"><img class="relatedPosts_cover lazyload"data-src="/image/cover/history.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-19</div><div class="relatedPosts_title">window.history.back(); 缓存 返回上级页面不刷新数据</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/16/【重识前端】全面攻破this/" title="【重识前端】全面攻破this"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-16</div><div class="relatedPosts_title">【重识前端】全面攻破this</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/15/【重识前端】闭包与模块/" title="【重识前端】闭包与模块"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">【重识前端】闭包与模块</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/13/【重识前端】原型原型链和继承/" title="【重识前端】原型/原型链和继承"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">【重识前端】原型/原型链和继承</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/25/【重识前端】深入内存世界/" title="【重识前端】深入内存世界"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-25</div><div class="relatedPosts_title">【重识前端】深入内存世界</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/28/【重识前端】暴走的异步编程/" title="【重识前端】暴走的异步编程"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-28</div><div class="relatedPosts_title">【重识前端】暴走的异步编程</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Derrick</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>
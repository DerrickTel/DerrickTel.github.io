<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>你真的懂React Hook吗？ | Derrick</title><meta name="description" content="你真的懂React Hook吗？"><meta name="keywords" content="ReactHook,React"><meta name="author" content="Derrick"><meta name="copyright" content="Derrick"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="你真的懂React Hook吗？"><meta name="twitter:description" content="你真的懂React Hook吗？"><meta name="twitter:image" content="http://derricktel.github.io/image/cover/React.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="你真的懂React Hook吗？"><meta property="og:url" content="http://derricktel.github.io/2020/05/20/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82React-Hook%E5%90%97/"><meta property="og:site_name" content="Derrick"><meta property="og:description" content="你真的懂React Hook吗？"><meta property="og:image" content="http://derricktel.github.io/image/cover/React.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://derricktel.github.io/2020/05/20/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82React-Hook%E5%90%97/"><link rel="prev" title="【前端进阶】从零搭建属于你的脚手架" href="http://derricktel.github.io/2020/06/06/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E9%85%8D%E7%BD%AE%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"><link rel="next" title="session和cookie的理解" href="http://derricktel.github.io/2020/04/11/session%E5%92%8Ccookie%E7%9A%84%E7%90%86%E8%A7%A3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#探究"><span class="toc-number">2.</span> <span class="toc-text">探究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What"><span class="toc-number">2.1.</span> <span class="toc-text">What</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How"><span class="toc-number">2.2.</span> <span class="toc-text">How</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class组件"><span class="toc-number">2.2.1.</span> <span class="toc-text">Class组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Hook"><span class="toc-number">2.2.2.</span> <span class="toc-text">React Hook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why"><span class="toc-number">2.3.</span> <span class="toc-text">Why</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在组件之间服用状态逻辑很难"><span class="toc-number">2.4.</span> <span class="toc-text">在组件之间服用状态逻辑很难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂组件变得难以理解"><span class="toc-number">2.5.</span> <span class="toc-text">复杂组件变得难以理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class组件-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">Class组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Hook："><span class="toc-number">2.5.2.</span> <span class="toc-text">React Hook：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结论"><span class="toc-number">2.6.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useState"><span class="toc-number">3.</span> <span class="toc-text">useState</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">3.1.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#请回答以下代码的运行结果"><span class="toc-number">3.1.1.</span> <span class="toc-text">请回答以下代码的运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#答案是"><span class="toc-number">3.1.2.</span> <span class="toc-text">答案是</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请回答以下代码的运行结果-1"><span class="toc-number">3.1.3.</span> <span class="toc-text">请回答以下代码的运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#答案是-1"><span class="toc-number">3.1.4.</span> <span class="toc-text">答案是</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect-useLayoutEffect"><span class="toc-number">4.</span> <span class="toc-text">useEffect&#x2F;useLayoutEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提示"><span class="toc-number">4.1.</span> <span class="toc-text">提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect和useLayoutEffect两兄弟的区别是什么？"><span class="toc-number">4.1.1.</span> <span class="toc-text">useEffect和useLayoutEffect两兄弟的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect的错误事例。看看有没有你"><span class="toc-number">4.1.2.</span> <span class="toc-text">useEffect的错误事例。看看有没有你</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么错了？"><span class="toc-number">4.1.3.</span> <span class="toc-text">为什么错了？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？"><span class="toc-number">4.1.4.</span> <span class="toc-text">我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useRef"><span class="toc-number">5.</span> <span class="toc-text">useRef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言-1"><span class="toc-number">5.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useRef-与-createRef-的区别"><span class="toc-number">5.1.1.</span> <span class="toc-text">useRef 与 createRef 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何解决每次render带来类闭包问题？"><span class="toc-number">5.1.2.</span> <span class="toc-text">如何解决每次render带来类闭包问题？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memo"><span class="toc-number">6.</span> <span class="toc-text">memo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#memo没有回调函数的话是怎么浅比较的？"><span class="toc-number">6.0.1.</span> <span class="toc-text">memo没有回调函数的话是怎么浅比较的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memo的回调函数"><span class="toc-number">6.0.2.</span> <span class="toc-text">memo的回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useMemo-useCallback"><span class="toc-number">7.</span> <span class="toc-text">useMemo&#x2F;useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言-2"><span class="toc-number">7.1.</span> <span class="toc-text">前言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useReducer-useContext"><span class="toc-number">8.</span> <span class="toc-text">useReducer&#x2F;useContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言-3"><span class="toc-number">8.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么做？"><span class="toc-number">8.2.</span> <span class="toc-text">怎么做？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useImperativeHandle-forwardRef"><span class="toc-number">9.</span> <span class="toc-text">useImperativeHandle&#x2F;forwardRef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正常使用"><span class="toc-number">9.1.</span> <span class="toc-text">正常使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ant-design-form"><span class="toc-number">9.2.</span> <span class="toc-text">ant-design form</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useDebugValue-自定义Hook"><span class="toc-number">10.</span> <span class="toc-text">useDebugValue&#x2F;自定义Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言-4"><span class="toc-number">10.1.</span> <span class="toc-text">前言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观看之后"><span class="toc-number">11.</span> <span class="toc-text">观看之后</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/image/cover/React.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Derrick</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">你真的懂React Hook吗？</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-20 00:19:44"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-01 18:24:41"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-01</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/React/">React</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>读这篇文章的前提是你已经对React Hook有所了解的情况下，如果你还没有了解，请先移步官网学习一下。<ol>
<li>最好不要去网上看别人的总结之类的，无非就是超的官网的，而且这样会让你的认知从一开始就走偏。</li>
</ol>
</li>
<li>这篇文章主要是探究Hook的动机，使用中的一些疑问；<ol>
<li>使用的话React官网已经讲得很详细了，这里就不多赘述了。</li>
</ol>
</li>
<li>有需要看接下来的疑难点的伙伴欢迎直接跳过探究直接看具体的疑问；</li>
</ol>
<h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><p>主要从3个方面研究React Hook</p>
<p>根据黄金思维圈（What、How、Why）</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>什么是Hook？</p>
<p>打开Google翻译，得到的解释：<em>钩、钩子</em></p>
<blockquote>
<p>再看看React官网的解释：They let you use state and other React features without writing a class.（它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。）</p>
</blockquote>
<p>所以，结合一下。我个人的理解是这样的：对于函数式的组件，可以用钩子（Hook）将想要的外部功能给“钩”进来。</p>
<p>在React Hook出来之前，函数式组件都是无状态的组件，最多就是根据<code>props</code>来加一些判断的逻辑；而在React Hook出来之后就可以在函数式组件里面加入状态（useState），类生命周期（useEffect），甚至是一些自己的复用逻辑（自定义Hook）等等这些外部的功能。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>怎么使用Hook？</p>
<p>大家一起看一下官网的一个例子。</p>
<p>题目：显示一个计数器。当你点击按钮，计数器的值就会增加。</p>
<h4 id="Class组件"><a href="#Class组件" class="headerlink" title="Class组件"></a>Class组件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个叫 "count" 的 state 变量  const [count, setCount] = useState(0);</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这样就算是完成了一个最简单的React Hook 实践，关于一些官方提供的Hook晚点会介绍。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><ul>
<li>为什么会有Hooks？</li>
<li>Hook能解决什么问题？</li>
</ul>
<p>做任何一件事情我觉得都应该理清这个两个问题，这样的话就会事半功倍。</p>
<p>我们先看看React官方是怎么解释“Why”的</p>
<blockquote>
<ol>
<li>在组件之间复用状态逻辑很难</li>
<li>复杂组件变得难以理解</li>
<li>难以理解的 class</li>
</ol>
</blockquote>
<p>本人个人认为第三点是来凑数的….</p>
<p>为什么这么说？</p>
<p>因为React用了这么久了基本都是在使用Class组件，这个是在之前，哪怕是现在学习React的必经之路吧！所以，这点我接下来就会跳过了😂</p>
<h3 id="在组件之间服用状态逻辑很难"><a href="#在组件之间服用状态逻辑很难" class="headerlink" title="在组件之间服用状态逻辑很难"></a>在组件之间服用状态逻辑很难</h3><p>其实高阶组件或者说是props都是很好的解决了复杂的聚合业务逻辑，那为什么说在<strong>组件之间服用状态逻辑很难</strong>呢？</p>
<p>其实道理非常简单。</p>
<p>举个简单的例子，方便大家理解。</p>
<p>场景：有 请求A，请求B，请求C，请求D。他们的请求都有相互依赖关系比如，发请求B的时候必须拿到请求A的结果中的某个值，而请求C也必须拿到请求B的结果中的某个值。以此类推请求D。</p>
<p>Promise出来之前是怎么做的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type:<span class="string">"post"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//成功回调</span></span><br><span class="line">        <span class="comment">//再次异步请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:<span class="string">"post"</span>,</span><br><span class="line">            url:<span class="string">"..."</span>,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//成功回调</span></span><br><span class="line">              <span class="comment">//再次异步请求</span></span><br><span class="line">              $.ajax(&#123;</span><br><span class="line">                  type:<span class="string">"post"</span>,</span><br><span class="line">                  url:<span class="string">"..."</span>,</span><br><span class="line">                  success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                      .......<span class="comment">//如此循环</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这还只是3层，如果是100层呢？那看起来就非常的难受了！</p>
<p>Promise较好的解决了这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(f1)</span><br><span class="line"> .then(f2)</span><br><span class="line"> .then(f3)</span><br><span class="line"> .then(f4)</span><br><span class="line"> .then(f5)</span><br><span class="line"> .then(f5)</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<p>然后是async/await。这里就不展开了，有兴趣的可以自己去了解一下。</p>
<p>结论</p>
<p>之所以这么大费周章的讲是为了解释，React中的高阶组件（HOC）。他的逻辑其实和回调地狱类似，一个两个其实都还算优雅或者说舒服，一旦多了的话。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withHover(</span><br><span class="line">  withTheme(</span><br><span class="line">    withAuth(</span><br><span class="line">      withRepos(Profile)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就会变成这样，不够优雅</span></span><br><span class="line">&lt;WithHover&gt;</span><br><span class="line">  &lt;WithTheme hovering=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">    &lt;WithAuth hovering=&#123;<span class="literal">false</span>&#125; theme=<span class="string">'dark'</span>&gt;</span><br><span class="line">      &lt;WithRepos hovering=&#123;<span class="literal">false</span>&#125; theme=<span class="string">'dark'</span> authed=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">        &lt;Profile </span><br><span class="line">          id=<span class="string">'JavaScript'</span></span><br><span class="line">          loading=&#123;<span class="literal">true</span>&#125; </span><br><span class="line">          repos=&#123;[]&#125;</span><br><span class="line">          authed=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">          theme=<span class="string">'dark'</span></span><br><span class="line">          hovering=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/WithRepos&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>WithAuth&gt;</span><br><span class="line">  &lt;WithTheme&gt;</span><br><span class="line">&lt;<span class="regexp">/WithHover&gt;</span></span><br></pre></td></tr></table></figure>

<p>而且每个高阶组件的逻辑复用我们可能还要一个个去研读。</p>
<h3 id="复杂组件变得难以理解"><a href="#复杂组件变得难以理解" class="headerlink" title="复杂组件变得难以理解"></a>复杂组件变得难以理解</h3><p>其实，这点非常好理解。举一个非常简单常见的例子大家就会明白了。</p>
<p>场景：假如我有一个子组件Child，他的功能是这样的：父组建会给一个id，在组件创建的时候获取一下有关信息，在id改变的时候再重新获取。</p>
<h4 id="Class组件-1"><a href="#Class组件-1" class="headerlink" title="Class组件"></a>Class组件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetch(<span class="keyword">this</span>.props.id)</span><br><span class="line"> &#125;</span><br><span class="line">componentDidUpdate (prevProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevProps.id !== <span class="keyword">this</span>.props.id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetch(<span class="keyword">this</span>.props.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fetch = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">loading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  fetchInfo(id)</span><br><span class="line">    .then(<span class="function"><span class="params">info</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    info,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="React-Hook："><a href="#React-Hook：" class="headerlink" title="React Hook："></a>React Hook：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">loading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  fetchInfo(id)</span><br><span class="line">    .then(<span class="function"><span class="params">info</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    info,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="keyword">this</span>.props.id)</span><br><span class="line">&#125;, [<span class="keyword">this</span>.props.id])</span><br></pre></td></tr></table></figure>



<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>简单的说一下他的优点吧。</p>
<ol>
<li>复用代码更加简单（需要什么就“钩”进来）</li>
<li>清爽的代码风格，一目了然。（useState支持数组和对象，可以清晰的定义特殊的字段等等）</li>
<li>代码量更少（可以看一下我之前的子父组建的例子）</li>
<li>更愿意去写一些小组件复用（我个人喜欢React就是因为他的组件写起来非常的顺手！ps：没有贬低其他框架的意思。。）</li>
<li>其实我个人认为React Hook在宣扬一个观念“按需加载”。</li>
</ol>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>简单的使用在上面的探究-How里面有介绍，更多的在React官网也有介绍。</p>
<h4 id="请回答以下代码的运行结果"><a href="#请回答以下代码的运行结果" class="headerlink" title="请回答以下代码的运行结果"></a>请回答以下代码的运行结果</h4><p><img src="/" class="lazyload" data-src="https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif"  alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。</p>
<blockquote>
<p>分割线</p>
</blockquote>
<p>来自己 <a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">试试吧！</a></p>
<h4 id="答案是"><a href="#答案是" class="headerlink" title="答案是"></a>答案是</h4><p>3</p>
<p>这是为什么呢？function组建究竟是如果工作的呢？</p>
<p>我们发现<code>count</code>在每一次函数调用中都是一个常量值。值得强调的是 — <strong>我们的组件函数每次渲染都会被调用，但是每一次调用中<code>count</code>值都是常量，并且它被赋予了当前渲染中的状态值。</strong></p>
<p>这并不是React特有的，普通的函数也有类似的行为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = person.name;  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + name);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = &#123;<span class="attr">name</span>: <span class="string">'Dan'</span>&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">'Yuzhi'</span>&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">'Dominic'</span>&#125;;</span><br><span class="line">sayHi(someone);</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://codesandbox.io/s/mm6ww11lk8" target="_blank" rel="noopener">这个例子</a>中, 外层的<code>someone</code>会被赋值很多次（就像在React中，<em>当前</em>的组件状态会改变一样）。<strong>然后，在<code>sayHi</code>函数中，局部常量<code>name</code>会和某次调用中的<code>person</code>关联。</strong>因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的<code>name</code>。</p>
<p>这就解释了我们的事件处理函数如何捕获了点击时候的<code>count</code>值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的<code>count</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// During first render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; <span class="comment">// Returned by useState()  // ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After a click, our function is called again</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span>; <span class="comment">// Returned by useState()  // ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After another click, our function is called again</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; <span class="comment">// Returned by useState()  // ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以实际上，每一次渲染都有一个“新版本”的<code>handleAlertClick</code>。每一个版本的<code>handleAlertClick</code>“记住” 了它自己的 <code>count</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// During first render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + <span class="number">0</span>);    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="comment">// The one with 0 inside  // ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After a click, our function is called again</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + <span class="number">1</span>);    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="comment">// The one with 1 inside  // ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After another click, our function is called again</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + <span class="number">2</span>);    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="comment">// The one with 2 inside  // ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为什么<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">在这个demo中</a>中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中<code>counter</code>的状态值。</p>
<p><strong>在任意一次渲染中，props和state是始终保持不变的。</strong>如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>
<h4 id="请回答以下代码的运行结果-1"><a href="#请回答以下代码的运行结果-1" class="headerlink" title="请回答以下代码的运行结果"></a>请回答以下代码的运行结果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count+<span class="number">1</span>)</span><br><span class="line">    setCount(count+<span class="number">2</span>)</span><br><span class="line">    setCount(count+<span class="number">3</span>)</span><br><span class="line">    setCount(count+<span class="number">4</span>)</span><br><span class="line">    setCount(count+<span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(count)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;addCount&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分割线</p>
</blockquote>
<h4 id="答案是-1"><a href="#答案是-1" class="headerlink" title="答案是"></a>答案是</h4><p>5</p>
<p>为什么呢？</p>
<p>useState的更新究竟是如何工作的呢？</p>
<p>我们进入<code>ReactHooks.js</code>来看看，发现<code>useState</code>的实现竟然异常简单，只有短短两行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactHooks.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实可以这样理解useState，useState其实就是useReducer的一个语法糖；但是这个不在这个问题的讨论范围内；</p>
<p>好，收回来。</p>
<p>其实我们在<code>const [xx, setXx] = useState(xx)</code>的时候就生成一个队列，我们暂时叫它为queue；所有这一轮运行读取到的state都被放到一个链表的队列里面去，然后再用do-while循环，每次都是拿到最新的值，但是不是Object.assgin的形式，而是直接赋值。话不多说直接源码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 获取初始化时的 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始渲染更新</span></span><br><span class="line">  <span class="keyword">if</span> (numberOfReRenders &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dispatch = queue.dispatch;</span><br><span class="line">    <span class="keyword">if</span> (renderPhaseUpdates !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取Hook对象上的 queue，内部存有本次更新的一系列数据</span></span><br><span class="line">      <span class="keyword">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class="line">      <span class="keyword">if</span> (firstRenderPhaseUpdate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        renderPhaseUpdates.delete(queue);</span><br><span class="line">        <span class="keyword">let</span> newState = hook.memoizedState;</span><br><span class="line">        <span class="keyword">let</span> update = firstRenderPhaseUpdate;</span><br><span class="line">        <span class="comment">// 获取更新后的state</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          <span class="comment">// 此时的reducer是basicStateReducer，直接返回action的值</span></span><br><span class="line">          <span class="comment">// 注意，这里是等于号所以</span></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * setObj(&#123; a: 1, b: 1, c: 1 &#125;)</span></span><br><span class="line"><span class="comment">        	* setObj(&#123; a: 2, b: 2 &#125;)</span></span><br><span class="line"><span class="comment">        	* setObj(&#123; a: 3 &#125;)</span></span><br><span class="line"><span class="comment">        	*</span></span><br><span class="line"><span class="comment">        	* 到最后也只有只有&#123; a: 3 &#125;，而b和c全没了</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          **/</span></span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">          update = update.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 对 更新hook.memoized </span></span><br><span class="line">        hook.memoizedState = newState;</span><br><span class="line">        <span class="comment">// 返回新的 state，及更新 hook 的 dispatch 方法</span></span><br><span class="line">        <span class="keyword">return</span> [newState, dispatch];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="useEffect-useLayoutEffect"><a href="#useEffect-useLayoutEffect" class="headerlink" title="useEffect/useLayoutEffect"></a>useEffect/useLayoutEffect</h2><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在学习useEffect这个Hook的时候，淡化你知道的“生命周期”这个概念。</p>
<h4 id="useEffect和useLayoutEffect两兄弟的区别是什么？"><a href="#useEffect和useLayoutEffect两兄弟的区别是什么？" class="headerlink" title="useEffect和useLayoutEffect两兄弟的区别是什么？"></a>useEffect和useLayoutEffect两兄弟的区别是什么？</h4><p>执行的时机不同</p>
<p>那么具体哪里不同呢？</p>
<p>其实在初始化useEffect和useLayoutEffect是没有区别的，他们真正的区别在于初始化之后；</p>
<p>举个非常形象的例子🌰：</p>
<p>除了初始化之后的一轮更新：</p>
<blockquote>
<p>浏览器：我要绘制了！</p>
<p>React：等等，我有一个哥们临时有事要处理，他是：useLayoutEffect</p>
<p>useLayoutEffect执行….</p>
<p>React：好了，你可以开始绘制了～@浏览器</p>
<p>浏览器：好的</p>
<p>浏览器更新UI…</p>
<p>浏览器：我更新好了。你有什么事要做的吗？@React</p>
<p>React：有的，useEffect你上</p>
<p>useEffect执行….</p>
</blockquote>
<p>可能有点废话了。其实区别就是</p>
<blockquote>
<p>useLayoutEffect()</p>
<p>浏览器绘制</p>
<p>useEffect()</p>
</blockquote>
<p>这样其实大家也能很直接的看到弊端了。那就是useLayoutEffect如果有大量的计算的话，那样可能会阻塞UI更新，或者说UI渲染。所以还是要谨慎使用。</p>
<p>一般来说他们没有什么太大的区别的，如果真的要使用useLayoutEffect的话要谨慎一些。不然可能会导致UI渲染阻塞之类的问题。</p>
<p>但是，也不是没有使用场景。</p>
<p>比如下面的这个代码就很需要useLayoutEffect</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> randomNum = <span class="number">10</span> + <span class="built_in">Math</span>.random()*<span class="number">200</span></span><br><span class="line">      setCount(<span class="number">10</span> + <span class="built_in">Math</span>.random()*<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;() =&gt; setCount(<span class="number">0</span>)&#125;&gt;&#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/   我是分割线</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  const [count, setCount] = useState(0);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    if (count === 0) &#123;</span></span><br><span class="line"><span class="regexp">      const randomNum = 10 + Math.random()*200</span></span><br><span class="line"><span class="regexp">      setCount(10 + Math.random()*200);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, [count]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实明白的同学一下就看出来了，如果使用useEffect的话会出现闪烁，会先回到0然后再更新新的随机数。而反观useLayoutEffect则不会，他会很自然的过渡。</p>
<p>总结：</p>
<p>useLayoutEffect的使用场景为：有一个中间状态希望隐藏的时候再使用。</p>
<p>大部分情况下useEffect可以适用于99%的场景。</p>
<h4 id="useEffect的错误事例。看看有没有你"><a href="#useEffect的错误事例。看看有没有你" class="headerlink" title="useEffect的错误事例。看看有没有你"></a>useEffect的错误事例。看看有没有你</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Imagine this function is also long</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Imagine this function is also long</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么错了？"><a href="#为什么错了？" class="headerlink" title="为什么错了？"></a>为什么错了？</h4><p>不难看出上面代码的意思是。想要模仿componentDidMount的生命周期，在页面或者组件加载之后发送一个请求。咋一看好像没有什么问题（实际在运行的过程中也没有什么问题，在写这篇文章之前我也是这么做的。）</p>
<p>但是大家可以想象一下，如果这个函数组件，是现在的5倍大，这个didMount里面调用的请求，未来依赖的东西你都可以100%的察觉到吗？</p>
<p>我觉得难！难免会有疏忽。到时候可能就会出现state或者props读取错误的情况。因为每一次render的state和props都是独立的。</p>
<p>那么，该如何解决呢？</p>
<p>有一个很土的办法，直接把函数扔到useEffect里面去</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// We moved these functions inside!    </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query=react'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(getFetchUrl());</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ Deps are OK</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那高级点的办法呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ✅ Preserves identity when its own deps are the same</span></span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = useCallback(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class="line">  &#125;, []);  <span class="comment">// ✅ Callback deps are OK</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'react'</span>);</span><br><span class="line">    <span class="comment">// ... Fetch data and do something ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// ✅ Effect deps are OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将函数用useCallback包裹，这样的话我们只需要做useEffect的依赖里面写上我们的函数，然后在useCallback里面写上我们的依赖。</p>
<h4 id="我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？"><a href="#我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？" class="headerlink" title="我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？"></a>我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCountRef = useRef();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    prevCountRef.current = count;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> prevCount = prevCountRef.current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实很好理解，如果看了前面useEffect和useLayoutEffect区别的同学一下就可以知道这个的实现原理。</p>
<p>首先，在一切都更新之后，然后会会执行useEffect内部的回调函数，将prevCount给赋值，由于没有触发渲染，所以只是单纯的赋值。这样就看起来prevCount的值永远都慢一步。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实在学习useEffect的时候。应该忘记你对React的一些知识。比如生命周期，在函数组件里面没有生命周期这个概念了。</p>
<p>每一次的render他都有自己的state和props。state和props更应该被看作一个常量，哪怕是const bar = xx这样的常量。这样理解起来useEffect这个副作用其实会更加顺畅，也不容易进入他的“陷阱”</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>为什么我把useRef单独拎出来说，不把他和<code>useImperativeHandle</code>放在一起讲，因为</p>
<blockquote>
<p>（官网原话）它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>
</blockquote>
<p>记住<code>useRef</code>不单单用于获取<code>DOM节点和组件实例</code>，还有一个巧妙的用法就是<code>作为容器保留可变变量</code>，可以这样说：<code>无法自如地使用useRef会让你失去hook将近一半的能力</code></p>
<h4 id="useRef-与-createRef-的区别"><a href="#useRef-与-createRef-的区别" class="headerlink" title="useRef 与 createRef 的区别"></a>useRef 与 createRef 的区别</h4><p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>
<p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>
<p>第一句话是显然的，因为 Hooks 不能用在 ClassComponent。</p>
<p>第二句话的原因是，<code>createRef</code> 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  &#x2F;&#x2F; 错误用法，永远也拿不到 ref</span><br><span class="line">  const valueRef &#x3D; React.createRef();</span><br><span class="line">  return &lt;div ref&#x3D;&#123;valueRef&#125; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上述 <code>valueRef</code> 会随着 App 函数的 Render 而重复初始化，<strong>这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变</strong>。</p>
<p>为什么 <code>createRef</code> 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 <code>componentDidMount</code> 等初始化时机仅执行一次。</p>
<h4 id="如何解决每次render带来类闭包问题？"><a href="#如何解决每次render带来类闭包问题？" class="headerlink" title="如何解决每次render带来类闭包问题？"></a>如何解决每次render带来类闭包问题？</h4><p>首先，题目怎么理解？<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">题目</a></p>
<p>如果我们希望他alert的时候可以获取到最新的值的话，可以使用useRef来解决</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState&lt;number&gt;(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = useRef&lt;number&gt;(count)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    countRef.current = count</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'current count: '</span> + countRef.current)</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure>



<h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2><h4 id="memo没有回调函数的话是怎么浅比较的？"><a href="#memo没有回调函数的话是怎么浅比较的？" class="headerlink" title="memo没有回调函数的话是怎么浅比较的？"></a>memo没有回调函数的话是怎么浅比较的？</h4><p>先来看看memo没有回调函数的时候他做了什么。</p>
<p>memo它是一个高阶组件（HOC）他与React.PureComponent十分相似。除了使用的地方不同（Class组件和Function组件）之外几乎一致。</p>
<p>Memo内部和PureComponent一样使用Object.is用于前对比，如果传入的props内存地址不变的话，那就不会渲染了（或者说复用最近的一次渲染）。</p>
<p>下面可以看源码事例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemoComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> | <span class="title">Fiber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ...省略...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断更新的过期时间是否小于渲染的过期时间</span></span><br><span class="line">  <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevProps = currentChild.memoizedProps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果自定义了compare函数，则采用自定义的compare函数，否则采用官方的shallowEqual(浅比较)函数。（下面有解析）</span></span><br><span class="line">    <span class="keyword">let</span> compare = Component.compare;</span><br><span class="line">    compare = compare !== <span class="literal">null</span> ? compare : shallowEqual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 判断当前 props 与 nextProps 是否相等；</span></span><br><span class="line"><span class="comment">     * 2. 判断即将渲染组件的引用是否与workInProgress Fiber中的引用是否一致；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 只有两者都为真，才会退出渲染。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) &#123;</span><br><span class="line">      <span class="comment">// 如果都为真，则退出渲染</span></span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ...省略...*/</span></span><br></pre></td></tr></table></figure>

<p>shallowEqual（浅比较）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用原型链的方法</span></span><br><span class="line"><span class="keyword">const</span> hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数实际上是Object.is()的polyfill</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA, objB</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先对基本数据类型的比较</span></span><br><span class="line">  <span class="keyword">if</span> (is(objA, objB)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等</span></span><br><span class="line">  <span class="comment">// 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span></span><br><span class="line">  <span class="comment">// 之后，就可以返回false了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">'object'</span> || objA === <span class="literal">null</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> || objB === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤掉基本数据类型之后，就是对对象的比较了</span></span><br><span class="line">  <span class="comment">// 首先拿出key值，对key的长度进行对比</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(objA)</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(objB)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 长度不等直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// key相等的情况下，在去循环比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">  <span class="comment">// key值相等的时候</span></span><br><span class="line">  <span class="comment">// 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span></span><br><span class="line">  <span class="comment">// 属性的顺序不影响结果也就是&#123;name:'daisy', age:'24'&#125; 跟&#123;age:'24'，name:'daisy' &#125;是一样的</span></span><br><span class="line">  <span class="comment">// 最后，对对象的value进行一个基本数据类型的比较，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!hasOwn.call(objB, keysA[i]) ||</span><br><span class="line">        !is(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> truea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以知道，加入没有传一个比较的回调函数会使用官方的浅比较。具体的可以看注释</p>
<h4 id="memo的回调函数"><a href="#memo的回调函数" class="headerlink" title="memo的回调函数"></a>memo的回调函数</h4><p>我们都知道react的生命周期中有一个shouldComponentUpdate。在这个函数中返回true的话就代表本次render需要执行，而返回false就可以跳过本次的render。</p>
<p>而memo正好相反，返回true表示本次跳过，返回false就表示本次需要执行render。</p>
<p>具体怎么用呢？</p>
<p>大家可以自己运行一下，看看效果。一定要自己试一下，不然很容易和shouldComponentUpdate弄混了。学习还是要自己动手才行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChangeLog</span>(<span class="params">&#123;w = <span class="string">''</span>&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'====render===='</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(ChangeLog, (prevProps, nextProps) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevProps.w !== nextProps.w) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="useMemo-useCallback"><a href="#useMemo-useCallback" class="headerlink" title="useMemo/useCallback"></a>useMemo/useCallback</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>之所以把这useMomo/useCallack两兄弟和在一起。是因为他们其实十分相似。</p>
<blockquote>
<p>一个是缓存变量（useMemo），一个是缓存函数（useCallback）。</p>
</blockquote>
<p>其实这么一说就清晰很多了。</p>
<p>具体的使用和useEffect一样，都是第一个参数为调用时的回调函数，第二个参数是调用判断所监听的值（可以是变量，也可以是函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br><span class="line"><span class="keyword">const</span> memoizedValue = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<p>useMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）</p>
<p>memoized 值不变的情况下，不会重新触发渲染逻辑。</p>
<p>说起渲染逻辑，需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作，比如网络请求等。</p>
<p>如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner</p>
<p>useCallback也是一样的，这里就不多赘述了。</p>
<h2 id="useReducer-useContext"><a href="#useReducer-useContext" class="headerlink" title="useReducer/useContext"></a>useReducer/useContext</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>帮他们两兄弟和在一起说主要说因为他们两兄弟在一般情况下是可以与Redux一战的。</p>
<p>但是！！</p>
<p>但是啊，但是如果你需要中间价，或者说需要“时间旅行”，又或者临时需要跨页面级的数据共享，那你还是需要redux来解决的。不过基本上的场景我们使用useReducer和useContext就可以完美的替代redux了。</p>
<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p>其实之前由于要起一个新项目，但是突然发现有一个爷爷组件的值为需要通知给孙子组件，然后孙子组件可能会用掉回调函数调用爷爷组件的方法。那个时候其实已经用Hook写了一半了，懒得加Redux了，又不想一层层传props下去。怎么办？</p>
<p>通过了解，我知道了useReducer/useContext刚刚好可以解决我的需求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodosDispatch = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">bar</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setCenter'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">bar</span>: action.bar &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然这个是自组件，但是哪怕是曾曾曾孙子组件都可以直接用useContext拿到dispatch</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepChild</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = useContext(TodosDispatch);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'add'</span>, <span class="attr">text</span>: <span class="string">'hello'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;Add todo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function TodosApp() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class="line"><span class="regexp">  const [state, dispatch] = useReducer(reducer, initialState);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;DeepTree todos=&#123;todos&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/TodosDispatch.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="useImperativeHandle-forwardRef"><a href="#useImperativeHandle-forwardRef" class="headerlink" title="useImperativeHandle/forwardRef"></a>useImperativeHandle/forwardRef</h2><p>这里就不多说了，基本上没有什么坑点和疑难点。</p>
<p>说一下基本用法和ant-design form中的使用</p>
<h3 id="正常使用"><a href="#正常使用" class="headerlink" title="正常使用"></a>正常使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code>一起使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>

<p>在本例中，渲染<FancyInput ref={inputRef} />的父组件可以调用 <code>inputRef.current.focus()</code>。</p>
<h3 id="ant-design-form"><a href="#ant-design-form" class="headerlink" title="ant-design form"></a>ant-design form</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref从第二个参数取，这里都是一致的</span></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props,ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    text: bar,</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;Form&gt;</span><br><span class="line">    			&#123;<span class="comment">//....&#125;</span></span><br><span class="line">        &lt;<span class="regexp">/Form&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(Form.create()(forwardRef(Example)));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Example</span><br><span class="line">      	<span class="comment">// 注意这个不再是传ref了，而是传wrappedComponentRef。因为antd的form他返回的是一个新的对象，这个是他自定义的一个接收ref的值</span></span><br><span class="line">        wrappedComponentRef=&#123;editTemplateRef&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>



<h2 id="useDebugValue-自定义Hook"><a href="#useDebugValue-自定义Hook" class="headerlink" title="useDebugValue/自定义Hook"></a>useDebugValue/自定义Hook</h2><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>useDebugValue是专门用于服务自定义的Hook的。</p>
<p>具体看看使用就好</p>
<p>useDebugValue，目的是能在react的浏览器调试工具上显示你的自定义hooks，或者给hooks标记一些东西<br>当使用一个参数的时候，就是把第一个参数标记在react的调试工具上,下面写一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useDebugValue, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [str, setStr] = useState&lt;string&gt;(<span class="string">''</span>);</span><br><span class="line">    useDebugValue(<span class="string">'debug'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        str, setStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (): JSX.Element =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h2&gt;&#123;str&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                setStr('重新渲染');</span></span><br><span class="line"><span class="regexp">            &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>



<p><img src="/" class="lazyload" data-src="/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/20190818212347571.png"  alt=""></p>
<p>会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用</p>
<p>当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useDebugValue, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useTest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [str, setStr] = useState&lt;string&gt;(<span class="string">''</span>);</span><br><span class="line">    useDebugValue(str, (value:string) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'这是改造后的'</span> + value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        str, setStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (): JSX.Element =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;&#123;str&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                setStr('重新渲染');</span></span><br><span class="line"><span class="regexp">           &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class="line">       &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果:</p>
<p><img src="/" class="lazyload" data-src="/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/2019081821194714.png"  alt=""></p>
<p>同时在控制台上打印了一个空字符</p>
<p>由于str的初始值是空的，所以打印就是空的了，这只是调试使用，hooks差不多就这些了，没有其他的了</p>
<h2 id="观看之后"><a href="#观看之后" class="headerlink" title="观看之后"></a>观看之后</h2><p>如果有哪里写的不对或者有疑问的欢迎大家在评论区互动。🙏</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Derrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://derricktel.github.io/2020/05/20/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82React-Hook%E5%90%97/">http://derricktel.github.io/2020/05/20/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82React-Hook%E5%90%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://derricktel.github.io" target="_blank">Derrick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ReactHook/">ReactHook</a><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="/image/cover/web.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickWechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickAlipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/06/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E9%85%8D%E7%BD%AE%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【前端进阶】从零搭建属于你的脚手架</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/11/session%E5%92%8Ccookie%E7%9A%84%E7%90%86%E8%A7%A3/"><img class="next_cover lazyload" data-src="/image/cover/http.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">session和cookie的理解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/30/React-Hook-倒计时/" title="React Hook 倒计时"><img class="relatedPosts_cover lazyload"data-src="/image/cover/React.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-30</div><div class="relatedPosts_title">React Hook 倒计时</div></div></a></div><div class="relatedPosts_item"><a href="/2019/06/19/React-State详解/" title="React入门（一） State详解"><img class="relatedPosts_cover lazyload"data-src="/image/cover/React.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-19</div><div class="relatedPosts_title">React入门（一） State详解</div></div></a></div><div class="relatedPosts_item"><a href="/2019/09/15/装饰器(Decorator)和React高阶组件(HOC)/" title="装饰器(Decorator)和React高阶组件(HOC)"><img class="relatedPosts_cover lazyload"data-src="/image/cover/decorator.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-09-15</div><div class="relatedPosts_title">装饰器(Decorator)和React高阶组件(HOC)</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Derrick</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>
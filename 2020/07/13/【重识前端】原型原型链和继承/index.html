<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【重识前端】原型/原型链和继承 | Derrick</title><meta name="description" content="【重识前端】原型/原型链和继承"><meta name="keywords" content="JavaScript,原型/原型链,继承"><meta name="author" content="Derrick"><meta name="copyright" content="Derrick"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【重识前端】原型/原型链和继承"><meta name="twitter:description" content="【重识前端】原型/原型链和继承"><meta name="twitter:image" content="http://derricktel.github.io/image/cover/web.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="【重识前端】原型/原型链和继承"><meta property="og:url" content="http://derricktel.github.io/2020/07/13/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF/"><meta property="og:site_name" content="Derrick"><meta property="og:description" content="【重识前端】原型/原型链和继承"><meta property="og:image" content="http://derricktel.github.io/image/cover/web.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://derricktel.github.io/2020/07/13/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF/"><link rel="prev" title="【重识前端】闭包与模块" href="http://derricktel.github.io/2020/07/15/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"><link rel="next" title="从零配置你的Webpack" href="http://derricktel.github.io/2020/06/07/%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84Webpack/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#探究"><span class="toc-number">1.</span> <span class="toc-text">探究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What"><span class="toc-number">1.1.</span> <span class="toc-text">What</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型"><span class="toc-number">1.1.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链"><span class="toc-number">1.1.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-number">1.1.3.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why"><span class="toc-number">1.2.</span> <span class="toc-text">why</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How"><span class="toc-number">1.3.</span> <span class="toc-text">How</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#总结一下"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">总结一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承-1"><span class="toc-number">1.4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链继承"><span class="toc-number">1.4.1.</span> <span class="toc-text">原型链继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数继承"><span class="toc-number">1.4.2.</span> <span class="toc-text">构造函数继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合继承"><span class="toc-number">1.4.3.</span> <span class="toc-text">组合继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型式继承"><span class="toc-number">1.4.4.</span> <span class="toc-text">原型式继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-3"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄生继承"><span class="toc-number">1.4.5.</span> <span class="toc-text">寄生继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-4"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-4"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄生组合继承-终极方案"><span class="toc-number">1.4.6.</span> <span class="toc-text">寄生组合继承(终极方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-5"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-5"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class继承"><span class="toc-number">1.4.7.</span> <span class="toc-text">class继承</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/image/cover/web.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Derrick</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【重识前端】原型/原型链和继承</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-13 23:51:21"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-10 22:37:33"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-10-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%87%8D%E6%8B%BE%E5%89%8D%E7%AB%AF/">重拾前端</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><p>我觉得学习一个东西最重要的是搞懂三样东西</p>
<p>What/How/Why</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>什么是原型?什么是原型链?什么是继承?</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>在JavaScript中，<strong>原型也是一个对象，通过原型可以实现对象的属性继承，</strong>JavaScript的对象中都包含了一个” [[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。</p>
<p>“[[Prototype]]”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了”<strong>proto</strong>“这个<strong>非标准</strong>（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器”Object.getPrototype(object)”）。</p>
<p>用一句话来概括就是: 原型是一个属性可以被继承的对象.原型也可以有自己的原型.</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型也可以有自己的原型, 而一个个原型通过prototype链接起来的就叫做原型链</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>儿子可以通过继承获得父亲的属性或者方法; </p>
<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>为什么会有原型/原型链和继承?</p>
<p>摘自JavaScript高级程序设计:</p>
<blockquote>
<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <strong>接口继承</strong> 和 <strong>实现继承</strong> .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>
</blockquote>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><h4 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h4><p>怎么找到原型?</p>
<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>
<h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><p>怎么找到原型链?</p>
<p>在找之前我们先了解一个原型与构造函数与实例直接的关系.</p>
<p>假定我们有一个构造函数 <code>function A(){}</code>, 我们称他为A</p>
<p>我们有一个实例B, 他是这样来的: <code>const B = new A()</code>, 我们称他为B</p>
<p>A的原型为C</p>
<p>接下里我们写一个等式来很好的展示他们之间的关系</p>
<p>A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>
<p>解释一下: A有一个属性<code>prototype</code> 指向A的原型 C, 而C的属性<code>construct</code>指向A, A通过new方法可以创建实例B, 而B有一个属性<code>__proto__</code>指向了C(A的原型)</p>
<p>OK, 理解完上面的东西之后, 我们再加一个知识点, A的原型C, 也是C的原型的一个实例.</p>
<p>先别懂没懂, 我们看一下实战.</p>
<p>书接上文中的原型, 我再复制一下, 方便阅读</p>
<blockquote>
<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>
</blockquote>
<p>我们接着点开<code>__proto__</code>,发现里面有一堆”花里胡哨”的东西, 我们找到了其中一个很眼熟的”靓仔” -&gt; <code>construct</code>;</p>
<p>根据之前的了解</p>
<blockquote>
<p>​    A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>
</blockquote>
<p>我们点开的这个<code>construct</code>其实那个空对象的构造函数<code>Object</code>, 那么他应该有一个<code>prototype</code>指向了他的原型.</p>
<p>我们找找, 确实发现了有这么一个属性(<code>prototype</code>); 那么点开之后应该与最早的空对象的<code>__proto__</code>的内容一致. 根据等式可得;</p>
<h5 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h5><p>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</p>
<p>接下来进入我们的重头戏继承</p>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>其实继承又分为好多种: 原型链继承, 构造函数继承, 组合继承和寄生组合继承;</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了 A</span></span><br><span class="line">B.prototype = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> B()</span><br><span class="line">b1.array.push(<span class="string">"d"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(b1.array); <span class="comment">//"a,b,c,d"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> B(); </span><br><span class="line"><span class="built_in">console</span>.log(b2.array); <span class="comment">//"a,b,c,d"</span></span><br><span class="line"></span><br><span class="line">b2.array.push(<span class="string">"e"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b2.array) <span class="comment">//"a,b,c,d,e"</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.array) <span class="comment">//"a,b,c,d,e"</span></span><br></pre></td></tr></table></figure>

<p>我们定义了两个构造函数, A和B; 根据之前的知识, 我们让B的原型指向了构造函数A创造出来的实例(<code>new A()</code>); 然后我们用构造函数B创造了实例b1,  往 继承来的属性array 增加一个字符串”d”; 然后我们输出一下, 按照我们的逾期的多了一个”e”的情况下, 还有”a,b,c”;</p>
<p>接下来就有些问题了. 我们按照惯例, 通过构造函数B, 创造了b2. b2确实也有了继承来的属性”array”, 可是这个array并不是我们想要的初始的<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>; 我们放弃探究, 继续往这个<code>array</code>里面增加一个<code>e</code>, 输出一下<code>b1</code>的属性<code>array</code>. 确实是可以增加这个<code>e</code>;</p>
<p>可是!</p>
<p>当我们输出<code>b1.array</code>时, 发现b1也被改了, 和之前诡异的b2多出一个<code>d</code>一样.</p>
<p>探究发现这个由于我们用的是引用类型, 所以他们存储的是指向同一个内存的内存地址; 所以才会发生这些问题. 这也暴露了原型链继承时的一个问题.引用类型带来的毛病;</p>
<p>其次, 我们发现我们的B的原型指向A的构造函数时不能传递参数, 这也的话有点呆板</p>
<p>综上原型链的继承在日常中是很少用到的</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>​    子类可以通过原型链的查找，实现父类的属性公用与子类的实例</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>
<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>
<li>无法直接给父级构造函数使用参数</li>
</ul>
<h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  A.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了 A</span></span><br><span class="line">B.prototype = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> B()</span><br><span class="line">b1.array.push(<span class="string">"d"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(b1.array); <span class="comment">//"a,b,c,d"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> B(); </span><br><span class="line"><span class="built_in">console</span>.log(b2.array); <span class="comment">//"a,b,c"</span></span><br><span class="line"></span><br><span class="line">b2.array.push(<span class="string">"e"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b2.array) <span class="comment">//"a,b,c,e"</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.array) <span class="comment">//"a,b,c,d"</span></span><br></pre></td></tr></table></figure>

<p>我们奇迹般的发现, 构造函数的继承解决了我们之前发现的JavaScript引用问题.那函数传参的问…</p>
<p>啪!</p>
<p>停, 我们现在来传递一下参数!</p>
<p>我们把上面的例子修改一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  A.call(<span class="keyword">this</span>, <span class="string">'B'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了 A</span></span><br><span class="line">B.prototype = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> B()</span><br><span class="line">b1.array.push(<span class="string">"d"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(b1.array); <span class="comment">//"a,b,c,d"</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.name); <span class="comment">//"B"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> B(); </span><br><span class="line"><span class="built_in">console</span>.log(b2.array); <span class="comment">//"a,b,c"</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.name); <span class="comment">//"B"</span></span><br><span class="line"></span><br><span class="line">b2.array.push(<span class="string">"e"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b2.array) <span class="comment">//"a,b,c,e"</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.array) <span class="comment">//"a,b,c,d"</span></span><br></pre></td></tr></table></figure>

<p>这样的话我们解决了原型链继承的两个问题(1.无法传参, 2.js引用问题);</p>
<p>该不会有人认为这样就很完美了吧?不会吧!不会吧!</p>
<p>我们冷静下来想想看, 其实这个传递参数是几乎算是写死的. 还不如直接在A里面直接写死好了, 根本就无法复用嘛; 而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>解决了原型链继承的 引用类型操作问题</li>
<li>解决了父类传递参数问题</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>仅仅使用借用构造函数模式继承，无法摆脱够着函数。方法在构造函数中定义复用不可谈</li>
<li>对于超类的原型定义的方法对于子类是不可使用的，子类的实例只是得到了父类的this绑定的属性 考虑到这些缺点，单独使用借用构造函数也是很少使用的</li>
</ul>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  A.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line">B.prototype.constructor = A; <span class="comment">// 因为原型链继承，会把constructor指向改变，所以要重新指回自身</span></span><br><span class="line">B.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> B(<span class="string">'a'</span>, <span class="number">10</span>)</span><br><span class="line">a.array.push(<span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.array) <span class="comment">// ["1", "2", "3", "a"]</span></span><br><span class="line">a.sayName() <span class="comment">// 'a'</span></span><br><span class="line">a.sayAge() <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'b'</span>, <span class="number">20</span>)</span><br><span class="line">b.array.push(<span class="string">'b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.array) <span class="comment">// ["1", "2", "3", "b"]</span></span><br><span class="line">b.sayName()<span class="comment">// 'b'</span></span><br><span class="line">b.sayAge() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中, 构造函数A有两个内置属性<code>name</code>和<code>array</code>. A的原型定义了一个方法<code>sayName</code>; 构造函数B在调用A的构造函数时传入了一个参数<code>name</code>, 然后又给B的原型上定义了一个方法<code>sayAge</code>. 这样一来, 就可以让两个B的实例分别拥有自己的属性, 当然也包括了array, 还可以拥有相同的方法.</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且(关键)，<code>instanceof</code> 和 <code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>解决了原型链继承引用类型的实例操作导致引用改变</li>
<li>解决了借构造函数继承方式的，父类原型子类实例可以使用</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>父类的构造函数被实例换了两次 * 实例会有父类的构造函数的一些this属性、子类的构造函数（prototype）上也有一份实例的上有的属性</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来非常简单</p>
<p>先在<code>object</code>函数内部创建一个临时的构造函数<code>F</code>, 然后将传入的这个对象<code>o</code>作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. </p>
<p>简单来说就是<code>object</code>对传入的对象进行了浅复制.</p>
<p>浅拷贝和深拷贝可以自行Google一下, 这算一个重要的知识点.</p>
<p>举个🌰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">  array: [<span class="string">'1'</span>, <span class="string">'2'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> qq = object(a)</span><br><span class="line"><span class="built_in">console</span>.log(qq.name)</span><br><span class="line">qq.array.push(<span class="string">'qq'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(qq.array)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ww = object(a)</span><br><span class="line"><span class="built_in">console</span>.log(ww.name)</span><br><span class="line">ww.array.push(<span class="string">'ww'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ww.array)</span><br><span class="line"><span class="built_in">console</span>.log(qq.array)</span><br></pre></td></tr></table></figure>

<p>有没有似曾相识的感觉….原型链继承的老毛病来了…</p>
<p>不过他也不是没有优点的.</p>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。</p>
<blockquote>
<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。有兴趣的话可以自己了解一下</p>
</blockquote>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>
<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>
<li>无法直接给父级构造函数使用参数</li>
</ul>
<h4 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h4><p>寄生继承和原型式继承紧密相关, 同样也是由克罗克福德推而广 之的.寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。</p>
<p>上代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> clone=object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，最后返回 clone 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">"Nicholas"</span>,</span><br><span class="line">	friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person); </span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。</p>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。</p>
<blockquote>
<p>使用寄生继承, 由于不能做到函数复用而降低效率, 这点和构造函数继承很像</p>
</blockquote>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul>
<li>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</li>
<li>可以给备份的对象添加一些属性</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>类似构造函数一样，创建寄生的方法需要在clone对象上面添加一些想要的属性，这些属性是放在clone上面的一些私有的属性</p>
<h4 id="寄生组合继承-终极方案"><a href="#寄生组合继承-终极方案" class="headerlink" title="寄生组合继承(终极方案"></a>寄生组合继承(终极方案</h4><p>前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。再来看一看下面组合继承的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.array = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  A.call(<span class="keyword">this</span>, name) <span class="comment">//第二次调用</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)&#125;</span><br><span class="line"></span><br><span class="line">B.prototype = <span class="keyword">new</span> A() <span class="comment">// 第一次调用</span></span><br><span class="line">B.prototype.constructor = B</span><br></pre></td></tr></table></figure>

<p>第一次调用A构造函数的时候, B的原型上就拥有了A的两个属性和一个方法;</p>
<p>第二次调用A的构造函数时, 为B的实例创建了A的两个的属性和一个方法, 于是实例的两个属性和一个方法就屏蔽了原型上的实例和方法; </p>
<p>是不是感觉有点点浪费, 不过好在我们已经找到解决方案—&gt;寄生组合继承</p>
<p>举一个非常简单的🌰, 并且我尽量逐字逐句的讲清楚</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F</span><br><span class="line">&#125; <span class="comment">//也可以用Object.create替代</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line">  B.call(<span class="keyword">this</span>, name); <span class="comment">// 只调用了这一次</span></span><br><span class="line">	<span class="keyword">this</span>.age = age; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">A, B</span>)</span>&#123; </span><br><span class="line">  <span class="comment">//让prototype可以拿到B的属性和方法...这是原型式继承</span></span><br><span class="line">  <span class="keyword">var</span> prototype = object(B.prototype); </span><br><span class="line">  <span class="comment">//由于重写了原型, 所以此时的constructor会指向Object, 所以必须指定一下constructor...那为什么会丢失呢?因为我们穿给object这个方法的是一个对象, 而对象的构造函数就是Object; 在原型那一小节我们说过了, 原型也是对象;</span></span><br><span class="line">  prototype.constructor = A; </span><br><span class="line">  <span class="comment">// 继承属性之后就需要将原型给指向回去, 为了原型链的正确指向</span></span><br><span class="line">  A.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(A, B);</span><br><span class="line"></span><br><span class="line">A.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。实际上是<strong>在组合继承的基础上，用超类型原型的副本代替调用超类型的构造函数给子类型指定原型</strong>。</p>
<p>本质上，是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<p>优点：只调用了一次超类型的构造函数，并且因此避免了在子类型的原型上创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code>。普遍认为寄生组合式继承是引用类型<strong>最理想</strong>的继承方式。</p>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul>
<li>在少一次实例化父类的情况下，实现了原型链继承和借用构造函数</li>
<li>减少了原型链查找的次数（子类直接继承超类的prototype，而不是父类的实例）</li>
</ul>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p>暂无</p>
<h4 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val)&#123;</span><br><span class="line">        <span class="keyword">super</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'zhangsan'</span>);</span><br><span class="line">child.getName();  <span class="comment">//zhangsan</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super。<br>class 的本质还是函数，这种表达不过是一种语法糖。</p>
<p>这里就不展开了.</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Derrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://derricktel.github.io/2020/07/13/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF/">http://derricktel.github.io/2020/07/13/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://derricktel.github.io" target="_blank">Derrick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型/原型链</a><a class="post-meta__tags" href="/tags/%E7%BB%A7%E6%89%BF/">继承</a></div><div class="post_share"><div class="social-share" data-image="/image/cover/github.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickWechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickAlipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/15/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"><img class="prev_cover lazyload" data-src="/image/cover/web.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【重识前端】闭包与模块</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/07/%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84Webpack/"><img class="next_cover lazyload" data-src="/image/cover/webpack.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从零配置你的Webpack</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/06/19/window-history-back-缓存-返回上级页面不刷新数据/" title="window.history.back(); 缓存 返回上级页面不刷新数据"><img class="relatedPosts_cover lazyload"data-src="/image/cover/history.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-19</div><div class="relatedPosts_title">window.history.back(); 缓存 返回上级页面不刷新数据</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/10/【重识前端】一次搞定事件循环/" title="【重识前端】一次搞定JavaScript的执行机制"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-10</div><div class="relatedPosts_title">【重识前端】一次搞定JavaScript的执行机制</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/16/【重识前端】全面攻破this/" title="【重识前端】全面攻破this"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-16</div><div class="relatedPosts_title">【重识前端】全面攻破this</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/15/【重识前端】闭包与模块/" title="【重识前端】闭包与模块"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">【重识前端】闭包与模块</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/25/【重识前端】深入内存世界/" title="【重识前端】深入内存世界"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-25</div><div class="relatedPosts_title">【重识前端】深入内存世界</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/28/【重识前端】暴走的异步编程/" title="【重识前端】暴走的异步编程"><img class="relatedPosts_cover lazyload"data-src="/image/cover/web.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-28</div><div class="relatedPosts_title">【重识前端】暴走的异步编程</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Derrick</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化 | Derrick</title><meta name="description" content="【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化"><meta name="keywords" content="react"><meta name="author" content="Derrick"><meta name="copyright" content="Derrick"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化"><meta name="twitter:description" content="【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化"><meta name="twitter:image" content="http://derricktel.github.io/image/cover/react.png"><meta property="og:type" content="article"><meta property="og:title" content="【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化"><meta property="og:url" content="http://derricktel.github.io/2021/04/06/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89Fiber%20%E5%88%9D%E5%A7%8B%E5%8C%96/"><meta property="og:site_name" content="Derrick"><meta property="og:description" content="【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化"><meta property="og:image" content="http://derricktel.github.io/image/cover/react.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://derricktel.github.io/2021/04/06/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89Fiber%20%E5%88%9D%E5%A7%8B%E5%8C%96/"><link rel="prev" title="全网最全React源码调试傻瓜式教程" href="http://derricktel.github.io/2021/06/17/%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8React%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/"><link rel="next" title="【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机" href="http://derricktel.github.io/2021/04/05/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%892000%E5%AD%97%E5%91%8A%E8%AF%89%E4%BD%A0Fiber%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">43</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前情回顾"><span class="toc-number">2.</span> <span class="toc-text">前情回顾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码攻读"><span class="toc-number">3.</span> <span class="toc-text">源码攻读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#legacyRenderSubtreeIntoContainer"><span class="toc-number">3.1.</span> <span class="toc-text">legacyRenderSubtreeIntoContainer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#legacyCreateRootFromDOMContainer"><span class="toc-number">3.2.</span> <span class="toc-text">legacyCreateRootFromDOMContainer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldHydrateDueToLegacyHeuristic"><span class="toc-number">3.2.1.</span> <span class="toc-text">shouldHydrateDueToLegacyHeuristic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createLegacyRoot"><span class="toc-number">3.2.2.</span> <span class="toc-text">createLegacyRoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createRootImpl"><span class="toc-number">3.2.3.</span> <span class="toc-text">createRootImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createContainer"><span class="toc-number">3.2.4.</span> <span class="toc-text">createContainer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FiberRootNode"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">FiberRootNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createHostRootFiber"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">createHostRootFiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createFiber"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">createFiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FiberNode"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">FiberNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initializeUpdateQueue"><span class="toc-number">3.2.4.5.</span> <span class="toc-text">initializeUpdateQueue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结一番"><span class="toc-number">4.</span> <span class="toc-text">小结一番</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#收尾"><span class="toc-number">5.</span> <span class="toc-text">收尾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方便阅读"><span class="toc-number">5.1.</span> <span class="toc-text">方便阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unbatchedUpdates"><span class="toc-number">5.2.</span> <span class="toc-text">unbatchedUpdates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#updateContainer"><span class="toc-number">5.3.</span> <span class="toc-text">updateContainer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最后"><span class="toc-number">6.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引"><span class="toc-number">7.</span> <span class="toc-text">索引</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/image/cover/react.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Derrick</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-about"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-04-06 14:08:31"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-04-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-06-17 15:12:28"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-06-17</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%87%8D%E6%8B%BE%E5%89%8D%E7%AB%AF/">重拾前端</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在第一章中，我们解读到ReactDOM.render之后就没有继续了。因为我看了一下设计到了Fiber的一些知识，所以在第二章补充了Fiber的基础知识之后，我将Fiber拆分成四块来讲</p>
<ul>
<li>动机（或者说初衷</li>
<li>初始化-Fiber树的准备工作</li>
<li>render-Fiber树的构建</li>
<li>commit-Fiber树映射到DOM</li>
</ul>
<p>现在是初始化阶段</p>
<p>我们现在直接进入Fiber的初始化。Action！</p>
<h1 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h1><p>回顾一下之前学习JSX的时候，阅读到ReactDOM.render。如果你没有阅读过之前的文章，强烈建议你到我的主页去阅读我之前的博客。下面我们开始。</p>
<p>ReactDOM.render的源码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidContainer</span>(<span class="params">node: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(</span><br><span class="line">    node &amp;&amp;</span><br><span class="line">    (node.nodeType === ELEMENT_NODE ||</span><br><span class="line">      node.nodeType === DOCUMENT_NODE ||</span><br><span class="line">      node.nodeType === DOCUMENT_FRAGMENT_NODE ||</span><br><span class="line">      (node.nodeType === COMMENT_NODE &amp;&amp;</span><br><span class="line">        (node: <span class="built_in">any</span>).nodeValue === <span class="string">' react-mount-point-unstable '</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: React$Element&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于抛出错误的, 就是判断这个container是不是找得到</span></span><br><span class="line">  invariant(</span><br><span class="line">    isValidContainer(container),</span><br><span class="line">    <span class="string">'Target container is not a DOM element.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">const</span> isModernRoot =</span><br><span class="line">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class="line">      container._reactRootContainer === <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (isModernRoot) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">'You are calling ReactDOM.render() on a container that was previously '</span> +</span><br><span class="line">          <span class="string">'passed to ReactDOM.createRoot(). This is not supported. '</span> +</span><br><span class="line">          <span class="string">'Did you mean to call root.render(element)?'</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里面涉及到了fiber的一些架构，开始补坑</span></span><br><span class="line">  <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后return的这个函数有点意思。</p>
<h1 id="源码攻读"><a href="#源码攻读" class="headerlink" title="源码攻读"></a>源码攻读</h1><h2 id="legacyRenderSubtreeIntoContainer"><a href="#legacyRenderSubtreeIntoContainer" class="headerlink" title="legacyRenderSubtreeIntoContainer"></a>legacyRenderSubtreeIntoContainer</h2><p>我们首先翻译一下这个函数的名字，进行驼峰拆分：</p>
<blockquote>
<p>Google翻译：legacy Render Subtree Into Container（旧版渲染子树放入容器</p>
</blockquote>
<p>先别急着翻译。我们先看看源码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params">parentComponent, children, container, forceHydrate, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// container 对应的是我们传入的真实 DOM 对象</span></span><br><span class="line">  <span class="keyword">var</span> root = container._reactRootContainer;</span><br><span class="line">  <span class="comment">// 初始化 fiberRoot 对象</span></span><br><span class="line">  <span class="keyword">var</span> fiberRoot;</span><br><span class="line">  <span class="comment">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span><br><span class="line">    <span class="comment">// legacyCreateRootFromDOMContainer 主要的功能是创建，并且进行一些“脏判断”。感兴趣的，我在后面也会详细给出</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class="line">    <span class="comment">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> originalCallback = callback;</span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">    <span class="comment">// 进入 unbatchedUpdates 方法</span></span><br><span class="line">    unbatchedUpdates(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _originalCallback = callback;</span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        _originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="comment">// Update</span></span><br><span class="line"></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>梳理一下整个流程，然后我们再一一看这些函数。</p>
<p>以下流程是指初始化，也就是<code>if/else</code>判断里面的<code>if</code>。而不是<code>else</code>，<code>else</code>是非首次渲染，走的更新流程，注释里面写了。</p>
<ol>
<li>创建<code>container._reactRootContainer</code>对象，并赋值给<code>root</code></li>
<li>将<code>root</code>上的<code>_inernalRoot</code>赋值给<code>fiberRoot</code></li>
<li>将<code>legacyRenderSubtreeIntoContainer</code>的一些参数和<code>fiberRoot</code>一起传给<code>updateContainer</code></li>
<li><code>将updateConatiner</code>作为回调函数传给<code>unbatechedUpdates</code></li>
</ol>
<p>ok，现在看不太懂没关系。我们将里面用到的函数一一解读，然后再回来补充整个流程。</p>
<h2 id="legacyCreateRootFromDOMContainer"><a href="#legacyCreateRootFromDOMContainer" class="headerlink" title="legacyCreateRootFromDOMContainer"></a>legacyCreateRootFromDOMContainer</h2><p>大家现在一定会晕头转向，因为我看的时候也是这样，他的名字和函数名字取的太像了，我们需要给他们独自用自己的方式命名。我会写下Google翻译， 帮助大家取名字。</p>
<blockquote>
<p>Google翻译：legacy Create Root From DOM Container（从DOM容器创建根目录</p>
</blockquote>
<p>看了翻译之后是不是焕然大悟？别急，我们先看看源码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RootType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果forceHydrate是false，就会调用后面的方法。</span></span><br><span class="line">  <span class="keyword">const</span> shouldHydrate =</span><br><span class="line">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">  <span class="comment">// First clear any existing content.</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSibling;</span><br><span class="line">    <span class="comment">// 这个循环，是为了清理所有的内容，然后找到我们要渲染的最初的根div。通常我们的html会有一个</span></span><br><span class="line">    <span class="comment">// &lt;div id="root"&gt;&lt;/div&gt; 为的就是保障他的纯净。</span></span><br><span class="line">    <span class="keyword">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          !warned &amp;&amp;</span><br><span class="line">          rootSibling.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class="line">          (rootSibling: <span class="built_in">any</span>).hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class="line">        ) &#123;</span><br><span class="line">          warned = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">console</span>.error(</span><br><span class="line">            <span class="string">'render(): Target node has markup rendered by React, but there '</span> +</span><br><span class="line">              <span class="string">'are unrelated nodes as well. This is most commonly caused by '</span> +</span><br><span class="line">              <span class="string">'white-space inserted around server-rendered markup.'</span>,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123;</span><br><span class="line">      warnedAboutHydrateAPI = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">console</span>.warn(</span><br><span class="line">        <span class="string">'render(): Calling ReactDOM.render() to hydrate server-rendered markup '</span> +</span><br><span class="line">          <span class="string">'will stop working in React v18. Replace the ReactDOM.render() call '</span> +</span><br><span class="line">          <span class="string">'with ReactDOM.hydrate() if you want React to attach to the server HTML.'</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createLegacyRoot(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          hydrate: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="literal">undefined</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又用到两个函数，我为大家召出来。</p>
<h3 id="shouldHydrateDueToLegacyHeuristic"><a href="#shouldHydrateDueToLegacyHeuristic" class="headerlink" title="shouldHydrateDueToLegacyHeuristic"></a>shouldHydrateDueToLegacyHeuristic</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReactRootElementInContainer</span>(<span class="params">container: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果没有就返回null</span></span><br><span class="line">  <span class="keyword">if</span> (!container) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 内部定义的一个常量</span></span><br><span class="line">  <span class="comment">// export const DOCUMENT_NODE = 9;看名字就顾名思义了</span></span><br><span class="line">  <span class="comment">// 如果是内部一个document节点就返回document节点</span></span><br><span class="line">  <span class="comment">// 感兴趣可以看看MDN的介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/Document</span></span><br><span class="line">  <span class="comment">// 常量的值也有：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType</span></span><br><span class="line">  <span class="keyword">if</span> (container.nodeType === DOCUMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">return</span> container.documentElement;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则返回第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> container.firstChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldHydrateDueToLegacyHeuristic</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将container传入函数，进行判断类型，并得到节点（有可能为空，看注释</span></span><br><span class="line">  <span class="keyword">const</span> rootElement = getReactRootElementInContainer(container);</span><br><span class="line">  <span class="comment">// 强转为布尔值</span></span><br><span class="line">  <span class="keyword">return</span> !!(</span><br><span class="line">    rootElement &amp;&amp;</span><br><span class="line">    rootElement.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class="line">    <span class="comment">// export const ROOT_ATTRIBUTE_NAME = 'data-reactroot'; </span></span><br><span class="line">    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到一个hasAttribute为”data-reactroot”。这是 React 在服务端渲染的时候加上去的。之前有说过Hydrate这个操作是服务端渲染的时候需要的东西。</p>
<blockquote>
<p>Google翻译：getReactRootElementInContainer（获取容器中的React根元素</p>
<p>Google翻译：shouldHydrateDueToLegacyHeuristic（应当因传统启发而水合</p>
<p>说人话就是是否需要进行hydrate操作</p>
</blockquote>
<p>所以<code>legacyCreateRootFromDOMContainer</code>这个函数是保障<code>container</code>的纯净。并且返回<code>createLegacyRoot</code>函数。ok继续看。</p>
<h3 id="createLegacyRoot"><a href="#createLegacyRoot" class="headerlink" title="createLegacyRoot"></a>createLegacyRoot</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMLegacyRoot</span>(<span class="params">container: Container, options: <span class="built_in">void</span> | RootOptions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是不是看见老朋友了。_internalRoot。继续看下面的内容，我们来解析一下createRootImpl</span></span><br><span class="line">  <span class="keyword">this</span>._internalRoot = createRootImpl(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createLegacyRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: RootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RootType</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 又是熟悉的操作，返回某个东西</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMLegacyRoot(container, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createRootImpl"><a href="#createRootImpl" class="headerlink" title="createRootImpl"></a>createRootImpl</h3><p>需要注意的是，我们通篇都是以非<code>hydrate</code>来看的，因为我们不是服务端渲染。但是我也会介绍如果有<code>hydrate</code>的内容。所以大家看的时候可以稍微带入一点去看，不然很容易走神！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并返回一个fiberRoot</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: <span class="built_in">void</span> | RootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class="line">  <span class="comment">// 判断是否为hydrate模式</span></span><br><span class="line">  <span class="keyword">const</span> hydrate = options != <span class="literal">null</span> &amp;&amp; options.hydrate === <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> hydrationCallbacks =</span><br><span class="line">    (options != <span class="literal">null</span> &amp;&amp; options.hydrationOptions) || <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> mutableSources =</span><br><span class="line">    (options != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      options.hydrationOptions != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      options.hydrationOptions.mutableSources) ||</span><br><span class="line">    <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> strictModeLevelOverride =</span><br><span class="line">    options != <span class="literal">null</span> &amp;&amp; options.unstable_strictModeLevel != <span class="literal">null</span></span><br><span class="line">      ? options.unstable_strictModeLevel</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 创建一个fiberRoot</span></span><br><span class="line">  <span class="keyword">const</span> root = createContainer(</span><br><span class="line">    container,</span><br><span class="line">    tag,</span><br><span class="line">    hydrate,</span><br><span class="line">    hydrationCallbacks,</span><br><span class="line">    strictModeLevelOverride,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 给container附加一个内部属性用于指向fiberRoot的current属性对应的rootFiber节点</span></span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rootContainerElement =</span><br><span class="line">    container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class="line">  listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mutableSources) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mutableSources.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> mutableSource = mutableSources[i];</span><br><span class="line">      registerMutableSourceForHydration(root, mutableSource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我在注释里面会加上「创建一个fiberRoot」，不是一个是创建一个container吗？我们看createContainer里面做了什么。</p>
<h3 id="createContainer"><a href="#createContainer" class="headerlink" title="createContainer"></a>createContainer</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">  strictModeLevelOverride: <span class="literal">null</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过FiberRootNode构造函数创建一个fiberRoot实例</span></span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = (<span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate): <span class="built_in">any</span>);</span><br><span class="line">  <span class="comment">// 如果有，就补充进这个回调函数</span></span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">  <span class="comment">// stateNode is any.</span></span><br><span class="line">  <span class="comment">// 通过createHostRootFiber方法创建fiber tree的根结点，即rootFiber</span></span><br><span class="line">  <span class="comment">// fiber节点也会像DOM树结构一样形成一个fiber tree单链表树结构</span></span><br><span class="line">  <span class="comment">// 每个DOM节点或者组件都会生成一个与之对应的fiber节点，在后续的调和(reconciliation)阶段起着至关重要的作用</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(tag, strictModeLevelOverride);</span><br><span class="line">  <span class="comment">// 创建完rootFiber之后，会将fiberRoot的实例的current属性指向刚创建的rootFiber</span></span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  <span class="comment">// 同时rootFiber的stateNode属性会指向fiberRoot实例，形成相互引用</span></span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    <span class="keyword">const</span> initialCache = <span class="keyword">new</span> Map();</span><br><span class="line">    root.pooledCache = initialCache;</span><br><span class="line">    <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">      element: <span class="literal">null</span>,</span><br><span class="line">      cache: initialCache,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.memoizedState = initialState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">      element: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.memoizedState = initialState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">	<span class="comment">// 最后将创建的fiberRoot实例返回</span></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部调用createFiberRoot方法返回一个fiberRoot实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">  strictModeLevelOverride: <span class="literal">null</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">OpaqueRoot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(</span><br><span class="line">    containerInfo,</span><br><span class="line">    tag,</span><br><span class="line">    hydrate,</span><br><span class="line">    hydrationCallbacks,</span><br><span class="line">    strictModeLevelOverride,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也比较简单，只是单纯的调用函数，然后返回。真正的秘密就在这些函数里面，耐心点继续看！黎明就在眼前</p>
<h4 id="FiberRootNode"><a href="#FiberRootNode" class="headerlink" title="FiberRootNode"></a>FiberRootNode</h4><p>一个非常恐怖的内容。但是看名字也能猜个大概。还记得我们之前说过。一个fiber节点要存的内容还蛮多的。比如被暂停时的状态，恢复时要做的事情，优先级等等….这里我尽可能的去写注释。帮助大家还要我自己理解。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//root 节点类型()</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="comment">//root根节点，render方法的第二个参数</span></span><br><span class="line">  <span class="keyword">this</span>.containerInfo = containerInfo;</span><br><span class="line">  <span class="comment">//在持久更新中会用到，不支持增量更新的平台，react-dom 是整个应用更新，所以用不到</span></span><br><span class="line">  <span class="keyword">this</span>.pendingChildren = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//当前应用root节点对应的Fiber对象</span></span><br><span class="line">  <span class="keyword">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//缓存</span></span><br><span class="line">  <span class="keyword">this</span>.pingCache = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//已经完成任务的FiberRoot对象，在commit(提交)阶段只会处理该值对应的任务</span></span><br><span class="line">  <span class="keyword">this</span>.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span></span><br><span class="line">  <span class="keyword">this</span>.timeoutHandle = noTimeout;</span><br><span class="line">  <span class="comment">//顶层 context 对象，只有主动调用renderSubtreeIntoContainer才会生效</span></span><br><span class="line">  <span class="keyword">this</span>.context = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.pendingContext = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 老朋友了，用来确定第一次渲染的时候是否需要注水</span></span><br><span class="line">  <span class="keyword">this</span>.hydrate = hydrate;</span><br><span class="line">  <span class="comment">//回调节点</span></span><br><span class="line">  <span class="keyword">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//回调属性</span></span><br><span class="line">  <span class="keyword">this</span>.callbackPriority = NoLane;</span><br><span class="line">  <span class="comment">// export const NoLanes: Lanes = 0b0000000000000000000000000000000;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  export function createLaneMap&lt;T&gt;(initial: T): LaneMap&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">    // Intentionally pushing one by one.</span></span><br><span class="line"><span class="comment">    // https://v8.dev/blog/elements-kinds#avoid-creating-holes</span></span><br><span class="line"><span class="comment">    const laneMap = [];</span></span><br><span class="line"><span class="comment">    for (let i = 0; i &lt; TotalLanes; i++) &#123;</span></span><br><span class="line"><span class="comment">      laneMap.push(initial);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return laneMap;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//任务时间。由于该字段在未来会重构，当前我们不需要理解他。</span></span><br><span class="line">  <span class="keyword">this</span>.eventTimes = createLaneMap(NoLanes);</span><br><span class="line">  <span class="comment">// 过期时间。函数上面的注释有。export const NoTimestamp = -1;</span></span><br><span class="line">  <span class="keyword">this</span>.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先级的初始化</span></span><br><span class="line">  <span class="keyword">this</span>.pendingLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.suspendedLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.pingedLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.mutableReadLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.entangledLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.entanglements = createLaneMap(NoLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pooledCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.pooledCacheLanes = NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (supportsHydration) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutableSourceEagerHydrationData = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class="line">    <span class="keyword">this</span>.memoizedInteractions = <span class="keyword">new</span> Set();</span><br><span class="line">    <span class="keyword">this</span>.pendingInteractionMap = <span class="keyword">new</span> Map();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hydrationCallbacks = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; enableProfilerCommitHooks) &#123;</span><br><span class="line">    <span class="keyword">this</span>.effectDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.passiveEffectDuration = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> ConcurrentRoot:</span><br><span class="line">        <span class="keyword">this</span>._debugRootType = <span class="string">'createRoot()'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LegacyRoot:</span><br><span class="line">        <span class="keyword">this</span>._debugRootType = <span class="string">'createLegacyRoot()'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createHostRootFiber"><a href="#createHostRootFiber" class="headerlink" title="createHostRootFiber"></a>createHostRootFiber</h4><p>通篇大论都是在判断mode类型。感兴趣的可以再深挖。这里我就略过了。眼睛已经看花了。。。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  strictModeLevelOverride: <span class="literal">null</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class="line">    mode = ConcurrentMode;</span><br><span class="line">    <span class="keyword">if</span> (strictModeLevelOverride !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strictModeLevelOverride &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        mode |= StrictLegacyMode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableStrictEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strictModeLevelOverride &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">          mode |= StrictEffectsMode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableStrictEffects &amp;&amp; createRootStrictEffectsByDefault) &#123;</span><br><span class="line">        mode |= StrictLegacyMode | StrictEffectsMode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mode |= StrictLegacyMode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mode = NoMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    mode |= ProfileMode;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// export const HostRoot = 3;</span></span><br><span class="line">  <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createFiber"><a href="#createFiber" class="headerlink" title="createFiber"></a>createFiber</h4><p>也是包一个壳子。主要还是为了创建FiberNode。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createFiber = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="FiberNode"><a href="#FiberNode" class="headerlink" title="FiberNode"></a>FiberNode</h4><p>官方其实已经注释了属性的要素。但是我还是会尽可能的完善。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="comment">// 用于标记fiber节点的类型</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="comment">// 用于唯一标识一个fiber节点</span></span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="comment">// 节点类型</span></span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ReactNode的节点类型</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// FiberNode会通过stateNode绑定一些其他的对象，例如FiberNode对应的Dom、FiberRoot、ReactComponent实例</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="comment">// 表示父级 FiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 表示第一个子 FiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 表示紧紧相邻的下一个兄弟 FiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 下标</span></span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示新的props</span></span><br><span class="line">  <span class="keyword">this</span>.pendingProps = pendingProps;</span><br><span class="line">  <span class="comment">// 表示经过所有流程处理后的新props</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 更新队列</span></span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 表示经过所有流程处理后的新state</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 依赖</span></span><br><span class="line">  <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="comment">// 标志更新的类型：删除、新增、修改。</span></span><br><span class="line">  <span class="keyword">this</span>.flags = NoFlags;</span><br><span class="line">  <span class="comment">// 子Fiber树的标志更新的类型：删除、新增、修改。</span></span><br><span class="line">  <span class="keyword">this</span>.subtreeFlags = NoFlags;</span><br><span class="line">  <span class="comment">// 需要删除的内容</span></span><br><span class="line">  <span class="keyword">this</span>.deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先级</span></span><br><span class="line">  <span class="keyword">this</span>.lanes = NoLanes;</span><br><span class="line">  <span class="comment">// 子的优先级</span></span><br><span class="line">  <span class="keyword">this</span>.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双缓冲：防止数据丢失，提高效率（之后Dom-diff的时候可以直接比较或者使用</span></span><br><span class="line">  <span class="keyword">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    <span class="comment">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initializing the fields below to smis and later updating them with</span></span><br><span class="line">    <span class="comment">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class="line">    <span class="comment">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class="line">    <span class="comment">// Fortunately this only impacts DEV builds.</span></span><br><span class="line">    <span class="comment">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class="line">    <span class="comment">// To work around this, initialize the fields below with doubles.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Learn more about this here:</span></span><br><span class="line">    <span class="comment">// https://github.com/facebook/react/issues/14365</span></span><br><span class="line">    <span class="comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class="line">    <span class="keyword">this</span>.actualDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="keyword">this</span>.selfBaseDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="keyword">this</span>.treeBaseDuration = <span class="built_in">Number</span>.NaN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class="line">    <span class="comment">// This won't trigger the performance cliff mentioned above,</span></span><br><span class="line">    <span class="comment">// and it simplifies other profiler code (including DevTools).</span></span><br><span class="line">    <span class="keyword">this</span>.actualDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>.selfBaseDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.treeBaseDuration = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// This isn't directly used but is handy for debugging internals:</span></span><br><span class="line">    <span class="keyword">this</span>._debugID = debugCounter++;</span><br><span class="line">    <span class="keyword">this</span>._debugSource = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._debugOwner = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._debugNeedsRemount = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._debugHookTypes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Object</span>.preventExtensions === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="initializeUpdateQueue"><a href="#initializeUpdateQueue" class="headerlink" title="initializeUpdateQueue"></a>initializeUpdateQueue</h4><p>createContainer还有最后一个函数，初始化更新队列。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>,</span><br><span class="line">      interleaved: <span class="literal">null</span>,</span><br><span class="line">      lanes: NoLanes,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="小结一番"><a href="#小结一番" class="headerlink" title="小结一番"></a>小结一番</h1><p>大费周章的做这些阅读，其实回过神来看。就是为了创建<code>fiberNode</code>（<code>FiberRootNode实例</code>）和<code>rootFiber</code>对象。这两兄弟是整个Fiber树构建的起点。</p>
<ul>
<li><code>fiberNode</code>（<code>FiberRootNode实例</code>） -&gt; 的关联对象是真实 DOM 的容器节点</li>
<li><code>rootFiber</code> -&gt; 虚拟 DOM 的根节点</li>
</ul>
<p>然后再回过神来看，确实。他们各自创建都是为他们所代表的东西而创建，无论是属性或者打入方法。</p>
<h1 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h1><p>最后他们都会被<code>unbatchedUpdates</code>所收编（看看最上面梦开始的地方「legacyRenderSubtreeIntoContainer」）。最后我们所创建的都会归入到它的手上。一起看看最后一个函数吧。</p>
<h2 id="方便阅读"><a href="#方便阅读" class="headerlink" title="方便阅读"></a>方便阅读</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unbatchedUpdates(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="unbatchedUpdates"><a href="#unbatchedUpdates" class="headerlink" title="unbatchedUpdates"></a>unbatchedUpdates</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unbatchedUpdates</span>(<span class="params">fn, a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是对上下文的处理，不必纠结</span></span><br><span class="line">  <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext &amp;= ~BatchedContext;</span><br><span class="line">  executionContext |= LegacyUnbatchedContext;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span><br><span class="line">    <span class="keyword">return</span> fn(a);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">      <span class="comment">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class="line">      resetRenderTimer();</span><br><span class="line">      flushSyncCallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="updateContainer"><a href="#updateContainer" class="headerlink" title="updateContainer"></a>updateContainer</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个 event 相关的入参，此处不必关注</span></span><br><span class="line">  <span class="keyword">var</span> eventTime = requestEventTime();</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个比较关键的入参，lane 表示优先级</span></span><br><span class="line">  <span class="keyword">var</span> lane = requestUpdateLane(current);</span><br><span class="line">  <span class="comment">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span><br><span class="line">  <span class="keyword">var</span> update = createUpdate(eventTime, lane); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// update 的 payload 对应的是一个 React 元素</span></span><br><span class="line">  update.payload = &#123;</span><br><span class="line">    element: element</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        error(<span class="string">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class="string">'function. Instead received: %s.'</span>, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 update 入队</span></span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  <span class="comment">// 调度 fiberRoot </span></span><br><span class="line">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class="line">  <span class="comment">// 返回当前节点（fiberRoot）的优先级</span></span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>
<ul>
<li><p>请求当前 Fiber 节点的 lane（优先级）；</p>
</li>
<li><p>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p>
</li>
<li><p>调度当前节点（rootFiber）。</p>
</li>
</ul>
<p>看到这里的伙伴，谢谢你的耐心。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为我也是在一边看，一边记录，如果有问题，大家一定要及时提出来。我也会及时更新的。这部分我应该会屡次阅读。毕竟大神写了几年，我不可能几天就看明白的。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a href="https://zh-hans.reactjs.org/docs" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Derrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://derricktel.github.io/2021/04/06/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89Fiber%20%E5%88%9D%E5%A7%8B%E5%8C%96/">http://derricktel.github.io/2021/04/06/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89Fiber%20%E5%88%9D%E5%A7%8B%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://derricktel.github.io" target="_blank">Derrick</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a></div><div class="post_share"><div class="social-share" data-image="/image/cover/react.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickWechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/DerrickAlipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/06/17/%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8React%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/"><img class="prev_cover lazyload" data-src="/image/cover/react.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全网最全React源码调试傻瓜式教程</div></div></a></div><div class="next-post pull_right"><a href="/2021/04/05/%E3%80%90%E9%87%8D%E8%AF%86%E5%89%8D%E7%AB%AF%E3%80%91React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%892000%E5%AD%97%E5%91%8A%E8%AF%89%E4%BD%A0Fiber%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA/"><img class="next_cover lazyload" data-src="/image/cover/react.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/03/29/【重识前端】React源码阅读（一）jsx/" title="【重识前端】React源码阅读（一）jsx"><img class="relatedPosts_cover lazyload"data-src="/image/cover/react.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-29</div><div class="relatedPosts_title">【重识前端】React源码阅读（一）jsx</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/05/【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机/" title="【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机"><img class="relatedPosts_cover lazyload"data-src="/image/cover/react.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-04-05</div><div class="relatedPosts_title">【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机</div></div></a></div><div class="relatedPosts_item"><a href="/2021/06/30/【重识前端】React源码阅读（四）/" title="【重识前端】React源码阅读（四）"><img class="relatedPosts_cover lazyload"data-src="/image/cover/react.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-06-30</div><div class="relatedPosts_title">【重识前端】React源码阅读（四）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/06/17/全网最全React源码调试教程/" title="全网最全React源码调试傻瓜式教程"><img class="relatedPosts_cover lazyload"data-src="/image/cover/react.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-06-17</div><div class="relatedPosts_title">全网最全React源码调试傻瓜式教程</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Derrick</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>
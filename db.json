{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/image/AntDesignForm总结/modal.png","path":"image/AntDesignForm总结/modal.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/20190312150929439.png","path":"image/AntDesignPro探索/20190312150929439.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/20190312150742764.png","path":"image/AntDesignPro探索/20190312150742764.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/20190312151053807.png","path":"image/AntDesignPro探索/20190312151053807.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/2019031215140926.png","path":"image/AntDesignPro探索/2019031215140926.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/20190312151839845.png","path":"image/AntDesignPro探索/20190312151839845.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/20190312152011733.png","path":"image/AntDesignPro探索/20190312152011733.png","modified":1,"renderable":0},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg","path":"image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg","modified":1,"renderable":0},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg","path":"image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg","modified":1,"renderable":0},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg","path":"image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg","modified":1,"renderable":0},{"_id":"source/image/React入门/20181123111537542.png","path":"image/React入门/20181123111537542.png","modified":1,"renderable":0},{"_id":"source/image/React入门/20181123143905811.png","path":"image/React入门/20181123143905811.png","modified":1,"renderable":0},{"_id":"source/image/SpringBoot跨域/20190311105909443.png","path":"image/SpringBoot跨域/20190311105909443.png","modified":1,"renderable":0},{"_id":"source/image/React入门/20181123134126335.png","path":"image/React入门/20181123134126335.png","modified":1,"renderable":0},{"_id":"source/image/SpringBoot跨域/20190311110735834.png","path":"image/SpringBoot跨域/20190311110735834.png","modified":1,"renderable":0},{"_id":"source/image/WebpackCleanWebpackPlugin/20190622155123842.png","path":"image/WebpackCleanWebpackPlugin/20190622155123842.png","modified":1,"renderable":0},{"_id":"source/image/cover/JWT.png","path":"image/cover/JWT.png","modified":1,"renderable":0},{"_id":"source/image/cover/ANTD.png","path":"image/cover/ANTD.png","modified":1,"renderable":0},{"_id":"source/image/cover/HEXO.png","path":"image/cover/HEXO.png","modified":1,"renderable":0},{"_id":"source/image/cover/KDpgvguMpGfqaHPjicRK.svg","path":"image/cover/KDpgvguMpGfqaHPjicRK.svg","modified":1,"renderable":0},{"_id":"source/image/cover/React.jpeg","path":"image/cover/React.jpeg","modified":1,"renderable":0},{"_id":"source/image/cover/antdP.png","path":"image/cover/antdP.png","modified":1,"renderable":0},{"_id":"source/image/cover/JavaScript.png","path":"image/cover/JavaScript.png","modified":1,"renderable":0},{"_id":"source/image/cover/css.png","path":"image/cover/css.png","modified":1,"renderable":0},{"_id":"source/image/cover/decorator.png","path":"image/cover/decorator.png","modified":1,"renderable":0},{"_id":"source/image/cover/http.png","path":"image/cover/http.png","modified":1,"renderable":0},{"_id":"source/image/cover/history.jpeg","path":"image/cover/history.jpeg","modified":1,"renderable":0},{"_id":"source/image/cover/github.jpg","path":"image/cover/github.jpg","modified":1,"renderable":0},{"_id":"source/image/cover/react.png","path":"image/cover/react.png","modified":1,"renderable":0},{"_id":"source/image/cover/webpack.png","path":"image/cover/webpack.png","modified":1,"renderable":0},{"_id":"source/image/cover/springboot.png","path":"image/cover/springboot.png","modified":1,"renderable":0},{"_id":"source/image/historyBack函数/20190318092239845.png","path":"image/historyBack函数/20190318092239845.png","modified":1,"renderable":0},{"_id":"source/image/cover/web.jpeg","path":"image/cover/web.jpeg","modified":1,"renderable":0},{"_id":"source/image/httpHttps/15fc2525666dc96e.jpg","path":"image/httpHttps/15fc2525666dc96e.jpg","modified":1,"renderable":0},{"_id":"source/image/pr/title.png","path":"image/pr/title.png","modified":1,"renderable":0},{"_id":"source/image/pr/pornhub.jpg","path":"image/pr/pornhub.jpg","modified":1,"renderable":0},{"_id":"source/image/react1/console.png","path":"image/react1/console.png","modified":1,"renderable":0},{"_id":"source/image/router/demo.gif","path":"image/router/demo.gif","modified":1,"renderable":0},{"_id":"source/image/地址栏/woshou.png","path":"image/地址栏/woshou.png","modified":1,"renderable":0},{"_id":"source/image/深拷贝浅拷贝/20190428204522836.png","path":"image/深拷贝浅拷贝/20190428204522836.png","modified":1,"renderable":0},{"_id":"source/image/深入内存世界/3.png","path":"image/深入内存世界/3.png","modified":1,"renderable":0},{"_id":"source/image/深拷贝浅拷贝/20190428205243797.png","path":"image/深拷贝浅拷贝/20190428205243797.png","modified":1,"renderable":0},{"_id":"source/image/深拷贝浅拷贝/20190428204904611.png","path":"image/深拷贝浅拷贝/20190428204904611.png","modified":1,"renderable":0},{"_id":"source/image/深拷贝浅拷贝/20190428205853748.png","path":"image/深拷贝浅拷贝/20190428205853748.png","modified":1,"renderable":0},{"_id":"source/image/深拷贝浅拷贝/20190428205350562.png","path":"image/深拷贝浅拷贝/20190428205350562.png","modified":1,"renderable":0},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/DerrickAlipay.jpg","path":"img/DerrickAlipay.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/DerrickWechat.png","path":"img/DerrickWechat.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/comment_bg.png","path":"img/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/post.jpg","path":"img/post.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/post_loadding.svg","path":"img/post_loadding.svg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"source/image/AntDesignPro探索/2019031215120430.png","path":"image/AntDesignPro探索/2019031215120430.png","modified":1,"renderable":0},{"_id":"source/image/CSSModules警告/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg","path":"image/CSSModules警告/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg","modified":1,"renderable":0},{"_id":"source/image/SpringBootJWT/20190325103836546.png","path":"image/SpringBootJWT/20190325103836546.png","modified":1,"renderable":0},{"_id":"source/image/SpringBoot跨域/20190311110721789.png","path":"image/SpringBoot跨域/20190311110721789.png","modified":1,"renderable":0},{"_id":"source/image/react1/stats.png","path":"image/react1/stats.png","modified":1,"renderable":0},{"_id":"source/image/地址栏/dns.png","path":"image/地址栏/dns.png","modified":1,"renderable":0},{"_id":"source/image/地址栏/huishou.png","path":"image/地址栏/huishou.png","modified":1,"renderable":0},{"_id":"themes/Butterfly/source/img/1avatar.png","path":"img/1avatar.png","modified":1,"renderable":1},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg","path":"image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg","modified":1,"renderable":0},{"_id":"source/image/react1/offer.png","path":"image/react1/offer.png","modified":1,"renderable":0},{"_id":"source/image/你真的懂ReactHook吗/2019081821194714.png","path":"image/你真的懂ReactHook吗/2019081821194714.png","modified":1,"renderable":0},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"source/image/BFC/1.png","path":"image/BFC/1.png","modified":1,"renderable":0},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":1,"renderable":1},{"_id":"source/image/pr/commit.png","path":"image/pr/commit.png","modified":1,"renderable":0},{"_id":"source/image/react1/bebel.png","path":"image/react1/bebel.png","modified":1,"renderable":0},{"_id":"source/image/react1/download.jpg","path":"image/react1/download.jpg","modified":1,"renderable":0},{"_id":"source/image/你真的懂ReactHook吗/20190818212347571.png","path":"image/你真的懂ReactHook吗/20190818212347571.png","modified":1,"renderable":0},{"_id":"themes/Butterfly/source/img/index.jpg","path":"img/index.jpg","modified":1,"renderable":1},{"_id":"source/image/BFC/2.png","path":"image/BFC/2.png","modified":1,"renderable":0},{"_id":"source/image/WebpackCleanWebpackPlugin/20190622155255789.png","path":"image/WebpackCleanWebpackPlugin/20190622155255789.png","modified":1,"renderable":0},{"_id":"source/image/cover/bg.jpg","path":"image/cover/bg.jpg","modified":1,"renderable":0},{"_id":"source/image/pr/pr.png","path":"image/pr/pr.png","modified":1,"renderable":0},{"_id":"source/image/react1/element.png","path":"image/react1/element.png","modified":1,"renderable":0},{"_id":"source/image/reactDebugger/console.png","path":"image/reactDebugger/console.png","modified":1,"renderable":0},{"_id":"source/image/深入内存世界/2.png","path":"image/深入内存世界/2.png","modified":1,"renderable":0},{"_id":"source/image/pr/create.png","path":"image/pr/create.png","modified":1,"renderable":0},{"_id":"source/image/pr/push.png","path":"image/pr/push.png","modified":1,"renderable":0},{"_id":"source/image/AntDesignPro探索/2019031215175956.png","path":"image/AntDesignPro探索/2019031215175956.png","modified":1,"renderable":0},{"_id":"source/image/Web前端学习路线/20190328205449472.png","path":"image/Web前端学习路线/20190328205449472.png","modified":1,"renderable":0},{"_id":"source/image/深入内存世界/1.jpeg","path":"image/深入内存世界/1.jpeg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/Butterfly/_config.yml","hash":"973b5c3d12c834b2dafed42f43f946ccefeac616","modified":1624543206992},{"_id":"themes/Butterfly/package.json","hash":"65bcf567dea408eb6969a02be629e2a27ee595d8","modified":1624543207006},{"_id":"source/_posts/5分钟快速精通Ant-Design-Form-1分钟快速构建复杂Ant-Design-Form表单.md","hash":"91deac5787b52428e5d0fdc089b4fb37330f1f0c","modified":1624543206846},{"_id":"source/_posts/HTTPHTTPS协议.md","hash":"08fde324fc97689baa9f33e9dfa1c6000e3eed0b","modified":1624543206846},{"_id":"source/_posts/Hexo+GitHub构建你的博客.md","hash":"3dd2f41843adfc5faaefb02debbd2dcb3d26cc06","modified":1624543206846},{"_id":"source/_posts/JWT-spring-boot-JAVA-使用步骤-spring-boot2-0.md","hash":"1f973e5ec964f230c749ffa5eae147ff4153b141","modified":1624543206846},{"_id":"source/_posts/React-State详解.md","hash":"ce1479b01f34645271ee96028b09880ec13e0aaa","modified":1624543206847},{"_id":"source/_posts/React-Hook-倒计时.md","hash":"e5f8fa722df5eb954673adb677b87f866a95b36b","modified":1624543206847},{"_id":"source/_posts/JavaScript-浅拷贝-深拷贝-赋值-引用-JS.md","hash":"c67207f101fab56091b779280bc4a6f327c22028","modified":1624543206847},{"_id":"source/_posts/Webpack-CleanWebpackPlugin-is-not-a-constructor.md","hash":"82aeac58b3b4e60c57292e560d62b9ccea4d730f","modified":1624543206847},{"_id":"source/_posts/Web前端-学习目录-学习框架-系统性的学习Web前端.md","hash":"b651177fb9f06900a656928cde3077c78f1d6f28","modified":1624543206848},{"_id":"source/_posts/ant-design-Form-组件总结-结合Modal-自定义Modal的实现-（Upload-Input-Select-DatePicker-Cascader）.md","hash":"ea5e4aace155c758dc3c49263897567c12426c97","modified":1624543206848},{"_id":"source/_posts/chunk-0-mini-css-extract-plugin-解决-CSS-Modules-警告.md","hash":"f24800bf6aee56b774ea2a705daf1b95101f1895","modified":1624543206848},{"_id":"source/_posts/ant-design-pro-2-0-新页面探索-umi-页面404-react.md","hash":"592163a84bbb6abd70321ec740b07c1ff8754690","modified":1624543206848},{"_id":"source/_posts/session和cookie的理解.md","hash":"6aed9a0b5941d486322bdc7f7933b7c307f86086","modified":1624543206849},{"_id":"source/_posts/sprng-boot-跨域-过滤器-fetch-react-Response-to-preflight-request-doesn-t-pass-access-control-check.md","hash":"66eca3e07adf7e0a981fd9f9e4f33b1224cd399c","modified":1624543206849},{"_id":"source/_posts/「如何给github提一个PR」.md","hash":"3c41c6f9e2ff2237b76ce1e69ce7abcb34ad74f9","modified":1624543206849},{"_id":"source/_posts/window-history-back-缓存-返回上级页面不刷新数据.md","hash":"72096bf30df0c6e0afc1bc52d6c25b9d71e11938","modified":1624543206849},{"_id":"source/_posts/【重识前端】React源码阅读（一）jsx.md","hash":"a524adec19dcf8e4fe6abfeffd717c08f0ef45ab","modified":1624779141936},{"_id":"source/_posts/【重识前端】React-Router源码阅读.md","hash":"96dc9cbfb11dd4ccf2e12960542a2619789833bb","modified":1624779194178},{"_id":"source/_posts/【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机.md","hash":"0ff0f7dddd47a7f7f659d5f4b874fb7d1c950cca","modified":1624543206850},{"_id":"source/_posts/【重识前端】React源码阅读（三）Fiber 初始化.md","hash":"e47569aa18e837f2d7c2dc85b2fe7a6462faa9d0","modified":1624543206850},{"_id":"source/_posts/【重识前端】React源码阅读（四）.md","hash":"581820f745a8aba4d4621e15e4c8a84d587bec36","modified":1624543206851},{"_id":"source/_posts/【重识前端】redux源码阅读.md","hash":"cd507291004834cb9655c964de7a6dd5210a802f","modified":1624543206851},{"_id":"source/_posts/【重识前端】一次搞定事件循环.md","hash":"4044bfc1c930fb5b77c865a43776ceb9da3754e9","modified":1624543206851},{"_id":"source/_posts/【重识前端】全面攻破this.md","hash":"b177e172617c042b7b216ab5141d100268c02fc8","modified":1624543206852},{"_id":"source/_posts/【重识前端】什么是BFC、IFC、GFC 和 FFC.md","hash":"d6e52bcca302ebac90408d92d41687ba09336e1b","modified":1624543206851},{"_id":"source/_posts/【重识前端】原型原型链和继承.md","hash":"5c4349cad27489cb3762a43f782282dbb968cc8c","modified":1624543206852},{"_id":"source/_posts/【重识前端】地址栏中输入网址后.md","hash":"c56762a207f0c559b3be2b0b603e9c30902eb5c7","modified":1624543206852},{"_id":"source/_posts/【重识前端】深入内存世界.md","hash":"4622907255a88e7354474abe3709daf0f7b14796","modified":1624543206853},{"_id":"source/_posts/【重识前端】闭包与模块.md","hash":"1e7c74db46f4def8536e3bcca413baacf30a1031","modified":1624543206853},{"_id":"source/_posts/【面经】2年前端杭州面试集合.md","hash":"628ecf46e82d30b0ed1e8bb47e3a454c03aee686","modified":1624543206854},{"_id":"source/_posts/【重识前端】暴走的异步编程.md","hash":"b6b4cb256c8274b438f2724f59b89266aea7d5b8","modified":1624543206853},{"_id":"source/_posts/你真的懂React-Hook吗.md","hash":"ee436c5f20af784a00889dab69b74237e6ef9cb6","modified":1624543206855},{"_id":"source/_posts/全网最全React源码调试教程.md","hash":"c056d321a8795b140a1d1d8b539f4f61255bb8b0","modified":1624543206855},{"_id":"source/_posts/从零配置你的Webpack.md","hash":"33b05e1c9d9f533e181ff6fb679ebc680b5a4a7a","modified":1624543206854},{"_id":"source/_posts/前端进阶-配置你自己的脚手架.md","hash":"9a305ee244406bed8773cae6670bec9382684ec9","modified":1624543206855},{"_id":"source/_posts/装饰器(Decorator)和React高阶组件(HOC).md","hash":"47ef35dc535eb6305f4d2ebdeeb673b4e05fab53","modified":1624543206855},{"_id":"source/_posts/面试官：听说你对package-json很熟？.md","hash":"26d751f569cc73211fcc97bc5d651bb4082ef34d","modified":1624543206855},{"_id":"source/about/index.md","hash":"d5c881255a4c077e4237da19209318bb28278fa9","modified":1624543206855},{"_id":"source/clean/index.md","hash":"59ec9db1320839dccfa150b794ea8d672c8d8efd","modified":1624543206855},{"_id":"themes/Butterfly/.github/stale.yml","hash":"70467ce772e68de57a4bf2ac285f1c0b122f25f5","modified":1624543206992},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"9a4f2daa73108fbd48a6af565d53230eef163bee","modified":1624543206992},{"_id":"themes/Butterfly/LICENSE","hash":"e7e7b7677bb19563a9013e936486bdefeb761d07","modified":1624543206992},{"_id":"themes/Butterfly/README_CN.md","hash":"c8c348065dc2113d52f2930f0b13b438e31c1172","modified":1624543206992},{"_id":"themes/Butterfly/README.md","hash":"8ce70d7d0facbb4cbe08dc59b03d3dfc5861fe4a","modified":1624543206992},{"_id":"themes/Butterfly/languages/default.yml","hash":"c6156fed37fa10c5704bf3780cd58c9ce1dc58dd","modified":1624543206993},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"5890f7257a5165e19851a7ee805ef0c98bc69f12","modified":1624543206993},{"_id":"themes/Butterfly/languages/en.yml","hash":"c6156fed37fa10c5704bf3780cd58c9ce1dc58dd","modified":1624543206993},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"0f029273acc3d945d1e784e142b61089ca318b06","modified":1624543206993},{"_id":"themes/Butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1624543206993},{"_id":"themes/Butterfly/layout/category.pug","hash":"e42b321de7b2ebdb3a499395d1559bb927eba7b4","modified":1624543206993},{"_id":"themes/Butterfly/layout/404.pug","hash":"a6413aa10bafd4492d912245f632321bd60b0b8d","modified":1624543206993},{"_id":"themes/Butterfly/layout/flink.pug","hash":"490c23ea939eab6a0bdc4d436219cc03799f208c","modified":1624543206993},{"_id":"themes/Butterfly/layout/tag.pug","hash":"6e18889daf0f6288fbacb5f589bdfb5e05c9c8f8","modified":1624543207006},{"_id":"themes/Butterfly/layout/post.pug","hash":"78b408d1557f79e0829af0df0e5bd66a35608309","modified":1624543207006},{"_id":"themes/Butterfly/layout/page.pug","hash":"70511837da68cb733395ff071b8be429737c559d","modified":1624543207006},{"_id":"themes/Butterfly/layout/page-tags.pug","hash":"f07502030375047b48e7e1db26be8f10b15a6562","modified":1624543207006},{"_id":"themes/Butterfly/layout/index.pug","hash":"131879062ce9afd20743f60dc9bf34d2e2e781aa","modified":1624543207006},{"_id":"source/image/AntDesignForm总结/modal.png","hash":"e2e06c1d4221e0d58ddf05bf54d3baf18770b7a8","modified":1624543206856},{"_id":"source/image/AntDesignPro探索/20190312150929439.png","hash":"95ea643ebfccad9d3dd13d32f2b3125d1dfc083d","modified":1624543206857},{"_id":"source/image/AntDesignPro探索/20190312150742764.png","hash":"7195c4a5006d0eae1be5a292557b450f65c6c911","modified":1624543206856},{"_id":"source/image/AntDesignPro探索/20190312151053807.png","hash":"71de09ee4a2571fe6f15bfb0ab72f57fecdff0ed","modified":1624543206857},{"_id":"source/image/AntDesignPro探索/2019031215140926.png","hash":"aea2d3b14caffc9a8705c54fb054970b2ab76cee","modified":1624543206858},{"_id":"source/image/AntDesignPro探索/20190312151839845.png","hash":"2fdadb1ef8077f5479c3b7f54e7fde29e7115686","modified":1624543206872},{"_id":"source/image/AntDesignPro探索/20190312152011733.png","hash":"5ebfaa1f282713b2fad33b230bbcd661cac4059f","modified":1624543206873},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg","hash":"6b84d92b26daaa7d70b6f275456a65495819e23b","modified":1624543206879},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg","hash":"5adc2f974658dcdcb1d2c5cf4d4946e551c5021e","modified":1624543206878},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg","hash":"124651411d1258ae1ca253eea3eecad3a47a3997","modified":1624543206879},{"_id":"source/image/React入门/20181123111537542.png","hash":"c35997a4f68255b834c654fa46a03879c79a9e8a","modified":1624543206881},{"_id":"source/image/React入门/20181123143905811.png","hash":"bfd5e05a8109dc65f49e30e7e043e8220ffacd53","modified":1624543206881},{"_id":"source/image/SpringBoot跨域/20190311105909443.png","hash":"597ceaa3d51037162b08d1e5ce90e17d61a003e8","modified":1624543206883},{"_id":"source/image/React入门/20181123134126335.png","hash":"9c0a1f31428bcfd09f5540989ec0ceec23e52020","modified":1624543206881},{"_id":"source/image/SpringBoot跨域/20190311110735834.png","hash":"1be7071509aad1e8b57968699800f771b96e5865","modified":1624543206883},{"_id":"source/image/WebpackCleanWebpackPlugin/20190622155123842.png","hash":"51a6b66753f63d1160b83ce9c819dc5931ef474f","modified":1624543206884},{"_id":"source/image/cover/JWT.png","hash":"54e734ffae7e5a15498be8006003dac36d104c5b","modified":1624543206912},{"_id":"source/image/cover/ANTD.png","hash":"898d9e3bc115706f2df19d89d34c786b20bea4e8","modified":1624543206911},{"_id":"source/image/cover/HEXO.png","hash":"c2c59b2d8b9c2f91be92d0b01bce3acd68921065","modified":1624543206911},{"_id":"source/image/cover/KDpgvguMpGfqaHPjicRK.svg","hash":"6ecaeecec62d077e011e8c69a633fddb366b4d19","modified":1624543206912},{"_id":"source/image/cover/React.jpeg","hash":"dc18c45077ecfaffaffd735900e9bb58d6cfd03f","modified":1624543206912},{"_id":"source/image/cover/antdP.png","hash":"e51856b14c5ba11da682c462541a1ae9f179f1fb","modified":1624543206913},{"_id":"source/image/cover/JavaScript.png","hash":"d051bd5987e275b1ebb32ddc841322d87f5f146a","modified":1624543206912},{"_id":"source/image/cover/css.png","hash":"052b66320dfb67fe6758555be7bfba9d96ab01fc","modified":1624543206917},{"_id":"source/image/cover/decorator.png","hash":"8a8cf27d287b3b02adc4a95db40430a1a6269613","modified":1624543206918},{"_id":"source/image/cover/http.png","hash":"c42bfcc7b07d40e89cafd721baed7c4b275fa551","modified":1624543206918},{"_id":"source/image/cover/history.jpeg","hash":"9d3cbcea80f59224e85021ecd695d355dfddb525","modified":1624543206918},{"_id":"source/image/cover/github.jpg","hash":"82d9e06e9bc1c7416f1408772210a8def27801b2","modified":1624543206918},{"_id":"source/image/cover/react.png","hash":"56effb8587fa0d3f273044aef82cf7889613f68c","modified":1624543206918},{"_id":"source/image/cover/webpack.png","hash":"7886cc0dfb91faf4b35652b67919d59ade7b74ae","modified":1624543206919},{"_id":"source/image/cover/springboot.png","hash":"dc2c4b7dc46f2dfaec66c6d6c596caebbf86c83f","modified":1624543206918},{"_id":"source/image/historyBack函数/20190318092239845.png","hash":"50b0bad4ccea97e01be0b4a5b9bc900ce703ae10","modified":1624543206920},{"_id":"source/image/cover/web.jpeg","hash":"d2bcd938948a48679ddb81531b38bec32c3c0f1c","modified":1624543206919},{"_id":"source/image/httpHttps/15fc2525666dc96e.jpg","hash":"57028340f40d6959e5cdf702c5c2d74c90a42f33","modified":1624543206921},{"_id":"source/image/pr/title.png","hash":"b4c16571881858b9ba5b68663a36c1ed2535724d","modified":1624543206931},{"_id":"source/image/pr/pornhub.jpg","hash":"d6f09aaba7c0dcff4f1d230e6480042fc4686faa","modified":1624543206924},{"_id":"source/image/react1/console.png","hash":"b4b1d198c39c92bbc056ffc7c8e65a858de96532","modified":1624543206934},{"_id":"source/image/router/demo.gif","hash":"188070a202ae35488a1ec158718e23eaf10d1ab2","modified":1624543206942},{"_id":"source/image/地址栏/woshou.png","hash":"4e19a237cd2864a1b7a37bb3751742c2d364e1e6","modified":1624543206948},{"_id":"source/image/深拷贝浅拷贝/20190428204522836.png","hash":"33e1d52e178309724c364a23e2600fd8dadd5c54","modified":1624543206977},{"_id":"source/image/深入内存世界/3.png","hash":"d27f3b1a0540385b5ee02e699e18819dbb025aea","modified":1624543206977},{"_id":"source/image/深拷贝浅拷贝/20190428205243797.png","hash":"6a69ed4fdcab7d20174a95b0a8006d419440c049","modified":1624543206978},{"_id":"source/image/深拷贝浅拷贝/20190428204904611.png","hash":"7caef4b8f9872e6d80d21f807c93ba6a4c9ceb21","modified":1624543206978},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"dac1c58da936086264361dc487602bacbd50dbba","modified":1624543206994},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"5a979181e297962cc8eadecd6e0c3c255cc604c7","modified":1624543206996},{"_id":"source/image/深拷贝浅拷贝/20190428205853748.png","hash":"f31ac1cc377d72e17d69a227b66567d207538e86","modified":1624543206978},{"_id":"source/image/深拷贝浅拷贝/20190428205350562.png","hash":"1a81ad3e621d51556a56bee13d2d5885c77f1475","modified":1624543206978},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"9d98c38f1634987ef22a3cdb391b1f9fa2f806d2","modified":1624543206995},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"4655e8d32f9d1e58cbf53592dd51ca75eef5d2af","modified":1624543206999},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"25ea63d6fc384a9a3248b8d7960baec813e25829","modified":1624543207007},{"_id":"themes/Butterfly/scripts/events/replace-config.js","hash":"5eee75eaa56f81344b5a6b8aa4bdf38dfcb70370","modified":1624543207007},{"_id":"themes/Butterfly/scripts/filters/hide-post.js","hash":"ad211cab96bf3f7abd4fe2a0abf87dbdccbf57f4","modified":1624543207007},{"_id":"themes/Butterfly/scripts/filters/post-lazyload.js","hash":"e3c8300250d8b6b0754656dd2d366d6e4afc5508","modified":1624543207007},{"_id":"themes/Butterfly/scripts/helpers/list-archives.js","hash":"e1d17ec106b0eca5077449592cc79baf00f37a59","modified":1624543207007},{"_id":"themes/Butterfly/scripts/helpers/related-post.js","hash":"658d5a6434d570cd03f30e2a99ba8c78c98c1f40","modified":1624543207008},{"_id":"themes/Butterfly/scripts/filters/random-cover.js","hash":"f42b6fc333e74198dcad1f4ed76260744cf8c3cc","modified":1624543207007},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"1fff288f686859458226ba1fb3789b8575ea7ddb","modified":1624543207008},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"d3e50e577e805f890ba823f367d33b2f21954b4a","modified":1624543207008},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"87dd8af711545ac79ef386f1aa6dcc8e4516ebc1","modified":1624543207008},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"0257868bd269a577f0d139a2ecfac2605750820f","modified":1624543207008},{"_id":"themes/Butterfly/source/css/index.styl","hash":"8bc1990ba957831fe9dc1041b5af589248eb96d8","modified":1624543207016},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"22a7daf3ef6c7ba0edbda7bd7dffd21cabd95471","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"3981532dfffb57d00e3ebf5f590a2094d426898a","modified":1624543207003},{"_id":"themes/Butterfly/source/css/var.styl","hash":"f43a4bad4478e1f7686bbdb76fee9528a5edd134","modified":1624543207016},{"_id":"themes/Butterfly/layout/includes/recent-posts.pug","hash":"17708d099c8f90c220e9ab913f90f2f079479351","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"418349c6a31f246d91aab53640ded1ae674463aa","modified":1624543207002},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1624543207018},{"_id":"themes/Butterfly/source/img/DerrickAlipay.jpg","hash":"97d102cc0d00683d45b78ba3cb141d75d77b3613","modified":1624543207018},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"92434097d199cec038f7aa9a25e32054b0d49f21","modified":1624543207019},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1624543207018},{"_id":"themes/Butterfly/source/img/favicon.ico","hash":"47877628a0f0e0f06430845b0e3a75e0ba1361ce","modified":1624543207020},{"_id":"themes/Butterfly/source/img/DerrickWechat.png","hash":"a3d80cbd61d52c93fe2dbdfd4240d96648e5c114","modified":1624543207018},{"_id":"themes/Butterfly/source/img/comment_bg.png","hash":"1adfc4ee925fb4f922c24d7774e7c46d940fe31b","modified":1624543207020},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1624543207021},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1624543207021},{"_id":"themes/Butterfly/source/img/post.jpg","hash":"554584218db9279874e48559f9a8e86b9ecca94b","modified":1624543207024},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1624543207024},{"_id":"themes/Butterfly/source/js/main.js","hash":"a7a5ad472b33ae14fb86a8a4878a67f853ccc2c5","modified":1624543207025},{"_id":"themes/Butterfly/source/img/post_loadding.svg","hash":"549c58cd09dbeefd573ce10646c49ded8bcc48ec","modified":1624543207024},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"0a48ec7f2b01f2ea3f86a12af63a7399cbfaccd6","modified":1624543207027},{"_id":"themes/Butterfly/source/js/utils.js","hash":"24ab72ca8a3010b4a75c80bbbae614b4e8e309c7","modified":1624543207028},{"_id":"source/image/AntDesignPro探索/2019031215120430.png","hash":"88420cbdf879904742f5a838e0693f8ae19d566c","modified":1624543206858},{"_id":"source/image/CSSModules警告/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg","hash":"89a001fc84f439c824224e0ae3696bd587d2186b","modified":1624543206880},{"_id":"source/image/SpringBootJWT/20190325103836546.png","hash":"66340b232074dc97c15b299a763926432aa90d74","modified":1624543206882},{"_id":"source/image/SpringBoot跨域/20190311110721789.png","hash":"fe87a2484bf20c0568bfda200d8b776ad0bedd74","modified":1624543206883},{"_id":"source/image/react1/stats.png","hash":"c7898a05b1e9b30456e1c3da2cb7c504235bcdb4","modified":1624543206939},{"_id":"source/image/地址栏/dns.png","hash":"254378373e7133d0a2248ef6014577698a9371b4","modified":1624543206946},{"_id":"source/image/地址栏/huishou.png","hash":"0a69a39b7d487a686dc92fbbbdb7b85002aee47b","modified":1624543206947},{"_id":"themes/Butterfly/source/img/1avatar.png","hash":"77f00530b5f24207d00f3e92f9821cc1d4eb3d40","modified":1624543207017},{"_id":"source/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg","hash":"42a16835031c841f79dd4bcac8101cc079c06310","modified":1624543206878},{"_id":"source/image/react1/offer.png","hash":"3b73122f741118500b02119976e167701fe4e394","modified":1624543206938},{"_id":"source/image/你真的懂ReactHook吗/2019081821194714.png","hash":"f383076a180704e8bb080c5da414486d5a6c2567","modified":1624543206943},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0758817464c300f785384ea21bf096f5010c4f96","modified":1624543206999},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"5ae50a271fe5a49f4012555657db028b7113612b","modified":1624543206994},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"e96dd925a1d17cfb4fe5ac13561982c9b13d6b53","modified":1624543206994},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"86b8e1df78277d519ea6577c877194821e811c9d","modified":1624543206999},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"0cff3caa687c7edd4eeabd5f9e4cfd95e8106734","modified":1624543206999},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"bb4de1b40ae07b27dda4e3e529687f6c1a9196ca","modified":1624543206994},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"5ca6a00615f963c48ae5fb27baf23dc18b30890d","modified":1624543206994},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"1d5d1b2cf17271cc6d69071f6df11fe477ae8bb3","modified":1624543206995},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"8ef3dc1a27c19645ac054e30594ed1930b1c56f0","modified":1624543206995},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"388c45fa45d339090678c76c0ae9ab1e2711ed71","modified":1624543206997},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"fe4750521c9b4f83c3dbca81395464838b915d11","modified":1624543206996},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"98feae7f019dc1fa8b5145deea07bfa6ad5a4550","modified":1624543206995},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"393e641a35174f26318b8724eddaf1a0b1386636","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"dae7d56c6ee85432e6cb29820a6c652190d2a3b8","modified":1624543206997},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"bfcf9e01cffbaddfd450aa4488cc6152f37f853a","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"4dea5574fa33f688a2a80d4e070e6c0ba9a62480","modified":1624543206997},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"46c6c1e122e841d1563f82ff39880b776151772a","modified":1624543206999},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"5a9ec6dc058feff4897870ea25e94c5746f04816","modified":1624543206999},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"a84dac02e9d30c9c8e7ed895214d46cf2d2af3db","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"e4fb9e5c72ca05d595f0959893c2fe03b8f478e2","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"2d267fcc926505fcc5ebc9f59146555b32654c7e","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"e44d63ee21b7ee247927f0189a783ffa9ba075fd","modified":1624543206997},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"e9eacd936c259d8f10e1becdd6e3ca129ea0e942","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"036213b05df9e51250c2734854de7a096a9ed8c2","modified":1624543206996},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"7750b7e9a051499e117bfcff734c1e88479eb1fc","modified":1624543206998},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"403601a903d02ef0a103d18909a6eb0b088fcb4c","modified":1624543207000},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"171ac3fbbfd631b4a6ef0e304fa15254193c4727","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"55135cbe7086704d445a9cb828b58635f7d271df","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/mixins/UI.pug","hash":"e0182e4e91820b2c35ccf067a314c393205ea0d8","modified":1624543207000},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"60bd18e051a442d5ce25325a55982922ab15be04","modified":1624543207000},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"41f6c6c9d753ed97ab2adef47f13595f8aebb464","modified":1624543207000},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"0f7db3dfab5250ef3af1f8966222bfab26fd9204","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"66b4f4e8119e987cd3f9907298689a1408a05859","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"3d2b2de0e199ab1fb151f41f2bbaac909f3d3d12","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"4108ab6b91461254901f19ed3e5e082e437324aa","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"a3c4bb20d0d7c81673a3ff6e94216999e0470571","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1624543207003},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"af2f09d374a55983d1ac695848ccfae50629f439","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1624543207003},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"2ea7c6070fc0f028b59c6ac4fbc80b4c3f36ced1","modified":1624543207004},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"44af3c7a67b86f048deacb451dd454b088631374","modified":1624543207004},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"74fc2a62e125f28947ec9cd60f968023da766adb","modified":1624543207004},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"2c6841dd502f8b26984554023da4e597cac4288a","modified":1624543207004},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"9f10622c73c2c87d3502660eb933af654d2600b4","modified":1624543207000},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"e24b08e7253e78d3088d7267188a1ca18b6b5315","modified":1624543207002},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"547a2737cd3ac45272a75561f5b5438d72d10f6d","modified":1624543207001},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"ae608179a5a40b08847a28b24b6aba65feebf74b","modified":1624543207004},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"9705ac9dd87075ec1f8e05eb01c0ca5276aa3bc7","modified":1624543207004},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"24468cdca3538875426f5e193518de924fecd1d5","modified":1624543207009},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"876c54fda6f9cbf5485586f1fad94b82488ad6ac","modified":1624543207005},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"12c40bfa22bda631fe4d0ab02dc71e3e0c99204d","modified":1624543207004},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"bb83b379954dc2e7f5a9915e5ed50da7223e3efa","modified":1624543207009},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"32b94940c8288020bb4245941ca587c8aad7c14c","modified":1624543207009},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"063630aea319d4fbf7ec6e11d6e082e56780d1a9","modified":1624543207005},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"b31f88fff690ec8efbbb8163eb01abed98a6ae0f","modified":1624543207005},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"2f454c991365ac88fdb171c86d6404dad7963c45","modified":1624543207005},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"f5875982abf021213e1274f615b812b29b5fee56","modified":1624543207009},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"de83e03d960028ffb0727ebba672048352a47869","modified":1624543207009},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"926d4ff56a0b19ae7d3d7ea39212aeb5d0f1841d","modified":1624543207010},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"87775163a58217964ce66be33067b34327f67d2a","modified":1624543207015},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"6cdcbaeca64576a2e6713898eef87f117755af24","modified":1624543207015},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"85f8695cb5672db2136f30a7e4c7176f17dd9207","modified":1624543207009},{"_id":"themes/Butterfly/source/css/_layout/gallery.styl","hash":"df07b7eae8a1a1f50c2c0a10833f7e67d77f8f8e","modified":1624543207010},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"b5bca389c3185b2794939f0f5dd889e1ed72f6cc","modified":1624543207010},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"2dace492e6da44e39ad5cc7eae8bc8bb5a34aaae","modified":1624543207010},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"9f614d995f1e74bb23f1fac7b6136bc63d8792c8","modified":1624543207011},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"7867299d5dc00c3e1d8a33ea71270eb47caabd7c","modified":1624543207011},{"_id":"themes/Butterfly/source/css/_layout/note.styl","hash":"b522d071c320c0aa52fd56f30b0bc9cf923e46d7","modified":1624543207011},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"9181061f214ed8e2b48c203e1d3d524edc4b56e7","modified":1624543207012},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"da195674ba8836b8a96a2d264da97f8b312815f4","modified":1624543207011},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"86b4813db1776a14f98e443123e8f8b22e35d7dc","modified":1624543207012},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"0df33f37f7339df71b68a6b781c068e5a344c9cc","modified":1624543207014},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"d1ad6bbdedf8bead2b0b18519629c731afbab49d","modified":1624543207014},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"4c27911ff1432870f328934cf6b171ecb16db1ce","modified":1624543207014},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1799a33e3f7cdc543227be833d59ef84bb038124","modified":1624543207014},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"42d636b01e0b41934425cf4716adcb01aff2ab44","modified":1624543207015},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"e79af6f332e1334a1c54fcf1850df37a9cb5e363","modified":1624543207015},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"ce20d0e71586ce7094074bd1b474e1fa40c6d29f","modified":1624543207015},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1624543207016},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"772b9397eabe165b76b7fe7a429a03314a041275","modified":1624543207015},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"8c6b33f0fbd7fd3ee7c9149a20423dc44a7cc4ed","modified":1624543207025},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1624543207026},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"a4aa32db60e5cc12bbe3b3a82209379bf8ab62ce","modified":1624543207025},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"2af6ddbabdd36979cc9c05b117452a1534702c6d","modified":1624543207026},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"75b3d7025c01947f3d425e592e910458393ee621","modified":1624543207027},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"ed2a7dedc314eb1047d030be2e95d0d5679bc577","modified":1624543207026},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"bc3d3f2afeefea55d9d6ba8dfa798435e1eb1062","modified":1624543207027},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"7cc7eb304403f4d504ba0b0824976ab86650c415","modified":1624543207026},{"_id":"source/image/BFC/1.png","hash":"540328be121a88237b66f1d73540de94ccad591b","modified":1624543206875},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"7295ee03e9ae40f855d0c494a9b84e76a36ffe20","modified":1624543207026},{"_id":"source/image/pr/commit.png","hash":"ffebdcd0e8d00099c2d64bf00b723d44c59536ee","modified":1624543206922},{"_id":"source/image/react1/bebel.png","hash":"9dc3cf33345745bce1fa8a866bf43708882d4c67","modified":1624543206933},{"_id":"source/image/react1/download.jpg","hash":"8da8d23163705f36e165f45ecd743726b7068a90","modified":1624543206935},{"_id":"source/image/你真的懂ReactHook吗/20190818212347571.png","hash":"9c1d608da7f8ed64f1923dda1ce43ad2ebbebec3","modified":1624543206945},{"_id":"themes/Butterfly/source/img/index.jpg","hash":"d79fc7faf6d37b088bd638ceef641dd33beb353f","modified":1624543207023},{"_id":"source/image/BFC/2.png","hash":"3ece8accca4992b9b7f91c4e03ede39d6a0902a5","modified":1624543206876},{"_id":"source/image/WebpackCleanWebpackPlugin/20190622155255789.png","hash":"5a9b0df917450afb2d036131b4a78ea9f44fcd5f","modified":1624543206886},{"_id":"source/image/cover/bg.jpg","hash":"e4af8ffeb55d0095eec7a79d9929f3eba168be41","modified":1624543206917},{"_id":"source/image/pr/pr.png","hash":"c115b00a0b9a472420144d5b9ece833536ad85c1","modified":1624543206927},{"_id":"source/image/react1/element.png","hash":"ec3e6ade030c3fd6f4c8fd17e3ae297eab738c5d","modified":1624543206937},{"_id":"source/image/reactDebugger/console.png","hash":"f7af90daf93c1942f7aa6d65b25694716c5ac915","modified":1624543206941},{"_id":"source/image/深入内存世界/2.png","hash":"f59706eeafcff03d4b973aaa3cb9ade0a0a4678e","modified":1624543206976},{"_id":"source/image/pr/create.png","hash":"c4582990440ad66a2ae4c91215758b22d6311a00","modified":1624543206924},{"_id":"source/image/pr/push.png","hash":"433a7e6d6b42f74e95f22b8c52b59673512f486e","modified":1624543206931},{"_id":"source/image/AntDesignPro探索/2019031215175956.png","hash":"342395e4f6eda6e2288a8554341f7df2ba3d3427","modified":1624543206871},{"_id":"source/image/Web前端学习路线/20190328205449472.png","hash":"e03d1580df71c0abd46cf5eb1d12887408f3180d","modified":1624543206910},{"_id":"source/image/深入内存世界/1.jpeg","hash":"04b62b1c23324009613d5c89505fbdff95021f6e","modified":1624543206974}],"Category":[{"name":"Ant-Design","_id":"ckqevra7m0004lwrd4z7p40hq"},{"name":"HTTP","_id":"ckqevra7q0009lwrdh0asfxf0"},{"name":"博客","_id":"ckqevra7t000elwrd5ew61qzx"},{"name":"React","_id":"ckqevra7w000llwrd8dde8pef"},{"name":"Java","_id":"ckqevra7z000rlwrd77hu6tem"},{"name":"WebPack","_id":"ckqevra850014lwrdhxf18gmk"},{"name":"JavaScript","_id":"ckqevra87001alwrd7fjtfq0q"},{"name":"Web前端","_id":"ckqevra8f001hlwrd7igc71fx"},{"name":"JavaScript","parent":"ckqevra7m0004lwrd4z7p40hq","_id":"ckqevra8i001mlwrdg43lfecp"},{"name":"Ant-Design-Pro","_id":"ckqevra8m001slwrdaen1ft73"},{"name":"CSS","_id":"ckqevra8q001zlwrd6rke3ay6"},{"name":"Spring-Boot","parent":"ckqevra7z000rlwrd77hu6tem","_id":"ckqevra8t0026lwrdhoxh17vv"},{"name":"github","_id":"ckqevra8v002blwrd31nmdmg0"},{"name":"重拾前端","_id":"ckqevra90002rlwrdh877dsjl"},{"name":"面经","_id":"ckqevra9g004ilwrd8ygh3lue"},{"name":"Webpack","_id":"ckqevra9h004mlwrda22k7e2y"},{"name":"react","_id":"ckqevra9i004qlwrdbc9r4088"},{"name":"前端","_id":"ckqevra9j004vlwrdhrv06f50"},{"name":"ES6","_id":"ckqevra9k004zlwrd4hxi70vh"}],"Data":[],"Page":[{"title":"关于我","date":"2020-04-11T13:41:09.000Z","_content":"\n> Never put off till tomorrow what you can do today.\n> —— Thomas Jefferson\n\n- 姓名: Derrick\n- 地点: 杭州\n- 年龄: 1995\n- 性别: 男\n- 爱好: 健身, 📖\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-04-11 21:41:09\n---\n\n> Never put off till tomorrow what you can do today.\n> —— Thomas Jefferson\n\n- 姓名: Derrick\n- 地点: 杭州\n- 年龄: 1995\n- 性别: 男\n- 爱好: 健身, 📖\n\n","updated":"2021-06-24T14:00:06.855Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckqevra7i0001lwrd4vhc90as","content":"<blockquote>\n<p>Never put off till tomorrow what you can do today.<br>—— Thomas Jefferson</p>\n</blockquote>\n<ul>\n<li>姓名: Derrick</li>\n<li>地点: 杭州</li>\n<li>年龄: 1995</li>\n<li>性别: 男</li>\n<li>爱好: 健身, 📖</li>\n</ul>\n","site":{"data":{}},"cover":"/img/post.jpg","excerpt":"","more":"<blockquote>\n<p>Never put off till tomorrow what you can do today.<br>—— Thomas Jefferson</p>\n</blockquote>\n<ul>\n<li>姓名: Derrick</li>\n<li>地点: 杭州</li>\n<li>年龄: 1995</li>\n<li>性别: 男</li>\n<li>爱好: 健身, 📖</li>\n</ul>\n"},{"title":"clean","date":"2020-04-11T14:34:16.000Z","_content":"","source":"clean/index.md","raw":"---\ntitle: clean\ndate: 2020-04-11 22:34:16\n---\n","updated":"2021-06-24T14:00:06.855Z","path":"clean/index.html","comments":1,"layout":"page","_id":"ckqevra7l0003lwrdbsjfd4ho","content":"","site":{"data":{}},"cover":"/img/post.jpg","excerpt":"","more":""}],"Post":[{"title":"5分钟快速精通Ant Design Form 1分钟快速构建复杂Ant Design Form表单","date":"2019-07-28T12:05:56.000Z","cover":"/image/cover/ANTD.png","_content":"## Ant Design Form\nAntd 表单的核心无非是以下两点\n\n 1. 表单创建（`Form.create`）在`this.props`写入`form`属性\n 2. 表单与组件的双向绑定（`this.props.form.getFieldDecorator`）\n 3. 表单的取值（`this.props.form.validateFields / this.props.form.validateFieldsAndScroll`）\n\n#### 表单创建\n`Form.create`这是一个高阶函数，传入的是react组件，返回一个新的react组件，在函数内部会对传入组件进行改造，添加上一定的方法用于进行一些秘密操作 ，这里不多做解释，有兴趣的同学可以上官网查看。\n\n[我是飞机票（React-高阶组件），点我](https://react.docschina.org/docs/higher-order-components.html)\n使用方法如下：\n\n```\nclass CustomizedForm extends React.Component { ... }\n\n// use wrappedComponentRef\nconst EnhancedForm =  Form.create()(CustomizedForm);\n```\n或者\n```\n@Form.create()\nclass CustomizedForm extends React.Component { ... }\n```\n#### 表单与组件的双向绑定\n他的目的是将表单的组件的值与表单绑定。最后表单可以直接取到某某组件的值。\n\n```\n<!-- 表单数据绑定 -->\n<Form.Item {...formItemLayout} label={'名称'}>\n\t{getFieldDecorator('searchName')(\n\t\t<Input placeholder={'请输入名称'} />\n\t)}\n</Form.Item>\n```\n这个是一个非常简单的绑定，组件input的值都会由'searchName'这个属性收纳。\n可以直接取值，当然也可以加入自己的校验规则，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。\n\n[我是飞机票（表单进阶），点我！](https://ant.design/components/form-cn/)\n\n#### 表单的取值\n\n```\nthis.props.form.validateFields((err, values) => {\n      if (!err) { // 这里也可以不要，是用于校验的。\n        console.log('Received values of form: ', values);\n      }\n    });\n```\n这是一个非常简单的取值，当然可以定制的取值，或者定制的校验，比如，在获取验证码的时候，不需要校验密码是否输入或者符合你的规则，就可以只校验手机号，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。\n\n[我是飞机票（表单进阶），点我！](https://ant.design/components/form-cn/)\n\n基本上你掌握了这些就可以较为灵活的使用Ant Design Form了。\n\n## 但是！划重点了！\n如果有一些更加进阶的想法。请看！\n\n[表单的进阶使用](https://blog.csdn.net/cuandeqin2083/article/details/89643390)\n\n# 重中之重\n如果你觉得自己构建表单非常麻烦，或者对表单的理解还是够透彻，想一步到位构件表单，推荐本人自用自创组件\nant-design-form\n\n上面的文档非常详细，如果有问题随时可以给我提issues。如果喜欢的话麻烦点个start~\n\n[我是ant-design-from的飞机票，点我点我！！](https://github.com/DerrickTel/ant-design-form)","source":"_posts/5分钟快速精通Ant-Design-Form-1分钟快速构建复杂Ant-Design-Form表单.md","raw":"---\ntitle: 5分钟快速精通Ant Design Form 1分钟快速构建复杂Ant Design Form表单\ndate: 2019-07-28 20:05:56\ntags: [Ant-Design-Form, Ant-Design]\ncategory: [Ant-Design]\ncover: /image/cover/ANTD.png\n---\n## Ant Design Form\nAntd 表单的核心无非是以下两点\n\n 1. 表单创建（`Form.create`）在`this.props`写入`form`属性\n 2. 表单与组件的双向绑定（`this.props.form.getFieldDecorator`）\n 3. 表单的取值（`this.props.form.validateFields / this.props.form.validateFieldsAndScroll`）\n\n#### 表单创建\n`Form.create`这是一个高阶函数，传入的是react组件，返回一个新的react组件，在函数内部会对传入组件进行改造，添加上一定的方法用于进行一些秘密操作 ，这里不多做解释，有兴趣的同学可以上官网查看。\n\n[我是飞机票（React-高阶组件），点我](https://react.docschina.org/docs/higher-order-components.html)\n使用方法如下：\n\n```\nclass CustomizedForm extends React.Component { ... }\n\n// use wrappedComponentRef\nconst EnhancedForm =  Form.create()(CustomizedForm);\n```\n或者\n```\n@Form.create()\nclass CustomizedForm extends React.Component { ... }\n```\n#### 表单与组件的双向绑定\n他的目的是将表单的组件的值与表单绑定。最后表单可以直接取到某某组件的值。\n\n```\n<!-- 表单数据绑定 -->\n<Form.Item {...formItemLayout} label={'名称'}>\n\t{getFieldDecorator('searchName')(\n\t\t<Input placeholder={'请输入名称'} />\n\t)}\n</Form.Item>\n```\n这个是一个非常简单的绑定，组件input的值都会由'searchName'这个属性收纳。\n可以直接取值，当然也可以加入自己的校验规则，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。\n\n[我是飞机票（表单进阶），点我！](https://ant.design/components/form-cn/)\n\n#### 表单的取值\n\n```\nthis.props.form.validateFields((err, values) => {\n      if (!err) { // 这里也可以不要，是用于校验的。\n        console.log('Received values of form: ', values);\n      }\n    });\n```\n这是一个非常简单的取值，当然可以定制的取值，或者定制的校验，比如，在获取验证码的时候，不需要校验密码是否输入或者符合你的规则，就可以只校验手机号，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。\n\n[我是飞机票（表单进阶），点我！](https://ant.design/components/form-cn/)\n\n基本上你掌握了这些就可以较为灵活的使用Ant Design Form了。\n\n## 但是！划重点了！\n如果有一些更加进阶的想法。请看！\n\n[表单的进阶使用](https://blog.csdn.net/cuandeqin2083/article/details/89643390)\n\n# 重中之重\n如果你觉得自己构建表单非常麻烦，或者对表单的理解还是够透彻，想一步到位构件表单，推荐本人自用自创组件\nant-design-form\n\n上面的文档非常详细，如果有问题随时可以给我提issues。如果喜欢的话麻烦点个start~\n\n[我是ant-design-from的飞机票，点我点我！！](https://github.com/DerrickTel/ant-design-form)","slug":"5分钟快速精通Ant-Design-Form-1分钟快速构建复杂Ant-Design-Form表单","published":1,"updated":"2021-06-24T14:00:06.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7e0000lwrdf9vb6x2s","content":"<h2 id=\"Ant-Design-Form\"><a href=\"#Ant-Design-Form\" class=\"headerlink\" title=\"Ant Design Form\"></a>Ant Design Form</h2><p>Antd 表单的核心无非是以下两点</p>\n<ol>\n<li>表单创建（<code>Form.create</code>）在<code>this.props</code>写入<code>form</code>属性</li>\n<li>表单与组件的双向绑定（<code>this.props.form.getFieldDecorator</code>）</li>\n<li>表单的取值（<code>this.props.form.validateFields / this.props.form.validateFieldsAndScroll</code>）</li>\n</ol>\n<h4 id=\"表单创建\"><a href=\"#表单创建\" class=\"headerlink\" title=\"表单创建\"></a>表单创建</h4><p><code>Form.create</code>这是一个高阶函数，传入的是react组件，返回一个新的react组件，在函数内部会对传入组件进行改造，添加上一定的方法用于进行一些秘密操作 ，这里不多做解释，有兴趣的同学可以上官网查看。</p>\n<p><a href=\"https://react.docschina.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">我是飞机票（React-高阶组件），点我</a><br>使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomizedForm extends React.Component &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; use wrappedComponentRef</span><br><span class=\"line\">const EnhancedForm &#x3D;  Form.create()(CustomizedForm);</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Form.create()</span><br><span class=\"line\">class CustomizedForm extends React.Component &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单与组件的双向绑定\"><a href=\"#表单与组件的双向绑定\" class=\"headerlink\" title=\"表单与组件的双向绑定\"></a>表单与组件的双向绑定</h4><p>他的目的是将表单的组件的值与表单绑定。最后表单可以直接取到某某组件的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 表单数据绑定 --&gt;</span><br><span class=\"line\">&lt;Form.Item &#123;...formItemLayout&#125; label&#x3D;&#123;&#39;名称&#39;&#125;&gt;</span><br><span class=\"line\">\t&#123;getFieldDecorator(&#39;searchName&#39;)(</span><br><span class=\"line\">\t\t&lt;Input placeholder&#x3D;&#123;&#39;请输入名称&#39;&#125; &#x2F;&gt;</span><br><span class=\"line\">\t)&#125;</span><br><span class=\"line\">&lt;&#x2F;Form.Item&gt;</span><br></pre></td></tr></table></figure>\n<p>这个是一个非常简单的绑定，组件input的值都会由’searchName’这个属性收纳。<br>可以直接取值，当然也可以加入自己的校验规则，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。</p>\n<p><a href=\"https://ant.design/components/form-cn/\" target=\"_blank\" rel=\"noopener\">我是飞机票（表单进阶），点我！</a></p>\n<h4 id=\"表单的取值\"><a href=\"#表单的取值\" class=\"headerlink\" title=\"表单的取值\"></a>表单的取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.props.form.validateFields((err, values) &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (!err) &#123; &#x2F;&#x2F; 这里也可以不要，是用于校验的。</span><br><span class=\"line\">        console.log(&#39;Received values of form: &#39;, values);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>这是一个非常简单的取值，当然可以定制的取值，或者定制的校验，比如，在获取验证码的时候，不需要校验密码是否输入或者符合你的规则，就可以只校验手机号，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。</p>\n<p><a href=\"https://ant.design/components/form-cn/\" target=\"_blank\" rel=\"noopener\">我是飞机票（表单进阶），点我！</a></p>\n<p>基本上你掌握了这些就可以较为灵活的使用Ant Design Form了。</p>\n<h2 id=\"但是！划重点了！\"><a href=\"#但是！划重点了！\" class=\"headerlink\" title=\"但是！划重点了！\"></a>但是！划重点了！</h2><p>如果有一些更加进阶的想法。请看！</p>\n<p><a href=\"https://blog.csdn.net/cuandeqin2083/article/details/89643390\" target=\"_blank\" rel=\"noopener\">表单的进阶使用</a></p>\n<h1 id=\"重中之重\"><a href=\"#重中之重\" class=\"headerlink\" title=\"重中之重\"></a>重中之重</h1><p>如果你觉得自己构建表单非常麻烦，或者对表单的理解还是够透彻，想一步到位构件表单，推荐本人自用自创组件<br>ant-design-form</p>\n<p>上面的文档非常详细，如果有问题随时可以给我提issues。如果喜欢的话麻烦点个start~</p>\n<p><a href=\"https://github.com/DerrickTel/ant-design-form\" target=\"_blank\" rel=\"noopener\">我是ant-design-from的飞机票，点我点我！！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ant-Design-Form\"><a href=\"#Ant-Design-Form\" class=\"headerlink\" title=\"Ant Design Form\"></a>Ant Design Form</h2><p>Antd 表单的核心无非是以下两点</p>\n<ol>\n<li>表单创建（<code>Form.create</code>）在<code>this.props</code>写入<code>form</code>属性</li>\n<li>表单与组件的双向绑定（<code>this.props.form.getFieldDecorator</code>）</li>\n<li>表单的取值（<code>this.props.form.validateFields / this.props.form.validateFieldsAndScroll</code>）</li>\n</ol>\n<h4 id=\"表单创建\"><a href=\"#表单创建\" class=\"headerlink\" title=\"表单创建\"></a>表单创建</h4><p><code>Form.create</code>这是一个高阶函数，传入的是react组件，返回一个新的react组件，在函数内部会对传入组件进行改造，添加上一定的方法用于进行一些秘密操作 ，这里不多做解释，有兴趣的同学可以上官网查看。</p>\n<p><a href=\"https://react.docschina.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">我是飞机票（React-高阶组件），点我</a><br>使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomizedForm extends React.Component &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; use wrappedComponentRef</span><br><span class=\"line\">const EnhancedForm &#x3D;  Form.create()(CustomizedForm);</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Form.create()</span><br><span class=\"line\">class CustomizedForm extends React.Component &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单与组件的双向绑定\"><a href=\"#表单与组件的双向绑定\" class=\"headerlink\" title=\"表单与组件的双向绑定\"></a>表单与组件的双向绑定</h4><p>他的目的是将表单的组件的值与表单绑定。最后表单可以直接取到某某组件的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 表单数据绑定 --&gt;</span><br><span class=\"line\">&lt;Form.Item &#123;...formItemLayout&#125; label&#x3D;&#123;&#39;名称&#39;&#125;&gt;</span><br><span class=\"line\">\t&#123;getFieldDecorator(&#39;searchName&#39;)(</span><br><span class=\"line\">\t\t&lt;Input placeholder&#x3D;&#123;&#39;请输入名称&#39;&#125; &#x2F;&gt;</span><br><span class=\"line\">\t)&#125;</span><br><span class=\"line\">&lt;&#x2F;Form.Item&gt;</span><br></pre></td></tr></table></figure>\n<p>这个是一个非常简单的绑定，组件input的值都会由’searchName’这个属性收纳。<br>可以直接取值，当然也可以加入自己的校验规则，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。</p>\n<p><a href=\"https://ant.design/components/form-cn/\" target=\"_blank\" rel=\"noopener\">我是飞机票（表单进阶），点我！</a></p>\n<h4 id=\"表单的取值\"><a href=\"#表单的取值\" class=\"headerlink\" title=\"表单的取值\"></a>表单的取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.props.form.validateFields((err, values) &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (!err) &#123; &#x2F;&#x2F; 这里也可以不要，是用于校验的。</span><br><span class=\"line\">        console.log(&#39;Received values of form: &#39;, values);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>这是一个非常简单的取值，当然可以定制的取值，或者定制的校验，比如，在获取验证码的时候，不需要校验密码是否输入或者符合你的规则，就可以只校验手机号，等等。这里不多做解释，这些都是附加的进阶功能，这里不多做描述。</p>\n<p><a href=\"https://ant.design/components/form-cn/\" target=\"_blank\" rel=\"noopener\">我是飞机票（表单进阶），点我！</a></p>\n<p>基本上你掌握了这些就可以较为灵活的使用Ant Design Form了。</p>\n<h2 id=\"但是！划重点了！\"><a href=\"#但是！划重点了！\" class=\"headerlink\" title=\"但是！划重点了！\"></a>但是！划重点了！</h2><p>如果有一些更加进阶的想法。请看！</p>\n<p><a href=\"https://blog.csdn.net/cuandeqin2083/article/details/89643390\" target=\"_blank\" rel=\"noopener\">表单的进阶使用</a></p>\n<h1 id=\"重中之重\"><a href=\"#重中之重\" class=\"headerlink\" title=\"重中之重\"></a>重中之重</h1><p>如果你觉得自己构建表单非常麻烦，或者对表单的理解还是够透彻，想一步到位构件表单，推荐本人自用自创组件<br>ant-design-form</p>\n<p>上面的文档非常详细，如果有问题随时可以给我提issues。如果喜欢的话麻烦点个start~</p>\n<p><a href=\"https://github.com/DerrickTel/ant-design-form\" target=\"_blank\" rel=\"noopener\">我是ant-design-from的飞机票，点我点我！！</a></p>\n"},{"title":"HTTPH/TTPS协议","date":"2019-08-24T11:02:25.000Z","cover":"/image/cover/http.png","_content":"\n## 协议\n\n网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。\n\n### HTTP协议\nHTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。\n\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\nHTPP有多个版本，目前广泛使用的是HTTP/1.1版本。\n\n## HTTP\nHTTP 全称是 HyperText Transfer Protocal ，即：超文本传输协议，从 1990 年开始就在 WWW 上广泛应用，是现今在 WWW 上应用最多的协议，HTTP 是应用层协议，当你上网浏览网页的时候，浏览器和 web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。HTTP 是一个基于请求/响应模式的、无状态的协议。即我们通常所说的 Request/Response\n\n### HTTP原理\n\nHTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。\n\nHTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\n\n### HTTP协议\n\nHTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。\n\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\nHTPP有多个版本，目前广泛使用的是HTTP/1.1版本。\n\n### HTTP特点\n\n - 支持客户端/服务器模式\n - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快\n - 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记\n - 无连接：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间\n - 无状态：HTTP 协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快\n\n## HTTPS\nHTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n\n解决HTTP的一些问题\n - 请求信息明文传输，容易被窃听截取。\n - 数据的完整性未校验，容易被篡改\n - 没有验证对方身份，存在冒充危险\n\n\n## 总结HTTPS和HTTP的区别\n\n - HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。\n - http和https使用连接方式不同，默认端口也不一样，http是80，https是443。\n\n## URL详解\n\nURL（Uniform Resource Locator）是统一资源定位符的简称，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址\n\n### 基本组成\n\n| 名称         | 功能                                                         |\n| ------------ | ------------------------------------------------------------ |\n| scheme       | 访问服务器以获取资源时要使用哪种协议，比如，http，https 和 FTP 等 |\n| host         | HTTP 服务器的 IP 地址或域名                                  |\n| port#        | HTTP 服务器的默认端口是 80，这种情况下端口号可以省略，如果使用了别的端口，必须指明，例如www.cnblogs.com：8080 |\n| path         | 访问资源的路径                                               |\n| query-string | 发给 http 服务器的数据                                       |\n| anchor       | 锚                                                           |\n\n![在这里插入图片描述](/image/httpHttps/15fc2525666dc96e.jpg)\n\n## HTTP请求\n### 类型\n| 名称    | 功能                                                         |\n| ------- | ------------------------------------------------------------ |\n| GET     | 向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中 |\n| POST    | 指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。 |\n| PUT     | 向指定资源位置上传其最新内容                                 |\n| DELETE  | 请求服务器删除 Request-URI 所标识的资源                      |\n| OPTIONS | 使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作 |\n| HEAD    | 与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据） |\n| TRACE   | 显示服务器收到的请求，主要用于测试或诊断                     |\n| CONNECT | HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器） |\n\n其中，最常见的是 GET 和 POST 方法，如果是 RESful 接口的话一般会用到 PUT、DELETE、GET、POST（分别对应增删查改\n\n### 请求头\n| 名称              | 功能                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| Authorization     | 用于设置身份认证信息                                         |\n| User-Agent        | 用户标识，如：OS 和浏览器的类型和版本                        |\n| If-Modified-Since | 值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取 |\n| If-None-Match     | 值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since    |\n| Cookie            | 已有的Cookie                                                 |\n| Referer           | 标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址 |\n| Host              | 请求的主机和端口号                                           |\n\n### 状态码\n| 状态码 | 对应的信息                                                   |\n| ------ | ------------------------------------------------------------ |\n| 1XX    | 提示信息—表示请求已接收，继续处理                            |\n| 2XX    | 用于表示请求已被成功接收、理解、接收                         |\n| 3XX    | 用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向 |\n| 4XX    | 客户端错误—请求有语法错误或者请求无法实现                    |\n| 5XX    | 服务器端错误—服务器未能实现合法的请求                        |\n\n### 响应头\n| 名称              | 功能                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| Date              | 服务器的日期                                                 |\n| Last-Modified     | 该资源最后被修改的时间                                       |\n| Transfer-Encoding | 取值一般为 chunked，出现在 Content-Length 不能确定的情况下，表示服务器不知道响应板体的数据大小，一般同时出现Content-Encoding响应头 |\n| Set-Cookie        | 设置 Cookie                                                  |\n| Location          | 重定向到另一个 URL，如输入浏览器就输入 baidu.com 回车，会自动跳转到www.baidu.com 就是通过这个响应头控制的 |\n| Server            | 后台服务器                                                   |\n\n>  Reference \n>  https://zhuanlan.zhihu.com/p/72616216\n>  https://juejin.im/post/5a0ce1d95188253e24708454","source":"_posts/HTTPHTTPS协议.md","raw":"---\ntitle: HTTPH/TTPS协议\ndate: 2019-08-24 19:02:25\ntags: [HTTP]\ncategories: [HTTP]\ncover: /image/cover/http.png\n---\n\n## 协议\n\n网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。\n\n### HTTP协议\nHTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。\n\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\nHTPP有多个版本，目前广泛使用的是HTTP/1.1版本。\n\n## HTTP\nHTTP 全称是 HyperText Transfer Protocal ，即：超文本传输协议，从 1990 年开始就在 WWW 上广泛应用，是现今在 WWW 上应用最多的协议，HTTP 是应用层协议，当你上网浏览网页的时候，浏览器和 web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。HTTP 是一个基于请求/响应模式的、无状态的协议。即我们通常所说的 Request/Response\n\n### HTTP原理\n\nHTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。\n\nHTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\n\n### HTTP协议\n\nHTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。\n\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\nHTPP有多个版本，目前广泛使用的是HTTP/1.1版本。\n\n### HTTP特点\n\n - 支持客户端/服务器模式\n - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快\n - 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记\n - 无连接：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间\n - 无状态：HTTP 协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快\n\n## HTTPS\nHTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n\n解决HTTP的一些问题\n - 请求信息明文传输，容易被窃听截取。\n - 数据的完整性未校验，容易被篡改\n - 没有验证对方身份，存在冒充危险\n\n\n## 总结HTTPS和HTTP的区别\n\n - HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。\n - http和https使用连接方式不同，默认端口也不一样，http是80，https是443。\n\n## URL详解\n\nURL（Uniform Resource Locator）是统一资源定位符的简称，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址\n\n### 基本组成\n\n| 名称         | 功能                                                         |\n| ------------ | ------------------------------------------------------------ |\n| scheme       | 访问服务器以获取资源时要使用哪种协议，比如，http，https 和 FTP 等 |\n| host         | HTTP 服务器的 IP 地址或域名                                  |\n| port#        | HTTP 服务器的默认端口是 80，这种情况下端口号可以省略，如果使用了别的端口，必须指明，例如www.cnblogs.com：8080 |\n| path         | 访问资源的路径                                               |\n| query-string | 发给 http 服务器的数据                                       |\n| anchor       | 锚                                                           |\n\n![在这里插入图片描述](/image/httpHttps/15fc2525666dc96e.jpg)\n\n## HTTP请求\n### 类型\n| 名称    | 功能                                                         |\n| ------- | ------------------------------------------------------------ |\n| GET     | 向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中 |\n| POST    | 指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。 |\n| PUT     | 向指定资源位置上传其最新内容                                 |\n| DELETE  | 请求服务器删除 Request-URI 所标识的资源                      |\n| OPTIONS | 使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作 |\n| HEAD    | 与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据） |\n| TRACE   | 显示服务器收到的请求，主要用于测试或诊断                     |\n| CONNECT | HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器） |\n\n其中，最常见的是 GET 和 POST 方法，如果是 RESful 接口的话一般会用到 PUT、DELETE、GET、POST（分别对应增删查改\n\n### 请求头\n| 名称              | 功能                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| Authorization     | 用于设置身份认证信息                                         |\n| User-Agent        | 用户标识，如：OS 和浏览器的类型和版本                        |\n| If-Modified-Since | 值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取 |\n| If-None-Match     | 值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since    |\n| Cookie            | 已有的Cookie                                                 |\n| Referer           | 标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址 |\n| Host              | 请求的主机和端口号                                           |\n\n### 状态码\n| 状态码 | 对应的信息                                                   |\n| ------ | ------------------------------------------------------------ |\n| 1XX    | 提示信息—表示请求已接收，继续处理                            |\n| 2XX    | 用于表示请求已被成功接收、理解、接收                         |\n| 3XX    | 用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向 |\n| 4XX    | 客户端错误—请求有语法错误或者请求无法实现                    |\n| 5XX    | 服务器端错误—服务器未能实现合法的请求                        |\n\n### 响应头\n| 名称              | 功能                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| Date              | 服务器的日期                                                 |\n| Last-Modified     | 该资源最后被修改的时间                                       |\n| Transfer-Encoding | 取值一般为 chunked，出现在 Content-Length 不能确定的情况下，表示服务器不知道响应板体的数据大小，一般同时出现Content-Encoding响应头 |\n| Set-Cookie        | 设置 Cookie                                                  |\n| Location          | 重定向到另一个 URL，如输入浏览器就输入 baidu.com 回车，会自动跳转到www.baidu.com 就是通过这个响应头控制的 |\n| Server            | 后台服务器                                                   |\n\n>  Reference \n>  https://zhuanlan.zhihu.com/p/72616216\n>  https://juejin.im/post/5a0ce1d95188253e24708454","slug":"HTTPHTTPS协议","published":1,"updated":"2021-06-24T14:00:06.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7k0002lwrd4m6jawuv","content":"<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>\n<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>HTTP 全称是 HyperText Transfer Protocal ，即：超文本传输协议，从 1990 年开始就在 WWW 上广泛应用，是现今在 WWW 上应用最多的协议，HTTP 是应用层协议，当你上网浏览网页的时候，浏览器和 web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。HTTP 是一个基于请求/响应模式的、无状态的协议。即我们通常所说的 Request/Response</p>\n<h3 id=\"HTTP原理\"><a href=\"#HTTP原理\" class=\"headerlink\" title=\"HTTP原理\"></a>HTTP原理</h3><p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。</p>\n<p>HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>\n<h3 id=\"HTTP协议-1\"><a href=\"#HTTP协议-1\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>\n<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p>\n<h3 id=\"HTTP特点\"><a href=\"#HTTP特点\" class=\"headerlink\" title=\"HTTP特点\"></a>HTTP特点</h3><ul>\n<li>支持客户端/服务器模式</li>\n<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</li>\n<li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</li>\n<li>无连接：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间</li>\n<li>无状态：HTTP 协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快</li>\n</ul>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p>\n<p>解决HTTP的一些问题</p>\n<ul>\n<li>请求信息明文传输，容易被窃听截取。</li>\n<li>数据的完整性未校验，容易被篡改</li>\n<li>没有验证对方身份，存在冒充危险</li>\n</ul>\n<h2 id=\"总结HTTPS和HTTP的区别\"><a href=\"#总结HTTPS和HTTP的区别\" class=\"headerlink\" title=\"总结HTTPS和HTTP的区别\"></a>总结HTTPS和HTTP的区别</h2><ul>\n<li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</li>\n<li>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</li>\n</ul>\n<h2 id=\"URL详解\"><a href=\"#URL详解\" class=\"headerlink\" title=\"URL详解\"></a>URL详解</h2><p>URL（Uniform Resource Locator）是统一资源定位符的简称，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址</p>\n<h3 id=\"基本组成\"><a href=\"#基本组成\" class=\"headerlink\" title=\"基本组成\"></a>基本组成</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>访问服务器以获取资源时要使用哪种协议，比如，http，https 和 FTP 等</td>\n</tr>\n<tr>\n<td>host</td>\n<td>HTTP 服务器的 IP 地址或域名</td>\n</tr>\n<tr>\n<td>port#</td>\n<td>HTTP 服务器的默认端口是 80，这种情况下端口号可以省略，如果使用了别的端口，必须指明，例如<a href=\"http://www.cnblogs.com：8080\">www.cnblogs.com：8080</a></td>\n</tr>\n<tr>\n<td>path</td>\n<td>访问资源的路径</td>\n</tr>\n<tr>\n<td>query-string</td>\n<td>发给 http 服务器的数据</td>\n</tr>\n<tr>\n<td>anchor</td>\n<td>锚</td>\n</tr>\n</tbody></table>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/httpHttps/15fc2525666dc96e.jpg\"  alt=\"在这里插入图片描述\"></p>\n<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>向指定资源位置上传其最新内容</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除 Request-URI 所标识的资源</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据）</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>显示服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）</td>\n</tr>\n</tbody></table>\n<p>其中，最常见的是 GET 和 POST 方法，如果是 RESful 接口的话一般会用到 PUT、DELETE、GET、POST（分别对应增删查改</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authorization</td>\n<td>用于设置身份认证信息</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>用户标识，如：OS 和浏览器的类型和版本</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>已有的Cookie</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求的主机和端口号</td>\n</tr>\n</tbody></table>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>对应的信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>提示信息—表示请求已接收，继续处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>用于表示请求已被成功接收、理解、接收</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>客户端错误—请求有语法错误或者请求无法实现</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>服务器端错误—服务器未能实现合法的请求</td>\n</tr>\n</tbody></table>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Date</td>\n<td>服务器的日期</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>该资源最后被修改的时间</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>取值一般为 chunked，出现在 Content-Length 不能确定的情况下，表示服务器不知道响应板体的数据大小，一般同时出现Content-Encoding响应头</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置 Cookie</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>重定向到另一个 URL，如输入浏览器就输入 baidu.com 回车，会自动跳转到<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 就是通过这个响应头控制的</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>后台服务器</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p> Reference<br> <a href=\"https://zhuanlan.zhihu.com/p/72616216\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/72616216</a><br> <a href=\"https://juejin.im/post/5a0ce1d95188253e24708454\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a0ce1d95188253e24708454</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>\n<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>HTTP 全称是 HyperText Transfer Protocal ，即：超文本传输协议，从 1990 年开始就在 WWW 上广泛应用，是现今在 WWW 上应用最多的协议，HTTP 是应用层协议，当你上网浏览网页的时候，浏览器和 web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。HTTP 是一个基于请求/响应模式的、无状态的协议。即我们通常所说的 Request/Response</p>\n<h3 id=\"HTTP原理\"><a href=\"#HTTP原理\" class=\"headerlink\" title=\"HTTP原理\"></a>HTTP原理</h3><p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。</p>\n<p>HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>\n<h3 id=\"HTTP协议-1\"><a href=\"#HTTP协议-1\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p>\n<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p>\n<h3 id=\"HTTP特点\"><a href=\"#HTTP特点\" class=\"headerlink\" title=\"HTTP特点\"></a>HTTP特点</h3><ul>\n<li>支持客户端/服务器模式</li>\n<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</li>\n<li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</li>\n<li>无连接：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间</li>\n<li>无状态：HTTP 协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快</li>\n</ul>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p>\n<p>解决HTTP的一些问题</p>\n<ul>\n<li>请求信息明文传输，容易被窃听截取。</li>\n<li>数据的完整性未校验，容易被篡改</li>\n<li>没有验证对方身份，存在冒充危险</li>\n</ul>\n<h2 id=\"总结HTTPS和HTTP的区别\"><a href=\"#总结HTTPS和HTTP的区别\" class=\"headerlink\" title=\"总结HTTPS和HTTP的区别\"></a>总结HTTPS和HTTP的区别</h2><ul>\n<li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</li>\n<li>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</li>\n</ul>\n<h2 id=\"URL详解\"><a href=\"#URL详解\" class=\"headerlink\" title=\"URL详解\"></a>URL详解</h2><p>URL（Uniform Resource Locator）是统一资源定位符的简称，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址</p>\n<h3 id=\"基本组成\"><a href=\"#基本组成\" class=\"headerlink\" title=\"基本组成\"></a>基本组成</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>访问服务器以获取资源时要使用哪种协议，比如，http，https 和 FTP 等</td>\n</tr>\n<tr>\n<td>host</td>\n<td>HTTP 服务器的 IP 地址或域名</td>\n</tr>\n<tr>\n<td>port#</td>\n<td>HTTP 服务器的默认端口是 80，这种情况下端口号可以省略，如果使用了别的端口，必须指明，例如<a href=\"http://www.cnblogs.com：8080\">www.cnblogs.com：8080</a></td>\n</tr>\n<tr>\n<td>path</td>\n<td>访问资源的路径</td>\n</tr>\n<tr>\n<td>query-string</td>\n<td>发给 http 服务器的数据</td>\n</tr>\n<tr>\n<td>anchor</td>\n<td>锚</td>\n</tr>\n</tbody></table>\n<p><img src=\"/image/httpHttps/15fc2525666dc96e.jpg\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>向指定资源位置上传其最新内容</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除 Request-URI 所标识的资源</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据）</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>显示服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）</td>\n</tr>\n</tbody></table>\n<p>其中，最常见的是 GET 和 POST 方法，如果是 RESful 接口的话一般会用到 PUT、DELETE、GET、POST（分别对应增删查改</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authorization</td>\n<td>用于设置身份认证信息</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>用户标识，如：OS 和浏览器的类型和版本</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>已有的Cookie</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求的主机和端口号</td>\n</tr>\n</tbody></table>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>对应的信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>提示信息—表示请求已接收，继续处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>用于表示请求已被成功接收、理解、接收</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>客户端错误—请求有语法错误或者请求无法实现</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>服务器端错误—服务器未能实现合法的请求</td>\n</tr>\n</tbody></table>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Date</td>\n<td>服务器的日期</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>该资源最后被修改的时间</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>取值一般为 chunked，出现在 Content-Length 不能确定的情况下，表示服务器不知道响应板体的数据大小，一般同时出现Content-Encoding响应头</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置 Cookie</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>重定向到另一个 URL，如输入浏览器就输入 baidu.com 回车，会自动跳转到<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 就是通过这个响应头控制的</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>后台服务器</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p> Reference<br> <a href=\"https://zhuanlan.zhihu.com/p/72616216\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/72616216</a><br> <a href=\"https://juejin.im/post/5a0ce1d95188253e24708454\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a0ce1d95188253e24708454</a></p>\n</blockquote>\n"},{"title":"Hexo+GitHub构建你的博客","date":"2019-06-17T11:17:25.000Z","cover":"/image/cover/HEXO.png","_content":"\n\nhttps://blog.csdn.net/cuandeqin2083/article/details/92791433\n\n","source":"_posts/Hexo+GitHub构建你的博客.md","raw":"---\ntitle: Hexo+GitHub构建你的博客\ndate: 2019-06-17 19:17:25\ntags: [Hexo, GitHub]\ncategories: [博客]\ncover: /image/cover/HEXO.png\n---\n\n\nhttps://blog.csdn.net/cuandeqin2083/article/details/92791433\n\n","slug":"Hexo+GitHub构建你的博客","published":1,"updated":"2021-06-24T14:00:06.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7n0006lwrd9h667myh","content":"<p><a href=\"https://blog.csdn.net/cuandeqin2083/article/details/92791433\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/cuandeqin2083/article/details/92791433</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/cuandeqin2083/article/details/92791433\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/cuandeqin2083/article/details/92791433</a></p>\n"},{"date":"2019-06-19T03:22:03.000Z","cover":"/image/cover/React.jpeg","_content":"\n@[TOC](React入门（一） State详解)\n\n# React入门（一） State详解\n\n我们都是程序员，废话不多说马上开始！\n\n## 一、 Demo创建/下载\n\n两种方法创建新的React APP\n\n### 1. github下载\n\n- 下载[git地址](https://github.com/DerrickTel/ReactDemo1.git).\n - 解压-打开\n  - npm install\n  - npm start \n  - ![如果有询问](/image/React入门/20181123111537542.png)\n  - y（3000端口任务在运行是否愿意运行在别的端口上？）\n\n\n\n### 2. 自己的命令行创建\n- 找到自己**心仪的文件夹**   *（全英文）*\n - 用命令行打开并抵达**心仪文件夹**\n  - npx create-react-app my-app\n  - cd my-app\n  - npm start\n> **注意**\n> npx在第一行不是一个错字 - 它是一个包转发工具，附带npm 5.2+。\n> 创建的时候已经默认运行过（npm install ）可以直接start\n\n然后把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <p>\n            修改文件夹 <code>src/App.js</code> 保存时候之后自动加载.\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n```\nCtrl + C \n\nCtrl + V\n\n## 二、State是什么？\n![在这里插入图片描述](/image/React入门/20181123134126335.png)\n\n英文翻译是状态。\n\n其实也可以理解为状态，一段文字中的某个值改变了，也可以理解为状态改变了。\n看一个简单的例子\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n```javascript\n  state={Text:'我是state'}\n```\n\n这里的state是给state设置初值，不然会报错。不相信的话自己可以试一下。*（因为state是undefined，所以他里面取不到Text）*\n\n通过上面的例子可以知道state里面放的是XX的状态\n\nkey value对应的\n\nthis.state.xx就可以取到对应key的**状态**的*值*\n\n\n## 三、State如何改变？\n\n通常在JS里面，我们要改变某一个值可能就只需要  X = XX; 就可以。\n\n\n这里的state是一个状态。状态改变了，页面会自动刷新为最新的页面用最新的状态显示。\n下面我们做一个小实验。\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            this.state.Text = '我是通过this.state.Text改变的State';\n            alert(this.state.Text);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n（不要在意细节！！！我们是测试按钮的样式不重要！！！）\n\n点击按钮之后，我们发现，state的值是改变了，但是页面上面显示的值不是我们想要的啊。\n\n\n\n那我要怎么才可以刷新页面出现我想要的state的值呢？\n\n官方提供的方法\n\nsetState(updater, [callback])\n\n\n可以这么理解，针对上面的例子\n\n\n```javascript\nthis.setState({Text:'我是通过this.state.Text改变的State'}, function(){})\n```\n\n后面的function，可以有，也可以没有。不需要的话就可以不用写-----------稍后会说\n\n所以只需要\n\n```javascript\nthis.setState({Text:'我是通过this.state.Text改变的State'})\n```\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            this.setState({Text:'我是通过this.state.Text改变的State'})\n            alert(this.state.Text);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n保存-热加载\n之后我们发现，状态是改变了，可是alert的值不是我们想要的，还是老的值（状态）的。\n\n可能你不知道我在说什么\n\n通过一个小例子我们仔细感受一下。官方的setState究竟在干什么。\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1});\n            console.log(this.state.conut);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n打开我们的react页面\n按Ctrl + Shift + I\n看log\n然后按钮\n\n![在这里插入图片描述](/image/React入门/20181123143905811.png)\n\n诶，我不是setState了吗，为什么值没有改变还是初值呢？\n\n我们换一个方法试一下\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1})\n            setTimeout(()=>{\n              console.log(this.state.conut);\n            },1000);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n\n那我们是不是可以认为setState不是一个立刻生效的函数。\n\n有点类似异步的网络请求。\n\n\n\n这是一个坑，很多新手都会遇到的坑。我曾经也遇到所以写出来。\n\n那既然是类似异步的网络请求肯定也有callback咯？\n\n是的！\n\n我们把console.log放到刚刚我们没有写function里面。\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1}, ()=>{\n              console.log(this.state.conut);\n            })\n            \n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n这样的好处我们不需要手动的控制等待时间的大小，因为根据设备的不同这个时间可能会太多或者太少。\n\n本人React小菜，有说的不对的地方还请大神指出。\n","source":"_posts/React-State详解.md","raw":"---\n#成年人的崩溃往往就在一瞬间title: React入门（一） State详解\ndate: 2019-06-19 11:22:03\ntags: [React, State]\ncategory: [React]\ncover: /image/cover/React.jpeg\n---\n\n@[TOC](React入门（一） State详解)\n\n# React入门（一） State详解\n\n我们都是程序员，废话不多说马上开始！\n\n## 一、 Demo创建/下载\n\n两种方法创建新的React APP\n\n### 1. github下载\n\n- 下载[git地址](https://github.com/DerrickTel/ReactDemo1.git).\n - 解压-打开\n  - npm install\n  - npm start \n  - ![如果有询问](/image/React入门/20181123111537542.png)\n  - y（3000端口任务在运行是否愿意运行在别的端口上？）\n\n\n\n### 2. 自己的命令行创建\n- 找到自己**心仪的文件夹**   *（全英文）*\n - 用命令行打开并抵达**心仪文件夹**\n  - npx create-react-app my-app\n  - cd my-app\n  - npm start\n> **注意**\n> npx在第一行不是一个错字 - 它是一个包转发工具，附带npm 5.2+。\n> 创建的时候已经默认运行过（npm install ）可以直接start\n\n然后把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <p>\n            修改文件夹 <code>src/App.js</code> 保存时候之后自动加载.\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n```\nCtrl + C \n\nCtrl + V\n\n## 二、State是什么？\n![在这里插入图片描述](/image/React入门/20181123134126335.png)\n\n英文翻译是状态。\n\n其实也可以理解为状态，一段文字中的某个值改变了，也可以理解为状态改变了。\n看一个简单的例子\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n```javascript\n  state={Text:'我是state'}\n```\n\n这里的state是给state设置初值，不然会报错。不相信的话自己可以试一下。*（因为state是undefined，所以他里面取不到Text）*\n\n通过上面的例子可以知道state里面放的是XX的状态\n\nkey value对应的\n\nthis.state.xx就可以取到对应key的**状态**的*值*\n\n\n## 三、State如何改变？\n\n通常在JS里面，我们要改变某一个值可能就只需要  X = XX; 就可以。\n\n\n这里的state是一个状态。状态改变了，页面会自动刷新为最新的页面用最新的状态显示。\n下面我们做一个小实验。\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            this.state.Text = '我是通过this.state.Text改变的State';\n            alert(this.state.Text);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n（不要在意细节！！！我们是测试按钮的样式不重要！！！）\n\n点击按钮之后，我们发现，state的值是改变了，但是页面上面显示的值不是我们想要的啊。\n\n\n\n那我要怎么才可以刷新页面出现我想要的state的值呢？\n\n官方提供的方法\n\nsetState(updater, [callback])\n\n\n可以这么理解，针对上面的例子\n\n\n```javascript\nthis.setState({Text:'我是通过this.state.Text改变的State'}, function(){})\n```\n\n后面的function，可以有，也可以没有。不需要的话就可以不用写-----------稍后会说\n\n所以只需要\n\n```javascript\nthis.setState({Text:'我是通过this.state.Text改变的State'})\n```\n\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={Text:'我是state'}\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            this.setState({Text:'我是通过this.state.Text改变的State'})\n            alert(this.state.Text);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n保存-热加载\n之后我们发现，状态是改变了，可是alert的值不是我们想要的，还是老的值（状态）的。\n\n可能你不知道我在说什么\n\n通过一个小例子我们仔细感受一下。官方的setState究竟在干什么。\n\n把 src/app.js的文件内容先改一下\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1});\n            console.log(this.state.conut);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n打开我们的react页面\n按Ctrl + Shift + I\n看log\n然后按钮\n\n![在这里插入图片描述](/image/React入门/20181123143905811.png)\n\n诶，我不是setState了吗，为什么值没有改变还是初值呢？\n\n我们换一个方法试一下\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1})\n            setTimeout(()=>{\n              console.log(this.state.conut);\n            },1000);\n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n\n那我们是不是可以认为setState不是一个立刻生效的函数。\n\n有点类似异步的网络请求。\n\n\n\n这是一个坑，很多新手都会遇到的坑。我曾经也遇到所以写出来。\n\n那既然是类似异步的网络请求肯定也有callback咯？\n\n是的！\n\n我们把console.log放到刚刚我们没有写function里面。\n\n```javascript\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  state={\n    Text:'大家一起看log吧，我这次啥也不做',\n    conut:0,\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            State输出：{this.state.Text}\n          </p>\n          <button onClick={()=>{\n            console.log(this.state.conut);\n            this.setState({conut: this.state.conut + 1}, ()=>{\n              console.log(this.state.conut);\n            })\n            \n          }}>\n            按我改变state\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n这样的好处我们不需要手动的控制等待时间的大小，因为根据设备的不同这个时间可能会太多或者太少。\n\n本人React小菜，有说的不对的地方还请大神指出。\n","slug":"React-State详解","published":1,"updated":"2021-06-24T14:00:06.847Z","title":"React-State详解","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7p0007lwrdgy43c737","content":"<p>@[TOC](React入门（一） State详解)</p>\n<h1 id=\"React入门（一）-State详解\"><a href=\"#React入门（一）-State详解\" class=\"headerlink\" title=\"React入门（一） State详解\"></a>React入门（一） State详解</h1><p>我们都是程序员，废话不多说马上开始！</p>\n<h2 id=\"一、-Demo创建-下载\"><a href=\"#一、-Demo创建-下载\" class=\"headerlink\" title=\"一、 Demo创建/下载\"></a>一、 Demo创建/下载</h2><p>两种方法创建新的React APP</p>\n<h3 id=\"1-github下载\"><a href=\"#1-github下载\" class=\"headerlink\" title=\"1. github下载\"></a>1. github下载</h3><ul>\n<li>下载<a href=\"https://github.com/DerrickTel/ReactDemo1.git\" target=\"_blank\" rel=\"noopener\">git地址</a>.<ul>\n<li>解压-打开</li>\n<li>npm install</li>\n<li>npm start </li>\n<li><img src=\"/\" class=\"lazyload\" data-src=\"/image/React%E5%85%A5%E9%97%A8/20181123111537542.png\"  alt=\"如果有询问\"></li>\n<li>y（3000端口任务在运行是否愿意运行在别的端口上？）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-自己的命令行创建\"><a href=\"#2-自己的命令行创建\" class=\"headerlink\" title=\"2. 自己的命令行创建\"></a>2. 自己的命令行创建</h3><ul>\n<li>找到自己<strong>心仪的文件夹</strong>   <em>（全英文）</em><ul>\n<li>用命令行打开并抵达<strong>心仪文件夹</strong></li>\n<li>npx create-react-app my-app</li>\n<li>cd my-app</li>\n<li>npm start<blockquote>\n<p><strong>注意</strong><br>npx在第一行不是一个错字 - 它是一个包转发工具，附带npm 5.2+。<br>创建的时候已经默认运行过（npm install ）可以直接start</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>然后把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            Edit &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; and save to reload.</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            修改文件夹 &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; 保存时候之后自动加载.</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>Ctrl + C </p>\n<p>Ctrl + V</p>\n<h2 id=\"二、State是什么？\"><a href=\"#二、State是什么？\" class=\"headerlink\" title=\"二、State是什么？\"></a>二、State是什么？</h2><p><img src=\"/\" class=\"lazyload\" data-src=\"/image/React%E5%85%A5%E9%97%A8/20181123134126335.png\"  alt=\"在这里插入图片描述\"></p>\n<p>英文翻译是状态。</p>\n<p>其实也可以理解为状态，一段文字中的某个值改变了，也可以理解为状态改变了。<br>看一个简单的例子</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的state是给state设置初值，不然会报错。不相信的话自己可以试一下。<em>（因为state是undefined，所以他里面取不到Text）</em></p>\n<p>通过上面的例子可以知道state里面放的是XX的状态</p>\n<p>key value对应的</p>\n<p>this.state.xx就可以取到对应key的<strong>状态</strong>的<em>值</em></p>\n<h2 id=\"三、State如何改变？\"><a href=\"#三、State如何改变？\" class=\"headerlink\" title=\"三、State如何改变？\"></a>三、State如何改变？</h2><p>通常在JS里面，我们要改变某一个值可能就只需要  X = XX; 就可以。</p>\n<p>这里的state是一个状态。状态改变了，页面会自动刷新为最新的页面用最新的状态显示。<br>下面我们做一个小实验。</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            this.state.Text = '我是通过this.state.Text改变的State';</span></span><br><span class=\"line\"><span class=\"regexp\">            alert(this.state.Text);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>（不要在意细节！！！我们是测试按钮的样式不重要！！！）</p>\n<p>点击按钮之后，我们发现，state的值是改变了，但是页面上面显示的值不是我们想要的啊。</p>\n<p>那我要怎么才可以刷新页面出现我想要的state的值呢？</p>\n<p>官方提供的方法</p>\n<p>setState(updater, [callback])</p>\n<p>可以这么理解，针对上面的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是通过this.state.Text改变的State'</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>后面的function，可以有，也可以没有。不需要的话就可以不用写———–稍后会说</p>\n<p>所以只需要</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是通过this.state.Text改变的State'</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;Text:'我是通过this.state.Text改变的State'&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            alert(this.state.Text);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>保存-热加载<br>之后我们发现，状态是改变了，可是alert的值不是我们想要的，还是老的值（状态）的。</p>\n<p>可能你不知道我在说什么</p>\n<p>通过一个小例子我们仔细感受一下。官方的setState究竟在干什么。</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>打开我们的react页面<br>按Ctrl + Shift + I<br>看log<br>然后按钮</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/React%E5%85%A5%E9%97%A8/20181123143905811.png\"  alt=\"在这里插入图片描述\"></p>\n<p>诶，我不是setState了吗，为什么值没有改变还是初值呢？</p>\n<p>我们换一个方法试一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            setTimeout(()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;,1000);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n\n<p>那我们是不是可以认为setState不是一个立刻生效的函数。</p>\n<p>有点类似异步的网络请求。</p>\n<p>这是一个坑，很多新手都会遇到的坑。我曾经也遇到所以写出来。</p>\n<p>那既然是类似异步的网络请求肯定也有callback咯？</p>\n<p>是的！</p>\n<p>我们把console.log放到刚刚我们没有写function里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;, ()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>这样的好处我们不需要手动的控制等待时间的大小，因为根据设备的不同这个时间可能会太多或者太少。</p>\n<p>本人React小菜，有说的不对的地方还请大神指出。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>@[TOC](React入门（一） State详解)</p>\n<h1 id=\"React入门（一）-State详解\"><a href=\"#React入门（一）-State详解\" class=\"headerlink\" title=\"React入门（一） State详解\"></a>React入门（一） State详解</h1><p>我们都是程序员，废话不多说马上开始！</p>\n<h2 id=\"一、-Demo创建-下载\"><a href=\"#一、-Demo创建-下载\" class=\"headerlink\" title=\"一、 Demo创建/下载\"></a>一、 Demo创建/下载</h2><p>两种方法创建新的React APP</p>\n<h3 id=\"1-github下载\"><a href=\"#1-github下载\" class=\"headerlink\" title=\"1. github下载\"></a>1. github下载</h3><ul>\n<li>下载<a href=\"https://github.com/DerrickTel/ReactDemo1.git\" target=\"_blank\" rel=\"noopener\">git地址</a>.<ul>\n<li>解压-打开</li>\n<li>npm install</li>\n<li>npm start </li>\n<li><img src=\"/image/React%E5%85%A5%E9%97%A8/20181123111537542.png\" alt=\"如果有询问\"></li>\n<li>y（3000端口任务在运行是否愿意运行在别的端口上？）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-自己的命令行创建\"><a href=\"#2-自己的命令行创建\" class=\"headerlink\" title=\"2. 自己的命令行创建\"></a>2. 自己的命令行创建</h3><ul>\n<li>找到自己<strong>心仪的文件夹</strong>   <em>（全英文）</em><ul>\n<li>用命令行打开并抵达<strong>心仪文件夹</strong></li>\n<li>npx create-react-app my-app</li>\n<li>cd my-app</li>\n<li>npm start<blockquote>\n<p><strong>注意</strong><br>npx在第一行不是一个错字 - 它是一个包转发工具，附带npm 5.2+。<br>创建的时候已经默认运行过（npm install ）可以直接start</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>然后把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            Edit &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; and save to reload.</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            修改文件夹 &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; 保存时候之后自动加载.</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>Ctrl + C </p>\n<p>Ctrl + V</p>\n<h2 id=\"二、State是什么？\"><a href=\"#二、State是什么？\" class=\"headerlink\" title=\"二、State是什么？\"></a>二、State是什么？</h2><p><img src=\"/image/React%E5%85%A5%E9%97%A8/20181123134126335.png\" alt=\"在这里插入图片描述\"></p>\n<p>英文翻译是状态。</p>\n<p>其实也可以理解为状态，一段文字中的某个值改变了，也可以理解为状态改变了。<br>看一个简单的例子</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的state是给state设置初值，不然会报错。不相信的话自己可以试一下。<em>（因为state是undefined，所以他里面取不到Text）</em></p>\n<p>通过上面的例子可以知道state里面放的是XX的状态</p>\n<p>key value对应的</p>\n<p>this.state.xx就可以取到对应key的<strong>状态</strong>的<em>值</em></p>\n<h2 id=\"三、State如何改变？\"><a href=\"#三、State如何改变？\" class=\"headerlink\" title=\"三、State如何改变？\"></a>三、State如何改变？</h2><p>通常在JS里面，我们要改变某一个值可能就只需要  X = XX; 就可以。</p>\n<p>这里的state是一个状态。状态改变了，页面会自动刷新为最新的页面用最新的状态显示。<br>下面我们做一个小实验。</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            this.state.Text = '我是通过this.state.Text改变的State';</span></span><br><span class=\"line\"><span class=\"regexp\">            alert(this.state.Text);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>（不要在意细节！！！我们是测试按钮的样式不重要！！！）</p>\n<p>点击按钮之后，我们发现，state的值是改变了，但是页面上面显示的值不是我们想要的啊。</p>\n<p>那我要怎么才可以刷新页面出现我想要的state的值呢？</p>\n<p>官方提供的方法</p>\n<p>setState(updater, [callback])</p>\n<p>可以这么理解，针对上面的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是通过this.state.Text改变的State'</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>后面的function，可以有，也可以没有。不需要的话就可以不用写———–稍后会说</p>\n<p>所以只需要</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是通过this.state.Text改变的State'</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;<span class=\"attr\">Text</span>:<span class=\"string\">'我是state'</span>&#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;Text:'我是通过this.state.Text改变的State'&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            alert(this.state.Text);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>保存-热加载<br>之后我们发现，状态是改变了，可是alert的值不是我们想要的，还是老的值（状态）的。</p>\n<p>可能你不知道我在说什么</p>\n<p>通过一个小例子我们仔细感受一下。官方的setState究竟在干什么。</p>\n<p>把 src/app.js的文件内容先改一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>打开我们的react页面<br>按Ctrl + Shift + I<br>看log<br>然后按钮</p>\n<p><img src=\"/image/React%E5%85%A5%E9%97%A8/20181123143905811.png\" alt=\"在这里插入图片描述\"></p>\n<p>诶，我不是setState了吗，为什么值没有改变还是初值呢？</p>\n<p>我们换一个方法试一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            setTimeout(()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;,1000);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n\n<p>那我们是不是可以认为setState不是一个立刻生效的函数。</p>\n<p>有点类似异步的网络请求。</p>\n<p>这是一个坑，很多新手都会遇到的坑。我曾经也遇到所以写出来。</p>\n<p>那既然是类似异步的网络请求肯定也有callback咯？</p>\n<p>是的！</p>\n<p>我们把console.log放到刚刚我们没有写function里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state=&#123;</span><br><span class=\"line\">    Text:<span class=\"string\">'大家一起看log吧，我这次啥也不做'</span>,</span><br><span class=\"line\">    conut:<span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;p&gt;</span><br><span class=\"line\">            State输出：&#123;<span class=\"keyword\">this</span>.state.Text&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;button onClick=&#123;()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            this.setState(&#123;conut: this.state.conut + 1&#125;, ()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              console.log(this.state.conut);</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            按我改变state</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<p>这样的好处我们不需要手动的控制等待时间的大小，因为根据设备的不同这个时间可能会太多或者太少。</p>\n<p>本人React小菜，有说的不对的地方还请大神指出。</p>\n"},{"title":"JWT spring boot JAVA 使用步骤 spring boot2.0","date":"2019-06-19T02:58:33.000Z","cover":"/image/cover/JWT.png","_content":"\n## 前言\nJWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。\n\n（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n## 使用\n\n - 添加依赖\nhttps://jwt.io/\n选择对应的版本\n - 使用\n\n```\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.Claim;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport org.springframework.util.StringUtils;\n\npublic class TokenConfig {\n    /** token秘钥，请勿泄露，请勿随便修改 backups:JKKLJOoasdlfj */\n    public static final String SECRET = \"JKKLJOoasdlfj\";\n    /** token 过期时间: 10天 */\n    public static final int calendarField = Calendar.DATE;\n    public static final int calendarInterval = 10;\n\n    /**\n     * JWT生成Token.<br/>\n     *\n     * JWT构成: header, payload, signature\n     *\n     * @param user_id\n     *            登录成功后用户user_id, 参数user_id不可传空\n     */\n    public static String createToken(Long user_id) throws Exception {\n        Date iatDate = new Date();\n        // expire time\n        Calendar nowTime = Calendar.getInstance();\n        nowTime.add(calendarField, calendarInterval);\n        Date expiresDate = nowTime.getTime();\n\n        // header Map\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"alg\", \"HS256\");\n        map.put(\"typ\", \"JWT\");\n\n        // build token\n        // param backups {iss:Service, aud:APP}\n        String token = JWT.create().withHeader(map) // header\n                .withClaim(\"iss\", \"Service\") // payload\n                .withClaim(\"aud\", \"APP\").withClaim(\"user_id\", null == user_id ? null : user_id.toString())\n                .withIssuedAt(iatDate) // sign time\n                .withExpiresAt(expiresDate) // expire time\n                .sign(Algorithm.HMAC256(SECRET)); // signature\n\n        return token;\n    }\n\n    /**\n     * 解密Token\n     *\n     * @param token\n     * @return\n     * @throws Exception\n     */\n    public static Map<String, Claim> verifyToken(String token) {\n        DecodedJWT jwt = null;\n        try {\n            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET)).build();\n            jwt = verifier.verify(token);\n        } catch (Exception e) {\n            // e.printStackTrace();\n            // token 校验失败, 抛出Token验证非法异常\n        }\n        return jwt.getClaims();\n    }\n\n    /**\n     * 根据Token获取user_id\n     *\n     * @param token\n     * @return user_id\n     */\n    public static Long getAppUID(String token) {\n        Map<String, Claim> claims = verifyToken(token);\n        Claim user_id_claim = claims.get(\"user_id\");\n        if (null == user_id_claim || StringUtils.isEmpty(user_id_claim.asString())) {\n            // token 校验失败, 抛出Token验证非法异常\n        }\n        return Long.valueOf(user_id_claim.asString());\n    }\n}\n```\n\n## 概念解析\nJWT 的三个部分依次如下。\n\n - Header（头部）\n - Payload（负载）\n - Signature（签名）\n\n\n写成一行，就是下面的样子。\n\n\n![https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg](/image/SpringBootJWT/20190325103836546.png)\n","source":"_posts/JWT-spring-boot-JAVA-使用步骤-spring-boot2-0.md","raw":"---\ntitle: JWT spring boot JAVA 使用步骤 spring boot2.0\ndate: 2019-06-19 10:58:33\ntags: [Spring-Boot-2.0, Java, JWT]\ncategory: [Java, Spring-Boot]\ncover: /image/cover/JWT.png\n---\n\n## 前言\nJWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。\n\n（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n## 使用\n\n - 添加依赖\nhttps://jwt.io/\n选择对应的版本\n - 使用\n\n```\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.Claim;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport org.springframework.util.StringUtils;\n\npublic class TokenConfig {\n    /** token秘钥，请勿泄露，请勿随便修改 backups:JKKLJOoasdlfj */\n    public static final String SECRET = \"JKKLJOoasdlfj\";\n    /** token 过期时间: 10天 */\n    public static final int calendarField = Calendar.DATE;\n    public static final int calendarInterval = 10;\n\n    /**\n     * JWT生成Token.<br/>\n     *\n     * JWT构成: header, payload, signature\n     *\n     * @param user_id\n     *            登录成功后用户user_id, 参数user_id不可传空\n     */\n    public static String createToken(Long user_id) throws Exception {\n        Date iatDate = new Date();\n        // expire time\n        Calendar nowTime = Calendar.getInstance();\n        nowTime.add(calendarField, calendarInterval);\n        Date expiresDate = nowTime.getTime();\n\n        // header Map\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"alg\", \"HS256\");\n        map.put(\"typ\", \"JWT\");\n\n        // build token\n        // param backups {iss:Service, aud:APP}\n        String token = JWT.create().withHeader(map) // header\n                .withClaim(\"iss\", \"Service\") // payload\n                .withClaim(\"aud\", \"APP\").withClaim(\"user_id\", null == user_id ? null : user_id.toString())\n                .withIssuedAt(iatDate) // sign time\n                .withExpiresAt(expiresDate) // expire time\n                .sign(Algorithm.HMAC256(SECRET)); // signature\n\n        return token;\n    }\n\n    /**\n     * 解密Token\n     *\n     * @param token\n     * @return\n     * @throws Exception\n     */\n    public static Map<String, Claim> verifyToken(String token) {\n        DecodedJWT jwt = null;\n        try {\n            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET)).build();\n            jwt = verifier.verify(token);\n        } catch (Exception e) {\n            // e.printStackTrace();\n            // token 校验失败, 抛出Token验证非法异常\n        }\n        return jwt.getClaims();\n    }\n\n    /**\n     * 根据Token获取user_id\n     *\n     * @param token\n     * @return user_id\n     */\n    public static Long getAppUID(String token) {\n        Map<String, Claim> claims = verifyToken(token);\n        Claim user_id_claim = claims.get(\"user_id\");\n        if (null == user_id_claim || StringUtils.isEmpty(user_id_claim.asString())) {\n            // token 校验失败, 抛出Token验证非法异常\n        }\n        return Long.valueOf(user_id_claim.asString());\n    }\n}\n```\n\n## 概念解析\nJWT 的三个部分依次如下。\n\n - Header（头部）\n - Payload（负载）\n - Signature（签名）\n\n\n写成一行，就是下面的样子。\n\n\n![https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg](/image/SpringBootJWT/20190325103836546.png)\n","slug":"JWT-spring-boot-JAVA-使用步骤-spring-boot2-0","published":1,"updated":"2021-06-24T14:00:06.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7p0008lwrd58in9g5h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。</p>\n<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>\n<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>\n<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>\n<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>\n<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>\n<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li>添加依赖<br><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a><br>选择对应的版本</li>\n<li>使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Calendar;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.auth0.jwt.JWT;</span><br><span class=\"line\">import com.auth0.jwt.JWTVerifier;</span><br><span class=\"line\">import com.auth0.jwt.algorithms.Algorithm;</span><br><span class=\"line\">import com.auth0.jwt.interfaces.Claim;</span><br><span class=\"line\">import com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class=\"line\">import org.springframework.util.StringUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class TokenConfig &#123;</span><br><span class=\"line\">    &#x2F;** token秘钥，请勿泄露，请勿随便修改 backups:JKKLJOoasdlfj *&#x2F;</span><br><span class=\"line\">    public static final String SECRET &#x3D; &quot;JKKLJOoasdlfj&quot;;</span><br><span class=\"line\">    &#x2F;** token 过期时间: 10天 *&#x2F;</span><br><span class=\"line\">    public static final int calendarField &#x3D; Calendar.DATE;</span><br><span class=\"line\">    public static final int calendarInterval &#x3D; 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * JWT生成Token.&lt;br&#x2F;&gt;</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * JWT构成: header, payload, signature</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param user_id</span><br><span class=\"line\">     *            登录成功后用户user_id, 参数user_id不可传空</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static String createToken(Long user_id) throws Exception &#123;</span><br><span class=\"line\">        Date iatDate &#x3D; new Date();</span><br><span class=\"line\">        &#x2F;&#x2F; expire time</span><br><span class=\"line\">        Calendar nowTime &#x3D; Calendar.getInstance();</span><br><span class=\"line\">        nowTime.add(calendarField, calendarInterval);</span><br><span class=\"line\">        Date expiresDate &#x3D; nowTime.getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; header Map</span><br><span class=\"line\">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(&quot;alg&quot;, &quot;HS256&quot;);</span><br><span class=\"line\">        map.put(&quot;typ&quot;, &quot;JWT&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; build token</span><br><span class=\"line\">        &#x2F;&#x2F; param backups &#123;iss:Service, aud:APP&#125;</span><br><span class=\"line\">        String token &#x3D; JWT.create().withHeader(map) &#x2F;&#x2F; header</span><br><span class=\"line\">                .withClaim(&quot;iss&quot;, &quot;Service&quot;) &#x2F;&#x2F; payload</span><br><span class=\"line\">                .withClaim(&quot;aud&quot;, &quot;APP&quot;).withClaim(&quot;user_id&quot;, null &#x3D;&#x3D; user_id ? null : user_id.toString())</span><br><span class=\"line\">                .withIssuedAt(iatDate) &#x2F;&#x2F; sign time</span><br><span class=\"line\">                .withExpiresAt(expiresDate) &#x2F;&#x2F; expire time</span><br><span class=\"line\">                .sign(Algorithm.HMAC256(SECRET)); &#x2F;&#x2F; signature</span><br><span class=\"line\"></span><br><span class=\"line\">        return token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 解密Token</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param token</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws Exception</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static Map&lt;String, Claim&gt; verifyToken(String token) &#123;</span><br><span class=\"line\">        DecodedJWT jwt &#x3D; null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            JWTVerifier verifier &#x3D; JWT.require(Algorithm.HMAC256(SECRET)).build();</span><br><span class=\"line\">            jwt &#x3D; verifier.verify(token);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; e.printStackTrace();</span><br><span class=\"line\">            &#x2F;&#x2F; token 校验失败, 抛出Token验证非法异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return jwt.getClaims();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 根据Token获取user_id</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param token</span><br><span class=\"line\">     * @return user_id</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static Long getAppUID(String token) &#123;</span><br><span class=\"line\">        Map&lt;String, Claim&gt; claims &#x3D; verifyToken(token);</span><br><span class=\"line\">        Claim user_id_claim &#x3D; claims.get(&quot;user_id&quot;);</span><br><span class=\"line\">        if (null &#x3D;&#x3D; user_id_claim || StringUtils.isEmpty(user_id_claim.asString())) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; token 校验失败, 抛出Token验证非法异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Long.valueOf(user_id_claim.asString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h2><p>JWT 的三个部分依次如下。</p>\n<ul>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ul>\n<p>写成一行，就是下面的样子。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/SpringBootJWT/20190325103836546.png\"  alt=\"https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。</p>\n<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>\n<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>\n<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>\n<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>\n<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>\n<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li>添加依赖<br><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a><br>选择对应的版本</li>\n<li>使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Calendar;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.auth0.jwt.JWT;</span><br><span class=\"line\">import com.auth0.jwt.JWTVerifier;</span><br><span class=\"line\">import com.auth0.jwt.algorithms.Algorithm;</span><br><span class=\"line\">import com.auth0.jwt.interfaces.Claim;</span><br><span class=\"line\">import com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class=\"line\">import org.springframework.util.StringUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class TokenConfig &#123;</span><br><span class=\"line\">    &#x2F;** token秘钥，请勿泄露，请勿随便修改 backups:JKKLJOoasdlfj *&#x2F;</span><br><span class=\"line\">    public static final String SECRET &#x3D; &quot;JKKLJOoasdlfj&quot;;</span><br><span class=\"line\">    &#x2F;** token 过期时间: 10天 *&#x2F;</span><br><span class=\"line\">    public static final int calendarField &#x3D; Calendar.DATE;</span><br><span class=\"line\">    public static final int calendarInterval &#x3D; 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * JWT生成Token.&lt;br&#x2F;&gt;</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * JWT构成: header, payload, signature</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param user_id</span><br><span class=\"line\">     *            登录成功后用户user_id, 参数user_id不可传空</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static String createToken(Long user_id) throws Exception &#123;</span><br><span class=\"line\">        Date iatDate &#x3D; new Date();</span><br><span class=\"line\">        &#x2F;&#x2F; expire time</span><br><span class=\"line\">        Calendar nowTime &#x3D; Calendar.getInstance();</span><br><span class=\"line\">        nowTime.add(calendarField, calendarInterval);</span><br><span class=\"line\">        Date expiresDate &#x3D; nowTime.getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; header Map</span><br><span class=\"line\">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(&quot;alg&quot;, &quot;HS256&quot;);</span><br><span class=\"line\">        map.put(&quot;typ&quot;, &quot;JWT&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; build token</span><br><span class=\"line\">        &#x2F;&#x2F; param backups &#123;iss:Service, aud:APP&#125;</span><br><span class=\"line\">        String token &#x3D; JWT.create().withHeader(map) &#x2F;&#x2F; header</span><br><span class=\"line\">                .withClaim(&quot;iss&quot;, &quot;Service&quot;) &#x2F;&#x2F; payload</span><br><span class=\"line\">                .withClaim(&quot;aud&quot;, &quot;APP&quot;).withClaim(&quot;user_id&quot;, null &#x3D;&#x3D; user_id ? null : user_id.toString())</span><br><span class=\"line\">                .withIssuedAt(iatDate) &#x2F;&#x2F; sign time</span><br><span class=\"line\">                .withExpiresAt(expiresDate) &#x2F;&#x2F; expire time</span><br><span class=\"line\">                .sign(Algorithm.HMAC256(SECRET)); &#x2F;&#x2F; signature</span><br><span class=\"line\"></span><br><span class=\"line\">        return token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 解密Token</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param token</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws Exception</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static Map&lt;String, Claim&gt; verifyToken(String token) &#123;</span><br><span class=\"line\">        DecodedJWT jwt &#x3D; null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            JWTVerifier verifier &#x3D; JWT.require(Algorithm.HMAC256(SECRET)).build();</span><br><span class=\"line\">            jwt &#x3D; verifier.verify(token);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; e.printStackTrace();</span><br><span class=\"line\">            &#x2F;&#x2F; token 校验失败, 抛出Token验证非法异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return jwt.getClaims();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 根据Token获取user_id</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param token</span><br><span class=\"line\">     * @return user_id</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public static Long getAppUID(String token) &#123;</span><br><span class=\"line\">        Map&lt;String, Claim&gt; claims &#x3D; verifyToken(token);</span><br><span class=\"line\">        Claim user_id_claim &#x3D; claims.get(&quot;user_id&quot;);</span><br><span class=\"line\">        if (null &#x3D;&#x3D; user_id_claim || StringUtils.isEmpty(user_id_claim.asString())) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; token 校验失败, 抛出Token验证非法异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Long.valueOf(user_id_claim.asString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h2><p>JWT 的三个部分依次如下。</p>\n<ul>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ul>\n<p>写成一行，就是下面的样子。</p>\n<p><img src=\"/image/SpringBootJWT/20190325103836546.png\" alt=\"https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg\"></p>\n"},{"title":"React Hook 倒计时","date":"2019-07-30T13:01:24.000Z","cover":"/image/cover/React.jpeg","_content":"\n```\nuseEffect(() => {\n    setTimeout(() => {\n      if (count > 0) {\n        setCount((c: number) => c - 1); // ✅ 在这不依赖于外部的 `count` 变量\n      }\n    }, 1000);\n  }, [count]); // ✅ 我们的 effect 不适用组件作用域中的任何变量\n```\n\n```\n<button onClick={() => setCount(60)} >点我</button>\n```\n\n","source":"_posts/React-Hook-倒计时.md","raw":"---\ntitle: React Hook 倒计时\ndate: 2019-07-30 21:01:24\ntags: [ReactHook, React, 倒计时]\ncategory: [React]\ncover: /image/cover/React.jpeg\n---\n\n```\nuseEffect(() => {\n    setTimeout(() => {\n      if (count > 0) {\n        setCount((c: number) => c - 1); // ✅ 在这不依赖于外部的 `count` 变量\n      }\n    }, 1000);\n  }, [count]); // ✅ 我们的 effect 不适用组件作用域中的任何变量\n```\n\n```\n<button onClick={() => setCount(60)} >点我</button>\n```\n\n","slug":"React-Hook-倒计时","published":1,"updated":"2021-06-24T14:00:06.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7r000blwrd9ucsbdrj","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (count &gt; 0) &#123;</span><br><span class=\"line\">        setCount((c: number) &#x3D;&gt; c - 1); &#x2F;&#x2F; ✅ 在这不依赖于外部的 &#96;count&#96; 变量</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">  &#125;, [count]); &#x2F;&#x2F; ✅ 我们的 effect 不适用组件作用域中的任何变量</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(60)&#125; &gt;点我&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (count &gt; 0) &#123;</span><br><span class=\"line\">        setCount((c: number) &#x3D;&gt; c - 1); &#x2F;&#x2F; ✅ 在这不依赖于外部的 &#96;count&#96; 变量</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">  &#125;, [count]); &#x2F;&#x2F; ✅ 我们的 effect 不适用组件作用域中的任何变量</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(60)&#125; &gt;点我&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Webpack CleanWebpackPlugin is not a constructor","date":"2019-06-22T07:55:56.000Z","cover":"/image/cover/webpack.png","_content":"\n## 前言\n今天自己跟着webpack官网的demo一步步走下来。发现了这个问题。\n\n![](/image/WebpackCleanWebpackPlugin/20190622155255789.png)\n\n查了一圈。发现了这个博主。nice！\n```\n// webpack版本：4.34.0\n \n// 抛错原写法\nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin(['dist'])\n]\n \n...\n \n// 另一种错误写法\n \nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin(['dist'], {\n        root: path.resolve(__dirname, '../'),   //根目录\n    })\n]\n \n...\n \n// =============================分割线==============================\n \n// 正确写法\n \nconst { CleanWebpackPlugin } = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin()\n]\n \n```\n\n 现在的版本不用指定文件路径了，直接调用new CleanWebpackPlugin()\n ![在这里插入图片描述](/image/WebpackCleanWebpackPlugin/20190622155123842.png)\n索引：https://blog.csdn.net/qq_36242361/article/details/90709258\n\n","source":"_posts/Webpack-CleanWebpackPlugin-is-not-a-constructor.md","raw":"---\ntitle: Webpack CleanWebpackPlugin is not a constructor\ndate: 2019-06-22 15:55:56\ntags: [WebPack, clean-webpack-plugin]\ncategory: [WebPack]\ncover: /image/cover/webpack.png\n---\n\n## 前言\n今天自己跟着webpack官网的demo一步步走下来。发现了这个问题。\n\n![](/image/WebpackCleanWebpackPlugin/20190622155255789.png)\n\n查了一圈。发现了这个博主。nice！\n```\n// webpack版本：4.34.0\n \n// 抛错原写法\nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin(['dist'])\n]\n \n...\n \n// 另一种错误写法\n \nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin(['dist'], {\n        root: path.resolve(__dirname, '../'),   //根目录\n    })\n]\n \n...\n \n// =============================分割线==============================\n \n// 正确写法\n \nconst { CleanWebpackPlugin } = require(\"clean-webpack-plugin\");\n \n...\n \nplugins: [\n    new CleanWebpackPlugin()\n]\n \n```\n\n 现在的版本不用指定文件路径了，直接调用new CleanWebpackPlugin()\n ![在这里插入图片描述](/image/WebpackCleanWebpackPlugin/20190622155123842.png)\n索引：https://blog.csdn.net/qq_36242361/article/details/90709258\n\n","slug":"Webpack-CleanWebpackPlugin-is-not-a-constructor","published":1,"updated":"2021-06-24T14:00:06.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7s000clwrdh53d8rtq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天自己跟着webpack官网的demo一步步走下来。发现了这个问题。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/WebpackCleanWebpackPlugin/20190622155255789.png\"  alt=\"\"></p>\n<p>查了一圈。发现了这个博主。nice！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; webpack版本：4.34.0</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 抛错原写法</span><br><span class=\"line\">const CleanWebpackPlugin &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin([&#39;dist&#39;])</span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 另一种错误写法</span><br><span class=\"line\"> </span><br><span class=\"line\">const CleanWebpackPlugin &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin([&#39;dist&#39;], &#123;</span><br><span class=\"line\">        root: path.resolve(__dirname, &#39;..&#x2F;&#39;),   &#x2F;&#x2F;根目录</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 正确写法</span><br><span class=\"line\"> </span><br><span class=\"line\">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin()</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p> 现在的版本不用指定文件路径了，直接调用new CleanWebpackPlugin()<br> <img src=\"/\" class=\"lazyload\" data-src=\"/image/WebpackCleanWebpackPlugin/20190622155123842.png\"  alt=\"在这里插入图片描述\"><br>索引：<a href=\"https://blog.csdn.net/qq_36242361/article/details/90709258\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36242361/article/details/90709258</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天自己跟着webpack官网的demo一步步走下来。发现了这个问题。</p>\n<p><img src=\"/image/WebpackCleanWebpackPlugin/20190622155255789.png\" alt=\"\"></p>\n<p>查了一圈。发现了这个博主。nice！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; webpack版本：4.34.0</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 抛错原写法</span><br><span class=\"line\">const CleanWebpackPlugin &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin([&#39;dist&#39;])</span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 另一种错误写法</span><br><span class=\"line\"> </span><br><span class=\"line\">const CleanWebpackPlugin &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin([&#39;dist&#39;], &#123;</span><br><span class=\"line\">        root: path.resolve(__dirname, &#39;..&#x2F;&#39;),   &#x2F;&#x2F;根目录</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 正确写法</span><br><span class=\"line\"> </span><br><span class=\"line\">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">...</span><br><span class=\"line\"> </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    new CleanWebpackPlugin()</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p> 现在的版本不用指定文件路径了，直接调用new CleanWebpackPlugin()<br> <img src=\"/image/WebpackCleanWebpackPlugin/20190622155123842.png\" alt=\"在这里插入图片描述\"><br>索引：<a href=\"https://blog.csdn.net/qq_36242361/article/details/90709258\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36242361/article/details/90709258</a></p>\n"},{"title":"JavaScript 浅拷贝 深拷贝 赋值 引用 JS","date":"2019-06-19T02:10:59.000Z","cover":"/image/cover/JavaScript.png","_content":"\n## 前言\n这个问题说严重也不严重，说不小也不小。\n如果你也刚刚好碰到了这个问题。就跟着我一起了解一下吧！\n\n## 基本类型和引用类型\n\n \n\n - **基本类型**\n\n基本类型也称值类型，数值类型。\n包括了\n\n  1. String\n 2. Number\n 3. Boolean\n 4. Null\n 5. Undefined\n 6. Symbol（ES6新增，表示独一无二的一个值。[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)）\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428204522836.png)\n\n基本类型的是放在栈区的，访问的时候也是按值访问，就是正常的理解的赋值。\n\n - **引用类型和浅拷贝**\n\n\n引用类型，顾名思义就是引用来访问的。\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428204904611.png)\n\n在这个例子中，我们操作的是**q**。为什么**w**也改变了呢？\n\n因为**w**不是真的给他赋值了[1, 2]。\n\n而是赋值给了**q**所指向的地址的指针。\n\n有点绕，其实说白了就是 q 是指向地址 A 的。\n\nw = q ，只是把 q 指向 地址 A 的这个指针赋值给了 w 。\n\nw 和 q 都可以操作这个地址的内容。\n\n所以，当我们用 q 来操作这个地址内容的时候，地址内容就变了。当 w 去取值的时候，内容已经变了。\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205243797.png)\n\n\nw 和 q 都可以操作这个地址内容。\n\n那么引用类型有那些呢？\n\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205350562.png)\n\n这样简单的引用赋值也叫做浅拷贝。\n\n可能会带来一些问题，比如:\n\nA和B都是数组；\n\n我只是懒得给B赋值和A一模一样的；\n\n所以我直接B = A；\n\n我在操作完B之后我又想去取值A的值的时候，发现A已经变了。\n\n在react中也有对state浅拷贝判断的（PureComponent）\n\n\n - **深拷贝**\n\n ![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205853748.png)\n\n这个就叫做深拷贝。\n\n将他的内容分解出来进行解析。\n\n但是这样会导致一个问题。\n\n麻烦！\n\n比如\n\nlet A = [ {a: [1, 2]}, {b: [1, 2]} ]。\n\n这个时候要深拷贝给B的话。\n\n要一直结构到很深处。\n\n有几个个办法可以解决。\n\n1.叫做**序列化**\n\n - JSON.stringify()\n\n - JSON.parse()\n\n 但是这样非常浪费资源\n\n2.Object.assign()拷贝\n\n - 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。\n\n 3.使用递归的方式实现深拷贝\n\n```\n //使用递归的方式实现数组、对象的深拷贝\nfunction deepClone1(obj) {\n  //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝\n  var objClone = Array.isArray(obj) ? [] : {};\n  //进行深拷贝的不能为空，并且是对象或者是\n  if (obj && typeof obj === \"object\") {\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (obj[key] && typeof obj[key] === \"object\") {\n          objClone[key] = deepClone1(obj[key]);\n        } else {\n          objClone[key] = obj[key];\n        }\n      }\n    }\n  }\n  return objClone;\n}\n```\n\n5.lodash函数库实现深拷贝\n\nlodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝\n","source":"_posts/JavaScript-浅拷贝-深拷贝-赋值-引用-JS.md","raw":"---\ntitle: JavaScript 浅拷贝 深拷贝 赋值 引用 JS\ndate: 2019-06-19 10:10:59\ntags: [深拷贝, 浅拷贝]\ncategory: [JavaScript]\ncover: /image/cover/JavaScript.png\n---\n\n## 前言\n这个问题说严重也不严重，说不小也不小。\n如果你也刚刚好碰到了这个问题。就跟着我一起了解一下吧！\n\n## 基本类型和引用类型\n\n \n\n - **基本类型**\n\n基本类型也称值类型，数值类型。\n包括了\n\n  1. String\n 2. Number\n 3. Boolean\n 4. Null\n 5. Undefined\n 6. Symbol（ES6新增，表示独一无二的一个值。[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)）\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428204522836.png)\n\n基本类型的是放在栈区的，访问的时候也是按值访问，就是正常的理解的赋值。\n\n - **引用类型和浅拷贝**\n\n\n引用类型，顾名思义就是引用来访问的。\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428204904611.png)\n\n在这个例子中，我们操作的是**q**。为什么**w**也改变了呢？\n\n因为**w**不是真的给他赋值了[1, 2]。\n\n而是赋值给了**q**所指向的地址的指针。\n\n有点绕，其实说白了就是 q 是指向地址 A 的。\n\nw = q ，只是把 q 指向 地址 A 的这个指针赋值给了 w 。\n\nw 和 q 都可以操作这个地址的内容。\n\n所以，当我们用 q 来操作这个地址内容的时候，地址内容就变了。当 w 去取值的时候，内容已经变了。\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205243797.png)\n\n\nw 和 q 都可以操作这个地址内容。\n\n那么引用类型有那些呢？\n\n\n\n![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205350562.png)\n\n这样简单的引用赋值也叫做浅拷贝。\n\n可能会带来一些问题，比如:\n\nA和B都是数组；\n\n我只是懒得给B赋值和A一模一样的；\n\n所以我直接B = A；\n\n我在操作完B之后我又想去取值A的值的时候，发现A已经变了。\n\n在react中也有对state浅拷贝判断的（PureComponent）\n\n\n - **深拷贝**\n\n ![在这里插入图片描述](/image/深拷贝浅拷贝/20190428205853748.png)\n\n这个就叫做深拷贝。\n\n将他的内容分解出来进行解析。\n\n但是这样会导致一个问题。\n\n麻烦！\n\n比如\n\nlet A = [ {a: [1, 2]}, {b: [1, 2]} ]。\n\n这个时候要深拷贝给B的话。\n\n要一直结构到很深处。\n\n有几个个办法可以解决。\n\n1.叫做**序列化**\n\n - JSON.stringify()\n\n - JSON.parse()\n\n 但是这样非常浪费资源\n\n2.Object.assign()拷贝\n\n - 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。\n\n 3.使用递归的方式实现深拷贝\n\n```\n //使用递归的方式实现数组、对象的深拷贝\nfunction deepClone1(obj) {\n  //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝\n  var objClone = Array.isArray(obj) ? [] : {};\n  //进行深拷贝的不能为空，并且是对象或者是\n  if (obj && typeof obj === \"object\") {\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (obj[key] && typeof obj[key] === \"object\") {\n          objClone[key] = deepClone1(obj[key]);\n        } else {\n          objClone[key] = obj[key];\n        }\n      }\n    }\n  }\n  return objClone;\n}\n```\n\n5.lodash函数库实现深拷贝\n\nlodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝\n","slug":"JavaScript-浅拷贝-深拷贝-赋值-引用-JS","published":1,"updated":"2021-06-24T14:00:06.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7u000glwrd6ddk4m07","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个问题说严重也不严重，说不小也不小。<br>如果你也刚刚好碰到了这个问题。就跟着我一起了解一下吧！</p>\n<h2 id=\"基本类型和引用类型\"><a href=\"#基本类型和引用类型\" class=\"headerlink\" title=\"基本类型和引用类型\"></a>基本类型和引用类型</h2><ul>\n<li><strong>基本类型</strong></li>\n</ul>\n<p>基本类型也称值类型，数值类型。<br>包括了</p>\n<ol>\n<li>String<ol start=\"2\">\n<li>Number</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol（ES6新增，表示独一无二的一个值。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">MDN</a>）</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428204522836.png\"  alt=\"在这里插入图片描述\"></p>\n<p>基本类型的是放在栈区的，访问的时候也是按值访问，就是正常的理解的赋值。</p>\n<ul>\n<li><strong>引用类型和浅拷贝</strong></li>\n</ul>\n<p>引用类型，顾名思义就是引用来访问的。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428204904611.png\"  alt=\"在这里插入图片描述\"></p>\n<p>在这个例子中，我们操作的是<strong>q</strong>。为什么<strong>w</strong>也改变了呢？</p>\n<p>因为<strong>w</strong>不是真的给他赋值了[1, 2]。</p>\n<p>而是赋值给了<strong>q</strong>所指向的地址的指针。</p>\n<p>有点绕，其实说白了就是 q 是指向地址 A 的。</p>\n<p>w = q ，只是把 q 指向 地址 A 的这个指针赋值给了 w 。</p>\n<p>w 和 q 都可以操作这个地址的内容。</p>\n<p>所以，当我们用 q 来操作这个地址内容的时候，地址内容就变了。当 w 去取值的时候，内容已经变了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205243797.png\"  alt=\"在这里插入图片描述\"></p>\n<p>w 和 q 都可以操作这个地址内容。</p>\n<p>那么引用类型有那些呢？</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205350562.png\"  alt=\"在这里插入图片描述\"></p>\n<p>这样简单的引用赋值也叫做浅拷贝。</p>\n<p>可能会带来一些问题，比如:</p>\n<p>A和B都是数组；</p>\n<p>我只是懒得给B赋值和A一模一样的；</p>\n<p>所以我直接B = A；</p>\n<p>我在操作完B之后我又想去取值A的值的时候，发现A已经变了。</p>\n<p>在react中也有对state浅拷贝判断的（PureComponent）</p>\n<ul>\n<li><p><strong>深拷贝</strong></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205853748.png\"  alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>这个就叫做深拷贝。</p>\n<p>将他的内容分解出来进行解析。</p>\n<p>但是这样会导致一个问题。</p>\n<p>麻烦！</p>\n<p>比如</p>\n<p>let A = [ {a: [1, 2]}, {b: [1, 2]} ]。</p>\n<p>这个时候要深拷贝给B的话。</p>\n<p>要一直结构到很深处。</p>\n<p>有几个个办法可以解决。</p>\n<p>1.叫做<strong>序列化</strong></p>\n<ul>\n<li><p>JSON.stringify()</p>\n</li>\n<li><p>JSON.parse()</p>\n<p>但是这样非常浪费资源</p>\n</li>\n</ul>\n<p>2.Object.assign()拷贝</p>\n<ul>\n<li>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</li>\n</ul>\n<p> 3.使用递归的方式实现深拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;使用递归的方式实现数组、对象的深拷贝</span><br><span class=\"line\">function deepClone1(obj) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span><br><span class=\"line\">  var objClone &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">  &#x2F;&#x2F;进行深拷贝的不能为空，并且是对象或者是</span><br><span class=\"line\">  if (obj &amp;&amp; typeof obj &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class=\"line\">    for (key in obj) &#123;</span><br><span class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">        if (obj[key] &amp;&amp; typeof obj[key] &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class=\"line\">          objClone[key] &#x3D; deepClone1(obj[key]);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          objClone[key] &#x3D; obj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return objClone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.lodash函数库实现深拷贝</p>\n<p>lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个问题说严重也不严重，说不小也不小。<br>如果你也刚刚好碰到了这个问题。就跟着我一起了解一下吧！</p>\n<h2 id=\"基本类型和引用类型\"><a href=\"#基本类型和引用类型\" class=\"headerlink\" title=\"基本类型和引用类型\"></a>基本类型和引用类型</h2><ul>\n<li><strong>基本类型</strong></li>\n</ul>\n<p>基本类型也称值类型，数值类型。<br>包括了</p>\n<ol>\n<li>String<ol start=\"2\">\n<li>Number</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol（ES6新增，表示独一无二的一个值。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">MDN</a>）</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428204522836.png\" alt=\"在这里插入图片描述\"></p>\n<p>基本类型的是放在栈区的，访问的时候也是按值访问，就是正常的理解的赋值。</p>\n<ul>\n<li><strong>引用类型和浅拷贝</strong></li>\n</ul>\n<p>引用类型，顾名思义就是引用来访问的。</p>\n<p><img src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428204904611.png\" alt=\"在这里插入图片描述\"></p>\n<p>在这个例子中，我们操作的是<strong>q</strong>。为什么<strong>w</strong>也改变了呢？</p>\n<p>因为<strong>w</strong>不是真的给他赋值了[1, 2]。</p>\n<p>而是赋值给了<strong>q</strong>所指向的地址的指针。</p>\n<p>有点绕，其实说白了就是 q 是指向地址 A 的。</p>\n<p>w = q ，只是把 q 指向 地址 A 的这个指针赋值给了 w 。</p>\n<p>w 和 q 都可以操作这个地址的内容。</p>\n<p>所以，当我们用 q 来操作这个地址内容的时候，地址内容就变了。当 w 去取值的时候，内容已经变了。</p>\n<p><img src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205243797.png\" alt=\"在这里插入图片描述\"></p>\n<p>w 和 q 都可以操作这个地址内容。</p>\n<p>那么引用类型有那些呢？</p>\n<p><img src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205350562.png\" alt=\"在这里插入图片描述\"></p>\n<p>这样简单的引用赋值也叫做浅拷贝。</p>\n<p>可能会带来一些问题，比如:</p>\n<p>A和B都是数组；</p>\n<p>我只是懒得给B赋值和A一模一样的；</p>\n<p>所以我直接B = A；</p>\n<p>我在操作完B之后我又想去取值A的值的时候，发现A已经变了。</p>\n<p>在react中也有对state浅拷贝判断的（PureComponent）</p>\n<ul>\n<li><p><strong>深拷贝</strong></p>\n<p><img src=\"/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/20190428205853748.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>这个就叫做深拷贝。</p>\n<p>将他的内容分解出来进行解析。</p>\n<p>但是这样会导致一个问题。</p>\n<p>麻烦！</p>\n<p>比如</p>\n<p>let A = [ {a: [1, 2]}, {b: [1, 2]} ]。</p>\n<p>这个时候要深拷贝给B的话。</p>\n<p>要一直结构到很深处。</p>\n<p>有几个个办法可以解决。</p>\n<p>1.叫做<strong>序列化</strong></p>\n<ul>\n<li><p>JSON.stringify()</p>\n</li>\n<li><p>JSON.parse()</p>\n<p>但是这样非常浪费资源</p>\n</li>\n</ul>\n<p>2.Object.assign()拷贝</p>\n<ul>\n<li>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</li>\n</ul>\n<p> 3.使用递归的方式实现深拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;使用递归的方式实现数组、对象的深拷贝</span><br><span class=\"line\">function deepClone1(obj) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span><br><span class=\"line\">  var objClone &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">  &#x2F;&#x2F;进行深拷贝的不能为空，并且是对象或者是</span><br><span class=\"line\">  if (obj &amp;&amp; typeof obj &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class=\"line\">    for (key in obj) &#123;</span><br><span class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">        if (obj[key] &amp;&amp; typeof obj[key] &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class=\"line\">          objClone[key] &#x3D; deepClone1(obj[key]);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          objClone[key] &#x3D; obj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return objClone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.lodash函数库实现深拷贝</p>\n<p>lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</p>\n"},{"title":"Web前端 学习目录 学习框架 系统性的学习Web前端","date":"2019-06-19T02:28:50.000Z","cover":"/image/cover/web.jpeg","_content":"\n## 前言\n\n\n这个是目前从网上偷来的，自己学习Web前端可能会用得到，特此记录一下\n\n\n> 每个 JavaScript 工程师都应懂的33个概念 @leonardomso\n\nhttps://github.com/stephentian/33-js-concepts\n\n![在这里插入图片描述](/image/Web前端学习路线/20190328205449472.png)\n\n","source":"_posts/Web前端-学习目录-学习框架-系统性的学习Web前端.md","raw":"---\ntitle: Web前端 学习目录 学习框架 系统性的学习Web前端\ndate: 2019-06-19 10:28:50\ntags: [系统性的学习, 学习目录, Web前端, 学习框架]\ncategory: [Web前端]\ncover: /image/cover/web.jpeg\n---\n\n## 前言\n\n\n这个是目前从网上偷来的，自己学习Web前端可能会用得到，特此记录一下\n\n\n> 每个 JavaScript 工程师都应懂的33个概念 @leonardomso\n\nhttps://github.com/stephentian/33-js-concepts\n\n![在这里插入图片描述](/image/Web前端学习路线/20190328205449472.png)\n\n","slug":"Web前端-学习目录-学习框架-系统性的学习Web前端","published":1,"updated":"2021-06-24T14:00:06.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7v000ilwrd3xfv52el","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个是目前从网上偷来的，自己学习Web前端可能会用得到，特此记录一下</p>\n<blockquote>\n<p>每个 JavaScript 工程师都应懂的33个概念 @leonardomso</p>\n</blockquote>\n<p><a href=\"https://github.com/stephentian/33-js-concepts\" target=\"_blank\" rel=\"noopener\">https://github.com/stephentian/33-js-concepts</a></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/Web%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/20190328205449472.png\"  alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个是目前从网上偷来的，自己学习Web前端可能会用得到，特此记录一下</p>\n<blockquote>\n<p>每个 JavaScript 工程师都应懂的33个概念 @leonardomso</p>\n</blockquote>\n<p><a href=\"https://github.com/stephentian/33-js-concepts\" target=\"_blank\" rel=\"noopener\">https://github.com/stephentian/33-js-concepts</a></p>\n<p><img src=\"/image/Web%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/20190328205449472.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"Ant Design Form 组件总结 结合Modal 自定义Modal的实现 （Upload Input Select DatePicker Cascader）","date":"2019-06-19T02:24:07.000Z","cover":"/image/cover/ANTD.png","_content":"\n## 起源\n\n最近在项目中发现要写多个弹框（用于查看、编辑、新建XX信息），如下图。\n\n![测试图片](/image/AntDesignForm总结/modal.png)\n\n像这样花里胡哨的弹框在一个大型的中台管理系统中，可能要写上好几遍的Modal\n但是其实他们大同小异。\n\n首先，他们的title是固定的（增、改、查）\n\n底下的内容也是固定的，无非就是Upload Input Select DatePicker Cascader\n\n（写不了<>。其实应该是ant design 的组件）\n\n\n## 改进\n\n所以我想自己写一个ModalView的组件。只需要传入这上面的数据类型，title之类的数据就可以完成渲染。\n\n如下，这个是我项目中的一个例子\n\n\n```\n<ModalView \n          onOk={this.edit}     // 点击Modal确定时的回调\n          onCancel={this.hideModal}   // 点击Modal取消，或者点击mask时的回调\n          show={visible}        // Modal的显隐\n          category={category}      // Modal的title，通过category来判断（目前只有查看、编辑、新增）\n          data={fStaffManage}     // 自定义Modal的核心，整个Modal的渲染\n          showData={showData}    // 点击查看和编辑时的默认数据\n/>\n```\n\n\n接下来是fStaffManage的数据结构\n\n\n```\nexport const fStaffManage = [\n  {\n    label: '员工编号（自动生成）',\n    key: 'id',\n    type: 'input',\n    Message: '请输入员工编号',\n    disabled: true,\n  },\n  {\n    label: '门店',\n    key: 'storeNo',\n    type: 'select',\n    Message: '请选择门店',\n    option: [],\n  },\n  {\n    label: '员工姓名',\n    key: 'userName',\n    type: 'input',\n    Message: '请输入员工姓名',\n  },\n  {\n    label: '角色类型',\n    key: 'roleCodes',\n    type: 'select',\n    Message: '请选择角色类型',\n    option: [{ severKey: '店员', showValue: '店员' }, { severKey: '店长', showValue: '店长' }],\n  },\n  {\n    label: '联系电话',\n    key: 'mobile',\n    type: 'input',\n    Message: '请输入联系电话',\n    pattern: '^1[34578]\\\\d{9}$',\n  },\n  {\n    label: '测试上传图片',\n    key: 'testImgUpload',\n    type: 'imageUpload',\n    Message: '请上传图片',\n  },\n];\n```\n**Message**  是用于Form表单的提示用于以及placeholder\n\n**label**   是用于Form的label\n\n**key**   是用于map循环时的key（防止warning和提升效率）\n\n**type**   是用于显示那种类型的组件\n\n**pattern**   是用于Form表单检测的正则表达式\n\n\n```\n/*\n * @Author: Derrick\n * @Date: 2019-04-04 16:53:05\n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 15:48:04\n */\nimport React, { PureComponent } from 'react';\nimport { Modal, Form, Button, Table, Upload, message, Row, Select } from 'antd';\nimport { connect } from 'dva';\nimport PropTypes from 'prop-types';\nimport componentAuth from '@/common/ComponentAuth';\nimport FormSelect from '@/common/FormItems/FormSelect';\nimport FormInput from '@/common/FormItems/FormInput';\nimport FormDataPicker from '@/common/FormItems/FormDataPicker';\nimport FormCascader from '@/common/FormItems/FormCascader';\nimport FormTextArea from '@/common/FormItems/FormTextArea';\nimport FormImageUpload from '@/common/FormItems/FormImageUpload';\nimport { HEADER_BASE, SEVER_URL_BASE } from '@/utils/constant';\nimport Col from 'antd/es/col';\n\nconst formItemLayout = {\n  labelCol: {\n    xs: { span: 24 },\n    sm: { span: 5 },\n  },\n  wrapperCol: {\n    xs: { span: 24 },\n    sm: { span: 16 },\n  },\n};\nconst { Item } = Form;\nconst { Option } = Select;\n\n@connect(({ mIdentifyCenter }) => ({\n  mIdentifyCenter\n}))\nclass ModalView extends PureComponent {\n  state = {\n    data: [],\n    storeId: '',\n  };\n\n  // 返回title\n  caseCategory = category => {\n    switch (category) {\n      case 'check':\n        return { title: '查看' };\n      case 'import':\n        return { title: '导入', import: true };\n      case 'create':\n        return { title: '新增' };\n      case 'edit':\n        return { title: '编辑' };\n      default:\n        return { title: '查看' };\n    }\n  };\n\n  showLabel = (type, label) => {\n    const { category } = this.props;\n\n    if (category === 'search') {\n      if (type !== 'datePicker') {\n        return undefined;\n      }\n      return label;\n    }\n    return label;\n  };\n\n  showRequire = disabled => {\n    const { category } = this.props;\n    if (category === 'search') {\n      return false;\n    }\n    if (disabled) {\n      return false;\n    }\n    return true;\n  };\n\n  form = () => {\n    const {\n      form: { getFieldDecorator },\n      data,\n      showData,\n      category,\n    } = this.props;\n\n    let ShowType;\n\n    return data.map(value => {\n      const { label, key, type, Message, option, disabled, pattern } = value;\n      if (!value) {\n        return null;\n      }\n      switch (type) {\n        case 'input':\n          ShowType = FormInput;\n          break;\n        case 'select':\n          ShowType = FormSelect;\n          break;\n        case 'datePicker':\n          ShowType = FormDataPicker;\n          break;\n        case 'cascader':\n          ShowType = FormCascader;\n          showData.region = [showData.provinceId, showData.cityId, showData.countyId];\n          break;\n        case 'textArea':\n          ShowType = FormTextArea;\n          break;\n        case 'imageUpload':\n          ShowType = FormImageUpload;\n          break;\n        default:\n          ShowType = null;\n      }\n      return (\n        <Item label={this.showLabel(type, label)} key={key}>\n          {getFieldDecorator(key, {\n            rules: [\n              {\n                required: this.showRequire(disabled),\n                message: Message,\n                pattern: pattern || undefined,\n                type: type === 'cascader' ? 'array' : 'string',\n              },\n            ],\n            initialValue: showData[key] ? showData[key] : undefined,\n          })(\n            <ShowType\n              option={option}\n              message={Message}\n              disabled={!!(disabled || category === 'check')}\n            />\n          )}\n        </Item>\n      );\n    });\n  };\n\n  checkOk = () => {\n    const { onOk, form } = this.props;\n    form.validateFields((err, fieldsValue) => {\n      if (!err) {\n        onOk(fieldsValue);\n      }\n    });\n  };\n  \n  closeModal = () => {\n    const { onCancel, form: { resetFields } } = this.props;\n    resetFields();\n    onCancel();\n  }\n\n  render() {\n    const { data } = this.state;\n    const { show, category = '', importColums, downloadUrl } = this.props;\n    const modalData = this.caseCategory(category);\n    return (\n      <Modal\n        visible={show}\n        onCancel={this.closeModal}\n        onOk={category === 'import' ? this.importOk : this.checkOk}\n        title={modalData.title}\n        width=\"70%\"\n        footer={modalData.title === '查看' ? null : undefined}\n      >\n          <Form style={{ paddingTop: '20px' }} {...formItemLayout}>\n            {this.form()}\n          </Form>\n      </Modal>\n    );\n  }\n}\n\nModalView.propTypes = {\n  onOk: PropTypes.func.isRequired, // 弹框点击确定\n  onCancel: PropTypes.func.isRequired, // 隐藏弹框\n  show: PropTypes.bool, // 是否显示弹窗\n  category: PropTypes.string, // 弹框的类型（title显示\n  data: PropTypes.arrayOf(PropTypes.object).isRequired, // 数据类型; 位置:'@/common/constant/sormView.js' 记得写注释; 格式: `s${文件名}`\n  showData: PropTypes.object, // 查看或者编辑时的默认数据\n  importCallBack: PropTypes.func, // 导入之后，点击确定的回调函数\n  importColums: PropTypes.array, // 导入时候显示表格的表头\n  downloadUrl: PropTypes.string, // 下载的模板的文件名\n};\n\nModalView.defaultProps = {\n  show: false,\n  category: 'check',\n  showData: {},\n  importCallBack: () => {},\n  importColums: [],\n  downloadUrl: '',\n};\n\nexport default Form.create()(ModalView);\n```\n\n - **FormCascader**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-11 09:57:54 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 16:52:57\n */\nimport React, { Component } from 'react';\nimport { Cascader } from 'antd';\nimport PropTypes from 'prop-types';\nimport regionData from '@/constant/regionData'\n\nclass FormCascader extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {value, disabled, message} = this.props;\n    return (\n      <Cascader placeholder={message} options={regionData} disabled={disabled} value={value} onChange={this.change} />\n    );\n  }\n}\n\nFormCascader.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormCascader.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormCascader;\n```\n\n - **FormDataPicker**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:57:08 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-15 14:28:40\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { DatePicker } from 'antd';\n\nclass FormDataPicker extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props\n    onChange(e)\n  }\n\n  render() {\n    const {value, disabled} = this.props;\n    return (\n      <DatePicker disabled={disabled} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormDataPicker.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n}\n\nFormDataPicker.defalutProps = {\n  disabled: false,\n}\n\nexport default FormDataPicker;\n```\n\n - **FormImageUpload**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-26 14:20:20 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 18:11:44\n */\nimport React, { PureComponent } from 'react';\nimport { Upload, Icon, message } from 'antd';\nimport { PICTURE_UPLOAD, HEADER_BASE } from '@/utils/constant';\n\nclass FormImageUpload extends PureComponent {\n\n  state = {\n    loading: false,\n  };\n\n  uploadButton = () => {\n    const { loading } = this.state;\n    return (\n      <div>\n        <Icon type={loading ? 'loading' : 'plus'} />\n        <div className=\"ant-upload-text\">Upload</div>\n      </div>\n    )\n  }\n\n  handleChange = (info) => {\n    if (info.file.status === 'uploading') {\n      this.setState({ loading: true });\n      return;\n    }\n    if (info.file.status === 'done') {\n      const {onChange} = this.props\n      this.setState({imageUrl: info.file.response.data[0], loading: false,})\n      onChange(info.file.response.data[0])\n    }\n  }\n\n  beforeUpload = (file) => {\n    const isJPG = file.type === 'image/jpeg';\n    if (!isJPG) {\n      message.error('只能上传JPG的图片!');\n    }\n    const isLt2M = file.size / 1024 / 1024 < 2;\n    if (!isLt2M) {\n      message.error('图片大小不能大于2MB!');\n    }\n    return isJPG && isLt2M;\n  }\n\n  upLoadProps = () => {\n    HEADER_BASE.user_id = window.sessionStorage.getItem('userId');\n    HEADER_BASE.token_id = window.sessionStorage.getItem('tokenId');\n    const props = {\n      name: 'file',\n      action: PICTURE_UPLOAD,\n      headers: HEADER_BASE,\n      onChange: this.handleChange,\n      showUploadList: false,\n      beforeUpload: this.beforeUpload,\n    };\n    return props;\n  };\n\n  render() {\n    \n    const { imageUrl } = this.state;\n\n    return (\n      <Upload\n        listType=\"picture-card\"\n        {...this.upLoadProps()}\n\n      >\n        {imageUrl ? <img src={imageUrl} alt=\"avatar\" /> : this.uploadButton()}\n      </Upload>\n    )\n  }\n}\n\nexport default FormImageUpload;\n```\n\n - **FormInput**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:57:08 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-15 14:46:23\n */\nimport React, { Component } from 'react';\nimport { Input } from 'antd';\nimport PropTypes from 'prop-types';\n\nclass FormInput extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <Input disabled={disabled} placeholder={message} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormInput.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormInput.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormInput;\n```\n\n\n - **FormSelect**\n\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:13:58 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 15:59:22\n */\nimport React, { Component } from 'react';\nimport { Select } from 'antd';\nimport PropTypes, { object } from 'prop-types';\n\nconst { Option } = Select;\nclass FormSelect extends Component {\n\n  option = () => {\n    const {option = []} = this.props;\n    return option.map((v) => {\n      const {showValue, severKey} = v;\n      return <Option value={severKey} key={severKey}>{showValue}</Option>\n    })\n  }\n\n  selectCurrency = (e) => {\n    const {onChange} = this.props\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <Select disabled={disabled} value={value} placeholder={message} style={{width: '170px'}} onSelect={this.selectCurrency}>\n        {this.option()}\n      </Select>    \n      );\n  }\n}\n\nFormSelect.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n  option: PropTypes.arrayOf(object), // 选择框的选项\n}\n\nFormSelect.defalutProps = {\n  disabled: false,\n  message: '',\n  option: [],\n}\n\nexport default FormSelect;\n```\n\n - **FormTextArea**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-23 10:20:36 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-23 10:21:33\n */\nimport React, { Component } from 'react';\nimport { Input } from 'antd';\nimport PropTypes from 'prop-types';\n\nconst { TextArea } = Input;\nclass FormTextArea extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <TextArea rows={4} disabled={disabled} placeholder={message} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormTextArea.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormTextArea.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormTextArea;\n```\n\n\n## 核心\n\n\n```\nconst {onChange} = this.props;\nonChange(XX)\n```\n\n\n这个onChange是可以直接改变FormItem的值。\n\n接下来可以加入您自己喜欢的组件，都是大同小异，基本上都离不开这个onChange。\n\n\n以上就是本人最近封装的一个组件，我感觉很好用所以想分享出来。\n","source":"_posts/ant-design-Form-组件总结-结合Modal-自定义Modal的实现-（Upload-Input-Select-DatePicker-Cascader）.md","raw":"---\ntitle: >-\n  Ant Design Form 组件总结 结合Modal 自定义Modal的实现 （Upload Input Select DatePicker\n  Cascader）\ndate: 2019-06-19 10:24:07\ntags: [Ant-Design-Form, Ant-Design组件合集]\ncategory: [Ant-Design, JavaScript]\ncover: /image/cover/ANTD.png\n---\n\n## 起源\n\n最近在项目中发现要写多个弹框（用于查看、编辑、新建XX信息），如下图。\n\n![测试图片](/image/AntDesignForm总结/modal.png)\n\n像这样花里胡哨的弹框在一个大型的中台管理系统中，可能要写上好几遍的Modal\n但是其实他们大同小异。\n\n首先，他们的title是固定的（增、改、查）\n\n底下的内容也是固定的，无非就是Upload Input Select DatePicker Cascader\n\n（写不了<>。其实应该是ant design 的组件）\n\n\n## 改进\n\n所以我想自己写一个ModalView的组件。只需要传入这上面的数据类型，title之类的数据就可以完成渲染。\n\n如下，这个是我项目中的一个例子\n\n\n```\n<ModalView \n          onOk={this.edit}     // 点击Modal确定时的回调\n          onCancel={this.hideModal}   // 点击Modal取消，或者点击mask时的回调\n          show={visible}        // Modal的显隐\n          category={category}      // Modal的title，通过category来判断（目前只有查看、编辑、新增）\n          data={fStaffManage}     // 自定义Modal的核心，整个Modal的渲染\n          showData={showData}    // 点击查看和编辑时的默认数据\n/>\n```\n\n\n接下来是fStaffManage的数据结构\n\n\n```\nexport const fStaffManage = [\n  {\n    label: '员工编号（自动生成）',\n    key: 'id',\n    type: 'input',\n    Message: '请输入员工编号',\n    disabled: true,\n  },\n  {\n    label: '门店',\n    key: 'storeNo',\n    type: 'select',\n    Message: '请选择门店',\n    option: [],\n  },\n  {\n    label: '员工姓名',\n    key: 'userName',\n    type: 'input',\n    Message: '请输入员工姓名',\n  },\n  {\n    label: '角色类型',\n    key: 'roleCodes',\n    type: 'select',\n    Message: '请选择角色类型',\n    option: [{ severKey: '店员', showValue: '店员' }, { severKey: '店长', showValue: '店长' }],\n  },\n  {\n    label: '联系电话',\n    key: 'mobile',\n    type: 'input',\n    Message: '请输入联系电话',\n    pattern: '^1[34578]\\\\d{9}$',\n  },\n  {\n    label: '测试上传图片',\n    key: 'testImgUpload',\n    type: 'imageUpload',\n    Message: '请上传图片',\n  },\n];\n```\n**Message**  是用于Form表单的提示用于以及placeholder\n\n**label**   是用于Form的label\n\n**key**   是用于map循环时的key（防止warning和提升效率）\n\n**type**   是用于显示那种类型的组件\n\n**pattern**   是用于Form表单检测的正则表达式\n\n\n```\n/*\n * @Author: Derrick\n * @Date: 2019-04-04 16:53:05\n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 15:48:04\n */\nimport React, { PureComponent } from 'react';\nimport { Modal, Form, Button, Table, Upload, message, Row, Select } from 'antd';\nimport { connect } from 'dva';\nimport PropTypes from 'prop-types';\nimport componentAuth from '@/common/ComponentAuth';\nimport FormSelect from '@/common/FormItems/FormSelect';\nimport FormInput from '@/common/FormItems/FormInput';\nimport FormDataPicker from '@/common/FormItems/FormDataPicker';\nimport FormCascader from '@/common/FormItems/FormCascader';\nimport FormTextArea from '@/common/FormItems/FormTextArea';\nimport FormImageUpload from '@/common/FormItems/FormImageUpload';\nimport { HEADER_BASE, SEVER_URL_BASE } from '@/utils/constant';\nimport Col from 'antd/es/col';\n\nconst formItemLayout = {\n  labelCol: {\n    xs: { span: 24 },\n    sm: { span: 5 },\n  },\n  wrapperCol: {\n    xs: { span: 24 },\n    sm: { span: 16 },\n  },\n};\nconst { Item } = Form;\nconst { Option } = Select;\n\n@connect(({ mIdentifyCenter }) => ({\n  mIdentifyCenter\n}))\nclass ModalView extends PureComponent {\n  state = {\n    data: [],\n    storeId: '',\n  };\n\n  // 返回title\n  caseCategory = category => {\n    switch (category) {\n      case 'check':\n        return { title: '查看' };\n      case 'import':\n        return { title: '导入', import: true };\n      case 'create':\n        return { title: '新增' };\n      case 'edit':\n        return { title: '编辑' };\n      default:\n        return { title: '查看' };\n    }\n  };\n\n  showLabel = (type, label) => {\n    const { category } = this.props;\n\n    if (category === 'search') {\n      if (type !== 'datePicker') {\n        return undefined;\n      }\n      return label;\n    }\n    return label;\n  };\n\n  showRequire = disabled => {\n    const { category } = this.props;\n    if (category === 'search') {\n      return false;\n    }\n    if (disabled) {\n      return false;\n    }\n    return true;\n  };\n\n  form = () => {\n    const {\n      form: { getFieldDecorator },\n      data,\n      showData,\n      category,\n    } = this.props;\n\n    let ShowType;\n\n    return data.map(value => {\n      const { label, key, type, Message, option, disabled, pattern } = value;\n      if (!value) {\n        return null;\n      }\n      switch (type) {\n        case 'input':\n          ShowType = FormInput;\n          break;\n        case 'select':\n          ShowType = FormSelect;\n          break;\n        case 'datePicker':\n          ShowType = FormDataPicker;\n          break;\n        case 'cascader':\n          ShowType = FormCascader;\n          showData.region = [showData.provinceId, showData.cityId, showData.countyId];\n          break;\n        case 'textArea':\n          ShowType = FormTextArea;\n          break;\n        case 'imageUpload':\n          ShowType = FormImageUpload;\n          break;\n        default:\n          ShowType = null;\n      }\n      return (\n        <Item label={this.showLabel(type, label)} key={key}>\n          {getFieldDecorator(key, {\n            rules: [\n              {\n                required: this.showRequire(disabled),\n                message: Message,\n                pattern: pattern || undefined,\n                type: type === 'cascader' ? 'array' : 'string',\n              },\n            ],\n            initialValue: showData[key] ? showData[key] : undefined,\n          })(\n            <ShowType\n              option={option}\n              message={Message}\n              disabled={!!(disabled || category === 'check')}\n            />\n          )}\n        </Item>\n      );\n    });\n  };\n\n  checkOk = () => {\n    const { onOk, form } = this.props;\n    form.validateFields((err, fieldsValue) => {\n      if (!err) {\n        onOk(fieldsValue);\n      }\n    });\n  };\n  \n  closeModal = () => {\n    const { onCancel, form: { resetFields } } = this.props;\n    resetFields();\n    onCancel();\n  }\n\n  render() {\n    const { data } = this.state;\n    const { show, category = '', importColums, downloadUrl } = this.props;\n    const modalData = this.caseCategory(category);\n    return (\n      <Modal\n        visible={show}\n        onCancel={this.closeModal}\n        onOk={category === 'import' ? this.importOk : this.checkOk}\n        title={modalData.title}\n        width=\"70%\"\n        footer={modalData.title === '查看' ? null : undefined}\n      >\n          <Form style={{ paddingTop: '20px' }} {...formItemLayout}>\n            {this.form()}\n          </Form>\n      </Modal>\n    );\n  }\n}\n\nModalView.propTypes = {\n  onOk: PropTypes.func.isRequired, // 弹框点击确定\n  onCancel: PropTypes.func.isRequired, // 隐藏弹框\n  show: PropTypes.bool, // 是否显示弹窗\n  category: PropTypes.string, // 弹框的类型（title显示\n  data: PropTypes.arrayOf(PropTypes.object).isRequired, // 数据类型; 位置:'@/common/constant/sormView.js' 记得写注释; 格式: `s${文件名}`\n  showData: PropTypes.object, // 查看或者编辑时的默认数据\n  importCallBack: PropTypes.func, // 导入之后，点击确定的回调函数\n  importColums: PropTypes.array, // 导入时候显示表格的表头\n  downloadUrl: PropTypes.string, // 下载的模板的文件名\n};\n\nModalView.defaultProps = {\n  show: false,\n  category: 'check',\n  showData: {},\n  importCallBack: () => {},\n  importColums: [],\n  downloadUrl: '',\n};\n\nexport default Form.create()(ModalView);\n```\n\n - **FormCascader**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-11 09:57:54 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 16:52:57\n */\nimport React, { Component } from 'react';\nimport { Cascader } from 'antd';\nimport PropTypes from 'prop-types';\nimport regionData from '@/constant/regionData'\n\nclass FormCascader extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {value, disabled, message} = this.props;\n    return (\n      <Cascader placeholder={message} options={regionData} disabled={disabled} value={value} onChange={this.change} />\n    );\n  }\n}\n\nFormCascader.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormCascader.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormCascader;\n```\n\n - **FormDataPicker**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:57:08 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-15 14:28:40\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { DatePicker } from 'antd';\n\nclass FormDataPicker extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props\n    onChange(e)\n  }\n\n  render() {\n    const {value, disabled} = this.props;\n    return (\n      <DatePicker disabled={disabled} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormDataPicker.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n}\n\nFormDataPicker.defalutProps = {\n  disabled: false,\n}\n\nexport default FormDataPicker;\n```\n\n - **FormImageUpload**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-26 14:20:20 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 18:11:44\n */\nimport React, { PureComponent } from 'react';\nimport { Upload, Icon, message } from 'antd';\nimport { PICTURE_UPLOAD, HEADER_BASE } from '@/utils/constant';\n\nclass FormImageUpload extends PureComponent {\n\n  state = {\n    loading: false,\n  };\n\n  uploadButton = () => {\n    const { loading } = this.state;\n    return (\n      <div>\n        <Icon type={loading ? 'loading' : 'plus'} />\n        <div className=\"ant-upload-text\">Upload</div>\n      </div>\n    )\n  }\n\n  handleChange = (info) => {\n    if (info.file.status === 'uploading') {\n      this.setState({ loading: true });\n      return;\n    }\n    if (info.file.status === 'done') {\n      const {onChange} = this.props\n      this.setState({imageUrl: info.file.response.data[0], loading: false,})\n      onChange(info.file.response.data[0])\n    }\n  }\n\n  beforeUpload = (file) => {\n    const isJPG = file.type === 'image/jpeg';\n    if (!isJPG) {\n      message.error('只能上传JPG的图片!');\n    }\n    const isLt2M = file.size / 1024 / 1024 < 2;\n    if (!isLt2M) {\n      message.error('图片大小不能大于2MB!');\n    }\n    return isJPG && isLt2M;\n  }\n\n  upLoadProps = () => {\n    HEADER_BASE.user_id = window.sessionStorage.getItem('userId');\n    HEADER_BASE.token_id = window.sessionStorage.getItem('tokenId');\n    const props = {\n      name: 'file',\n      action: PICTURE_UPLOAD,\n      headers: HEADER_BASE,\n      onChange: this.handleChange,\n      showUploadList: false,\n      beforeUpload: this.beforeUpload,\n    };\n    return props;\n  };\n\n  render() {\n    \n    const { imageUrl } = this.state;\n\n    return (\n      <Upload\n        listType=\"picture-card\"\n        {...this.upLoadProps()}\n\n      >\n        {imageUrl ? <img src={imageUrl} alt=\"avatar\" /> : this.uploadButton()}\n      </Upload>\n    )\n  }\n}\n\nexport default FormImageUpload;\n```\n\n - **FormInput**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:57:08 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-15 14:46:23\n */\nimport React, { Component } from 'react';\nimport { Input } from 'antd';\nimport PropTypes from 'prop-types';\n\nclass FormInput extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <Input disabled={disabled} placeholder={message} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormInput.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormInput.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormInput;\n```\n\n\n - **FormSelect**\n\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-10 10:13:58 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-28 15:59:22\n */\nimport React, { Component } from 'react';\nimport { Select } from 'antd';\nimport PropTypes, { object } from 'prop-types';\n\nconst { Option } = Select;\nclass FormSelect extends Component {\n\n  option = () => {\n    const {option = []} = this.props;\n    return option.map((v) => {\n      const {showValue, severKey} = v;\n      return <Option value={severKey} key={severKey}>{showValue}</Option>\n    })\n  }\n\n  selectCurrency = (e) => {\n    const {onChange} = this.props\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <Select disabled={disabled} value={value} placeholder={message} style={{width: '170px'}} onSelect={this.selectCurrency}>\n        {this.option()}\n      </Select>    \n      );\n  }\n}\n\nFormSelect.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n  option: PropTypes.arrayOf(object), // 选择框的选项\n}\n\nFormSelect.defalutProps = {\n  disabled: false,\n  message: '',\n  option: [],\n}\n\nexport default FormSelect;\n```\n\n - **FormTextArea**\n\n```\n/*\n * @Author: Derrick \n * @Date: 2019-04-23 10:20:36 \n * @Last Modified by: Derrick\n * @Last Modified time: 2019-04-23 10:21:33\n */\nimport React, { Component } from 'react';\nimport { Input } from 'antd';\nimport PropTypes from 'prop-types';\n\nconst { TextArea } = Input;\nclass FormTextArea extends Component {\n\n  change = (e) => {\n    const {onChange} = this.props;\n    onChange(e)\n  }\n\n  render() {\n    const {message, value, disabled} = this.props;\n    return (\n      <TextArea rows={4} disabled={disabled} placeholder={message} value={value} onChange={this.change} />\n      );\n  }\n}\n\nFormTextArea.propsType = {\n  disabled: PropTypes.bool, // 是否不可选\n  message: PropTypes.string, // 默认文字（placeholder\n}\n\nFormTextArea.defalutProps = {\n  disabled: false,\n  message: '',\n}\n\nexport default FormTextArea;\n```\n\n\n## 核心\n\n\n```\nconst {onChange} = this.props;\nonChange(XX)\n```\n\n\n这个onChange是可以直接改变FormItem的值。\n\n接下来可以加入您自己喜欢的组件，都是大同小异，基本上都离不开这个onChange。\n\n\n以上就是本人最近封装的一个组件，我感觉很好用所以想分享出来。\n","slug":"ant-design-Form-组件总结-结合Modal-自定义Modal的实现-（Upload-Input-Select-DatePicker-Cascader）","published":1,"updated":"2021-06-24T14:00:06.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7w000nlwrd3s5pdwt1","content":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>最近在项目中发现要写多个弹框（用于查看、编辑、新建XX信息），如下图。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignForm%E6%80%BB%E7%BB%93/modal.png\"  alt=\"测试图片\"></p>\n<p>像这样花里胡哨的弹框在一个大型的中台管理系统中，可能要写上好几遍的Modal<br>但是其实他们大同小异。</p>\n<p>首先，他们的title是固定的（增、改、查）</p>\n<p>底下的内容也是固定的，无非就是Upload Input Select DatePicker Cascader</p>\n<p>（写不了&lt;&gt;。其实应该是ant design 的组件）</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>所以我想自己写一个ModalView的组件。只需要传入这上面的数据类型，title之类的数据就可以完成渲染。</p>\n<p>如下，这个是我项目中的一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ModalView </span><br><span class=\"line\">          onOk&#x3D;&#123;this.edit&#125;     &#x2F;&#x2F; 点击Modal确定时的回调</span><br><span class=\"line\">          onCancel&#x3D;&#123;this.hideModal&#125;   &#x2F;&#x2F; 点击Modal取消，或者点击mask时的回调</span><br><span class=\"line\">          show&#x3D;&#123;visible&#125;        &#x2F;&#x2F; Modal的显隐</span><br><span class=\"line\">          category&#x3D;&#123;category&#125;      &#x2F;&#x2F; Modal的title，通过category来判断（目前只有查看、编辑、新增）</span><br><span class=\"line\">          data&#x3D;&#123;fStaffManage&#125;     &#x2F;&#x2F; 自定义Modal的核心，整个Modal的渲染</span><br><span class=\"line\">          showData&#x3D;&#123;showData&#125;    &#x2F;&#x2F; 点击查看和编辑时的默认数据</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来是fStaffManage的数据结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const fStaffManage &#x3D; [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;员工编号（自动生成）&#39;,</span><br><span class=\"line\">    key: &#39;id&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入员工编号&#39;,</span><br><span class=\"line\">    disabled: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;门店&#39;,</span><br><span class=\"line\">    key: &#39;storeNo&#39;,</span><br><span class=\"line\">    type: &#39;select&#39;,</span><br><span class=\"line\">    Message: &#39;请选择门店&#39;,</span><br><span class=\"line\">    option: [],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;员工姓名&#39;,</span><br><span class=\"line\">    key: &#39;userName&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入员工姓名&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;角色类型&#39;,</span><br><span class=\"line\">    key: &#39;roleCodes&#39;,</span><br><span class=\"line\">    type: &#39;select&#39;,</span><br><span class=\"line\">    Message: &#39;请选择角色类型&#39;,</span><br><span class=\"line\">    option: [&#123; severKey: &#39;店员&#39;, showValue: &#39;店员&#39; &#125;, &#123; severKey: &#39;店长&#39;, showValue: &#39;店长&#39; &#125;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;联系电话&#39;,</span><br><span class=\"line\">    key: &#39;mobile&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入联系电话&#39;,</span><br><span class=\"line\">    pattern: &#39;^1[34578]\\\\d&#123;9&#125;$&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;测试上传图片&#39;,</span><br><span class=\"line\">    key: &#39;testImgUpload&#39;,</span><br><span class=\"line\">    type: &#39;imageUpload&#39;,</span><br><span class=\"line\">    Message: &#39;请上传图片&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p><strong>Message</strong>  是用于Form表单的提示用于以及placeholder</p>\n<p><strong>label</strong>   是用于Form的label</p>\n<p><strong>key</strong>   是用于map循环时的key（防止warning和提升效率）</p>\n<p><strong>type</strong>   是用于显示那种类型的组件</p>\n<p><strong>pattern</strong>   是用于Form表单检测的正则表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick</span><br><span class=\"line\"> * @Date: 2019-04-04 16:53:05</span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 15:48:04</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Modal, Form, Button, Table, Upload, message, Row, Select &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import &#123; connect &#125; from &#39;dva&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import componentAuth from &#39;@&#x2F;common&#x2F;ComponentAuth&#39;;</span><br><span class=\"line\">import FormSelect from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormSelect&#39;;</span><br><span class=\"line\">import FormInput from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormInput&#39;;</span><br><span class=\"line\">import FormDataPicker from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormDataPicker&#39;;</span><br><span class=\"line\">import FormCascader from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormCascader&#39;;</span><br><span class=\"line\">import FormTextArea from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormTextArea&#39;;</span><br><span class=\"line\">import FormImageUpload from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormImageUpload&#39;;</span><br><span class=\"line\">import &#123; HEADER_BASE, SEVER_URL_BASE &#125; from &#39;@&#x2F;utils&#x2F;constant&#39;;</span><br><span class=\"line\">import Col from &#39;antd&#x2F;es&#x2F;col&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const formItemLayout &#x3D; &#123;</span><br><span class=\"line\">  labelCol: &#123;</span><br><span class=\"line\">    xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">    sm: &#123; span: 5 &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  wrapperCol: &#123;</span><br><span class=\"line\">    xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">    sm: &#123; span: 16 &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const &#123; Item &#125; &#x3D; Form;</span><br><span class=\"line\">const &#123; Option &#125; &#x3D; Select;</span><br><span class=\"line\"></span><br><span class=\"line\">@connect((&#123; mIdentifyCenter &#125;) &#x3D;&gt; (&#123;</span><br><span class=\"line\">  mIdentifyCenter</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\">class ModalView extends PureComponent &#123;</span><br><span class=\"line\">  state &#x3D; &#123;</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    storeId: &#39;&#39;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 返回title</span><br><span class=\"line\">  caseCategory &#x3D; category &#x3D;&gt; &#123;</span><br><span class=\"line\">    switch (category) &#123;</span><br><span class=\"line\">      case &#39;check&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;查看&#39; &#125;;</span><br><span class=\"line\">      case &#39;import&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;导入&#39;, import: true &#125;;</span><br><span class=\"line\">      case &#39;create&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;新增&#39; &#125;;</span><br><span class=\"line\">      case &#39;edit&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;编辑&#39; &#125;;</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        return &#123; title: &#39;查看&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLabel &#x3D; (type, label) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; category &#125; &#x3D; this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (category &#x3D;&#x3D;&#x3D; &#39;search&#39;) &#123;</span><br><span class=\"line\">      if (type !&#x3D;&#x3D; &#39;datePicker&#39;) &#123;</span><br><span class=\"line\">        return undefined;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return label;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return label;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  showRequire &#x3D; disabled &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; category &#125; &#x3D; this.props;</span><br><span class=\"line\">    if (category &#x3D;&#x3D;&#x3D; &#39;search&#39;) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (disabled) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  form &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      form: &#123; getFieldDecorator &#125;,</span><br><span class=\"line\">      data,</span><br><span class=\"line\">      showData,</span><br><span class=\"line\">      category,</span><br><span class=\"line\">    &#125; &#x3D; this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    let ShowType;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data.map(value &#x3D;&gt; &#123;</span><br><span class=\"line\">      const &#123; label, key, type, Message, option, disabled, pattern &#125; &#x3D; value;</span><br><span class=\"line\">      if (!value) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      switch (type) &#123;</span><br><span class=\"line\">        case &#39;input&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormInput;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;select&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormSelect;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;datePicker&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormDataPicker;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;cascader&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormCascader;</span><br><span class=\"line\">          showData.region &#x3D; [showData.provinceId, showData.cityId, showData.countyId];</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;textArea&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormTextArea;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;imageUpload&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormImageUpload;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">          ShowType &#x3D; null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        &lt;Item label&#x3D;&#123;this.showLabel(type, label)&#125; key&#x3D;&#123;key&#125;&gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(key, &#123;</span><br><span class=\"line\">            rules: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                required: this.showRequire(disabled),</span><br><span class=\"line\">                message: Message,</span><br><span class=\"line\">                pattern: pattern || undefined,</span><br><span class=\"line\">                type: type &#x3D;&#x3D;&#x3D; &#39;cascader&#39; ? &#39;array&#39; : &#39;string&#39;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            initialValue: showData[key] ? showData[key] : undefined,</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;ShowType</span><br><span class=\"line\">              option&#x3D;&#123;option&#125;</span><br><span class=\"line\">              message&#x3D;&#123;Message&#125;</span><br><span class=\"line\">              disabled&#x3D;&#123;!!(disabled || category &#x3D;&#x3D;&#x3D; &#39;check&#39;)&#125;</span><br><span class=\"line\">            &#x2F;&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;&#x2F;Item&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  checkOk &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; onOk, form &#125; &#x3D; this.props;</span><br><span class=\"line\">    form.validateFields((err, fieldsValue) &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (!err) &#123;</span><br><span class=\"line\">        onOk(fieldsValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  closeModal &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; onCancel, form: &#123; resetFields &#125; &#125; &#x3D; this.props;</span><br><span class=\"line\">    resetFields();</span><br><span class=\"line\">    onCancel();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; data &#125; &#x3D; this.state;</span><br><span class=\"line\">    const &#123; show, category &#x3D; &#39;&#39;, importColums, downloadUrl &#125; &#x3D; this.props;</span><br><span class=\"line\">    const modalData &#x3D; this.caseCategory(category);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Modal</span><br><span class=\"line\">        visible&#x3D;&#123;show&#125;</span><br><span class=\"line\">        onCancel&#x3D;&#123;this.closeModal&#125;</span><br><span class=\"line\">        onOk&#x3D;&#123;category &#x3D;&#x3D;&#x3D; &#39;import&#39; ? this.importOk : this.checkOk&#125;</span><br><span class=\"line\">        title&#x3D;&#123;modalData.title&#125;</span><br><span class=\"line\">        width&#x3D;&quot;70%&quot;</span><br><span class=\"line\">        footer&#x3D;&#123;modalData.title &#x3D;&#x3D;&#x3D; &#39;查看&#39; ? null : undefined&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">          &lt;Form style&#x3D;&#123;&#123; paddingTop: &#39;20px&#39; &#125;&#125; &#123;...formItemLayout&#125;&gt;</span><br><span class=\"line\">            &#123;this.form()&#125;</span><br><span class=\"line\">          &lt;&#x2F;Form&gt;</span><br><span class=\"line\">      &lt;&#x2F;Modal&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ModalView.propTypes &#x3D; &#123;</span><br><span class=\"line\">  onOk: PropTypes.func.isRequired, &#x2F;&#x2F; 弹框点击确定</span><br><span class=\"line\">  onCancel: PropTypes.func.isRequired, &#x2F;&#x2F; 隐藏弹框</span><br><span class=\"line\">  show: PropTypes.bool, &#x2F;&#x2F; 是否显示弹窗</span><br><span class=\"line\">  category: PropTypes.string, &#x2F;&#x2F; 弹框的类型（title显示</span><br><span class=\"line\">  data: PropTypes.arrayOf(PropTypes.object).isRequired, &#x2F;&#x2F; 数据类型; 位置:&#39;@&#x2F;common&#x2F;constant&#x2F;sormView.js&#39; 记得写注释; 格式: &#96;s$&#123;文件名&#125;&#96;</span><br><span class=\"line\">  showData: PropTypes.object, &#x2F;&#x2F; 查看或者编辑时的默认数据</span><br><span class=\"line\">  importCallBack: PropTypes.func, &#x2F;&#x2F; 导入之后，点击确定的回调函数</span><br><span class=\"line\">  importColums: PropTypes.array, &#x2F;&#x2F; 导入时候显示表格的表头</span><br><span class=\"line\">  downloadUrl: PropTypes.string, &#x2F;&#x2F; 下载的模板的文件名</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ModalView.defaultProps &#x3D; &#123;</span><br><span class=\"line\">  show: false,</span><br><span class=\"line\">  category: &#39;check&#39;,</span><br><span class=\"line\">  showData: &#123;&#125;,</span><br><span class=\"line\">  importCallBack: () &#x3D;&gt; &#123;&#125;,</span><br><span class=\"line\">  importColums: [],</span><br><span class=\"line\">  downloadUrl: &#39;&#39;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Form.create()(ModalView);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormCascader</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-11 09:57:54 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 16:52:57</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Cascader &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import regionData from &#39;@&#x2F;constant&#x2F;regionData&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormCascader extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;value, disabled, message&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Cascader placeholder&#x3D;&#123;message&#125; options&#x3D;&#123;regionData&#125; disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormCascader.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormCascader.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormCascader;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormDataPicker</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:57:08 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-15 14:28:40</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import &#123; DatePicker &#125; from &#39;antd&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormDataPicker extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;DatePicker disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormDataPicker.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormDataPicker.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormDataPicker;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormImageUpload</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-26 14:20:20 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 18:11:44</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Upload, Icon, message &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import &#123; PICTURE_UPLOAD, HEADER_BASE &#125; from &#39;@&#x2F;utils&#x2F;constant&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormImageUpload extends PureComponent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  state &#x3D; &#123;</span><br><span class=\"line\">    loading: false,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  uploadButton &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; loading &#125; &#x3D; this.state;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Icon type&#x3D;&#123;loading ? &#39;loading&#39; : &#39;plus&#39;&#125; &#x2F;&gt;</span><br><span class=\"line\">        &lt;div className&#x3D;&quot;ant-upload-text&quot;&gt;Upload&lt;&#x2F;div&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange &#x3D; (info) &#x3D;&gt; &#123;</span><br><span class=\"line\">    if (info.file.status &#x3D;&#x3D;&#x3D; &#39;uploading&#39;) &#123;</span><br><span class=\"line\">      this.setState(&#123; loading: true &#125;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (info.file.status &#x3D;&#x3D;&#x3D; &#39;done&#39;) &#123;</span><br><span class=\"line\">      const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">      this.setState(&#123;imageUrl: info.file.response.data[0], loading: false,&#125;)</span><br><span class=\"line\">      onChange(info.file.response.data[0])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeUpload &#x3D; (file) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const isJPG &#x3D; file.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;;</span><br><span class=\"line\">    if (!isJPG) &#123;</span><br><span class=\"line\">      message.error(&#39;只能上传JPG的图片!&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const isLt2M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 2;</span><br><span class=\"line\">    if (!isLt2M) &#123;</span><br><span class=\"line\">      message.error(&#39;图片大小不能大于2MB!&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isJPG &amp;&amp; isLt2M;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  upLoadProps &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    HEADER_BASE.user_id &#x3D; window.sessionStorage.getItem(&#39;userId&#39;);</span><br><span class=\"line\">    HEADER_BASE.token_id &#x3D; window.sessionStorage.getItem(&#39;tokenId&#39;);</span><br><span class=\"line\">    const props &#x3D; &#123;</span><br><span class=\"line\">      name: &#39;file&#39;,</span><br><span class=\"line\">      action: PICTURE_UPLOAD,</span><br><span class=\"line\">      headers: HEADER_BASE,</span><br><span class=\"line\">      onChange: this.handleChange,</span><br><span class=\"line\">      showUploadList: false,</span><br><span class=\"line\">      beforeUpload: this.beforeUpload,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return props;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const &#123; imageUrl &#125; &#x3D; this.state;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Upload</span><br><span class=\"line\">        listType&#x3D;&quot;picture-card&quot;</span><br><span class=\"line\">        &#123;...this.upLoadProps()&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &#123;imageUrl ? &lt;img src&#x3D;&#123;imageUrl&#125; alt&#x3D;&quot;avatar&quot; &#x2F;&gt; : this.uploadButton()&#125;</span><br><span class=\"line\">      &lt;&#x2F;Upload&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormImageUpload;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormInput</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:57:08 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-15 14:46:23</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Input &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormInput extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Input disabled&#x3D;&#123;disabled&#125; placeholder&#x3D;&#123;message&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormInput.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormInput.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormInput;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>FormSelect</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:13:58 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 15:59:22</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Select &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes, &#123; object &#125; from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; Option &#125; &#x3D; Select;</span><br><span class=\"line\">class FormSelect extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  option &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;option &#x3D; []&#125; &#x3D; this.props;</span><br><span class=\"line\">    return option.map((v) &#x3D;&gt; &#123;</span><br><span class=\"line\">      const &#123;showValue, severKey&#125; &#x3D; v;</span><br><span class=\"line\">      return &lt;Option value&#x3D;&#123;severKey&#125; key&#x3D;&#123;severKey&#125;&gt;&#123;showValue&#125;&lt;&#x2F;Option&gt;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  selectCurrency &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Select disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; placeholder&#x3D;&#123;message&#125; style&#x3D;&#123;&#123;width: &#39;170px&#39;&#125;&#125; onSelect&#x3D;&#123;this.selectCurrency&#125;&gt;</span><br><span class=\"line\">        &#123;this.option()&#125;</span><br><span class=\"line\">      &lt;&#x2F;Select&gt;    </span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormSelect.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">  option: PropTypes.arrayOf(object), &#x2F;&#x2F; 选择框的选项</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormSelect.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">  option: [],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormSelect;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormTextArea</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-23 10:20:36 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-23 10:21:33</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Input &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; TextArea &#125; &#x3D; Input;</span><br><span class=\"line\">class FormTextArea extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;TextArea rows&#x3D;&#123;4&#125; disabled&#x3D;&#123;disabled&#125; placeholder&#x3D;&#123;message&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormTextArea.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormTextArea.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormTextArea;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"核心\"><a href=\"#核心\" class=\"headerlink\" title=\"核心\"></a>核心</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">onChange(XX)</span><br></pre></td></tr></table></figure>\n\n\n<p>这个onChange是可以直接改变FormItem的值。</p>\n<p>接下来可以加入您自己喜欢的组件，都是大同小异，基本上都离不开这个onChange。</p>\n<p>以上就是本人最近封装的一个组件，我感觉很好用所以想分享出来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>最近在项目中发现要写多个弹框（用于查看、编辑、新建XX信息），如下图。</p>\n<p><img src=\"/image/AntDesignForm%E6%80%BB%E7%BB%93/modal.png\" alt=\"测试图片\"></p>\n<p>像这样花里胡哨的弹框在一个大型的中台管理系统中，可能要写上好几遍的Modal<br>但是其实他们大同小异。</p>\n<p>首先，他们的title是固定的（增、改、查）</p>\n<p>底下的内容也是固定的，无非就是Upload Input Select DatePicker Cascader</p>\n<p>（写不了&lt;&gt;。其实应该是ant design 的组件）</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>所以我想自己写一个ModalView的组件。只需要传入这上面的数据类型，title之类的数据就可以完成渲染。</p>\n<p>如下，这个是我项目中的一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ModalView </span><br><span class=\"line\">          onOk&#x3D;&#123;this.edit&#125;     &#x2F;&#x2F; 点击Modal确定时的回调</span><br><span class=\"line\">          onCancel&#x3D;&#123;this.hideModal&#125;   &#x2F;&#x2F; 点击Modal取消，或者点击mask时的回调</span><br><span class=\"line\">          show&#x3D;&#123;visible&#125;        &#x2F;&#x2F; Modal的显隐</span><br><span class=\"line\">          category&#x3D;&#123;category&#125;      &#x2F;&#x2F; Modal的title，通过category来判断（目前只有查看、编辑、新增）</span><br><span class=\"line\">          data&#x3D;&#123;fStaffManage&#125;     &#x2F;&#x2F; 自定义Modal的核心，整个Modal的渲染</span><br><span class=\"line\">          showData&#x3D;&#123;showData&#125;    &#x2F;&#x2F; 点击查看和编辑时的默认数据</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来是fStaffManage的数据结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const fStaffManage &#x3D; [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;员工编号（自动生成）&#39;,</span><br><span class=\"line\">    key: &#39;id&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入员工编号&#39;,</span><br><span class=\"line\">    disabled: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;门店&#39;,</span><br><span class=\"line\">    key: &#39;storeNo&#39;,</span><br><span class=\"line\">    type: &#39;select&#39;,</span><br><span class=\"line\">    Message: &#39;请选择门店&#39;,</span><br><span class=\"line\">    option: [],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;员工姓名&#39;,</span><br><span class=\"line\">    key: &#39;userName&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入员工姓名&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;角色类型&#39;,</span><br><span class=\"line\">    key: &#39;roleCodes&#39;,</span><br><span class=\"line\">    type: &#39;select&#39;,</span><br><span class=\"line\">    Message: &#39;请选择角色类型&#39;,</span><br><span class=\"line\">    option: [&#123; severKey: &#39;店员&#39;, showValue: &#39;店员&#39; &#125;, &#123; severKey: &#39;店长&#39;, showValue: &#39;店长&#39; &#125;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;联系电话&#39;,</span><br><span class=\"line\">    key: &#39;mobile&#39;,</span><br><span class=\"line\">    type: &#39;input&#39;,</span><br><span class=\"line\">    Message: &#39;请输入联系电话&#39;,</span><br><span class=\"line\">    pattern: &#39;^1[34578]\\\\d&#123;9&#125;$&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: &#39;测试上传图片&#39;,</span><br><span class=\"line\">    key: &#39;testImgUpload&#39;,</span><br><span class=\"line\">    type: &#39;imageUpload&#39;,</span><br><span class=\"line\">    Message: &#39;请上传图片&#39;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p><strong>Message</strong>  是用于Form表单的提示用于以及placeholder</p>\n<p><strong>label</strong>   是用于Form的label</p>\n<p><strong>key</strong>   是用于map循环时的key（防止warning和提升效率）</p>\n<p><strong>type</strong>   是用于显示那种类型的组件</p>\n<p><strong>pattern</strong>   是用于Form表单检测的正则表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick</span><br><span class=\"line\"> * @Date: 2019-04-04 16:53:05</span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 15:48:04</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Modal, Form, Button, Table, Upload, message, Row, Select &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import &#123; connect &#125; from &#39;dva&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import componentAuth from &#39;@&#x2F;common&#x2F;ComponentAuth&#39;;</span><br><span class=\"line\">import FormSelect from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormSelect&#39;;</span><br><span class=\"line\">import FormInput from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormInput&#39;;</span><br><span class=\"line\">import FormDataPicker from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormDataPicker&#39;;</span><br><span class=\"line\">import FormCascader from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormCascader&#39;;</span><br><span class=\"line\">import FormTextArea from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormTextArea&#39;;</span><br><span class=\"line\">import FormImageUpload from &#39;@&#x2F;common&#x2F;FormItems&#x2F;FormImageUpload&#39;;</span><br><span class=\"line\">import &#123; HEADER_BASE, SEVER_URL_BASE &#125; from &#39;@&#x2F;utils&#x2F;constant&#39;;</span><br><span class=\"line\">import Col from &#39;antd&#x2F;es&#x2F;col&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const formItemLayout &#x3D; &#123;</span><br><span class=\"line\">  labelCol: &#123;</span><br><span class=\"line\">    xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">    sm: &#123; span: 5 &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  wrapperCol: &#123;</span><br><span class=\"line\">    xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">    sm: &#123; span: 16 &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const &#123; Item &#125; &#x3D; Form;</span><br><span class=\"line\">const &#123; Option &#125; &#x3D; Select;</span><br><span class=\"line\"></span><br><span class=\"line\">@connect((&#123; mIdentifyCenter &#125;) &#x3D;&gt; (&#123;</span><br><span class=\"line\">  mIdentifyCenter</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\">class ModalView extends PureComponent &#123;</span><br><span class=\"line\">  state &#x3D; &#123;</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    storeId: &#39;&#39;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 返回title</span><br><span class=\"line\">  caseCategory &#x3D; category &#x3D;&gt; &#123;</span><br><span class=\"line\">    switch (category) &#123;</span><br><span class=\"line\">      case &#39;check&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;查看&#39; &#125;;</span><br><span class=\"line\">      case &#39;import&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;导入&#39;, import: true &#125;;</span><br><span class=\"line\">      case &#39;create&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;新增&#39; &#125;;</span><br><span class=\"line\">      case &#39;edit&#39;:</span><br><span class=\"line\">        return &#123; title: &#39;编辑&#39; &#125;;</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        return &#123; title: &#39;查看&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLabel &#x3D; (type, label) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; category &#125; &#x3D; this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (category &#x3D;&#x3D;&#x3D; &#39;search&#39;) &#123;</span><br><span class=\"line\">      if (type !&#x3D;&#x3D; &#39;datePicker&#39;) &#123;</span><br><span class=\"line\">        return undefined;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return label;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return label;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  showRequire &#x3D; disabled &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; category &#125; &#x3D; this.props;</span><br><span class=\"line\">    if (category &#x3D;&#x3D;&#x3D; &#39;search&#39;) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (disabled) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  form &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      form: &#123; getFieldDecorator &#125;,</span><br><span class=\"line\">      data,</span><br><span class=\"line\">      showData,</span><br><span class=\"line\">      category,</span><br><span class=\"line\">    &#125; &#x3D; this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    let ShowType;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data.map(value &#x3D;&gt; &#123;</span><br><span class=\"line\">      const &#123; label, key, type, Message, option, disabled, pattern &#125; &#x3D; value;</span><br><span class=\"line\">      if (!value) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      switch (type) &#123;</span><br><span class=\"line\">        case &#39;input&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormInput;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;select&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormSelect;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;datePicker&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormDataPicker;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;cascader&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormCascader;</span><br><span class=\"line\">          showData.region &#x3D; [showData.provinceId, showData.cityId, showData.countyId];</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;textArea&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormTextArea;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        case &#39;imageUpload&#39;:</span><br><span class=\"line\">          ShowType &#x3D; FormImageUpload;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">          ShowType &#x3D; null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        &lt;Item label&#x3D;&#123;this.showLabel(type, label)&#125; key&#x3D;&#123;key&#125;&gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(key, &#123;</span><br><span class=\"line\">            rules: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                required: this.showRequire(disabled),</span><br><span class=\"line\">                message: Message,</span><br><span class=\"line\">                pattern: pattern || undefined,</span><br><span class=\"line\">                type: type &#x3D;&#x3D;&#x3D; &#39;cascader&#39; ? &#39;array&#39; : &#39;string&#39;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            initialValue: showData[key] ? showData[key] : undefined,</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;ShowType</span><br><span class=\"line\">              option&#x3D;&#123;option&#125;</span><br><span class=\"line\">              message&#x3D;&#123;Message&#125;</span><br><span class=\"line\">              disabled&#x3D;&#123;!!(disabled || category &#x3D;&#x3D;&#x3D; &#39;check&#39;)&#125;</span><br><span class=\"line\">            &#x2F;&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;&#x2F;Item&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  checkOk &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; onOk, form &#125; &#x3D; this.props;</span><br><span class=\"line\">    form.validateFields((err, fieldsValue) &#x3D;&gt; &#123;</span><br><span class=\"line\">      if (!err) &#123;</span><br><span class=\"line\">        onOk(fieldsValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  closeModal &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; onCancel, form: &#123; resetFields &#125; &#125; &#x3D; this.props;</span><br><span class=\"line\">    resetFields();</span><br><span class=\"line\">    onCancel();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; data &#125; &#x3D; this.state;</span><br><span class=\"line\">    const &#123; show, category &#x3D; &#39;&#39;, importColums, downloadUrl &#125; &#x3D; this.props;</span><br><span class=\"line\">    const modalData &#x3D; this.caseCategory(category);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Modal</span><br><span class=\"line\">        visible&#x3D;&#123;show&#125;</span><br><span class=\"line\">        onCancel&#x3D;&#123;this.closeModal&#125;</span><br><span class=\"line\">        onOk&#x3D;&#123;category &#x3D;&#x3D;&#x3D; &#39;import&#39; ? this.importOk : this.checkOk&#125;</span><br><span class=\"line\">        title&#x3D;&#123;modalData.title&#125;</span><br><span class=\"line\">        width&#x3D;&quot;70%&quot;</span><br><span class=\"line\">        footer&#x3D;&#123;modalData.title &#x3D;&#x3D;&#x3D; &#39;查看&#39; ? null : undefined&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">          &lt;Form style&#x3D;&#123;&#123; paddingTop: &#39;20px&#39; &#125;&#125; &#123;...formItemLayout&#125;&gt;</span><br><span class=\"line\">            &#123;this.form()&#125;</span><br><span class=\"line\">          &lt;&#x2F;Form&gt;</span><br><span class=\"line\">      &lt;&#x2F;Modal&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ModalView.propTypes &#x3D; &#123;</span><br><span class=\"line\">  onOk: PropTypes.func.isRequired, &#x2F;&#x2F; 弹框点击确定</span><br><span class=\"line\">  onCancel: PropTypes.func.isRequired, &#x2F;&#x2F; 隐藏弹框</span><br><span class=\"line\">  show: PropTypes.bool, &#x2F;&#x2F; 是否显示弹窗</span><br><span class=\"line\">  category: PropTypes.string, &#x2F;&#x2F; 弹框的类型（title显示</span><br><span class=\"line\">  data: PropTypes.arrayOf(PropTypes.object).isRequired, &#x2F;&#x2F; 数据类型; 位置:&#39;@&#x2F;common&#x2F;constant&#x2F;sormView.js&#39; 记得写注释; 格式: &#96;s$&#123;文件名&#125;&#96;</span><br><span class=\"line\">  showData: PropTypes.object, &#x2F;&#x2F; 查看或者编辑时的默认数据</span><br><span class=\"line\">  importCallBack: PropTypes.func, &#x2F;&#x2F; 导入之后，点击确定的回调函数</span><br><span class=\"line\">  importColums: PropTypes.array, &#x2F;&#x2F; 导入时候显示表格的表头</span><br><span class=\"line\">  downloadUrl: PropTypes.string, &#x2F;&#x2F; 下载的模板的文件名</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ModalView.defaultProps &#x3D; &#123;</span><br><span class=\"line\">  show: false,</span><br><span class=\"line\">  category: &#39;check&#39;,</span><br><span class=\"line\">  showData: &#123;&#125;,</span><br><span class=\"line\">  importCallBack: () &#x3D;&gt; &#123;&#125;,</span><br><span class=\"line\">  importColums: [],</span><br><span class=\"line\">  downloadUrl: &#39;&#39;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Form.create()(ModalView);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormCascader</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-11 09:57:54 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 16:52:57</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Cascader &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import regionData from &#39;@&#x2F;constant&#x2F;regionData&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormCascader extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;value, disabled, message&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Cascader placeholder&#x3D;&#123;message&#125; options&#x3D;&#123;regionData&#125; disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormCascader.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormCascader.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormCascader;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormDataPicker</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:57:08 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-15 14:28:40</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\">import &#123; DatePicker &#125; from &#39;antd&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormDataPicker extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;DatePicker disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormDataPicker.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormDataPicker.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormDataPicker;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormImageUpload</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-26 14:20:20 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 18:11:44</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Upload, Icon, message &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import &#123; PICTURE_UPLOAD, HEADER_BASE &#125; from &#39;@&#x2F;utils&#x2F;constant&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormImageUpload extends PureComponent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  state &#x3D; &#123;</span><br><span class=\"line\">    loading: false,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  uploadButton &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123; loading &#125; &#x3D; this.state;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Icon type&#x3D;&#123;loading ? &#39;loading&#39; : &#39;plus&#39;&#125; &#x2F;&gt;</span><br><span class=\"line\">        &lt;div className&#x3D;&quot;ant-upload-text&quot;&gt;Upload&lt;&#x2F;div&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange &#x3D; (info) &#x3D;&gt; &#123;</span><br><span class=\"line\">    if (info.file.status &#x3D;&#x3D;&#x3D; &#39;uploading&#39;) &#123;</span><br><span class=\"line\">      this.setState(&#123; loading: true &#125;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (info.file.status &#x3D;&#x3D;&#x3D; &#39;done&#39;) &#123;</span><br><span class=\"line\">      const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">      this.setState(&#123;imageUrl: info.file.response.data[0], loading: false,&#125;)</span><br><span class=\"line\">      onChange(info.file.response.data[0])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeUpload &#x3D; (file) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const isJPG &#x3D; file.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;;</span><br><span class=\"line\">    if (!isJPG) &#123;</span><br><span class=\"line\">      message.error(&#39;只能上传JPG的图片!&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const isLt2M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 2;</span><br><span class=\"line\">    if (!isLt2M) &#123;</span><br><span class=\"line\">      message.error(&#39;图片大小不能大于2MB!&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isJPG &amp;&amp; isLt2M;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  upLoadProps &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    HEADER_BASE.user_id &#x3D; window.sessionStorage.getItem(&#39;userId&#39;);</span><br><span class=\"line\">    HEADER_BASE.token_id &#x3D; window.sessionStorage.getItem(&#39;tokenId&#39;);</span><br><span class=\"line\">    const props &#x3D; &#123;</span><br><span class=\"line\">      name: &#39;file&#39;,</span><br><span class=\"line\">      action: PICTURE_UPLOAD,</span><br><span class=\"line\">      headers: HEADER_BASE,</span><br><span class=\"line\">      onChange: this.handleChange,</span><br><span class=\"line\">      showUploadList: false,</span><br><span class=\"line\">      beforeUpload: this.beforeUpload,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return props;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const &#123; imageUrl &#125; &#x3D; this.state;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Upload</span><br><span class=\"line\">        listType&#x3D;&quot;picture-card&quot;</span><br><span class=\"line\">        &#123;...this.upLoadProps()&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &#123;imageUrl ? &lt;img src&#x3D;&#123;imageUrl&#125; alt&#x3D;&quot;avatar&quot; &#x2F;&gt; : this.uploadButton()&#125;</span><br><span class=\"line\">      &lt;&#x2F;Upload&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormImageUpload;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormInput</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:57:08 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-15 14:46:23</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Input &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FormInput extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Input disabled&#x3D;&#123;disabled&#125; placeholder&#x3D;&#123;message&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormInput.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormInput.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormInput;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>FormSelect</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-10 10:13:58 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-28 15:59:22</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Select &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes, &#123; object &#125; from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; Option &#125; &#x3D; Select;</span><br><span class=\"line\">class FormSelect extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  option &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;option &#x3D; []&#125; &#x3D; this.props;</span><br><span class=\"line\">    return option.map((v) &#x3D;&gt; &#123;</span><br><span class=\"line\">      const &#123;showValue, severKey&#125; &#x3D; v;</span><br><span class=\"line\">      return &lt;Option value&#x3D;&#123;severKey&#125; key&#x3D;&#123;severKey&#125;&gt;&#123;showValue&#125;&lt;&#x2F;Option&gt;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  selectCurrency &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Select disabled&#x3D;&#123;disabled&#125; value&#x3D;&#123;value&#125; placeholder&#x3D;&#123;message&#125; style&#x3D;&#123;&#123;width: &#39;170px&#39;&#125;&#125; onSelect&#x3D;&#123;this.selectCurrency&#125;&gt;</span><br><span class=\"line\">        &#123;this.option()&#125;</span><br><span class=\"line\">      &lt;&#x2F;Select&gt;    </span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormSelect.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">  option: PropTypes.arrayOf(object), &#x2F;&#x2F; 选择框的选项</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormSelect.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">  option: [],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormSelect;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>FormTextArea</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * @Author: Derrick </span><br><span class=\"line\"> * @Date: 2019-04-23 10:20:36 </span><br><span class=\"line\"> * @Last Modified by: Derrick</span><br><span class=\"line\"> * @Last Modified time: 2019-04-23 10:21:33</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class=\"line\">import &#123; Input &#125; from &#39;antd&#39;;</span><br><span class=\"line\">import PropTypes from &#39;prop-types&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; TextArea &#125; &#x3D; Input;</span><br><span class=\"line\">class FormTextArea extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  change &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;message, value, disabled&#125; &#x3D; this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;TextArea rows&#x3D;&#123;4&#125; disabled&#x3D;&#123;disabled&#125; placeholder&#x3D;&#123;message&#125; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.change&#125; &#x2F;&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormTextArea.propsType &#x3D; &#123;</span><br><span class=\"line\">  disabled: PropTypes.bool, &#x2F;&#x2F; 是否不可选</span><br><span class=\"line\">  message: PropTypes.string, &#x2F;&#x2F; 默认文字（placeholder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FormTextArea.defalutProps &#x3D; &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  message: &#39;&#39;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FormTextArea;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"核心\"><a href=\"#核心\" class=\"headerlink\" title=\"核心\"></a>核心</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;onChange&#125; &#x3D; this.props;</span><br><span class=\"line\">onChange(XX)</span><br></pre></td></tr></table></figure>\n\n\n<p>这个onChange是可以直接改变FormItem的值。</p>\n<p>接下来可以加入您自己喜欢的组件，都是大同小异，基本上都离不开这个onChange。</p>\n<p>以上就是本人最近封装的一个组件，我感觉很好用所以想分享出来。</p>\n"},{"title":"ant design pro 2.0 新页面探索 umi 页面404 react","date":"2019-06-19T03:16:30.000Z","cover":"/image/cover/antdP.png","_content":"\n## 前言\n\n\t\tant design pro 2.0发布了\n\t\n\t\t使用umi作为路由配置，全自动化。\n\n## 开始\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312150742764.png)\n\n这个是官方的介绍。根据提示我开始加入我的路由\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312151053807.png)\n\n我在最后面另起一行，加入了我的新的路由。名字叫做Test。\n\ncomponent是你具体路由的实际位置（根路径是pages）\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312150929439.png)\n\nCtrl + S\n\n看效果！\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215120430.png)\n\n - 菜单是出来了\n - 为什么404！！\n\n 通过4个多小时的google，在这位兄台的指点下。我知道了。\n\n\n新页面要写在404之前。\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215140926.png)\n\n正常的新手，都是在最后加入一个新的路由。。。不知道这个坑爹的问题是为什么。我马上去质问了一下ant design pro的作者之一。得到了解答！！！非常的激动！！\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215175956.png)\n\n\n所以我们只要在404之前添加新的页面就可以了\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312151839845.png)\n\n\n补充：\n是因为React-Router规定的。","source":"_posts/ant-design-pro-2-0-新页面探索-umi-页面404-react.md","raw":"---\ntitle: ant design pro 2.0 新页面探索 umi 页面404 react\ndate: 2019-06-19 11:16:30\ntags: [React-Router, UMI, Ant-Design-Pro]\ncategory: [Ant-Design-Pro]\ncover: /image/cover/antdP.png\n---\n\n## 前言\n\n\t\tant design pro 2.0发布了\n\t\n\t\t使用umi作为路由配置，全自动化。\n\n## 开始\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312150742764.png)\n\n这个是官方的介绍。根据提示我开始加入我的路由\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312151053807.png)\n\n我在最后面另起一行，加入了我的新的路由。名字叫做Test。\n\ncomponent是你具体路由的实际位置（根路径是pages）\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312150929439.png)\n\nCtrl + S\n\n看效果！\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215120430.png)\n\n - 菜单是出来了\n - 为什么404！！\n\n 通过4个多小时的google，在这位兄台的指点下。我知道了。\n\n\n新页面要写在404之前。\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215140926.png)\n\n正常的新手，都是在最后加入一个新的路由。。。不知道这个坑爹的问题是为什么。我马上去质问了一下ant design pro的作者之一。得到了解答！！！非常的激动！！\n\n\n![在这里插入图片描述](/image/AntDesignPro探索/2019031215175956.png)\n\n\n所以我们只要在404之前添加新的页面就可以了\n\n![在这里插入图片描述](/image/AntDesignPro探索/20190312151839845.png)\n\n\n补充：\n是因为React-Router规定的。","slug":"ant-design-pro-2-0-新页面探索-umi-页面404-react","published":1,"updated":"2021-06-24T14:00:06.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7y000plwrd3tbg7sno","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><pre><code>ant design pro 2.0发布了\n\n使用umi作为路由配置，全自动化。</code></pre><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312150742764.png\"  alt=\"在这里插入图片描述\"></p>\n<p>这个是官方的介绍。根据提示我开始加入我的路由</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312151053807.png\"  alt=\"在这里插入图片描述\"></p>\n<p>我在最后面另起一行，加入了我的新的路由。名字叫做Test。</p>\n<p>component是你具体路由的实际位置（根路径是pages）</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312150929439.png\"  alt=\"在这里插入图片描述\"></p>\n<p>Ctrl + S</p>\n<p>看效果！</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215120430.png\"  alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>菜单是出来了</p>\n</li>\n<li><p>为什么404！！</p>\n<p>通过4个多小时的google，在这位兄台的指点下。我知道了。</p>\n</li>\n</ul>\n<p>新页面要写在404之前。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215140926.png\"  alt=\"在这里插入图片描述\"></p>\n<p>正常的新手，都是在最后加入一个新的路由。。。不知道这个坑爹的问题是为什么。我马上去质问了一下ant design pro的作者之一。得到了解答！！！非常的激动！！</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215175956.png\"  alt=\"在这里插入图片描述\"></p>\n<p>所以我们只要在404之前添加新的页面就可以了</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312151839845.png\"  alt=\"在这里插入图片描述\"></p>\n<p>补充：<br>是因为React-Router规定的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><pre><code>ant design pro 2.0发布了\n\n使用umi作为路由配置，全自动化。</code></pre><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312150742764.png\" alt=\"在这里插入图片描述\"></p>\n<p>这个是官方的介绍。根据提示我开始加入我的路由</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312151053807.png\" alt=\"在这里插入图片描述\"></p>\n<p>我在最后面另起一行，加入了我的新的路由。名字叫做Test。</p>\n<p>component是你具体路由的实际位置（根路径是pages）</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312150929439.png\" alt=\"在这里插入图片描述\"></p>\n<p>Ctrl + S</p>\n<p>看效果！</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215120430.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>菜单是出来了</p>\n</li>\n<li><p>为什么404！！</p>\n<p>通过4个多小时的google，在这位兄台的指点下。我知道了。</p>\n</li>\n</ul>\n<p>新页面要写在404之前。</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215140926.png\" alt=\"在这里插入图片描述\"></p>\n<p>正常的新手，都是在最后加入一个新的路由。。。不知道这个坑爹的问题是为什么。我马上去质问了一下ant design pro的作者之一。得到了解答！！！非常的激动！！</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/2019031215175956.png\" alt=\"在这里插入图片描述\"></p>\n<p>所以我们只要在404之前添加新的页面就可以了</p>\n<p><img src=\"/image/AntDesignPro%E6%8E%A2%E7%B4%A2/20190312151839845.png\" alt=\"在这里插入图片描述\"></p>\n<p>补充：<br>是因为React-Router规定的。</p>\n"},{"title":"chunk 0 [mini-css-extract-plugin] 解决 CSS Modules 警告","date":"2019-06-29T02:38:06.000Z","cover":"/image/cover/css.png","_content":"\n## 前言\n前两周，用公司的CI部署的时候，发现![](/image/CSSModules警告/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg)\n很鲜明的ERR！\n其实这个这个只是一个warning。但是由于环境变量（process.env.ci === true）。所以这个warning被转化成了error，导致了编译失败。一般的CI服务器会自动将这个这设置为true。\n\n## 解决方案\n因为知道了原因，所以解决方案有以下两个\n\n - 修复这个warning。\n - 让运维小哥哥帮忙把这个环境变量设置为false。\n\n本着探寻的心。我开始了google，baidu。\n我查了整整两天。\n\n其实这些东西可能使用webpack的一些配置就改完了。但是由于我使用的是`react-app-rewired`。\n[ant design mobile](https://mobile.ant.design/docs/react/use-with-create-react-app-cn)\n具体想了解的可以自己去了解。我们言归正传。\n\n## 探索\n我开始找各种“人”的毛病\n`less，sass，less-loader，node-sass，postcss-px2rem` 等等。我几乎吧package.json里面的东西都试了一遍，不管是最新的，或者是我查询的过程中有提到了，我升级或者降级为固定版本。\n无果！\n\n![一个issue](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg)\n\n他的大致意思是，CSS更加关注加载顺序，OK\n我把我的项目所有的CSS加载顺序改成了一致（其实根本没有加载两个以上CSS的地方，我只是把他们都放到最后一行import）\n\n\n还是翻车了。但是给了我很大的启发。\n\n我开始关注原理。看报错的内容。\n\n几乎都是和Ant Design Mobil相关的。\n\n我想到了我几乎所有的页面都是几乎一个我自己写的组件`<PageContainer>`\n\n![PageContainer](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg)\n\n在这里我用到了Ant Design Mobile的组件。\n我尝试把这里的组件全部删除。然后在本地build。\n\n竟然成功了！\n\n很明显，问题出在了我这个共用组件头上。我开始研究他。\n\n最后我发现，只要在我的这个组件里面的组件直接用到了Ant Design Mobile的组件就会报出CSS Module的警告。\n\n在Ant Design 的issues里面我发现，也有人有这个问题，但是也有人说明了原因。\n\n我个人的理解是这样的：因为Ant Design 内部也做了CSS的按需加载。导致我们引用组件的时候，很容易造成CSS引入顺序的不一致。\n\n然后我想出了解决方案，将我所有的组件，或者说子组件，全部封装到孙子组件中。就可以解决了\n\n![子组件](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg)\n\n最后，预约的看到了\n\n![编译成功](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg)","source":"_posts/chunk-0-mini-css-extract-plugin-解决-CSS-Modules-警告.md","raw":"---\ntitle: 'chunk 0 [mini-css-extract-plugin] 解决 CSS Modules 警告'\ndate: 2019-06-29 10:38:06\ntags: [CSS-Module]\ncategory: [CSS]\ncover: /image/cover/css.png\n---\n\n## 前言\n前两周，用公司的CI部署的时候，发现![](/image/CSSModules警告/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg)\n很鲜明的ERR！\n其实这个这个只是一个warning。但是由于环境变量（process.env.ci === true）。所以这个warning被转化成了error，导致了编译失败。一般的CI服务器会自动将这个这设置为true。\n\n## 解决方案\n因为知道了原因，所以解决方案有以下两个\n\n - 修复这个warning。\n - 让运维小哥哥帮忙把这个环境变量设置为false。\n\n本着探寻的心。我开始了google，baidu。\n我查了整整两天。\n\n其实这些东西可能使用webpack的一些配置就改完了。但是由于我使用的是`react-app-rewired`。\n[ant design mobile](https://mobile.ant.design/docs/react/use-with-create-react-app-cn)\n具体想了解的可以自己去了解。我们言归正传。\n\n## 探索\n我开始找各种“人”的毛病\n`less，sass，less-loader，node-sass，postcss-px2rem` 等等。我几乎吧package.json里面的东西都试了一遍，不管是最新的，或者是我查询的过程中有提到了，我升级或者降级为固定版本。\n无果！\n\n![一个issue](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg)\n\n他的大致意思是，CSS更加关注加载顺序，OK\n我把我的项目所有的CSS加载顺序改成了一致（其实根本没有加载两个以上CSS的地方，我只是把他们都放到最后一行import）\n\n\n还是翻车了。但是给了我很大的启发。\n\n我开始关注原理。看报错的内容。\n\n几乎都是和Ant Design Mobil相关的。\n\n我想到了我几乎所有的页面都是几乎一个我自己写的组件`<PageContainer>`\n\n![PageContainer](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg)\n\n在这里我用到了Ant Design Mobile的组件。\n我尝试把这里的组件全部删除。然后在本地build。\n\n竟然成功了！\n\n很明显，问题出在了我这个共用组件头上。我开始研究他。\n\n最后我发现，只要在我的这个组件里面的组件直接用到了Ant Design Mobile的组件就会报出CSS Module的警告。\n\n在Ant Design 的issues里面我发现，也有人有这个问题，但是也有人说明了原因。\n\n我个人的理解是这样的：因为Ant Design 内部也做了CSS的按需加载。导致我们引用组件的时候，很容易造成CSS引入顺序的不一致。\n\n然后我想出了解决方案，将我所有的组件，或者说子组件，全部封装到孙子组件中。就可以解决了\n\n![子组件](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg)\n\n最后，预约的看到了\n\n![编译成功](/image/CSSModules警告/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg)","slug":"chunk-0-mini-css-extract-plugin-解决-CSS-Modules-警告","published":1,"updated":"2021-06-24T14:00:06.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra7z000tlwrd4qd2htwb","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两周，用公司的CI部署的时候，发现<img src=\"/\" class=\"lazyload\" data-src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg\"  alt=\"\"><br>很鲜明的ERR！<br>其实这个这个只是一个warning。但是由于环境变量（process.env.ci === true）。所以这个warning被转化成了error，导致了编译失败。一般的CI服务器会自动将这个这设置为true。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>因为知道了原因，所以解决方案有以下两个</p>\n<ul>\n<li>修复这个warning。</li>\n<li>让运维小哥哥帮忙把这个环境变量设置为false。</li>\n</ul>\n<p>本着探寻的心。我开始了google，baidu。<br>我查了整整两天。</p>\n<p>其实这些东西可能使用webpack的一些配置就改完了。但是由于我使用的是<code>react-app-rewired</code>。<br><a href=\"https://mobile.ant.design/docs/react/use-with-create-react-app-cn\" target=\"_blank\" rel=\"noopener\">ant design mobile</a><br>具体想了解的可以自己去了解。我们言归正传。</p>\n<h2 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h2><p>我开始找各种“人”的毛病<br><code>less，sass，less-loader，node-sass，postcss-px2rem</code> 等等。我几乎吧package.json里面的东西都试了一遍，不管是最新的，或者是我查询的过程中有提到了，我升级或者降级为固定版本。<br>无果！</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg\"  alt=\"一个issue\"></p>\n<p>他的大致意思是，CSS更加关注加载顺序，OK<br>我把我的项目所有的CSS加载顺序改成了一致（其实根本没有加载两个以上CSS的地方，我只是把他们都放到最后一行import）</p>\n<p>还是翻车了。但是给了我很大的启发。</p>\n<p>我开始关注原理。看报错的内容。</p>\n<p>几乎都是和Ant Design Mobil相关的。</p>\n<p>我想到了我几乎所有的页面都是几乎一个我自己写的组件<code>&lt;PageContainer&gt;</code></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg\"  alt=\"PageContainer\"></p>\n<p>在这里我用到了Ant Design Mobile的组件。<br>我尝试把这里的组件全部删除。然后在本地build。</p>\n<p>竟然成功了！</p>\n<p>很明显，问题出在了我这个共用组件头上。我开始研究他。</p>\n<p>最后我发现，只要在我的这个组件里面的组件直接用到了Ant Design Mobile的组件就会报出CSS Module的警告。</p>\n<p>在Ant Design 的issues里面我发现，也有人有这个问题，但是也有人说明了原因。</p>\n<p>我个人的理解是这样的：因为Ant Design 内部也做了CSS的按需加载。导致我们引用组件的时候，很容易造成CSS引入顺序的不一致。</p>\n<p>然后我想出了解决方案，将我所有的组件，或者说子组件，全部封装到孙子组件中。就可以解决了</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg\"  alt=\"子组件\"></p>\n<p>最后，预约的看到了</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg\"  alt=\"编译成功\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两周，用公司的CI部署的时候，发现<img src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kyLnRpaW1nLmNvbS82OTE2NDMvMmVmODNhMzcxNjA4OWEwZS5wbmc.jpeg\" alt=\"\"><br>很鲜明的ERR！<br>其实这个这个只是一个warning。但是由于环境变量（process.env.ci === true）。所以这个warning被转化成了error，导致了编译失败。一般的CI服务器会自动将这个这设置为true。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>因为知道了原因，所以解决方案有以下两个</p>\n<ul>\n<li>修复这个warning。</li>\n<li>让运维小哥哥帮忙把这个环境变量设置为false。</li>\n</ul>\n<p>本着探寻的心。我开始了google，baidu。<br>我查了整整两天。</p>\n<p>其实这些东西可能使用webpack的一些配置就改完了。但是由于我使用的是<code>react-app-rewired</code>。<br><a href=\"https://mobile.ant.design/docs/react/use-with-create-react-app-cn\" target=\"_blank\" rel=\"noopener\">ant design mobile</a><br>具体想了解的可以自己去了解。我们言归正传。</p>\n<h2 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h2><p>我开始找各种“人”的毛病<br><code>less，sass，less-loader，node-sass，postcss-px2rem</code> 等等。我几乎吧package.json里面的东西都试了一遍，不管是最新的，或者是我查询的过程中有提到了，我升级或者降级为固定版本。<br>无果！</p>\n<p><img src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvMGM4ZDhiNjZlMGNmZTY0Ny5wbmc.jpeg\" alt=\"一个issue\"></p>\n<p>他的大致意思是，CSS更加关注加载顺序，OK<br>我把我的项目所有的CSS加载顺序改成了一致（其实根本没有加载两个以上CSS的地方，我只是把他们都放到最后一行import）</p>\n<p>还是翻车了。但是给了我很大的启发。</p>\n<p>我开始关注原理。看报错的内容。</p>\n<p>几乎都是和Ant Design Mobil相关的。</p>\n<p>我想到了我几乎所有的页面都是几乎一个我自己写的组件<code>&lt;PageContainer&gt;</code></p>\n<p><img src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvZWIwYzBmODU2NDE0OGZjMC5wbmc.jpeg\" alt=\"PageContainer\"></p>\n<p>在这里我用到了Ant Design Mobile的组件。<br>我尝试把这里的组件全部删除。然后在本地build。</p>\n<p>竟然成功了！</p>\n<p>很明显，问题出在了我这个共用组件头上。我开始研究他。</p>\n<p>最后我发现，只要在我的这个组件里面的组件直接用到了Ant Design Mobile的组件就会报出CSS Module的警告。</p>\n<p>在Ant Design 的issues里面我发现，也有人有这个问题，但是也有人说明了原因。</p>\n<p>我个人的理解是这样的：因为Ant Design 内部也做了CSS的按需加载。导致我们引用组件的时候，很容易造成CSS引入顺序的不一致。</p>\n<p>然后我想出了解决方案，将我所有的组件，或者说子组件，全部封装到孙子组件中。就可以解决了</p>\n<p><img src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvODU2M2ZjOGJhZTU1ODI3Yy5wbmc.jpeg\" alt=\"子组件\"></p>\n<p>最后，预约的看到了</p>\n<p><img src=\"/image/CSSModules%E8%AD%A6%E5%91%8A/aHR0cDovL2kxLmZ1aW1nLmNvbS82OTE2NDMvYTkxMmI1YzhlNTk3YTYzYy5wbmc.jpeg\" alt=\"编译成功\"></p>\n"},{"title":"session和cookie的理解","date":"2020-04-11T02:31:35.000Z","cover":"/image/cover/http.png","_content":"\n\n## 曾经的我\n\ncookie是浏览器中传输自带的; balabala...\n\nsession是存在服务端的; 存一些用户信息.......balabala....\n\n## 现在的我\n\n从以下几个角度出发\n\n### 一. http协议是无状态的;\n\n当我们开发一些对状态有要求的接口时, cookie和session就可以弥补这一块的不足\n\n- 对于http协议, cookie只是请求头中的一个字段, 和别的字段并没有特别大的差别;\n- 浏览器对cookie做了默认的支持, 但是也限制了cookie; 比如同源策略;\n  - 什么是同源策略?\n    - 同源策略就是域名, 端口, 协议; 必须都相同才可以访问cookie的内容\n  - 为什么要做同源策略?\n    - 同源策略是浏览器基于安全的角度的一个机制, 限制了只有同域才可以访问cookie的内容\n\n### 二.当我们要做单点登录sso功能的时候\n\n- 什么是单点登录和sso?\n  - 单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。\n  - 最简单的例子就是, 我们是打开淘宝网的时候, 我们打开一个商品详情页有可能是是重新打开一个页面, 那我们刚刚登录的信息可能就消失了, 要是每次打开一个页面都需要登录那样会非常的麻烦\n    - 这样时候, 就需要cookie的帮助了;我们可以考虑吧域名种在可以访问的域名下, 通常都是二级域名\n      - 什么是一级, 二级, 三级....域名?\n      - 举例: www.taobao.com\n        - 一级域名是指com(又称顶级域名; [维基百科, 点我!!](https://zh.wikipedia.org/wiki/域名)\n        - 二级域名就是taobao\n        - 所以三级域名就是www\n    - 这样我们在淘宝这个域名底下的所有页面都可以畅通无阻\n    - 但是也会面临信息泄露的危险\n      - 虽然可以用时效来限制但是效果也不是很好\n      - **Secure Cookie机制**\n        - 设置了cookie只能在https上面传输不能在http上传输\n        - 但是也不是万无一失, 因为还是可以在客户端, 进行读写的;\n      - **HTTPOnly属性**\n        - Cookie的HttpOnly属性，指浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。\n        - 这样可以阻止非http的攻击, 如JavaScript\n      - **Same-Site属性**\n        - Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险。\n          - 主要是为了限制CSRF攻击\n            - 什么是CSRF攻击?\n              - 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。\n            - 还可以用于跟踪用户信息, 比如在你的网站内部放入一个你看不见的\n            - `<img src=\"facebook.com\" style=\"visibility:hidden;\">`\n            - 这样就可以知道你访问了那些网站做一些相应的推荐\n            - 那么有些同学就会联想到; 比如我在拼多多看了iPhone11; 再去看朋友圈很可能有就相应的推荐, 这些我个人猜测可能是pdd直接把你的信息卖给了腾讯, 或者做了交易(逃\n          - 具体的三个值Strict; Lax; None;感兴趣的同学可以自己去查这里就不展开了\n      - cookie又分为本地cookie和内存cookie\n        - 本地cookie与内存cookie，区别在于cookie设置的expires字段。如果没有设置过期时间，就是内存cookie。随着浏览器的关闭而从内存中消失。\n        - 还是一样都会泄露用户信息的风险\n        - 哪怕是内存cookie攻击者可以设置时效使其成为本地cookie\n\n### 三.session\n\nsession是服务器为web用户独立开辟的一个空间, 里面可以有用户一些信息等等\n\n- 如果是一个服务器可能还好, 但是如果是多个服务器或者说多层转发的话就会引发一个问题, session命中问题; 所以我们需要把信息存在MySQL或者Redis里面\n\n### 四.token\n\n除了session和cookie来辅助http这个无状态请求, 还有什么办法? \n\n- token\n  - token分为很多种, 常见的有JWT, sessionId, mac地址等等\n  - token可以存储在很多地方, 比如本地的localStorage或者sessionStorage, 然后在请求头中携带\n\n### 五.sessionStorage\n\n刚刚说到sessionStorage; 下面来说说我碰到的一个问题\n\n- sessionStorage如果打开一个新标签页, 他的sessionStorage是否共享?\n- 大家先想想再看答案\n\n以前的我以为是可以共享的.其实是半错半对的\n\n为什么这么说?\n\nMDN是这么说的\n\n> ...data stored in sessionStorage gets cleared when the page session ends...**Opening a page in a new tab or window will cause a new session to be initiated**, which differs from how session cookies work.\n\n大家可以做一个实验\n\n>1. 在浏览器中打开这个 index.html，我们称之为标签页 A。注意：需要用 http 协议打开！例如 http://localhost/index.html\n>2. 点击页面上的链接，此时会弹出来标签页 B。\n>3. 在标签页 B 中打开控制台并执行 `sessionStorage.getItem('j')`，得到 `'s'`\n>4. 新建一个新标签页 D，然后在地址栏内输入 http://localhost/index.html 打开同样的页面， 然后执行 `sessionStorage.getItem('j')` 。\n\n按照我的预期，标签页 D 得到的应该还是 `'s'`，毕竟我认为 sessionStorage 的数据是在同一网站的多个标签页之间共享的。但是**我错了**，得到的结果是 `null`。\n\n细心的同学可能已经发现了\n\n细心的同学可能已经发现了，标签页 B 和标签页 D 之间唯一的不同就是它们被打开的方式：**标签页 B 是通过在标签页 A 中点击链接打开的，但标签页 D 是在浏览器地址栏输入地址打开的。**\n\n所以现在我明白了：通过点击链接（或者用了 `window.open`）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。\n\n","source":"_posts/session和cookie的理解.md","raw":"---\ntitle: session和cookie的理解\ndate: 2020-04-11 10:31:35\ntags: [HTTP]\ncategories: [HTTP]\ncover: /image/cover/http.png\n\n---\n\n\n## 曾经的我\n\ncookie是浏览器中传输自带的; balabala...\n\nsession是存在服务端的; 存一些用户信息.......balabala....\n\n## 现在的我\n\n从以下几个角度出发\n\n### 一. http协议是无状态的;\n\n当我们开发一些对状态有要求的接口时, cookie和session就可以弥补这一块的不足\n\n- 对于http协议, cookie只是请求头中的一个字段, 和别的字段并没有特别大的差别;\n- 浏览器对cookie做了默认的支持, 但是也限制了cookie; 比如同源策略;\n  - 什么是同源策略?\n    - 同源策略就是域名, 端口, 协议; 必须都相同才可以访问cookie的内容\n  - 为什么要做同源策略?\n    - 同源策略是浏览器基于安全的角度的一个机制, 限制了只有同域才可以访问cookie的内容\n\n### 二.当我们要做单点登录sso功能的时候\n\n- 什么是单点登录和sso?\n  - 单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。\n  - 最简单的例子就是, 我们是打开淘宝网的时候, 我们打开一个商品详情页有可能是是重新打开一个页面, 那我们刚刚登录的信息可能就消失了, 要是每次打开一个页面都需要登录那样会非常的麻烦\n    - 这样时候, 就需要cookie的帮助了;我们可以考虑吧域名种在可以访问的域名下, 通常都是二级域名\n      - 什么是一级, 二级, 三级....域名?\n      - 举例: www.taobao.com\n        - 一级域名是指com(又称顶级域名; [维基百科, 点我!!](https://zh.wikipedia.org/wiki/域名)\n        - 二级域名就是taobao\n        - 所以三级域名就是www\n    - 这样我们在淘宝这个域名底下的所有页面都可以畅通无阻\n    - 但是也会面临信息泄露的危险\n      - 虽然可以用时效来限制但是效果也不是很好\n      - **Secure Cookie机制**\n        - 设置了cookie只能在https上面传输不能在http上传输\n        - 但是也不是万无一失, 因为还是可以在客户端, 进行读写的;\n      - **HTTPOnly属性**\n        - Cookie的HttpOnly属性，指浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。\n        - 这样可以阻止非http的攻击, 如JavaScript\n      - **Same-Site属性**\n        - Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险。\n          - 主要是为了限制CSRF攻击\n            - 什么是CSRF攻击?\n              - 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。\n            - 还可以用于跟踪用户信息, 比如在你的网站内部放入一个你看不见的\n            - `<img src=\"facebook.com\" style=\"visibility:hidden;\">`\n            - 这样就可以知道你访问了那些网站做一些相应的推荐\n            - 那么有些同学就会联想到; 比如我在拼多多看了iPhone11; 再去看朋友圈很可能有就相应的推荐, 这些我个人猜测可能是pdd直接把你的信息卖给了腾讯, 或者做了交易(逃\n          - 具体的三个值Strict; Lax; None;感兴趣的同学可以自己去查这里就不展开了\n      - cookie又分为本地cookie和内存cookie\n        - 本地cookie与内存cookie，区别在于cookie设置的expires字段。如果没有设置过期时间，就是内存cookie。随着浏览器的关闭而从内存中消失。\n        - 还是一样都会泄露用户信息的风险\n        - 哪怕是内存cookie攻击者可以设置时效使其成为本地cookie\n\n### 三.session\n\nsession是服务器为web用户独立开辟的一个空间, 里面可以有用户一些信息等等\n\n- 如果是一个服务器可能还好, 但是如果是多个服务器或者说多层转发的话就会引发一个问题, session命中问题; 所以我们需要把信息存在MySQL或者Redis里面\n\n### 四.token\n\n除了session和cookie来辅助http这个无状态请求, 还有什么办法? \n\n- token\n  - token分为很多种, 常见的有JWT, sessionId, mac地址等等\n  - token可以存储在很多地方, 比如本地的localStorage或者sessionStorage, 然后在请求头中携带\n\n### 五.sessionStorage\n\n刚刚说到sessionStorage; 下面来说说我碰到的一个问题\n\n- sessionStorage如果打开一个新标签页, 他的sessionStorage是否共享?\n- 大家先想想再看答案\n\n以前的我以为是可以共享的.其实是半错半对的\n\n为什么这么说?\n\nMDN是这么说的\n\n> ...data stored in sessionStorage gets cleared when the page session ends...**Opening a page in a new tab or window will cause a new session to be initiated**, which differs from how session cookies work.\n\n大家可以做一个实验\n\n>1. 在浏览器中打开这个 index.html，我们称之为标签页 A。注意：需要用 http 协议打开！例如 http://localhost/index.html\n>2. 点击页面上的链接，此时会弹出来标签页 B。\n>3. 在标签页 B 中打开控制台并执行 `sessionStorage.getItem('j')`，得到 `'s'`\n>4. 新建一个新标签页 D，然后在地址栏内输入 http://localhost/index.html 打开同样的页面， 然后执行 `sessionStorage.getItem('j')` 。\n\n按照我的预期，标签页 D 得到的应该还是 `'s'`，毕竟我认为 sessionStorage 的数据是在同一网站的多个标签页之间共享的。但是**我错了**，得到的结果是 `null`。\n\n细心的同学可能已经发现了\n\n细心的同学可能已经发现了，标签页 B 和标签页 D 之间唯一的不同就是它们被打开的方式：**标签页 B 是通过在标签页 A 中点击链接打开的，但标签页 D 是在浏览器地址栏输入地址打开的。**\n\n所以现在我明白了：通过点击链接（或者用了 `window.open`）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。\n\n","slug":"session和cookie的理解","published":1,"updated":"2021-06-24T14:00:06.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra80000ulwrd3uaf7bk4","content":"<h2 id=\"曾经的我\"><a href=\"#曾经的我\" class=\"headerlink\" title=\"曾经的我\"></a>曾经的我</h2><p>cookie是浏览器中传输自带的; balabala…</p>\n<p>session是存在服务端的; 存一些用户信息…….balabala….</p>\n<h2 id=\"现在的我\"><a href=\"#现在的我\" class=\"headerlink\" title=\"现在的我\"></a>现在的我</h2><p>从以下几个角度出发</p>\n<h3 id=\"一-http协议是无状态的\"><a href=\"#一-http协议是无状态的\" class=\"headerlink\" title=\"一. http协议是无状态的;\"></a>一. http协议是无状态的;</h3><p>当我们开发一些对状态有要求的接口时, cookie和session就可以弥补这一块的不足</p>\n<ul>\n<li>对于http协议, cookie只是请求头中的一个字段, 和别的字段并没有特别大的差别;</li>\n<li>浏览器对cookie做了默认的支持, 但是也限制了cookie; 比如同源策略;<ul>\n<li>什么是同源策略?<ul>\n<li>同源策略就是域名, 端口, 协议; 必须都相同才可以访问cookie的内容</li>\n</ul>\n</li>\n<li>为什么要做同源策略?<ul>\n<li>同源策略是浏览器基于安全的角度的一个机制, 限制了只有同域才可以访问cookie的内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二-当我们要做单点登录sso功能的时候\"><a href=\"#二-当我们要做单点登录sso功能的时候\" class=\"headerlink\" title=\"二.当我们要做单点登录sso功能的时候\"></a>二.当我们要做单点登录sso功能的时候</h3><ul>\n<li>什么是单点登录和sso?<ul>\n<li>单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。</li>\n<li>最简单的例子就是, 我们是打开淘宝网的时候, 我们打开一个商品详情页有可能是是重新打开一个页面, 那我们刚刚登录的信息可能就消失了, 要是每次打开一个页面都需要登录那样会非常的麻烦<ul>\n<li>这样时候, 就需要cookie的帮助了;我们可以考虑吧域名种在可以访问的域名下, 通常都是二级域名<ul>\n<li>什么是一级, 二级, 三级….域名?</li>\n<li>举例: <a href=\"http://www.taobao.com\" target=\"_blank\" rel=\"noopener\">www.taobao.com</a><ul>\n<li>一级域名是指com(又称顶级域名; <a href=\"https://zh.wikipedia.org/wiki/域名\" target=\"_blank\" rel=\"noopener\">维基百科, 点我!!</a></li>\n<li>二级域名就是taobao</li>\n<li>所以三级域名就是www</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>这样我们在淘宝这个域名底下的所有页面都可以畅通无阻</li>\n<li>但是也会面临信息泄露的危险<ul>\n<li>虽然可以用时效来限制但是效果也不是很好</li>\n<li><strong>Secure Cookie机制</strong><ul>\n<li>设置了cookie只能在https上面传输不能在http上传输</li>\n<li>但是也不是万无一失, 因为还是可以在客户端, 进行读写的;</li>\n</ul>\n</li>\n<li><strong>HTTPOnly属性</strong><ul>\n<li>Cookie的HttpOnly属性，指浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。</li>\n<li>这样可以阻止非http的攻击, 如JavaScript</li>\n</ul>\n</li>\n<li><strong>Same-Site属性</strong><ul>\n<li>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。<ul>\n<li>主要是为了限制CSRF攻击<ul>\n<li>什么是CSRF攻击?<ul>\n<li>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。</li>\n</ul>\n</li>\n<li>还可以用于跟踪用户信息, 比如在你的网站内部放入一个你看不见的</li>\n<li><code>&lt;img src=&quot;facebook.com&quot; style=&quot;visibility:hidden;&quot;&gt;</code></li>\n<li>这样就可以知道你访问了那些网站做一些相应的推荐</li>\n<li>那么有些同学就会联想到; 比如我在拼多多看了iPhone11; 再去看朋友圈很可能有就相应的推荐, 这些我个人猜测可能是pdd直接把你的信息卖给了腾讯, 或者做了交易(逃</li>\n</ul>\n</li>\n<li>具体的三个值Strict; Lax; None;感兴趣的同学可以自己去查这里就不展开了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>cookie又分为本地cookie和内存cookie<ul>\n<li>本地cookie与内存cookie，区别在于cookie设置的expires字段。如果没有设置过期时间，就是内存cookie。随着浏览器的关闭而从内存中消失。</li>\n<li>还是一样都会泄露用户信息的风险</li>\n<li>哪怕是内存cookie攻击者可以设置时效使其成为本地cookie</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三-session\"><a href=\"#三-session\" class=\"headerlink\" title=\"三.session\"></a>三.session</h3><p>session是服务器为web用户独立开辟的一个空间, 里面可以有用户一些信息等等</p>\n<ul>\n<li>如果是一个服务器可能还好, 但是如果是多个服务器或者说多层转发的话就会引发一个问题, session命中问题; 所以我们需要把信息存在MySQL或者Redis里面</li>\n</ul>\n<h3 id=\"四-token\"><a href=\"#四-token\" class=\"headerlink\" title=\"四.token\"></a>四.token</h3><p>除了session和cookie来辅助http这个无状态请求, 还有什么办法? </p>\n<ul>\n<li>token<ul>\n<li>token分为很多种, 常见的有JWT, sessionId, mac地址等等</li>\n<li>token可以存储在很多地方, 比如本地的localStorage或者sessionStorage, 然后在请求头中携带</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五-sessionStorage\"><a href=\"#五-sessionStorage\" class=\"headerlink\" title=\"五.sessionStorage\"></a>五.sessionStorage</h3><p>刚刚说到sessionStorage; 下面来说说我碰到的一个问题</p>\n<ul>\n<li>sessionStorage如果打开一个新标签页, 他的sessionStorage是否共享?</li>\n<li>大家先想想再看答案</li>\n</ul>\n<p>以前的我以为是可以共享的.其实是半错半对的</p>\n<p>为什么这么说?</p>\n<p>MDN是这么说的</p>\n<blockquote>\n<p>…data stored in sessionStorage gets cleared when the page session ends…<strong>Opening a page in a new tab or window will cause a new session to be initiated</strong>, which differs from how session cookies work.</p>\n</blockquote>\n<p>大家可以做一个实验</p>\n<blockquote>\n<ol>\n<li>在浏览器中打开这个 index.html，我们称之为标签页 A。注意：需要用 http 协议打开！例如 <a href=\"http://localhost/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.html</a></li>\n<li>点击页面上的链接，此时会弹出来标签页 B。</li>\n<li>在标签页 B 中打开控制台并执行 <code>sessionStorage.getItem(&#39;j&#39;)</code>，得到 <code>&#39;s&#39;</code></li>\n<li>新建一个新标签页 D，然后在地址栏内输入 <a href=\"http://localhost/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.html</a> 打开同样的页面， 然后执行 <code>sessionStorage.getItem(&#39;j&#39;)</code> 。</li>\n</ol>\n</blockquote>\n<p>按照我的预期，标签页 D 得到的应该还是 <code>&#39;s&#39;</code>，毕竟我认为 sessionStorage 的数据是在同一网站的多个标签页之间共享的。但是<strong>我错了</strong>，得到的结果是 <code>null</code>。</p>\n<p>细心的同学可能已经发现了</p>\n<p>细心的同学可能已经发现了，标签页 B 和标签页 D 之间唯一的不同就是它们被打开的方式：<strong>标签页 B 是通过在标签页 A 中点击链接打开的，但标签页 D 是在浏览器地址栏输入地址打开的。</strong></p>\n<p>所以现在我明白了：通过点击链接（或者用了 <code>window.open</code>）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"曾经的我\"><a href=\"#曾经的我\" class=\"headerlink\" title=\"曾经的我\"></a>曾经的我</h2><p>cookie是浏览器中传输自带的; balabala…</p>\n<p>session是存在服务端的; 存一些用户信息…….balabala….</p>\n<h2 id=\"现在的我\"><a href=\"#现在的我\" class=\"headerlink\" title=\"现在的我\"></a>现在的我</h2><p>从以下几个角度出发</p>\n<h3 id=\"一-http协议是无状态的\"><a href=\"#一-http协议是无状态的\" class=\"headerlink\" title=\"一. http协议是无状态的;\"></a>一. http协议是无状态的;</h3><p>当我们开发一些对状态有要求的接口时, cookie和session就可以弥补这一块的不足</p>\n<ul>\n<li>对于http协议, cookie只是请求头中的一个字段, 和别的字段并没有特别大的差别;</li>\n<li>浏览器对cookie做了默认的支持, 但是也限制了cookie; 比如同源策略;<ul>\n<li>什么是同源策略?<ul>\n<li>同源策略就是域名, 端口, 协议; 必须都相同才可以访问cookie的内容</li>\n</ul>\n</li>\n<li>为什么要做同源策略?<ul>\n<li>同源策略是浏览器基于安全的角度的一个机制, 限制了只有同域才可以访问cookie的内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二-当我们要做单点登录sso功能的时候\"><a href=\"#二-当我们要做单点登录sso功能的时候\" class=\"headerlink\" title=\"二.当我们要做单点登录sso功能的时候\"></a>二.当我们要做单点登录sso功能的时候</h3><ul>\n<li>什么是单点登录和sso?<ul>\n<li>单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。</li>\n<li>最简单的例子就是, 我们是打开淘宝网的时候, 我们打开一个商品详情页有可能是是重新打开一个页面, 那我们刚刚登录的信息可能就消失了, 要是每次打开一个页面都需要登录那样会非常的麻烦<ul>\n<li>这样时候, 就需要cookie的帮助了;我们可以考虑吧域名种在可以访问的域名下, 通常都是二级域名<ul>\n<li>什么是一级, 二级, 三级….域名?</li>\n<li>举例: <a href=\"http://www.taobao.com\" target=\"_blank\" rel=\"noopener\">www.taobao.com</a><ul>\n<li>一级域名是指com(又称顶级域名; <a href=\"https://zh.wikipedia.org/wiki/域名\" target=\"_blank\" rel=\"noopener\">维基百科, 点我!!</a></li>\n<li>二级域名就是taobao</li>\n<li>所以三级域名就是www</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>这样我们在淘宝这个域名底下的所有页面都可以畅通无阻</li>\n<li>但是也会面临信息泄露的危险<ul>\n<li>虽然可以用时效来限制但是效果也不是很好</li>\n<li><strong>Secure Cookie机制</strong><ul>\n<li>设置了cookie只能在https上面传输不能在http上传输</li>\n<li>但是也不是万无一失, 因为还是可以在客户端, 进行读写的;</li>\n</ul>\n</li>\n<li><strong>HTTPOnly属性</strong><ul>\n<li>Cookie的HttpOnly属性，指浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。</li>\n<li>这样可以阻止非http的攻击, 如JavaScript</li>\n</ul>\n</li>\n<li><strong>Same-Site属性</strong><ul>\n<li>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。<ul>\n<li>主要是为了限制CSRF攻击<ul>\n<li>什么是CSRF攻击?<ul>\n<li>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。</li>\n</ul>\n</li>\n<li>还可以用于跟踪用户信息, 比如在你的网站内部放入一个你看不见的</li>\n<li><code>&lt;img src=&quot;facebook.com&quot; style=&quot;visibility:hidden;&quot;&gt;</code></li>\n<li>这样就可以知道你访问了那些网站做一些相应的推荐</li>\n<li>那么有些同学就会联想到; 比如我在拼多多看了iPhone11; 再去看朋友圈很可能有就相应的推荐, 这些我个人猜测可能是pdd直接把你的信息卖给了腾讯, 或者做了交易(逃</li>\n</ul>\n</li>\n<li>具体的三个值Strict; Lax; None;感兴趣的同学可以自己去查这里就不展开了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>cookie又分为本地cookie和内存cookie<ul>\n<li>本地cookie与内存cookie，区别在于cookie设置的expires字段。如果没有设置过期时间，就是内存cookie。随着浏览器的关闭而从内存中消失。</li>\n<li>还是一样都会泄露用户信息的风险</li>\n<li>哪怕是内存cookie攻击者可以设置时效使其成为本地cookie</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三-session\"><a href=\"#三-session\" class=\"headerlink\" title=\"三.session\"></a>三.session</h3><p>session是服务器为web用户独立开辟的一个空间, 里面可以有用户一些信息等等</p>\n<ul>\n<li>如果是一个服务器可能还好, 但是如果是多个服务器或者说多层转发的话就会引发一个问题, session命中问题; 所以我们需要把信息存在MySQL或者Redis里面</li>\n</ul>\n<h3 id=\"四-token\"><a href=\"#四-token\" class=\"headerlink\" title=\"四.token\"></a>四.token</h3><p>除了session和cookie来辅助http这个无状态请求, 还有什么办法? </p>\n<ul>\n<li>token<ul>\n<li>token分为很多种, 常见的有JWT, sessionId, mac地址等等</li>\n<li>token可以存储在很多地方, 比如本地的localStorage或者sessionStorage, 然后在请求头中携带</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五-sessionStorage\"><a href=\"#五-sessionStorage\" class=\"headerlink\" title=\"五.sessionStorage\"></a>五.sessionStorage</h3><p>刚刚说到sessionStorage; 下面来说说我碰到的一个问题</p>\n<ul>\n<li>sessionStorage如果打开一个新标签页, 他的sessionStorage是否共享?</li>\n<li>大家先想想再看答案</li>\n</ul>\n<p>以前的我以为是可以共享的.其实是半错半对的</p>\n<p>为什么这么说?</p>\n<p>MDN是这么说的</p>\n<blockquote>\n<p>…data stored in sessionStorage gets cleared when the page session ends…<strong>Opening a page in a new tab or window will cause a new session to be initiated</strong>, which differs from how session cookies work.</p>\n</blockquote>\n<p>大家可以做一个实验</p>\n<blockquote>\n<ol>\n<li>在浏览器中打开这个 index.html，我们称之为标签页 A。注意：需要用 http 协议打开！例如 <a href=\"http://localhost/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.html</a></li>\n<li>点击页面上的链接，此时会弹出来标签页 B。</li>\n<li>在标签页 B 中打开控制台并执行 <code>sessionStorage.getItem(&#39;j&#39;)</code>，得到 <code>&#39;s&#39;</code></li>\n<li>新建一个新标签页 D，然后在地址栏内输入 <a href=\"http://localhost/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.html</a> 打开同样的页面， 然后执行 <code>sessionStorage.getItem(&#39;j&#39;)</code> 。</li>\n</ol>\n</blockquote>\n<p>按照我的预期，标签页 D 得到的应该还是 <code>&#39;s&#39;</code>，毕竟我认为 sessionStorage 的数据是在同一网站的多个标签页之间共享的。但是<strong>我错了</strong>，得到的结果是 <code>null</code>。</p>\n<p>细心的同学可能已经发现了</p>\n<p>细心的同学可能已经发现了，标签页 B 和标签页 D 之间唯一的不同就是它们被打开的方式：<strong>标签页 B 是通过在标签页 A 中点击链接打开的，但标签页 D 是在浏览器地址栏输入地址打开的。</strong></p>\n<p>所以现在我明白了：通过点击链接（或者用了 <code>window.open</code>）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。</p>\n"},{"title":"「如何给开源库提一个PR」","date":"2021-01-22T08:39:14.000Z","cover":"/image/cover/github.jpg","_content":"\n## 前言\n\n之前一直想给`github`上面优秀的项目做一些力所能及的事情，比如解决一下`issues`，或者提一个`pr`，修改一下`bug`。但是苦于一直不知道怎么正确的去做这件事情。所以搁置了，后来发现了[pro-components](https://github.com/ant-design/pro-components)这个项目，和我的理念非常契合，就是一个包装版的[ant-design](https://github.com/ant-design/ant-design)，可以更快更好的使用[ant-design](https://github.com/ant-design/ant-design)。\n\n因为一个比较出名的项目的`pr`，可能在简历筛选的时候会比较吃香，这个应该大家都知道，而且还可以混个脸熟。哈哈哈。\n\n主要是为了记录自己的操作过程，和分享。\n\n接下来会涉及到实际操作，所以请大家先点赞收藏再看。\n\n## github三个按钮\n\n我们知道，`github`上面的代码是可以直接看的，方式有以下几种：\n\n- 下载`zip`\n- `fork`到自己的项目中，然后自己`clone`下来(重点介绍，和提`pr`密切相关)\n- 直接`clone`下来\n- 在网页上直接观看\n\n\n\n我们看到`github`项目的时候，发现不仅有我们都知道的`star`，还有`watch`和`fork`。\n\n![pornhub](/image/pr/title.png)\n\n### Star\n\n这里说点废话，小伙伴有没有人和我一样英语不好，经常记成`start`的！！！\n\n`star` 翻译过来应该是星星，这里解释为`关注`或者`点赞`更合适\n\n`star`的话就相当于是我给这个项目做一个标记，或者说是给这个项目点了一个「好评」\n\n通常我们认为一个项目的受欢迎程度基本上都是由star来进行评判的。（注意！是基本上，当然还有npm的下载数，这个有点类型观看数\n\n![pornhub](/image/pr/pornhub.jpg)\n\n有点类型上图的，喜欢数（`start`，和观看次数（`npm`下载量\n\n\n\n### Watch\n\n`Watch`翻译过来可以称之为观察。\n\n默认每一个用户都是处于`Not watching`的状态，当你选择`Watching`，表示你以后会关注这个项目的所有动态，以后只要这个项目发生变动，如被别人提交了`pull request`、被别人发起了`issue`等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。\n\n如果你不想接受这些通知，那么点击` Not Watching` 即可。\n\n\n\n### Fork\n\n这里要重点说一下，因为和我们现在的主题：RP（Pull Request）息息相关。\n\n> 接下来要说的pr就是pull request\n\n当选择` fork`，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。\n\n一般来说，我们不需要使用` fork` 这个功能，至少我一般不会用，除非有一些项目，可能存在` bug` 或者可以继续优化的地方，你想帮助原项目作者去完善这个项目，那么你可以` fork `一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起 `pull request`给原项目作者了，然后就静静等待他的 `merge`。\n\n当前很多人错误的在使用` fork`。很多人把` fork `当成了收藏一样的功能，包括一开始使用 `github `的我，每次看到一个好的项目就先 `fork`，因为这样，就可以我的` repository`(仓库)列表下查看 `fork` 的项目了。\n\n> 而且还有一个问题，就是你fork的是当前，此时此刻的代码，假如后续作者更新了新的内容，你fork的就不会变，但是有一个方式可以pull到最新的代码，这个也是很重要的，不如你提交你的pr的时候，会有冲突\n\n总得来说，`fork`就是给我们提`pr`使用的。\n\n\n\n## 实操\n\n### fork项目到自己的仓库\n\n找到自己想要提pr的项目，然后点击图上的「fork」\n\n![pornhub](/image/pr/title.png)\n\n加入有Organizations（组织）的同学可能会需要选择是自己个人的项目还是的Organizations（组织）项目。\n\n选择完之后就会出现在自己的项目里面了。\n\n\n\n### clone代码到本地\n\n在自己的` repository`(仓库)里面找到刚刚`fork`的项目，通常是同名的，然后`clone`到自己的机器上面之后。\n\n\n\n### 新建分支\n\n虽然，可以不用新建分支，直接在master分支上面commit和push，但是！不符合规范，因为master分支我们接下来可能要用作于与真正的要修改的项目的master联通要用的，所以，最好是再弄一个分支来区别开来，之后操作完可以删除。\n\n理论上我们还是要符合一个过程化的规范的，虽然也可以不用这样，但是我们也可以学习别的优秀的开源代码的规范来命名，帮助自己提前感受一下大神的感觉。\n\n我们根据master分支新建完分支，然后切换分支之后就可以开始修改代码了。\n\n\n\n### 提交代码\n\n这里要说一下，一般来说，每个开源库都有自己的代码规范，比如我最近参与的[pro-components](https://github.com/ant-design/pro-components)这个项目，只需要符合他的eslint规范就好了。后面可能还会涉及到一些单元测试的问题，后面会说到。\n\n你改完之后，就需要commit了，有的项目会要求你按规范写commit message。比如[pro-components](https://github.com/ant-design/pro-components)这个项目，如图\n\n![pornhub](/image/pr/commit.png)\n\n是的，你发现了，左下角有一个跳过...最好还是要符合规范，毕竟在别人的地盘办事，而且你的所有记录都是可以查的哦，以后被人查你的pr，会发现你是一个会规范的人很加分哦！！\n\n\n\n### 开始提PR\n\n跑远了，在我们正常的`commit`， `pull `，`push`之后，就可以打开我们想修改的那个仓库。\n\n会在头顶出现一个东西。\n\n![pornhub](/image/pr/push.png)\n\n我们需要点击图中框起来的「Compare & pull request 」，之后就会出现如下图\n\n![pornhub](/image/pr/create.png)\n\n默认会帮我们选好分支的，我们只需要完善其中的信息，还有我们之前提交的message也可以修改。最好可以用英文来解释，本次提交的内容。\n\n然后点击提交之后就好了。\n\n\n\n#### 方法二\n\n我们可以直接点击\n\n![pornhub](/image/pr/pr.png)\n\n然后选择和之前一样的东西就好，具体是选择项目以及要合并的分支，然后写内容。点击提交。\n\n\n\n### 后续\n\n一个优秀项目通常会有代码审核，这个时候，你可能需要修改一下测试用例，然后我们只需要在前面创建的分支上继续`push`就好了。可能还会有作者给你的意见。改完之后继续`push`\n\n\n\n### 填坑\n\n\n\n前面说的，我们fork的只是当时的代码，后续作者更新的我们需要重新拉取，操作如下：\n\n#### 添加\n\n```\n$ git remote add upstream https://github.com/xx/xx.git\n```\n\n#### 查看\n\n```\n$ git remote -v \n\norigin\tssh://xxx (fetch)\norigin\tssh://xxx (push)\nupstream\tssh://yyy (fetch)\nupstream\tssh://yyy (push)\n```\n\n#### 取消\n\n```\n$ git branch --unset-upstream\n```\n\n#### 拉取\n\n覆盖本地的 master。\n\n```\n$ git fetch upstream\n$ git checkout master\n$ git rebase upstream/master\n```\n\n\n\n### 最后\n\n只需要等待作者`merge`啦。然后祝大家顺利，有任何问题都可以在评论区指出或者于我讨论。","source":"_posts/「如何给github提一个PR」.md","raw":"---\ntitle: 「如何给开源库提一个PR」\ndate: 2021-01-22 16:39:14\ntags: [github]\ncategories: [github]\ncover: /image/cover/github.jpg\n---\n\n## 前言\n\n之前一直想给`github`上面优秀的项目做一些力所能及的事情，比如解决一下`issues`，或者提一个`pr`，修改一下`bug`。但是苦于一直不知道怎么正确的去做这件事情。所以搁置了，后来发现了[pro-components](https://github.com/ant-design/pro-components)这个项目，和我的理念非常契合，就是一个包装版的[ant-design](https://github.com/ant-design/ant-design)，可以更快更好的使用[ant-design](https://github.com/ant-design/ant-design)。\n\n因为一个比较出名的项目的`pr`，可能在简历筛选的时候会比较吃香，这个应该大家都知道，而且还可以混个脸熟。哈哈哈。\n\n主要是为了记录自己的操作过程，和分享。\n\n接下来会涉及到实际操作，所以请大家先点赞收藏再看。\n\n## github三个按钮\n\n我们知道，`github`上面的代码是可以直接看的，方式有以下几种：\n\n- 下载`zip`\n- `fork`到自己的项目中，然后自己`clone`下来(重点介绍，和提`pr`密切相关)\n- 直接`clone`下来\n- 在网页上直接观看\n\n\n\n我们看到`github`项目的时候，发现不仅有我们都知道的`star`，还有`watch`和`fork`。\n\n![pornhub](/image/pr/title.png)\n\n### Star\n\n这里说点废话，小伙伴有没有人和我一样英语不好，经常记成`start`的！！！\n\n`star` 翻译过来应该是星星，这里解释为`关注`或者`点赞`更合适\n\n`star`的话就相当于是我给这个项目做一个标记，或者说是给这个项目点了一个「好评」\n\n通常我们认为一个项目的受欢迎程度基本上都是由star来进行评判的。（注意！是基本上，当然还有npm的下载数，这个有点类型观看数\n\n![pornhub](/image/pr/pornhub.jpg)\n\n有点类型上图的，喜欢数（`start`，和观看次数（`npm`下载量\n\n\n\n### Watch\n\n`Watch`翻译过来可以称之为观察。\n\n默认每一个用户都是处于`Not watching`的状态，当你选择`Watching`，表示你以后会关注这个项目的所有动态，以后只要这个项目发生变动，如被别人提交了`pull request`、被别人发起了`issue`等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。\n\n如果你不想接受这些通知，那么点击` Not Watching` 即可。\n\n\n\n### Fork\n\n这里要重点说一下，因为和我们现在的主题：RP（Pull Request）息息相关。\n\n> 接下来要说的pr就是pull request\n\n当选择` fork`，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。\n\n一般来说，我们不需要使用` fork` 这个功能，至少我一般不会用，除非有一些项目，可能存在` bug` 或者可以继续优化的地方，你想帮助原项目作者去完善这个项目，那么你可以` fork `一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起 `pull request`给原项目作者了，然后就静静等待他的 `merge`。\n\n当前很多人错误的在使用` fork`。很多人把` fork `当成了收藏一样的功能，包括一开始使用 `github `的我，每次看到一个好的项目就先 `fork`，因为这样，就可以我的` repository`(仓库)列表下查看 `fork` 的项目了。\n\n> 而且还有一个问题，就是你fork的是当前，此时此刻的代码，假如后续作者更新了新的内容，你fork的就不会变，但是有一个方式可以pull到最新的代码，这个也是很重要的，不如你提交你的pr的时候，会有冲突\n\n总得来说，`fork`就是给我们提`pr`使用的。\n\n\n\n## 实操\n\n### fork项目到自己的仓库\n\n找到自己想要提pr的项目，然后点击图上的「fork」\n\n![pornhub](/image/pr/title.png)\n\n加入有Organizations（组织）的同学可能会需要选择是自己个人的项目还是的Organizations（组织）项目。\n\n选择完之后就会出现在自己的项目里面了。\n\n\n\n### clone代码到本地\n\n在自己的` repository`(仓库)里面找到刚刚`fork`的项目，通常是同名的，然后`clone`到自己的机器上面之后。\n\n\n\n### 新建分支\n\n虽然，可以不用新建分支，直接在master分支上面commit和push，但是！不符合规范，因为master分支我们接下来可能要用作于与真正的要修改的项目的master联通要用的，所以，最好是再弄一个分支来区别开来，之后操作完可以删除。\n\n理论上我们还是要符合一个过程化的规范的，虽然也可以不用这样，但是我们也可以学习别的优秀的开源代码的规范来命名，帮助自己提前感受一下大神的感觉。\n\n我们根据master分支新建完分支，然后切换分支之后就可以开始修改代码了。\n\n\n\n### 提交代码\n\n这里要说一下，一般来说，每个开源库都有自己的代码规范，比如我最近参与的[pro-components](https://github.com/ant-design/pro-components)这个项目，只需要符合他的eslint规范就好了。后面可能还会涉及到一些单元测试的问题，后面会说到。\n\n你改完之后，就需要commit了，有的项目会要求你按规范写commit message。比如[pro-components](https://github.com/ant-design/pro-components)这个项目，如图\n\n![pornhub](/image/pr/commit.png)\n\n是的，你发现了，左下角有一个跳过...最好还是要符合规范，毕竟在别人的地盘办事，而且你的所有记录都是可以查的哦，以后被人查你的pr，会发现你是一个会规范的人很加分哦！！\n\n\n\n### 开始提PR\n\n跑远了，在我们正常的`commit`， `pull `，`push`之后，就可以打开我们想修改的那个仓库。\n\n会在头顶出现一个东西。\n\n![pornhub](/image/pr/push.png)\n\n我们需要点击图中框起来的「Compare & pull request 」，之后就会出现如下图\n\n![pornhub](/image/pr/create.png)\n\n默认会帮我们选好分支的，我们只需要完善其中的信息，还有我们之前提交的message也可以修改。最好可以用英文来解释，本次提交的内容。\n\n然后点击提交之后就好了。\n\n\n\n#### 方法二\n\n我们可以直接点击\n\n![pornhub](/image/pr/pr.png)\n\n然后选择和之前一样的东西就好，具体是选择项目以及要合并的分支，然后写内容。点击提交。\n\n\n\n### 后续\n\n一个优秀项目通常会有代码审核，这个时候，你可能需要修改一下测试用例，然后我们只需要在前面创建的分支上继续`push`就好了。可能还会有作者给你的意见。改完之后继续`push`\n\n\n\n### 填坑\n\n\n\n前面说的，我们fork的只是当时的代码，后续作者更新的我们需要重新拉取，操作如下：\n\n#### 添加\n\n```\n$ git remote add upstream https://github.com/xx/xx.git\n```\n\n#### 查看\n\n```\n$ git remote -v \n\norigin\tssh://xxx (fetch)\norigin\tssh://xxx (push)\nupstream\tssh://yyy (fetch)\nupstream\tssh://yyy (push)\n```\n\n#### 取消\n\n```\n$ git branch --unset-upstream\n```\n\n#### 拉取\n\n覆盖本地的 master。\n\n```\n$ git fetch upstream\n$ git checkout master\n$ git rebase upstream/master\n```\n\n\n\n### 最后\n\n只需要等待作者`merge`啦。然后祝大家顺利，有任何问题都可以在评论区指出或者于我讨论。","slug":"「如何给github提一个PR」","published":1,"updated":"2021-06-24T14:00:06.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra81000wlwrdbwstad04","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前一直想给<code>github</code>上面优秀的项目做一些力所能及的事情，比如解决一下<code>issues</code>，或者提一个<code>pr</code>，修改一下<code>bug</code>。但是苦于一直不知道怎么正确的去做这件事情。所以搁置了，后来发现了<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，和我的理念非常契合，就是一个包装版的<a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">ant-design</a>，可以更快更好的使用<a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">ant-design</a>。</p>\n<p>因为一个比较出名的项目的<code>pr</code>，可能在简历筛选的时候会比较吃香，这个应该大家都知道，而且还可以混个脸熟。哈哈哈。</p>\n<p>主要是为了记录自己的操作过程，和分享。</p>\n<p>接下来会涉及到实际操作，所以请大家先点赞收藏再看。</p>\n<h2 id=\"github三个按钮\"><a href=\"#github三个按钮\" class=\"headerlink\" title=\"github三个按钮\"></a>github三个按钮</h2><p>我们知道，<code>github</code>上面的代码是可以直接看的，方式有以下几种：</p>\n<ul>\n<li>下载<code>zip</code></li>\n<li><code>fork</code>到自己的项目中，然后自己<code>clone</code>下来(重点介绍，和提<code>pr</code>密切相关)</li>\n<li>直接<code>clone</code>下来</li>\n<li>在网页上直接观看</li>\n</ul>\n<p>我们看到<code>github</code>项目的时候，发现不仅有我们都知道的<code>star</code>，还有<code>watch</code>和<code>fork</code>。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/title.png\"  alt=\"pornhub\"></p>\n<h3 id=\"Star\"><a href=\"#Star\" class=\"headerlink\" title=\"Star\"></a>Star</h3><p>这里说点废话，小伙伴有没有人和我一样英语不好，经常记成<code>start</code>的！！！</p>\n<p><code>star</code> 翻译过来应该是星星，这里解释为<code>关注</code>或者<code>点赞</code>更合适</p>\n<p><code>star</code>的话就相当于是我给这个项目做一个标记，或者说是给这个项目点了一个「好评」</p>\n<p>通常我们认为一个项目的受欢迎程度基本上都是由star来进行评判的。（注意！是基本上，当然还有npm的下载数，这个有点类型观看数</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/pornhub.jpg\"  alt=\"pornhub\"></p>\n<p>有点类型上图的，喜欢数（<code>start</code>，和观看次数（<code>npm</code>下载量</p>\n<h3 id=\"Watch\"><a href=\"#Watch\" class=\"headerlink\" title=\"Watch\"></a>Watch</h3><p><code>Watch</code>翻译过来可以称之为观察。</p>\n<p>默认每一个用户都是处于<code>Not watching</code>的状态，当你选择<code>Watching</code>，表示你以后会关注这个项目的所有动态，以后只要这个项目发生变动，如被别人提交了<code>pull request</code>、被别人发起了<code>issue</code>等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。</p>\n<p>如果你不想接受这些通知，那么点击<code>Not Watching</code> 即可。</p>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><p>这里要重点说一下，因为和我们现在的主题：RP（Pull Request）息息相关。</p>\n<blockquote>\n<p>接下来要说的pr就是pull request</p>\n</blockquote>\n<p>当选择<code>fork</code>，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。</p>\n<p>一般来说，我们不需要使用<code>fork</code> 这个功能，至少我一般不会用，除非有一些项目，可能存在<code>bug</code> 或者可以继续优化的地方，你想帮助原项目作者去完善这个项目，那么你可以<code>fork</code>一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起 <code>pull request</code>给原项目作者了，然后就静静等待他的 <code>merge</code>。</p>\n<p>当前很多人错误的在使用<code>fork</code>。很多人把<code>fork</code>当成了收藏一样的功能，包括一开始使用 <code>github</code>的我，每次看到一个好的项目就先 <code>fork</code>，因为这样，就可以我的<code>repository</code>(仓库)列表下查看 <code>fork</code> 的项目了。</p>\n<blockquote>\n<p>而且还有一个问题，就是你fork的是当前，此时此刻的代码，假如后续作者更新了新的内容，你fork的就不会变，但是有一个方式可以pull到最新的代码，这个也是很重要的，不如你提交你的pr的时候，会有冲突</p>\n</blockquote>\n<p>总得来说，<code>fork</code>就是给我们提<code>pr</code>使用的。</p>\n<h2 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h2><h3 id=\"fork项目到自己的仓库\"><a href=\"#fork项目到自己的仓库\" class=\"headerlink\" title=\"fork项目到自己的仓库\"></a>fork项目到自己的仓库</h3><p>找到自己想要提pr的项目，然后点击图上的「fork」</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/title.png\"  alt=\"pornhub\"></p>\n<p>加入有Organizations（组织）的同学可能会需要选择是自己个人的项目还是的Organizations（组织）项目。</p>\n<p>选择完之后就会出现在自己的项目里面了。</p>\n<h3 id=\"clone代码到本地\"><a href=\"#clone代码到本地\" class=\"headerlink\" title=\"clone代码到本地\"></a>clone代码到本地</h3><p>在自己的<code>repository</code>(仓库)里面找到刚刚<code>fork</code>的项目，通常是同名的，然后<code>clone</code>到自己的机器上面之后。</p>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>虽然，可以不用新建分支，直接在master分支上面commit和push，但是！不符合规范，因为master分支我们接下来可能要用作于与真正的要修改的项目的master联通要用的，所以，最好是再弄一个分支来区别开来，之后操作完可以删除。</p>\n<p>理论上我们还是要符合一个过程化的规范的，虽然也可以不用这样，但是我们也可以学习别的优秀的开源代码的规范来命名，帮助自己提前感受一下大神的感觉。</p>\n<p>我们根据master分支新建完分支，然后切换分支之后就可以开始修改代码了。</p>\n<h3 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h3><p>这里要说一下，一般来说，每个开源库都有自己的代码规范，比如我最近参与的<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，只需要符合他的eslint规范就好了。后面可能还会涉及到一些单元测试的问题，后面会说到。</p>\n<p>你改完之后，就需要commit了，有的项目会要求你按规范写commit message。比如<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，如图</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/commit.png\"  alt=\"pornhub\"></p>\n<p>是的，你发现了，左下角有一个跳过…最好还是要符合规范，毕竟在别人的地盘办事，而且你的所有记录都是可以查的哦，以后被人查你的pr，会发现你是一个会规范的人很加分哦！！</p>\n<h3 id=\"开始提PR\"><a href=\"#开始提PR\" class=\"headerlink\" title=\"开始提PR\"></a>开始提PR</h3><p>跑远了，在我们正常的<code>commit</code>， <code>pull</code>，<code>push</code>之后，就可以打开我们想修改的那个仓库。</p>\n<p>会在头顶出现一个东西。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/push.png\"  alt=\"pornhub\"></p>\n<p>我们需要点击图中框起来的「Compare &amp; pull request 」，之后就会出现如下图</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/create.png\"  alt=\"pornhub\"></p>\n<p>默认会帮我们选好分支的，我们只需要完善其中的信息，还有我们之前提交的message也可以修改。最好可以用英文来解释，本次提交的内容。</p>\n<p>然后点击提交之后就好了。</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>我们可以直接点击</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/pr/pr.png\"  alt=\"pornhub\"></p>\n<p>然后选择和之前一样的东西就好，具体是选择项目以及要合并的分支，然后写内容。点击提交。</p>\n<h3 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h3><p>一个优秀项目通常会有代码审核，这个时候，你可能需要修改一下测试用例，然后我们只需要在前面创建的分支上继续<code>push</code>就好了。可能还会有作者给你的意见。改完之后继续<code>push</code></p>\n<h3 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h3><p>前面说的，我们fork的只是当时的代码，后续作者更新的我们需要重新拉取，操作如下：</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add upstream https:&#x2F;&#x2F;github.com&#x2F;xx&#x2F;xx.git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v </span><br><span class=\"line\"></span><br><span class=\"line\">origin\tssh:&#x2F;&#x2F;xxx (fetch)</span><br><span class=\"line\">origin\tssh:&#x2F;&#x2F;xxx (push)</span><br><span class=\"line\">upstream\tssh:&#x2F;&#x2F;yyy (fetch)</span><br><span class=\"line\">upstream\tssh:&#x2F;&#x2F;yyy (push)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"取消\"><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --unset-upstream</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拉取\"><a href=\"#拉取\" class=\"headerlink\" title=\"拉取\"></a>拉取</h4><p>覆盖本地的 master。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch upstream</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git rebase upstream&#x2F;master</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>只需要等待作者<code>merge</code>啦。然后祝大家顺利，有任何问题都可以在评论区指出或者于我讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前一直想给<code>github</code>上面优秀的项目做一些力所能及的事情，比如解决一下<code>issues</code>，或者提一个<code>pr</code>，修改一下<code>bug</code>。但是苦于一直不知道怎么正确的去做这件事情。所以搁置了，后来发现了<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，和我的理念非常契合，就是一个包装版的<a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">ant-design</a>，可以更快更好的使用<a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">ant-design</a>。</p>\n<p>因为一个比较出名的项目的<code>pr</code>，可能在简历筛选的时候会比较吃香，这个应该大家都知道，而且还可以混个脸熟。哈哈哈。</p>\n<p>主要是为了记录自己的操作过程，和分享。</p>\n<p>接下来会涉及到实际操作，所以请大家先点赞收藏再看。</p>\n<h2 id=\"github三个按钮\"><a href=\"#github三个按钮\" class=\"headerlink\" title=\"github三个按钮\"></a>github三个按钮</h2><p>我们知道，<code>github</code>上面的代码是可以直接看的，方式有以下几种：</p>\n<ul>\n<li>下载<code>zip</code></li>\n<li><code>fork</code>到自己的项目中，然后自己<code>clone</code>下来(重点介绍，和提<code>pr</code>密切相关)</li>\n<li>直接<code>clone</code>下来</li>\n<li>在网页上直接观看</li>\n</ul>\n<p>我们看到<code>github</code>项目的时候，发现不仅有我们都知道的<code>star</code>，还有<code>watch</code>和<code>fork</code>。</p>\n<p><img src=\"/image/pr/title.png\" alt=\"pornhub\"></p>\n<h3 id=\"Star\"><a href=\"#Star\" class=\"headerlink\" title=\"Star\"></a>Star</h3><p>这里说点废话，小伙伴有没有人和我一样英语不好，经常记成<code>start</code>的！！！</p>\n<p><code>star</code> 翻译过来应该是星星，这里解释为<code>关注</code>或者<code>点赞</code>更合适</p>\n<p><code>star</code>的话就相当于是我给这个项目做一个标记，或者说是给这个项目点了一个「好评」</p>\n<p>通常我们认为一个项目的受欢迎程度基本上都是由star来进行评判的。（注意！是基本上，当然还有npm的下载数，这个有点类型观看数</p>\n<p><img src=\"/image/pr/pornhub.jpg\" alt=\"pornhub\"></p>\n<p>有点类型上图的，喜欢数（<code>start</code>，和观看次数（<code>npm</code>下载量</p>\n<h3 id=\"Watch\"><a href=\"#Watch\" class=\"headerlink\" title=\"Watch\"></a>Watch</h3><p><code>Watch</code>翻译过来可以称之为观察。</p>\n<p>默认每一个用户都是处于<code>Not watching</code>的状态，当你选择<code>Watching</code>，表示你以后会关注这个项目的所有动态，以后只要这个项目发生变动，如被别人提交了<code>pull request</code>、被别人发起了<code>issue</code>等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。</p>\n<p>如果你不想接受这些通知，那么点击<code>Not Watching</code> 即可。</p>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><p>这里要重点说一下，因为和我们现在的主题：RP（Pull Request）息息相关。</p>\n<blockquote>\n<p>接下来要说的pr就是pull request</p>\n</blockquote>\n<p>当选择<code>fork</code>，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。</p>\n<p>一般来说，我们不需要使用<code>fork</code> 这个功能，至少我一般不会用，除非有一些项目，可能存在<code>bug</code> 或者可以继续优化的地方，你想帮助原项目作者去完善这个项目，那么你可以<code>fork</code>一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起 <code>pull request</code>给原项目作者了，然后就静静等待他的 <code>merge</code>。</p>\n<p>当前很多人错误的在使用<code>fork</code>。很多人把<code>fork</code>当成了收藏一样的功能，包括一开始使用 <code>github</code>的我，每次看到一个好的项目就先 <code>fork</code>，因为这样，就可以我的<code>repository</code>(仓库)列表下查看 <code>fork</code> 的项目了。</p>\n<blockquote>\n<p>而且还有一个问题，就是你fork的是当前，此时此刻的代码，假如后续作者更新了新的内容，你fork的就不会变，但是有一个方式可以pull到最新的代码，这个也是很重要的，不如你提交你的pr的时候，会有冲突</p>\n</blockquote>\n<p>总得来说，<code>fork</code>就是给我们提<code>pr</code>使用的。</p>\n<h2 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h2><h3 id=\"fork项目到自己的仓库\"><a href=\"#fork项目到自己的仓库\" class=\"headerlink\" title=\"fork项目到自己的仓库\"></a>fork项目到自己的仓库</h3><p>找到自己想要提pr的项目，然后点击图上的「fork」</p>\n<p><img src=\"/image/pr/title.png\" alt=\"pornhub\"></p>\n<p>加入有Organizations（组织）的同学可能会需要选择是自己个人的项目还是的Organizations（组织）项目。</p>\n<p>选择完之后就会出现在自己的项目里面了。</p>\n<h3 id=\"clone代码到本地\"><a href=\"#clone代码到本地\" class=\"headerlink\" title=\"clone代码到本地\"></a>clone代码到本地</h3><p>在自己的<code>repository</code>(仓库)里面找到刚刚<code>fork</code>的项目，通常是同名的，然后<code>clone</code>到自己的机器上面之后。</p>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>虽然，可以不用新建分支，直接在master分支上面commit和push，但是！不符合规范，因为master分支我们接下来可能要用作于与真正的要修改的项目的master联通要用的，所以，最好是再弄一个分支来区别开来，之后操作完可以删除。</p>\n<p>理论上我们还是要符合一个过程化的规范的，虽然也可以不用这样，但是我们也可以学习别的优秀的开源代码的规范来命名，帮助自己提前感受一下大神的感觉。</p>\n<p>我们根据master分支新建完分支，然后切换分支之后就可以开始修改代码了。</p>\n<h3 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h3><p>这里要说一下，一般来说，每个开源库都有自己的代码规范，比如我最近参与的<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，只需要符合他的eslint规范就好了。后面可能还会涉及到一些单元测试的问题，后面会说到。</p>\n<p>你改完之后，就需要commit了，有的项目会要求你按规范写commit message。比如<a href=\"https://github.com/ant-design/pro-components\" target=\"_blank\" rel=\"noopener\">pro-components</a>这个项目，如图</p>\n<p><img src=\"/image/pr/commit.png\" alt=\"pornhub\"></p>\n<p>是的，你发现了，左下角有一个跳过…最好还是要符合规范，毕竟在别人的地盘办事，而且你的所有记录都是可以查的哦，以后被人查你的pr，会发现你是一个会规范的人很加分哦！！</p>\n<h3 id=\"开始提PR\"><a href=\"#开始提PR\" class=\"headerlink\" title=\"开始提PR\"></a>开始提PR</h3><p>跑远了，在我们正常的<code>commit</code>， <code>pull</code>，<code>push</code>之后，就可以打开我们想修改的那个仓库。</p>\n<p>会在头顶出现一个东西。</p>\n<p><img src=\"/image/pr/push.png\" alt=\"pornhub\"></p>\n<p>我们需要点击图中框起来的「Compare &amp; pull request 」，之后就会出现如下图</p>\n<p><img src=\"/image/pr/create.png\" alt=\"pornhub\"></p>\n<p>默认会帮我们选好分支的，我们只需要完善其中的信息，还有我们之前提交的message也可以修改。最好可以用英文来解释，本次提交的内容。</p>\n<p>然后点击提交之后就好了。</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>我们可以直接点击</p>\n<p><img src=\"/image/pr/pr.png\" alt=\"pornhub\"></p>\n<p>然后选择和之前一样的东西就好，具体是选择项目以及要合并的分支，然后写内容。点击提交。</p>\n<h3 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h3><p>一个优秀项目通常会有代码审核，这个时候，你可能需要修改一下测试用例，然后我们只需要在前面创建的分支上继续<code>push</code>就好了。可能还会有作者给你的意见。改完之后继续<code>push</code></p>\n<h3 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h3><p>前面说的，我们fork的只是当时的代码，后续作者更新的我们需要重新拉取，操作如下：</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add upstream https:&#x2F;&#x2F;github.com&#x2F;xx&#x2F;xx.git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v </span><br><span class=\"line\"></span><br><span class=\"line\">origin\tssh:&#x2F;&#x2F;xxx (fetch)</span><br><span class=\"line\">origin\tssh:&#x2F;&#x2F;xxx (push)</span><br><span class=\"line\">upstream\tssh:&#x2F;&#x2F;yyy (fetch)</span><br><span class=\"line\">upstream\tssh:&#x2F;&#x2F;yyy (push)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"取消\"><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --unset-upstream</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拉取\"><a href=\"#拉取\" class=\"headerlink\" title=\"拉取\"></a>拉取</h4><p>覆盖本地的 master。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch upstream</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git rebase upstream&#x2F;master</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>只需要等待作者<code>merge</code>啦。然后祝大家顺利，有任何问题都可以在评论区指出或者于我讨论。</p>\n"},{"title":"sprng boot 跨域 过滤器 fetch react Response to preflight request doesn't pass access control check","date":"2019-06-19T03:20:11.000Z","cover":"/image/cover/springboot.png","_content":"\n## 前言\n浏览器出于安全考虑，限制了JS发起跨站请求，使用XHR对象发起请求必须遵循同源策略（SOP：Same Origin Policy），跨站请求会被浏览器阻止，这对开发者来说是很痛苦的一件事，尤其是要开发前后端分离的应用时。\n\n在现代化的Web开发中，不同网络环境下的资源数据共享越来越普遍，同源策略可以说是在一定程度上限制了Web API的发展。\n\n简单的说，CORS就是为了请求能够安全跨域而生的。至于CORS的安全性研究，本文不做探讨。\n\n\n## CORS浅述\n名词解释：跨域资源共享（Cross-Origin Resource Sharing）\n\n概念：是一种跨域机制、规范、标准，怎么叫都一样，但是这套标准是针对服务端的，而浏览器端只要支持HTML5即可。\n\n作用：可以让服务端决定哪些请求源可以进来拿数据，所以服务端起主导作用（所以出了事找后台程序猿，无关前端^ ^）\n\n常用场景：\n\n - 前后端完全分离的应用\n\n## 服务端未允许跨域\n\n![服务端未允许跨域](/image/SpringBoot跨域/20190311105909443.png?raw=true)\n\n## 如何解决\n\n```\npackage pers.yiji.YiJiClientServer.util;\n\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\n@Configuration\npublic class CorsConfig {\n\n    /**\n     * cors support\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean corsFilter() {\n        // 注册CORS过滤器\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true); // 是否支持安全证书\n        config.addAllowedOrigin(\"*\"); // 允许任何域名使用\n        config.addAllowedHeader(\"*\"); // 允许任何头\n        config.addAllowedMethod(\"*\"); // 允许任何方法（post、get等）\n        // 预检请求的有效期，单位为秒。\n        //        config.setMaxAge(3600L);\n\n        source.registerCorsConfiguration(\"/**\", config);\n        FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));\n        bean.setOrder(0);\n        return bean;\n    }\n}\n```\n\n具体每句话的意思基本上注释都有写。\n\n主要就是为了注册一个过滤器，这里是基本上允许所有的请求，在特殊的场景可以使用域名控制等。\n\n```\nconfig.addAllowedOrigin(\"*\"); // 允许任何域名使用（*可以换成特定的域名）\n```\n\n\n## 结果\n![在这里插入图片描述](/image/SpringBoot跨域/20190311110721789.png?raw=true)\n\n![在这里插入图片描述](/image/SpringBoot跨域/20190311110735834.png?raw=true)\n","source":"_posts/sprng-boot-跨域-过滤器-fetch-react-Response-to-preflight-request-doesn-t-pass-access-control-check.md","raw":"---\ntitle: >-\n  sprng boot 跨域 过滤器 fetch react Response to preflight request doesn't pass\n  access control check\ndate: 2019-06-19 11:20:11\ntags: [Spring-Boot, 跨域, Java]\ncategory: [Java, Spring-Boot]\ncover: /image/cover/springboot.png\n---\n\n## 前言\n浏览器出于安全考虑，限制了JS发起跨站请求，使用XHR对象发起请求必须遵循同源策略（SOP：Same Origin Policy），跨站请求会被浏览器阻止，这对开发者来说是很痛苦的一件事，尤其是要开发前后端分离的应用时。\n\n在现代化的Web开发中，不同网络环境下的资源数据共享越来越普遍，同源策略可以说是在一定程度上限制了Web API的发展。\n\n简单的说，CORS就是为了请求能够安全跨域而生的。至于CORS的安全性研究，本文不做探讨。\n\n\n## CORS浅述\n名词解释：跨域资源共享（Cross-Origin Resource Sharing）\n\n概念：是一种跨域机制、规范、标准，怎么叫都一样，但是这套标准是针对服务端的，而浏览器端只要支持HTML5即可。\n\n作用：可以让服务端决定哪些请求源可以进来拿数据，所以服务端起主导作用（所以出了事找后台程序猿，无关前端^ ^）\n\n常用场景：\n\n - 前后端完全分离的应用\n\n## 服务端未允许跨域\n\n![服务端未允许跨域](/image/SpringBoot跨域/20190311105909443.png?raw=true)\n\n## 如何解决\n\n```\npackage pers.yiji.YiJiClientServer.util;\n\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\n@Configuration\npublic class CorsConfig {\n\n    /**\n     * cors support\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean corsFilter() {\n        // 注册CORS过滤器\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true); // 是否支持安全证书\n        config.addAllowedOrigin(\"*\"); // 允许任何域名使用\n        config.addAllowedHeader(\"*\"); // 允许任何头\n        config.addAllowedMethod(\"*\"); // 允许任何方法（post、get等）\n        // 预检请求的有效期，单位为秒。\n        //        config.setMaxAge(3600L);\n\n        source.registerCorsConfiguration(\"/**\", config);\n        FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));\n        bean.setOrder(0);\n        return bean;\n    }\n}\n```\n\n具体每句话的意思基本上注释都有写。\n\n主要就是为了注册一个过滤器，这里是基本上允许所有的请求，在特殊的场景可以使用域名控制等。\n\n```\nconfig.addAllowedOrigin(\"*\"); // 允许任何域名使用（*可以换成特定的域名）\n```\n\n\n## 结果\n![在这里插入图片描述](/image/SpringBoot跨域/20190311110721789.png?raw=true)\n\n![在这里插入图片描述](/image/SpringBoot跨域/20190311110735834.png?raw=true)\n","slug":"sprng-boot-跨域-过滤器-fetch-react-Response-to-preflight-request-doesn-t-pass-access-control-check","published":1,"updated":"2021-06-24T14:00:06.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra830010lwrd3lxe3i50","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>浏览器出于安全考虑，限制了JS发起跨站请求，使用XHR对象发起请求必须遵循同源策略（SOP：Same Origin Policy），跨站请求会被浏览器阻止，这对开发者来说是很痛苦的一件事，尤其是要开发前后端分离的应用时。</p>\n<p>在现代化的Web开发中，不同网络环境下的资源数据共享越来越普遍，同源策略可以说是在一定程度上限制了Web API的发展。</p>\n<p>简单的说，CORS就是为了请求能够安全跨域而生的。至于CORS的安全性研究，本文不做探讨。</p>\n<h2 id=\"CORS浅述\"><a href=\"#CORS浅述\" class=\"headerlink\" title=\"CORS浅述\"></a>CORS浅述</h2><p>名词解释：跨域资源共享（Cross-Origin Resource Sharing）</p>\n<p>概念：是一种跨域机制、规范、标准，怎么叫都一样，但是这套标准是针对服务端的，而浏览器端只要支持HTML5即可。</p>\n<p>作用：可以让服务端决定哪些请求源可以进来拿数据，所以服务端起主导作用（所以出了事找后台程序猿，无关前端^ ^）</p>\n<p>常用场景：</p>\n<ul>\n<li>前后端完全分离的应用</li>\n</ul>\n<h2 id=\"服务端未允许跨域\"><a href=\"#服务端未允许跨域\" class=\"headerlink\" title=\"服务端未允许跨域\"></a>服务端未允许跨域</h2><p><img src=\"/\" class=\"lazyload\" data-src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311105909443.png?raw=true\"  alt=\"服务端未允许跨域\"></p>\n<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package pers.yiji.YiJiClientServer.util;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.web.cors.CorsConfiguration;</span><br><span class=\"line\">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class=\"line\">import org.springframework.web.filter.CorsFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class CorsConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * cors support</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FilterRegistrationBean corsFilter() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 注册CORS过滤器</span><br><span class=\"line\">        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class=\"line\">        config.setAllowCredentials(true); &#x2F;&#x2F; 是否支持安全证书</span><br><span class=\"line\">        config.addAllowedOrigin(&quot;*&quot;); &#x2F;&#x2F; 允许任何域名使用</span><br><span class=\"line\">        config.addAllowedHeader(&quot;*&quot;); &#x2F;&#x2F; 允许任何头</span><br><span class=\"line\">        config.addAllowedMethod(&quot;*&quot;); &#x2F;&#x2F; 允许任何方法（post、get等）</span><br><span class=\"line\">        &#x2F;&#x2F; 预检请求的有效期，单位为秒。</span><br><span class=\"line\">        &#x2F;&#x2F;        config.setMaxAge(3600L);</span><br><span class=\"line\"></span><br><span class=\"line\">        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class=\"line\">        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(new CorsFilter(source));</span><br><span class=\"line\">        bean.setOrder(0);</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体每句话的意思基本上注释都有写。</p>\n<p>主要就是为了注册一个过滤器，这里是基本上允许所有的请求，在特殊的场景可以使用域名控制等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.addAllowedOrigin(&quot;*&quot;); &#x2F;&#x2F; 允许任何域名使用（*可以换成特定的域名）</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"/\" class=\"lazyload\" data-src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311110721789.png?raw=true\"  alt=\"在这里插入图片描述\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311110735834.png?raw=true\"  alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>浏览器出于安全考虑，限制了JS发起跨站请求，使用XHR对象发起请求必须遵循同源策略（SOP：Same Origin Policy），跨站请求会被浏览器阻止，这对开发者来说是很痛苦的一件事，尤其是要开发前后端分离的应用时。</p>\n<p>在现代化的Web开发中，不同网络环境下的资源数据共享越来越普遍，同源策略可以说是在一定程度上限制了Web API的发展。</p>\n<p>简单的说，CORS就是为了请求能够安全跨域而生的。至于CORS的安全性研究，本文不做探讨。</p>\n<h2 id=\"CORS浅述\"><a href=\"#CORS浅述\" class=\"headerlink\" title=\"CORS浅述\"></a>CORS浅述</h2><p>名词解释：跨域资源共享（Cross-Origin Resource Sharing）</p>\n<p>概念：是一种跨域机制、规范、标准，怎么叫都一样，但是这套标准是针对服务端的，而浏览器端只要支持HTML5即可。</p>\n<p>作用：可以让服务端决定哪些请求源可以进来拿数据，所以服务端起主导作用（所以出了事找后台程序猿，无关前端^ ^）</p>\n<p>常用场景：</p>\n<ul>\n<li>前后端完全分离的应用</li>\n</ul>\n<h2 id=\"服务端未允许跨域\"><a href=\"#服务端未允许跨域\" class=\"headerlink\" title=\"服务端未允许跨域\"></a>服务端未允许跨域</h2><p><img src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311105909443.png?raw=true\" alt=\"服务端未允许跨域\"></p>\n<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package pers.yiji.YiJiClientServer.util;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.web.cors.CorsConfiguration;</span><br><span class=\"line\">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class=\"line\">import org.springframework.web.filter.CorsFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class CorsConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * cors support</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FilterRegistrationBean corsFilter() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 注册CORS过滤器</span><br><span class=\"line\">        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class=\"line\">        config.setAllowCredentials(true); &#x2F;&#x2F; 是否支持安全证书</span><br><span class=\"line\">        config.addAllowedOrigin(&quot;*&quot;); &#x2F;&#x2F; 允许任何域名使用</span><br><span class=\"line\">        config.addAllowedHeader(&quot;*&quot;); &#x2F;&#x2F; 允许任何头</span><br><span class=\"line\">        config.addAllowedMethod(&quot;*&quot;); &#x2F;&#x2F; 允许任何方法（post、get等）</span><br><span class=\"line\">        &#x2F;&#x2F; 预检请求的有效期，单位为秒。</span><br><span class=\"line\">        &#x2F;&#x2F;        config.setMaxAge(3600L);</span><br><span class=\"line\"></span><br><span class=\"line\">        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class=\"line\">        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(new CorsFilter(source));</span><br><span class=\"line\">        bean.setOrder(0);</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体每句话的意思基本上注释都有写。</p>\n<p>主要就是为了注册一个过滤器，这里是基本上允许所有的请求，在特殊的场景可以使用域名控制等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.addAllowedOrigin(&quot;*&quot;); &#x2F;&#x2F; 允许任何域名使用（*可以换成特定的域名）</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311110721789.png?raw=true\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"/image/SpringBoot%E8%B7%A8%E5%9F%9F/20190311110735834.png?raw=true\" alt=\"在这里插入图片描述\"></p>\n"},{"date":"2021-03-29T02:08:31.000Z","cover":"/image/cover/react.png","_content":"\n# 前言\n\n一些废话和个人感悟，看干货的直接跳过....到`jsx`\n\n重识前端断断续续也写了大半年了。里面基本上都是个人技术栈的积累，以及面试题的回答。感兴趣的伙伴可以点到我的主页去看。\n\n说说今天的主角-`React`吧。`React`的源码之前一直想要去阅读学习的，也确确实实在看了，但是经常看着看着就发困。然后就开始偷懒，从一些周边的开始阅读，比如`React-Router`，`React-Redux`之类的。之前都是看完之后再开始写文章。现在想一边看一边写，换个方式看看。如果有写错的地方欢迎大家讨论，如果觉得还可以的话可以点个赞，谢谢！\n\n作为一名`React`的重度使用者和爱好者。我将会和大家一起从「使用者」到「了解者」进步！\n\n# React的相关信息\n\n## 功利的角度\n\n打开招聘软件，现在基本上的大厂，甚至是外包公司都普遍要求你会`React`或者`Vue`。给出的薪资也是非常的诱人。\n\n（图片来自Boss某聘）\n\n![offer](/image/react1/offer.png)\n\n\n\n为了发财这个朴实的梦想也应该学习。\n\n## 学习的角度\n\n如今前端御三家：`Angular`、`React`、`Vue`三分天下。国内更青睐`React`和`Vue`。所以，从学习的角度更应该学习`React`。\n\n\n\nhttps://www.npmtrends.com/react-vs-vue-vs-@angular/core\n\n\n\n![offer](/image/react1/download.jpg)\n\n\n\n![offer](/image/react1/stats)\n\n## 为什么非要学习源码\n\n这个问题我之前也问过，几乎所有的面试都是造火箭，工作拧螺丝。\n\n我认为从两个角度来看这个问题：\n\n1. 应聘者\n   1. 吃透`React`的情况下，解决问题的上限肯定是提高了\n   2. 一个优秀的框架是一位优秀的老师\n2. 招聘者，既然都是能干活的，我就找一个懂得更多的人来干这个活\n\n\n\n# JSX\n\n废话不多说，直接开始。\n\nJSX，再熟悉不过了，日常使用React过程中肯定会用到的。给一个demo，帮大家回一下。\n\n```react\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nclass App extends React.Component {\n  render() {\n    const text = \"哈哈哈\"\n    return (\n      <div>\n        <p>{text}</p>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n\n\n我先问几个问题，如果能够清晰的快速答出来，那么恭喜你，你的基础很扎实，如果不行，那就一起看看，看完之后可以把你的答案写在评论区，和大家讨论。\n\n- 什么是`JSX`？`JSX`和`JS`有什么关系？\n- `JSX`的底层原理是什么？\n- 为什么`React`要选择`JSX`？\n\n带着问题一起来看。\n\n## 什么是JSX\n\n先看看`React`官网的一句话。\n\n> ```react\n> const element = <h1>Hello, world!</h1>;\n> ```\n>\n> 它被称为 JSX，是一个 JavaScript 的语法扩展。\n\n语法扩展，意思就是`JS`有的他都有的情况下，还有一些别的功能。可是这货，明显在`JavaScript`学习过程中没见过他呀。他能运行在`JavaScript`的环境中吗？打开`Chrome`控制台。\n\n\n\n![console](/image/react/console.png)\n\n\n\n上来就是劈头盖脸的语法错误，看样子这部分就是多出来的功能了呗。那咋运行啊？\n\n\n\n```js\n{\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n},\n```\n\n怎么样，熟悉不，意思是告诉`webpack`，解析`jsx`结尾的代码，需要用到`babel`。ok，也就是说要想运行`jsx`，就必须用`babel`解析。那好，什么是babel？\n\n### babel\n\n拉一段`babel`官网上的一句话\n\n> ## Babel 是一个 JavaScript 编译器\n>\n> Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\n\n`babel`，其实就是帮我们解析我们写的代码，然后变成浏览器能够认识样式。比如`jsx`，比如新鲜的`es6`语法可以运行在老版本的浏览器上，让老版本的浏览器能够认识。\n\n那问题又来了，jsx被babel变成什么样子了？\n\n在线转换：https://babeljs.io/repl\n\n大家可以把上面的小demo，扔进去。\n\n\n\n![bebel](/image/react/bebel.png)\n\n\n\n发现没有。我们`return`出去的东西变成了`React.createElement`。哈哈，这就是为什么我们即使没有用到`React`(解决了一到面试题！)，也需要在上面`import`，因为`jsx`最后是会被转化为`React.createElement`，会用到的！（不过现在最新的好像不需要引用也不会报错了，因为他自己识别了。\n\n官网介绍：https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\n\n> ```\n> // 由编译器引入（禁止自己引入！）\n> import {jsx as _jsx} from 'react/jsx-runtime';\n> \n> function App() {\n>   return _jsx('h1', { children: 'Hello world' });\n> }\n> ```\n>\n> 注意，此时源代码**无需引入 React** 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）\n\n\n\n回到之前`React`官网提到的\n\n> 它被称为 JSX，是一个 JavaScript 的语法扩展。\n\n有没有呼应起来了，确实`js`他都有，但是`js`没有的，他还有比如转化为`React.createElement`。\n\n\n\n## createElement\n\n我们是来读源码学习的，我们既然知道了`jsx`的底层是调用`react`的函数，我们就来看看这个函数是个什么情况。\n\n```javascript\nexport function createElement(type, config, children) {\n  // propName 变量用于储存后面需要用到的元素属性\n  let propName; \n  // props 变量用于储存元素属性的键值对集合\n  const props = {}; \n  // key、ref、self、source 均为 React 元素的属性，此处不必深究\n  let key = null;\n  let ref = null; \n  let self = null; \n  let source = null; \n\n  // config 对象中存储的是元素的属性\n  if (config != null) { \n    // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    // 此处将 key 值字符串化\n    if (hasValidKey(config)) {\n      key = '' + config.key; \n    }\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面\n    for (propName in config) {\n      if (\n        // 筛选出可以提进 props 对象里的属性\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName) \n      ) {\n        props[propName] = config[propName]; \n      }\n    }\n  }\n  // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度\n  const childrenLength = arguments.length - 2; \n  // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength === 1) { \n    // 直接把这个参数的值赋给props.children\n    props.children = children; \n    // 处理嵌套多个子元素的情况\n  } else if (childrenLength > 1) { \n    // 声明一个子元素数组\n    const childArray = Array(childrenLength); \n    // 把子元素推进数组里\n    for (let i = 0; i < childrenLength; i++) { \n      childArray[i] = arguments[i + 2];\n    }\n    // 最后把这个数组赋值给props.children\n    props.children = childArray; \n  } \n\n  // 处理 defaultProps\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) { \n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n```\n\n\n\n先不看参数，我们就先看返回值的名字和这个函数的名字。我们初步猜测，`jsx`是通过`createElement`这个函数来创建一个`React`元素，然后由`ReactDOM.render`来渲染到我们指定名字的元素上。\n\n\n\n\n\nok，那么我们平常写的jsx元素就是`ReactElement`生成的东西。我们看看`ReactElement`生成的是个什么东西。\n\n我们先把我们平常写的`jsx`给打印一下。\n\n\n\n![element](/image/react/element.png)\n\n\n\n凭直觉，是不是感觉这个是一个`虚拟DOM`的节点，他有类型然后又是`div`，对应的会不会是`html`的`div`标签？还有`className`，这个很明显就是对应`class`。我们去一看究竟。\n\n## ReactElement\n\n\n\n```javascript\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // 这个是一个React结点的标识符\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // 很明显就是对应的html的标签\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // 记录由谁创建的，暂时也不知道什么用。先挖个坑\n    _owner: owner,\n  };\n\n  // 开发环境下的配置，主要就是Object.freeze，可以在MDN上面查一下。我就不多介绍了\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n\n\n\n看过之后，是不是和我们看到的节点一样，首先，标注一下`$$typeof`为`react节点`。然后就是正常的传参，比如`key`，`ref`，`props`等等。\n\n## ReactDOM.render\n\n这个就是React节点渲染为真是节点的操作。话不多说，上源码！\n\n\n\n```javascript\nexport function isValidContainer(node: mixed): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // 用于抛出错误的, 就是判断这个container是不是找得到\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  \n  // 这里面涉及到了fiber的一些架构，我想之后再说，再挖个坑\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n```\n\n\n\n有没有感觉很简单，去除`__DEV__`情况的话。也是返回一个函数的结果。。。\n\n\n\n## ReactDOM.hydrate\n\n\n\n这个函数我发现很有意思，与ReactDOM.render只有一行代码不一样\n\n```diff\nlegacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n-   false,\n+   true,\n    callback,\n  );\n```\n\n\n\n首先，这个`hydrate`的意思是注水。大致的意思是给一个结点增加水分，增添色彩。之前是给`SSR`过程中添加点击事件之类使用的。在`React17`之后会淘汰掉`ReactDOM.Render`，全部用`ReactDOM.hydrate`来代替。\n\nReact官网的一句话\n\n> 使用 `ReactDOM.render()` 对服务端渲染容器进行 hydrate 操作的方式已经被废弃，并且会在 React 17 被移除。作为替代，请使用 [`hydrate()`](https://zh-hans.reactjs.org/docs/react-dom.html#hydrate)。\n\n\n\n## 为什么要使用JSX\n\n这里分享一个解题的小技巧。为什么要XX其实就是要问你，XX的好处。ok，那接下来就很好回答了\n\n首先，因为如果不用`jsx`，我们就要在代码里面写上百个`React.crearteElement`。\n\n第二，这个语法糖可以让开发者使用熟悉的`HTML`标签来创建`虚拟DOM`，降低学习成本。提升开发效率与开发体验\n\n\n\n\n\n![bebel](/image/react/bebel.png)\n\n\n\n# 剩余的坑\n\n- legacyRenderSubtreeIntoContainer（涉及fiber架构\n- _owner（创建的时候，这个属性有什么用\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\nhttps://www.babeljs.cn/docs/\n\n\n\n\n\n\n\n","source":"_posts/【重识前端】React源码阅读（一）jsx.md","raw":"---\n#成年人的崩溃往往就在一瞬间title: 【重识前端】React源码阅读（一）什么是jsx\ndate: 2021-03-29 10:08:31\ntags: [react]\ncategory: [重拾前端]\ncover: /image/cover/react.png\n---\n\n# 前言\n\n一些废话和个人感悟，看干货的直接跳过....到`jsx`\n\n重识前端断断续续也写了大半年了。里面基本上都是个人技术栈的积累，以及面试题的回答。感兴趣的伙伴可以点到我的主页去看。\n\n说说今天的主角-`React`吧。`React`的源码之前一直想要去阅读学习的，也确确实实在看了，但是经常看着看着就发困。然后就开始偷懒，从一些周边的开始阅读，比如`React-Router`，`React-Redux`之类的。之前都是看完之后再开始写文章。现在想一边看一边写，换个方式看看。如果有写错的地方欢迎大家讨论，如果觉得还可以的话可以点个赞，谢谢！\n\n作为一名`React`的重度使用者和爱好者。我将会和大家一起从「使用者」到「了解者」进步！\n\n# React的相关信息\n\n## 功利的角度\n\n打开招聘软件，现在基本上的大厂，甚至是外包公司都普遍要求你会`React`或者`Vue`。给出的薪资也是非常的诱人。\n\n（图片来自Boss某聘）\n\n![offer](/image/react1/offer.png)\n\n\n\n为了发财这个朴实的梦想也应该学习。\n\n## 学习的角度\n\n如今前端御三家：`Angular`、`React`、`Vue`三分天下。国内更青睐`React`和`Vue`。所以，从学习的角度更应该学习`React`。\n\n\n\nhttps://www.npmtrends.com/react-vs-vue-vs-@angular/core\n\n\n\n![offer](/image/react1/download.jpg)\n\n\n\n![offer](/image/react1/stats)\n\n## 为什么非要学习源码\n\n这个问题我之前也问过，几乎所有的面试都是造火箭，工作拧螺丝。\n\n我认为从两个角度来看这个问题：\n\n1. 应聘者\n   1. 吃透`React`的情况下，解决问题的上限肯定是提高了\n   2. 一个优秀的框架是一位优秀的老师\n2. 招聘者，既然都是能干活的，我就找一个懂得更多的人来干这个活\n\n\n\n# JSX\n\n废话不多说，直接开始。\n\nJSX，再熟悉不过了，日常使用React过程中肯定会用到的。给一个demo，帮大家回一下。\n\n```react\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nclass App extends React.Component {\n  render() {\n    const text = \"哈哈哈\"\n    return (\n      <div>\n        <p>{text}</p>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n\n\n我先问几个问题，如果能够清晰的快速答出来，那么恭喜你，你的基础很扎实，如果不行，那就一起看看，看完之后可以把你的答案写在评论区，和大家讨论。\n\n- 什么是`JSX`？`JSX`和`JS`有什么关系？\n- `JSX`的底层原理是什么？\n- 为什么`React`要选择`JSX`？\n\n带着问题一起来看。\n\n## 什么是JSX\n\n先看看`React`官网的一句话。\n\n> ```react\n> const element = <h1>Hello, world!</h1>;\n> ```\n>\n> 它被称为 JSX，是一个 JavaScript 的语法扩展。\n\n语法扩展，意思就是`JS`有的他都有的情况下，还有一些别的功能。可是这货，明显在`JavaScript`学习过程中没见过他呀。他能运行在`JavaScript`的环境中吗？打开`Chrome`控制台。\n\n\n\n![console](/image/react/console.png)\n\n\n\n上来就是劈头盖脸的语法错误，看样子这部分就是多出来的功能了呗。那咋运行啊？\n\n\n\n```js\n{\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n},\n```\n\n怎么样，熟悉不，意思是告诉`webpack`，解析`jsx`结尾的代码，需要用到`babel`。ok，也就是说要想运行`jsx`，就必须用`babel`解析。那好，什么是babel？\n\n### babel\n\n拉一段`babel`官网上的一句话\n\n> ## Babel 是一个 JavaScript 编译器\n>\n> Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\n\n`babel`，其实就是帮我们解析我们写的代码，然后变成浏览器能够认识样式。比如`jsx`，比如新鲜的`es6`语法可以运行在老版本的浏览器上，让老版本的浏览器能够认识。\n\n那问题又来了，jsx被babel变成什么样子了？\n\n在线转换：https://babeljs.io/repl\n\n大家可以把上面的小demo，扔进去。\n\n\n\n![bebel](/image/react/bebel.png)\n\n\n\n发现没有。我们`return`出去的东西变成了`React.createElement`。哈哈，这就是为什么我们即使没有用到`React`(解决了一到面试题！)，也需要在上面`import`，因为`jsx`最后是会被转化为`React.createElement`，会用到的！（不过现在最新的好像不需要引用也不会报错了，因为他自己识别了。\n\n官网介绍：https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\n\n> ```\n> // 由编译器引入（禁止自己引入！）\n> import {jsx as _jsx} from 'react/jsx-runtime';\n> \n> function App() {\n>   return _jsx('h1', { children: 'Hello world' });\n> }\n> ```\n>\n> 注意，此时源代码**无需引入 React** 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）\n\n\n\n回到之前`React`官网提到的\n\n> 它被称为 JSX，是一个 JavaScript 的语法扩展。\n\n有没有呼应起来了，确实`js`他都有，但是`js`没有的，他还有比如转化为`React.createElement`。\n\n\n\n## createElement\n\n我们是来读源码学习的，我们既然知道了`jsx`的底层是调用`react`的函数，我们就来看看这个函数是个什么情况。\n\n```javascript\nexport function createElement(type, config, children) {\n  // propName 变量用于储存后面需要用到的元素属性\n  let propName; \n  // props 变量用于储存元素属性的键值对集合\n  const props = {}; \n  // key、ref、self、source 均为 React 元素的属性，此处不必深究\n  let key = null;\n  let ref = null; \n  let self = null; \n  let source = null; \n\n  // config 对象中存储的是元素的属性\n  if (config != null) { \n    // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    // 此处将 key 值字符串化\n    if (hasValidKey(config)) {\n      key = '' + config.key; \n    }\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面\n    for (propName in config) {\n      if (\n        // 筛选出可以提进 props 对象里的属性\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName) \n      ) {\n        props[propName] = config[propName]; \n      }\n    }\n  }\n  // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度\n  const childrenLength = arguments.length - 2; \n  // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength === 1) { \n    // 直接把这个参数的值赋给props.children\n    props.children = children; \n    // 处理嵌套多个子元素的情况\n  } else if (childrenLength > 1) { \n    // 声明一个子元素数组\n    const childArray = Array(childrenLength); \n    // 把子元素推进数组里\n    for (let i = 0; i < childrenLength; i++) { \n      childArray[i] = arguments[i + 2];\n    }\n    // 最后把这个数组赋值给props.children\n    props.children = childArray; \n  } \n\n  // 处理 defaultProps\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) { \n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n```\n\n\n\n先不看参数，我们就先看返回值的名字和这个函数的名字。我们初步猜测，`jsx`是通过`createElement`这个函数来创建一个`React`元素，然后由`ReactDOM.render`来渲染到我们指定名字的元素上。\n\n\n\n\n\nok，那么我们平常写的jsx元素就是`ReactElement`生成的东西。我们看看`ReactElement`生成的是个什么东西。\n\n我们先把我们平常写的`jsx`给打印一下。\n\n\n\n![element](/image/react/element.png)\n\n\n\n凭直觉，是不是感觉这个是一个`虚拟DOM`的节点，他有类型然后又是`div`，对应的会不会是`html`的`div`标签？还有`className`，这个很明显就是对应`class`。我们去一看究竟。\n\n## ReactElement\n\n\n\n```javascript\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // 这个是一个React结点的标识符\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // 很明显就是对应的html的标签\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // 记录由谁创建的，暂时也不知道什么用。先挖个坑\n    _owner: owner,\n  };\n\n  // 开发环境下的配置，主要就是Object.freeze，可以在MDN上面查一下。我就不多介绍了\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n```\n\n\n\n看过之后，是不是和我们看到的节点一样，首先，标注一下`$$typeof`为`react节点`。然后就是正常的传参，比如`key`，`ref`，`props`等等。\n\n## ReactDOM.render\n\n这个就是React节点渲染为真是节点的操作。话不多说，上源码！\n\n\n\n```javascript\nexport function isValidContainer(node: mixed): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // 用于抛出错误的, 就是判断这个container是不是找得到\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  \n  // 这里面涉及到了fiber的一些架构，我想之后再说，再挖个坑\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n```\n\n\n\n有没有感觉很简单，去除`__DEV__`情况的话。也是返回一个函数的结果。。。\n\n\n\n## ReactDOM.hydrate\n\n\n\n这个函数我发现很有意思，与ReactDOM.render只有一行代码不一样\n\n```diff\nlegacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n-   false,\n+   true,\n    callback,\n  );\n```\n\n\n\n首先，这个`hydrate`的意思是注水。大致的意思是给一个结点增加水分，增添色彩。之前是给`SSR`过程中添加点击事件之类使用的。在`React17`之后会淘汰掉`ReactDOM.Render`，全部用`ReactDOM.hydrate`来代替。\n\nReact官网的一句话\n\n> 使用 `ReactDOM.render()` 对服务端渲染容器进行 hydrate 操作的方式已经被废弃，并且会在 React 17 被移除。作为替代，请使用 [`hydrate()`](https://zh-hans.reactjs.org/docs/react-dom.html#hydrate)。\n\n\n\n## 为什么要使用JSX\n\n这里分享一个解题的小技巧。为什么要XX其实就是要问你，XX的好处。ok，那接下来就很好回答了\n\n首先，因为如果不用`jsx`，我们就要在代码里面写上百个`React.crearteElement`。\n\n第二，这个语法糖可以让开发者使用熟悉的`HTML`标签来创建`虚拟DOM`，降低学习成本。提升开发效率与开发体验\n\n\n\n\n\n![bebel](/image/react/bebel.png)\n\n\n\n# 剩余的坑\n\n- legacyRenderSubtreeIntoContainer（涉及fiber架构\n- _owner（创建的时候，这个属性有什么用\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\nhttps://www.babeljs.cn/docs/\n\n\n\n\n\n\n\n","slug":"【重识前端】React源码阅读（一）jsx","published":1,"updated":"2021-06-27T07:32:21.936Z","title":"【重识前端】React源码阅读（一）jsx","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra840012lwrd97u032an","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一些废话和个人感悟，看干货的直接跳过….到<code>jsx</code></p>\n<p>重识前端断断续续也写了大半年了。里面基本上都是个人技术栈的积累，以及面试题的回答。感兴趣的伙伴可以点到我的主页去看。</p>\n<p>说说今天的主角-<code>React</code>吧。<code>React</code>的源码之前一直想要去阅读学习的，也确确实实在看了，但是经常看着看着就发困。然后就开始偷懒，从一些周边的开始阅读，比如<code>React-Router</code>，<code>React-Redux</code>之类的。之前都是看完之后再开始写文章。现在想一边看一边写，换个方式看看。如果有写错的地方欢迎大家讨论，如果觉得还可以的话可以点个赞，谢谢！</p>\n<p>作为一名<code>React</code>的重度使用者和爱好者。我将会和大家一起从「使用者」到「了解者」进步！</p>\n<h1 id=\"React的相关信息\"><a href=\"#React的相关信息\" class=\"headerlink\" title=\"React的相关信息\"></a>React的相关信息</h1><h2 id=\"功利的角度\"><a href=\"#功利的角度\" class=\"headerlink\" title=\"功利的角度\"></a>功利的角度</h2><p>打开招聘软件，现在基本上的大厂，甚至是外包公司都普遍要求你会<code>React</code>或者<code>Vue</code>。给出的薪资也是非常的诱人。</p>\n<p>（图片来自Boss某聘）</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react1/offer.png\"  alt=\"offer\"></p>\n<p>为了发财这个朴实的梦想也应该学习。</p>\n<h2 id=\"学习的角度\"><a href=\"#学习的角度\" class=\"headerlink\" title=\"学习的角度\"></a>学习的角度</h2><p>如今前端御三家：<code>Angular</code>、<code>React</code>、<code>Vue</code>三分天下。国内更青睐<code>React</code>和<code>Vue</code>。所以，从学习的角度更应该学习<code>React</code>。</p>\n<p><a href=\"https://www.npmtrends.com/react-vs-vue-vs-@angular/core\" target=\"_blank\" rel=\"noopener\">https://www.npmtrends.com/react-vs-vue-vs-@angular/core</a></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react1/download.jpg\"  alt=\"offer\"></p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react1/stats\"  alt=\"offer\"></p>\n<h2 id=\"为什么非要学习源码\"><a href=\"#为什么非要学习源码\" class=\"headerlink\" title=\"为什么非要学习源码\"></a>为什么非要学习源码</h2><p>这个问题我之前也问过，几乎所有的面试都是造火箭，工作拧螺丝。</p>\n<p>我认为从两个角度来看这个问题：</p>\n<ol>\n<li>应聘者<ol>\n<li>吃透<code>React</code>的情况下，解决问题的上限肯定是提高了</li>\n<li>一个优秀的框架是一位优秀的老师</li>\n</ol>\n</li>\n<li>招聘者，既然都是能干活的，我就找一个懂得更多的人来干这个活</li>\n</ol>\n<h1 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h1><p>废话不多说，直接开始。</p>\n<p>JSX，再熟悉不过了，日常使用React过程中肯定会用到的。给一个demo，帮大家回一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const text &#x3D; &quot;哈哈哈&quot;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;text&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const rootElement &#x3D; document.getElementById(&quot;root&quot;);</span><br><span class=\"line\">ReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我先问几个问题，如果能够清晰的快速答出来，那么恭喜你，你的基础很扎实，如果不行，那就一起看看，看完之后可以把你的答案写在评论区，和大家讨论。</p>\n<ul>\n<li>什么是<code>JSX</code>？<code>JSX</code>和<code>JS</code>有什么关系？</li>\n<li><code>JSX</code>的底层原理是什么？</li>\n<li>为什么<code>React</code>要选择<code>JSX</code>？</li>\n</ul>\n<p>带着问题一起来看。</p>\n<h2 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h2><p>先看看<code>React</code>官网的一句话。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>它被称为 JSX，是一个 JavaScript 的语法扩展。</p>\n</blockquote>\n<p>语法扩展，意思就是<code>JS</code>有的他都有的情况下，还有一些别的功能。可是这货，明显在<code>JavaScript</code>学习过程中没见过他呀。他能运行在<code>JavaScript</code>的环境中吗？打开<code>Chrome</code>控制台。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react/console.png\"  alt=\"console\"></p>\n<p>上来就是劈头盖脸的语法错误，看样子这部分就是多出来的功能了呗。那咋运行啊？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(js|jsx)?$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 开启缓存</span></span><br><span class=\"line\">        options: &#123; <span class=\"attr\">cacheDirectory</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，熟悉不，意思是告诉<code>webpack</code>，解析<code>jsx</code>结尾的代码，需要用到<code>babel</code>。ok，也就是说要想运行<code>jsx</code>，就必须用<code>babel</code>解析。那好，什么是babel？</p>\n<h3 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h3><p>拉一段<code>babel</code>官网上的一句话</p>\n<blockquote>\n<h2 id=\"Babel-是一个-JavaScript-编译器\"><a href=\"#Babel-是一个-JavaScript-编译器\" class=\"headerlink\" title=\"Babel 是一个 JavaScript 编译器\"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>\n</blockquote>\n<p><code>babel</code>，其实就是帮我们解析我们写的代码，然后变成浏览器能够认识样式。比如<code>jsx</code>，比如新鲜的<code>es6</code>语法可以运行在老版本的浏览器上，让老版本的浏览器能够认识。</p>\n<p>那问题又来了，jsx被babel变成什么样子了？</p>\n<p>在线转换：<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">https://babeljs.io/repl</a></p>\n<p>大家可以把上面的小demo，扔进去。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react/bebel.png\"  alt=\"bebel\"></p>\n<p>发现没有。我们<code>return</code>出去的东西变成了<code>React.createElement</code>。哈哈，这就是为什么我们即使没有用到<code>React</code>(解决了一到面试题！)，也需要在上面<code>import</code>，因为<code>jsx</code>最后是会被转化为<code>React.createElement</code>，会用到的！（不过现在最新的好像不需要引用也不会报错了，因为他自己识别了。</p>\n<p>官网介绍：<a href=\"https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html</a></p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 由编译器引入（禁止自己引入！）</span><br><span class=\"line\">import &#123;jsx as _jsx&#125; from &#39;react&#x2F;jsx-runtime&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return _jsx(&#39;h1&#39;, &#123; children: &#39;Hello world&#39; &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时源代码<strong>无需引入 React</strong> 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n</blockquote>\n<p>回到之前<code>React</code>官网提到的</p>\n<blockquote>\n<p>它被称为 JSX，是一个 JavaScript 的语法扩展。</p>\n</blockquote>\n<p>有没有呼应起来了，确实<code>js</code>他都有，但是<code>js</code>没有的，他还有比如转化为<code>React.createElement</code>。</p>\n<h2 id=\"createElement\"><a href=\"#createElement\" class=\"headerlink\" title=\"createElement\"></a>createElement</h2><p>我们是来读源码学习的，我们既然知道了<code>jsx</code>的底层是调用<code>react</code>的函数，我们就来看看这个函数是个什么情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">type, config, children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// propName 变量用于储存后面需要用到的元素属性</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> propName; </span><br><span class=\"line\">  <span class=\"comment\">// props 变量用于储存元素属性的键值对集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = &#123;&#125;; </span><br><span class=\"line\">  <span class=\"comment\">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> key = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ref = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> source = <span class=\"literal\">null</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// config 对象中存储的是元素的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处将 key 值字符串化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    self = config.__self === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__self;</span><br><span class=\"line\">    source = config.__source === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__source;</span><br><span class=\"line\">    <span class=\"comment\">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        <span class=\"comment\">// 筛选出可以提进 props 对象里的属性</span></span><br><span class=\"line\">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class=\"line\">        !RESERVED_PROPS.hasOwnProperty(propName) </span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        props[propName] = config[propName]; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> childrenLength = <span class=\"built_in\">arguments</span>.length - <span class=\"number\">2</span>; </span><br><span class=\"line\">  <span class=\"comment\">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 直接把这个参数的值赋给props.children</span></span><br><span class=\"line\">    props.children = children; </span><br><span class=\"line\">    <span class=\"comment\">// 处理嵌套多个子元素的情况</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 声明一个子元素数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> childArray = <span class=\"built_in\">Array</span>(childrenLength); </span><br><span class=\"line\">    <span class=\"comment\">// 把子元素推进数组里</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childrenLength; i++) &#123; </span><br><span class=\"line\">      childArray[i] = <span class=\"built_in\">arguments</span>[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后把这个数组赋值给props.children</span></span><br><span class=\"line\">    props.children = childArray; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 defaultProps</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ReactElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    key,</span><br><span class=\"line\">    ref,</span><br><span class=\"line\">    self,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    ReactCurrentOwner.current,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先不看参数，我们就先看返回值的名字和这个函数的名字。我们初步猜测，<code>jsx</code>是通过<code>createElement</code>这个函数来创建一个<code>React</code>元素，然后由<code>ReactDOM.render</code>来渲染到我们指定名字的元素上。</p>\n<p>ok，那么我们平常写的jsx元素就是<code>ReactElement</code>生成的东西。我们看看<code>ReactElement</code>生成的是个什么东西。</p>\n<p>我们先把我们平常写的<code>jsx</code>给打印一下。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react/element.png\"  alt=\"element\"></p>\n<p>凭直觉，是不是感觉这个是一个<code>虚拟DOM</code>的节点，他有类型然后又是<code>div</code>，对应的会不会是<code>html</code>的<code>div</code>标签？还有<code>className</code>，这个很明显就是对应<code>class</code>。我们去一看究竟。</p>\n<h2 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ReactElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个是一个React结点的标识符</span></span><br><span class=\"line\">    $$<span class=\"keyword\">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 很明显就是对应的html的标签</span></span><br><span class=\"line\">    type: type,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录由谁创建的，暂时也不知道什么用。先挖个坑</span></span><br><span class=\"line\">    _owner: owner,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开发环境下的配置，主要就是Object.freeze，可以在MDN上面查一下。我就不多介绍了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The validation flag is currently mutative. We put it on</span></span><br><span class=\"line\">    <span class=\"comment\">// an external backing store so that we can freeze the whole object.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can be replaced with a WeakMap once they are implemented in</span></span><br><span class=\"line\">    <span class=\"comment\">// commonly used development environments.</span></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// To make comparing ReactElements easier for testing purposes, we make</span></span><br><span class=\"line\">    <span class=\"comment\">// the validation flag non-enumerable (where possible, which should</span></span><br><span class=\"line\">    <span class=\"comment\">// include every environment we run tests in), so the test framework</span></span><br><span class=\"line\">    <span class=\"comment\">// ignores it.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// self and source are DEV only properties.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// Two elements created in two different places should be considered</span></span><br><span class=\"line\">    <span class=\"comment\">// equal for testing purposes and therefore we hide it from enumeration.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: source,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.freeze) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.freeze(element.props);</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>看过之后，是不是和我们看到的节点一样，首先，标注一下<code>$$typeof</code>为<code>react节点</code>。然后就是正常的传参，比如<code>key</code>，<code>ref</code>，<code>props</code>等等。</p>\n<h2 id=\"ReactDOM-render\"><a href=\"#ReactDOM-render\" class=\"headerlink\" title=\"ReactDOM.render\"></a>ReactDOM.render</h2><p>这个就是React节点渲染为真是节点的操作。话不多说，上源码！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValidContainer</span>(<span class=\"params\">node: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    node &amp;&amp;</span><br><span class=\"line\">    (node.nodeType === ELEMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_FRAGMENT_NODE ||</span><br><span class=\"line\">      (node.nodeType === COMMENT_NODE &amp;&amp;</span><br><span class=\"line\">        (node: any).nodeValue === <span class=\"string\">' react-mount-point-unstable '</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: React$Element&lt;any&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于抛出错误的, 就是判断这个container是不是找得到</span></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainer(container),</span><br><span class=\"line\">    <span class=\"string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer === <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isModernRoot) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'You are calling ReactDOM.render() on a container that was previously '</span> +</span><br><span class=\"line\">          <span class=\"string\">'passed to ReactDOM.createRoot(). This is not supported. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Did you mean to call root.render(element)?'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里面涉及到了fiber的一些架构，我想之后再说，再挖个坑</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有没有感觉很简单，去除<code>__DEV__</code>情况的话。也是返回一个函数的结果。。。</p>\n<h2 id=\"ReactDOM-hydrate\"><a href=\"#ReactDOM-hydrate\" class=\"headerlink\" title=\"ReactDOM.hydrate\"></a>ReactDOM.hydrate</h2><p>这个函数我发现很有意思，与ReactDOM.render只有一行代码不一样</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    null,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\"><span class=\"deletion\">-   false,</span></span><br><span class=\"line\"><span class=\"addition\">+   true,</span></span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>首先，这个<code>hydrate</code>的意思是注水。大致的意思是给一个结点增加水分，增添色彩。之前是给<code>SSR</code>过程中添加点击事件之类使用的。在<code>React17</code>之后会淘汰掉<code>ReactDOM.Render</code>，全部用<code>ReactDOM.hydrate</code>来代替。</p>\n<p>React官网的一句话</p>\n<blockquote>\n<p>使用 <code>ReactDOM.render()</code> 对服务端渲染容器进行 hydrate 操作的方式已经被废弃，并且会在 React 17 被移除。作为替代，请使用 <a href=\"https://zh-hans.reactjs.org/docs/react-dom.html#hydrate\" target=\"_blank\" rel=\"noopener\"><code>hydrate()</code></a>。</p>\n</blockquote>\n<h2 id=\"为什么要使用JSX\"><a href=\"#为什么要使用JSX\" class=\"headerlink\" title=\"为什么要使用JSX\"></a>为什么要使用JSX</h2><p>这里分享一个解题的小技巧。为什么要XX其实就是要问你，XX的好处。ok，那接下来就很好回答了</p>\n<p>首先，因为如果不用<code>jsx</code>，我们就要在代码里面写上百个<code>React.crearteElement</code>。</p>\n<p>第二，这个语法糖可以让开发者使用熟悉的<code>HTML</code>标签来创建<code>虚拟DOM</code>，降低学习成本。提升开发效率与开发体验</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/react/bebel.png\"  alt=\"bebel\"></p>\n<h1 id=\"剩余的坑\"><a href=\"#剩余的坑\" class=\"headerlink\" title=\"剩余的坑\"></a>剩余的坑</h1><ul>\n<li>legacyRenderSubtreeIntoContainer（涉及fiber架构</li>\n<li>_owner（创建的时候，这个属性有什么用</li>\n</ul>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n<p><a href=\"https://www.babeljs.cn/docs/\" target=\"_blank\" rel=\"noopener\">https://www.babeljs.cn/docs/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一些废话和个人感悟，看干货的直接跳过….到<code>jsx</code></p>\n<p>重识前端断断续续也写了大半年了。里面基本上都是个人技术栈的积累，以及面试题的回答。感兴趣的伙伴可以点到我的主页去看。</p>\n<p>说说今天的主角-<code>React</code>吧。<code>React</code>的源码之前一直想要去阅读学习的，也确确实实在看了，但是经常看着看着就发困。然后就开始偷懒，从一些周边的开始阅读，比如<code>React-Router</code>，<code>React-Redux</code>之类的。之前都是看完之后再开始写文章。现在想一边看一边写，换个方式看看。如果有写错的地方欢迎大家讨论，如果觉得还可以的话可以点个赞，谢谢！</p>\n<p>作为一名<code>React</code>的重度使用者和爱好者。我将会和大家一起从「使用者」到「了解者」进步！</p>\n<h1 id=\"React的相关信息\"><a href=\"#React的相关信息\" class=\"headerlink\" title=\"React的相关信息\"></a>React的相关信息</h1><h2 id=\"功利的角度\"><a href=\"#功利的角度\" class=\"headerlink\" title=\"功利的角度\"></a>功利的角度</h2><p>打开招聘软件，现在基本上的大厂，甚至是外包公司都普遍要求你会<code>React</code>或者<code>Vue</code>。给出的薪资也是非常的诱人。</p>\n<p>（图片来自Boss某聘）</p>\n<p><img src=\"/image/react1/offer.png\" alt=\"offer\"></p>\n<p>为了发财这个朴实的梦想也应该学习。</p>\n<h2 id=\"学习的角度\"><a href=\"#学习的角度\" class=\"headerlink\" title=\"学习的角度\"></a>学习的角度</h2><p>如今前端御三家：<code>Angular</code>、<code>React</code>、<code>Vue</code>三分天下。国内更青睐<code>React</code>和<code>Vue</code>。所以，从学习的角度更应该学习<code>React</code>。</p>\n<p><a href=\"https://www.npmtrends.com/react-vs-vue-vs-@angular/core\" target=\"_blank\" rel=\"noopener\">https://www.npmtrends.com/react-vs-vue-vs-@angular/core</a></p>\n<p><img src=\"/image/react1/download.jpg\" alt=\"offer\"></p>\n<p><img src=\"/image/react1/stats\" alt=\"offer\"></p>\n<h2 id=\"为什么非要学习源码\"><a href=\"#为什么非要学习源码\" class=\"headerlink\" title=\"为什么非要学习源码\"></a>为什么非要学习源码</h2><p>这个问题我之前也问过，几乎所有的面试都是造火箭，工作拧螺丝。</p>\n<p>我认为从两个角度来看这个问题：</p>\n<ol>\n<li>应聘者<ol>\n<li>吃透<code>React</code>的情况下，解决问题的上限肯定是提高了</li>\n<li>一个优秀的框架是一位优秀的老师</li>\n</ol>\n</li>\n<li>招聘者，既然都是能干活的，我就找一个懂得更多的人来干这个活</li>\n</ol>\n<h1 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h1><p>废话不多说，直接开始。</p>\n<p>JSX，再熟悉不过了，日常使用React过程中肯定会用到的。给一个demo，帮大家回一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const text &#x3D; &quot;哈哈哈&quot;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;text&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const rootElement &#x3D; document.getElementById(&quot;root&quot;);</span><br><span class=\"line\">ReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我先问几个问题，如果能够清晰的快速答出来，那么恭喜你，你的基础很扎实，如果不行，那就一起看看，看完之后可以把你的答案写在评论区，和大家讨论。</p>\n<ul>\n<li>什么是<code>JSX</code>？<code>JSX</code>和<code>JS</code>有什么关系？</li>\n<li><code>JSX</code>的底层原理是什么？</li>\n<li>为什么<code>React</code>要选择<code>JSX</code>？</li>\n</ul>\n<p>带着问题一起来看。</p>\n<h2 id=\"什么是JSX\"><a href=\"#什么是JSX\" class=\"headerlink\" title=\"什么是JSX\"></a>什么是JSX</h2><p>先看看<code>React</code>官网的一句话。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>它被称为 JSX，是一个 JavaScript 的语法扩展。</p>\n</blockquote>\n<p>语法扩展，意思就是<code>JS</code>有的他都有的情况下，还有一些别的功能。可是这货，明显在<code>JavaScript</code>学习过程中没见过他呀。他能运行在<code>JavaScript</code>的环境中吗？打开<code>Chrome</code>控制台。</p>\n<p><img src=\"/image/react/console.png\" alt=\"console\"></p>\n<p>上来就是劈头盖脸的语法错误，看样子这部分就是多出来的功能了呗。那咋运行啊？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(js|jsx)?$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 开启缓存</span></span><br><span class=\"line\">        options: &#123; <span class=\"attr\">cacheDirectory</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，熟悉不，意思是告诉<code>webpack</code>，解析<code>jsx</code>结尾的代码，需要用到<code>babel</code>。ok，也就是说要想运行<code>jsx</code>，就必须用<code>babel</code>解析。那好，什么是babel？</p>\n<h3 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h3><p>拉一段<code>babel</code>官网上的一句话</p>\n<blockquote>\n<h2 id=\"Babel-是一个-JavaScript-编译器\"><a href=\"#Babel-是一个-JavaScript-编译器\" class=\"headerlink\" title=\"Babel 是一个 JavaScript 编译器\"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>\n</blockquote>\n<p><code>babel</code>，其实就是帮我们解析我们写的代码，然后变成浏览器能够认识样式。比如<code>jsx</code>，比如新鲜的<code>es6</code>语法可以运行在老版本的浏览器上，让老版本的浏览器能够认识。</p>\n<p>那问题又来了，jsx被babel变成什么样子了？</p>\n<p>在线转换：<a href=\"https://babeljs.io/repl\" target=\"_blank\" rel=\"noopener\">https://babeljs.io/repl</a></p>\n<p>大家可以把上面的小demo，扔进去。</p>\n<p><img src=\"/image/react/bebel.png\" alt=\"bebel\"></p>\n<p>发现没有。我们<code>return</code>出去的东西变成了<code>React.createElement</code>。哈哈，这就是为什么我们即使没有用到<code>React</code>(解决了一到面试题！)，也需要在上面<code>import</code>，因为<code>jsx</code>最后是会被转化为<code>React.createElement</code>，会用到的！（不过现在最新的好像不需要引用也不会报错了，因为他自己识别了。</p>\n<p>官网介绍：<a href=\"https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html</a></p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 由编译器引入（禁止自己引入！）</span><br><span class=\"line\">import &#123;jsx as _jsx&#125; from &#39;react&#x2F;jsx-runtime&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return _jsx(&#39;h1&#39;, &#123; children: &#39;Hello world&#39; &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时源代码<strong>无需引入 React</strong> 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n</blockquote>\n<p>回到之前<code>React</code>官网提到的</p>\n<blockquote>\n<p>它被称为 JSX，是一个 JavaScript 的语法扩展。</p>\n</blockquote>\n<p>有没有呼应起来了，确实<code>js</code>他都有，但是<code>js</code>没有的，他还有比如转化为<code>React.createElement</code>。</p>\n<h2 id=\"createElement\"><a href=\"#createElement\" class=\"headerlink\" title=\"createElement\"></a>createElement</h2><p>我们是来读源码学习的，我们既然知道了<code>jsx</code>的底层是调用<code>react</code>的函数，我们就来看看这个函数是个什么情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">type, config, children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// propName 变量用于储存后面需要用到的元素属性</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> propName; </span><br><span class=\"line\">  <span class=\"comment\">// props 变量用于储存元素属性的键值对集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = &#123;&#125;; </span><br><span class=\"line\">  <span class=\"comment\">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> key = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ref = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> source = <span class=\"literal\">null</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// config 对象中存储的是元素的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处将 key 值字符串化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    self = config.__self === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__self;</span><br><span class=\"line\">    source = config.__source === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__source;</span><br><span class=\"line\">    <span class=\"comment\">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        <span class=\"comment\">// 筛选出可以提进 props 对象里的属性</span></span><br><span class=\"line\">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class=\"line\">        !RESERVED_PROPS.hasOwnProperty(propName) </span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        props[propName] = config[propName]; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> childrenLength = <span class=\"built_in\">arguments</span>.length - <span class=\"number\">2</span>; </span><br><span class=\"line\">  <span class=\"comment\">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 直接把这个参数的值赋给props.children</span></span><br><span class=\"line\">    props.children = children; </span><br><span class=\"line\">    <span class=\"comment\">// 处理嵌套多个子元素的情况</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 声明一个子元素数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> childArray = <span class=\"built_in\">Array</span>(childrenLength); </span><br><span class=\"line\">    <span class=\"comment\">// 把子元素推进数组里</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childrenLength; i++) &#123; </span><br><span class=\"line\">      childArray[i] = <span class=\"built_in\">arguments</span>[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后把这个数组赋值给props.children</span></span><br><span class=\"line\">    props.children = childArray; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 defaultProps</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ReactElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    key,</span><br><span class=\"line\">    ref,</span><br><span class=\"line\">    self,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    ReactCurrentOwner.current,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先不看参数，我们就先看返回值的名字和这个函数的名字。我们初步猜测，<code>jsx</code>是通过<code>createElement</code>这个函数来创建一个<code>React</code>元素，然后由<code>ReactDOM.render</code>来渲染到我们指定名字的元素上。</p>\n<p>ok，那么我们平常写的jsx元素就是<code>ReactElement</code>生成的东西。我们看看<code>ReactElement</code>生成的是个什么东西。</p>\n<p>我们先把我们平常写的<code>jsx</code>给打印一下。</p>\n<p><img src=\"/image/react/element.png\" alt=\"element\"></p>\n<p>凭直觉，是不是感觉这个是一个<code>虚拟DOM</code>的节点，他有类型然后又是<code>div</code>，对应的会不会是<code>html</code>的<code>div</code>标签？还有<code>className</code>，这个很明显就是对应<code>class</code>。我们去一看究竟。</p>\n<h2 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ReactElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个是一个React结点的标识符</span></span><br><span class=\"line\">    $$<span class=\"keyword\">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 很明显就是对应的html的标签</span></span><br><span class=\"line\">    type: type,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录由谁创建的，暂时也不知道什么用。先挖个坑</span></span><br><span class=\"line\">    _owner: owner,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开发环境下的配置，主要就是Object.freeze，可以在MDN上面查一下。我就不多介绍了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The validation flag is currently mutative. We put it on</span></span><br><span class=\"line\">    <span class=\"comment\">// an external backing store so that we can freeze the whole object.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can be replaced with a WeakMap once they are implemented in</span></span><br><span class=\"line\">    <span class=\"comment\">// commonly used development environments.</span></span><br><span class=\"line\">    element._store = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// To make comparing ReactElements easier for testing purposes, we make</span></span><br><span class=\"line\">    <span class=\"comment\">// the validation flag non-enumerable (where possible, which should</span></span><br><span class=\"line\">    <span class=\"comment\">// include every environment we run tests in), so the test framework</span></span><br><span class=\"line\">    <span class=\"comment\">// ignores it.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element._store, <span class=\"string\">'validated'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// self and source are DEV only properties.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element, <span class=\"string\">'_self'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: self,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// Two elements created in two different places should be considered</span></span><br><span class=\"line\">    <span class=\"comment\">// equal for testing purposes and therefore we hide it from enumeration.</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(element, <span class=\"string\">'_source'</span>, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      value: source,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.freeze) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.freeze(element.props);</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.freeze(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>看过之后，是不是和我们看到的节点一样，首先，标注一下<code>$$typeof</code>为<code>react节点</code>。然后就是正常的传参，比如<code>key</code>，<code>ref</code>，<code>props</code>等等。</p>\n<h2 id=\"ReactDOM-render\"><a href=\"#ReactDOM-render\" class=\"headerlink\" title=\"ReactDOM.render\"></a>ReactDOM.render</h2><p>这个就是React节点渲染为真是节点的操作。话不多说，上源码！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValidContainer</span>(<span class=\"params\">node: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    node &amp;&amp;</span><br><span class=\"line\">    (node.nodeType === ELEMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_FRAGMENT_NODE ||</span><br><span class=\"line\">      (node.nodeType === COMMENT_NODE &amp;&amp;</span><br><span class=\"line\">        (node: any).nodeValue === <span class=\"string\">' react-mount-point-unstable '</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: React$Element&lt;any&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于抛出错误的, 就是判断这个container是不是找得到</span></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainer(container),</span><br><span class=\"line\">    <span class=\"string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer === <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isModernRoot) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'You are calling ReactDOM.render() on a container that was previously '</span> +</span><br><span class=\"line\">          <span class=\"string\">'passed to ReactDOM.createRoot(). This is not supported. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Did you mean to call root.render(element)?'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里面涉及到了fiber的一些架构，我想之后再说，再挖个坑</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有没有感觉很简单，去除<code>__DEV__</code>情况的话。也是返回一个函数的结果。。。</p>\n<h2 id=\"ReactDOM-hydrate\"><a href=\"#ReactDOM-hydrate\" class=\"headerlink\" title=\"ReactDOM.hydrate\"></a>ReactDOM.hydrate</h2><p>这个函数我发现很有意思，与ReactDOM.render只有一行代码不一样</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    null,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\"><span class=\"deletion\">-   false,</span></span><br><span class=\"line\"><span class=\"addition\">+   true,</span></span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>首先，这个<code>hydrate</code>的意思是注水。大致的意思是给一个结点增加水分，增添色彩。之前是给<code>SSR</code>过程中添加点击事件之类使用的。在<code>React17</code>之后会淘汰掉<code>ReactDOM.Render</code>，全部用<code>ReactDOM.hydrate</code>来代替。</p>\n<p>React官网的一句话</p>\n<blockquote>\n<p>使用 <code>ReactDOM.render()</code> 对服务端渲染容器进行 hydrate 操作的方式已经被废弃，并且会在 React 17 被移除。作为替代，请使用 <a href=\"https://zh-hans.reactjs.org/docs/react-dom.html#hydrate\" target=\"_blank\" rel=\"noopener\"><code>hydrate()</code></a>。</p>\n</blockquote>\n<h2 id=\"为什么要使用JSX\"><a href=\"#为什么要使用JSX\" class=\"headerlink\" title=\"为什么要使用JSX\"></a>为什么要使用JSX</h2><p>这里分享一个解题的小技巧。为什么要XX其实就是要问你，XX的好处。ok，那接下来就很好回答了</p>\n<p>首先，因为如果不用<code>jsx</code>，我们就要在代码里面写上百个<code>React.crearteElement</code>。</p>\n<p>第二，这个语法糖可以让开发者使用熟悉的<code>HTML</code>标签来创建<code>虚拟DOM</code>，降低学习成本。提升开发效率与开发体验</p>\n<p><img src=\"/image/react/bebel.png\" alt=\"bebel\"></p>\n<h1 id=\"剩余的坑\"><a href=\"#剩余的坑\" class=\"headerlink\" title=\"剩余的坑\"></a>剩余的坑</h1><ul>\n<li>legacyRenderSubtreeIntoContainer（涉及fiber架构</li>\n<li>_owner（创建的时候，这个属性有什么用</li>\n</ul>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n<p><a href=\"https://www.babeljs.cn/docs/\" target=\"_blank\" rel=\"noopener\">https://www.babeljs.cn/docs/</a></p>\n"},{"title":"window.history.back(); 缓存 返回上级页面不刷新数据","date":"2019-06-19T03:12:34.000Z","cover":"/image/cover/history.jpeg","_content":"\n## 问题\n\n - 我们经常会做完一个操作之后返回上一个页面（比如新增完一条记录）\n\n - 然后我们希望返回上一个页面的时候就自动刷新他。\n - 但是由于JS的缓存机制\n - 导致我们的数据还是从前一次里面取的（他的初衷是希望你更快，更省资源）\n - 但是和我们的需求不同\n - 如图：\n\n![在这里插入图片描述](/image/historyBack函数/20190318092239845.png)\n\n## 探索\n从网上找的一些资料：\n\n - 在`window.history.back();` 后面加`location.reload();`\n - `window.history.go(-1);window.location.reload()`\n\n均无终而返\n\n## 解决\n\n - `window.location.replace(document.referrer)`\n - `window.location.href=“上一个页面URL”`（下下策）\n","source":"_posts/window-history-back-缓存-返回上级页面不刷新数据.md","raw":"---\ntitle: window.history.back(); 缓存 返回上级页面不刷新数据\ndate: 2019-06-19 11:12:34\ntags: [HTML, JavaScript]\ncategory: [Web前端]\ncover: /image/cover/history.jpeg\n---\n\n## 问题\n\n - 我们经常会做完一个操作之后返回上一个页面（比如新增完一条记录）\n\n - 然后我们希望返回上一个页面的时候就自动刷新他。\n - 但是由于JS的缓存机制\n - 导致我们的数据还是从前一次里面取的（他的初衷是希望你更快，更省资源）\n - 但是和我们的需求不同\n - 如图：\n\n![在这里插入图片描述](/image/historyBack函数/20190318092239845.png)\n\n## 探索\n从网上找的一些资料：\n\n - 在`window.history.back();` 后面加`location.reload();`\n - `window.history.go(-1);window.location.reload()`\n\n均无终而返\n\n## 解决\n\n - `window.location.replace(document.referrer)`\n - `window.location.href=“上一个页面URL”`（下下策）\n","slug":"window-history-back-缓存-返回上级页面不刷新数据","published":1,"updated":"2021-06-24T14:00:06.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra860017lwrd1rs03p22","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li><p>我们经常会做完一个操作之后返回上一个页面（比如新增完一条记录）</p>\n</li>\n<li><p>然后我们希望返回上一个页面的时候就自动刷新他。</p>\n</li>\n<li><p>但是由于JS的缓存机制</p>\n</li>\n<li><p>导致我们的数据还是从前一次里面取的（他的初衷是希望你更快，更省资源）</p>\n</li>\n<li><p>但是和我们的需求不同</p>\n</li>\n<li><p>如图：</p>\n</li>\n</ul>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/historyBack%E5%87%BD%E6%95%B0/20190318092239845.png\"  alt=\"在这里插入图片描述\"></p>\n<h2 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h2><p>从网上找的一些资料：</p>\n<ul>\n<li>在<code>window.history.back();</code> 后面加<code>location.reload();</code></li>\n<li><code>window.history.go(-1);window.location.reload()</code></li>\n</ul>\n<p>均无终而返</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><code>window.location.replace(document.referrer)</code></li>\n<li><code>window.location.href=“上一个页面URL”</code>（下下策）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li><p>我们经常会做完一个操作之后返回上一个页面（比如新增完一条记录）</p>\n</li>\n<li><p>然后我们希望返回上一个页面的时候就自动刷新他。</p>\n</li>\n<li><p>但是由于JS的缓存机制</p>\n</li>\n<li><p>导致我们的数据还是从前一次里面取的（他的初衷是希望你更快，更省资源）</p>\n</li>\n<li><p>但是和我们的需求不同</p>\n</li>\n<li><p>如图：</p>\n</li>\n</ul>\n<p><img src=\"/image/historyBack%E5%87%BD%E6%95%B0/20190318092239845.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h2><p>从网上找的一些资料：</p>\n<ul>\n<li>在<code>window.history.back();</code> 后面加<code>location.reload();</code></li>\n<li><code>window.history.go(-1);window.location.reload()</code></li>\n</ul>\n<p>均无终而返</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><code>window.location.replace(document.referrer)</code></li>\n<li><code>window.location.href=“上一个页面URL”</code>（下下策）</li>\n</ul>\n"},{"title":"【重识前端】React-Router源码阅读","date":"2020-11-14T12:29:17.000Z","cover":"/image/cover/web.jpeg","_content":"\n# 前言\n\n此处介绍一下React-Router的核心原理。特别细致的标点符号的不予讨论。\n\n# 学前小知识\n\n`React-Router`其实最核心的东西是`Route`组件和由统一作者开发的`History`库来建立的。接下来跟着镜头一起走进神秘的`ßReact-Router`世界吧。\n\n已经知道怎么使用的直接跳过，到下面的源码分析去┗|｀O′|┛ 嗷~~\n\n# 简单示例\n\n一起建一个简单的示例吧。先用`react`官网的`create-react-app`脚手架弄个`react`出来。\n\n```sh\nnpx create-react-app my-app\ncd my-app\nnpm start\n```\n\n安装[react-router-dom](https://reactrouter.com/web/guides/quick-start)\n\n```sh\nnpm install react-router-dom\n```\n\n在大家安装之余，我简答的介绍一下`react-router`和`react-router-dom`的区别。\n\n## react-router和react-router-dom的区别。\n\n### 先看提供的API\u0003\n\n```javascript\nimport { Switch, Route, Router } from 'react-router';\n\nimport { Swtich, Route, BrowserRouter, HashHistory, Link } from 'react-router-dom';\n```\n\n#### React-router\n\n提供了路由的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api；\n\n#### React-router-dom\n\n提供了`BrowserRouter`、`Route`、`Link`等api，可以通过dom操作触发事件控制路由。\n\n`Link`组件，会渲染一个a标签；`BrowserRouter`和`HashRouter`组件，前者使用`pushState`和`popState`事件构建路由，后者使用` hash `和 `hashchange `事件构建路由。\n\n`react-router-dom`在`react-router`的基础上扩展了可操作`dom`的`api`。\n\n`Swtich` 和 `Route` 都是从`react-router`中导入了相应的组件并重新导出，没做什么特殊处理。\n\n`react-router-dom`中`package.json`依赖中存在对`react-router`的依赖，故此，不需要`npm`安装`react-router`。\n\n> - 可直接 npm 安装 react-router-dom，使用其api。\n\n## 简单修改\n\n👌，大家🔥应该已经安装完了吧？接下来简单的修改一下脚手架里面的内容。主要是为了熟悉对手，知己知彼百战百胜。\n\n![demo](/image/router/demo.png)\n\n修改一下`src/app.js`\n\n```javascript\nimport React from 'react';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nfunction Home() {\n  return (\n    <>\n      <h1>首页</h1>\n      <Link to=\"/login\">登录</Link>\n    </>\n  )\n}\n\nfunction Login() {\n  return (\n    <>\n      <h1>登录页</h1>\n      <Link to=\"/\">回首页</Link>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/login\" component={Login}/>\n        <Route path=\"/\" component={Home}/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\n这样就完成了一个最简单的示例了。\n\n# SPA的核心思想\n\n- 监听`URL`的变化\n- 改变某些`context`的值\n- 获取对应的页面组件\n- `render`新的页面\n\n# 源码攻读\n\n## BrowserRouter\n\n从前面的简单示例中我们，发现有一个最外层的伙计，叫`BrowserRouter`。我们直接干到他的github源码去瞅瞅。\n\n链接：https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n\nif (__DEV__) {\n  BrowserRouter.propTypes = {\n    basename: PropTypes.string,\n    children: PropTypes.node,\n    forceRefresh: PropTypes.bool,\n    getUserConfirmation: PropTypes.func,\n    keyLength: PropTypes.number\n  };\n\n  BrowserRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<BrowserRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { BrowserRouter as Router }`.\"\n    );\n  };\n}\n\nexport default BrowserRouter;\n\n```\n\n抛开一些七七八八的判断。重新看。\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n```\n\n写着几个大字：《瓜子二手车》他只是一个中间商，他在赚差价。（打钱！\n\n`BrowserRouter`是依赖于两个库：分别为`history`和`react-router`。ok，我们一探究竟。\n\n## react-router\n\n源码链接：https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js\n\n\n\n```javascript\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\n```\n\n这两个东西其实很简单，都是引用了一个叫做`createContext`，目的也很简单，这里其实就是创建的普通context，只不过拥有特定的名称而已。源码如下。就几行。\n\n```javascript\n// TODO: Replace with React.createContext once we can assume React 16+\nimport createContext from \"mini-create-react-context\";\n\nconst createNamedContext = name => {\n  const context = createContext();\n  context.displayName = name;\n\n  return context;\n};\n\nexport default createNamedContext;\n```\n\nOK，重点是接下来，抛开context之后，我们需要关注的东西。我整理一下。\n\n先看构造函数\n\n### 构造函数\n\n```javascript\nconstructor(props) {\n  super(props);\n\n  this.state = {\n    location: props.history.location\n  };\n\n  // This is a bit of a hack. We have to start listening for location\n  // changes here in the constructor in case there are any <Redirect>s\n  // on the initial render. If there are, they will replace/push when\n  // they mount and since cDM fires in children before parents, we may\n  // get a new location before the <Router> is mounted.\n  \n  // _isMounted 表示组件是否加载完成\n  this._isMounted = false;\n  // 组件未加载完毕，但是 location 发生的变化，暂存在 _pendingLocation 字段中\n  this._pendingLocation = null;\n\n  // 没有 staticContext 属性，表示是 HashRouter 或是 BrowserRouter\n  if (!props.staticContext) {\n    this.unlisten = props.history.listen(location => {\n      if (this._isMounted) {\n        // 组件加载完毕，将变化的 location 方法 state 中\n        this.setState({ location });\n      } else {\n        this._pendingLocation = location;\n      }\n    });\n  }\n}\n```\n\n有两个值☞`_isMounted`和`_pendingLocation`\n\n分别是  是否挂载   待定\n\n内部维护了一个location，默认值是由外面传入的history，我找到传入的地方。\n\n其实就是之前看到的`BrowserRouter`\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n```\n\n不难发现，history的默认值就是由history这个库来提供的，这个后面会提到，我们继续看。\n\n先简单看一下注释的翻译(谷歌翻译)\n\n> 这有点hack。 我们必须开始在构造函数中监听位置更改，以防初始渲染中存在任何<Redirect>。 如果有的话，它们将在安装时替换/推动，并且由于cDM在父级之前在子级中触发，因此在安装<Router>之前，我们可能会获得一个新位置。 \n\n什么意思呢，我简单描述一下：\n\n> 因为子组件会比父组件更早渲染完成, 以及`<Redirect>`的存在, 若是在`<Router>`的`componentDidMount`生命周期中对`history.location`进行监听, 则有可能在监听事件注册之前, `history.location`已经由于`<Redirect>`发生了多次改变, 因此我们需要在`<Router>`的`constructor`中就注册监听事件\n\n收回来，进入`if`继续看。\n\n```javascript\nthis.unlisten = props.history.listen(location => {\n  if (this._isMounted) {\n  \tthis.setState({ location });\n  } else {\n  \tthis._pendingLocation = location;\n  }\n});\n```\n\n就是调用了`history`的`listen`方法。从代码中可以大致了解到就是对`history`进行监听，然后进行一些操作。\n\n### componentWillUnmount\n\n那么这个`unlisten`什么时候执行呢？\n\n```javascript\ncomponentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  }\n```\n\n在`Router`这个组件卸载的时候就执行啦。也就是说，取消了对`history`的监听。\n\n### componentDidUnmount\n\n然后看一下`conponentDidMount`\n\n```javascript\ncomponentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n```\n\n也很简单，就是修改一下是否挂载的值，以及继续之前在构造函数里面的判断。如果暂存数据有的话就把他存下来。\n\n### render\n\n```react\nrender() {\n    return (\n      <RouterContext.Provider\n        value={{\n          // 根据 HashRouter 还是 BrowserRouter，可判断 history 类型\n          history: this.props.history,\n          // 这个 location 就是监听 history 变化得到的 location\n          location: this.state.location,\n          // path url params isExact 四个属性\n          match: Router.computeRootMatch(this.state.location.pathname),\n          // 只有 StaticRouter 会传 staticContext\n          // HashRouter 和 BrowserRouter 都是 null\n          staticContext: this.props.staticContext\n        }}\n      >\n        <HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      </RouterContext.Provider>\n    );\n  }\n```\n\n### 总结\n\nRouter这个组件主要就是将一些数据进行存储。存到`Context`，之间不乏一些特殊情况的判断，比如子组件渲染比父组件早，以及`Redirect`的情况的处理。在卸载的时候要移除对`history`的监听。\n\n子组件作为消费者，就可以对页面进行修改，跳转，获取这些数值。\n\n\n\n## history\n\n### createBrowserHistory\n\n#### 返回的内容\n\n之前一直有不断提到的`history`，我们一起来看看它是谁\n\n源码连接：https://github.com/ReactTraining/history/blob/master/packages/history/index.ts\n\n我们之前用到的`createBrowserHistory`，他其实是返回的一个对象，这个对象里面有我们常用的一些方法。\n\n```javascript\nlet history: BrowserHistory = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(listener) {\n      return listeners.push(listener);\n    },\n    block(blocker) {\n      let unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n```\n\n大部分精髓就是这里。发现有多熟悉的伙伴！ => `push`、`replace`、`go`等等。有些其实都是`window`提供的。\n\n有些直接看代码就可以明白的就不解释了，比如`forward`，`back`。\n\n##### go\n\n比如上面提到的`go`方法，截取部分源码。\n\n```typescript\nlet globalHistory = window.history;\nfunction go(delta: number) {\n    globalHistory.go(delta);\n  }\n```\n\n\n\n##### createHref\n\n```typescript\n\n// 返回一个完整的url\nexport function createPath({\n  pathname = '/',\n  search = '',\n  hash = ''\n}: PartialPath) {\n  return pathname + search + hash;\n}\n\n// 返回一个url\nfunction createHref(to: To) {\n  \t// 看上面\n    return typeof to === 'string' ? to : createPath(to);\n  }\n```\n\n\n\n##### push\n\n`push`的源码，里面附带了一些会用到的函数。\n\n```typescript\n// 就是简单处理一下返回值。\nfunction getNextLocation(to: To, state: State = null): Location {\n  return readOnly<Location>({\n    ...location,\n    ...(typeof to === 'string' ? parsePath(to) : to),\n    state,\n    key: createKey()\n  });\n}\n\n// 进行判断\nfunction allowTx(action: Action, location: Location, retry: () => void) {\n    return (\n      // 长度为0就返回true，长度大于0就调用函数，并传入参数。这个blockers等一下仔细探讨一下\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n\n// 顾名思义获取state和url\nfunction getHistoryStateAndUrl(\n    nextLocation: Location,\n    index: number\n  ): [HistoryState, string] {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      // 看上面 有专门介绍\n      createHref(nextLocation)\n    ];\n  }\n\n// 返回一些关于location的信息\nfunction getIndexAndLocation(): [number, Location] {\n    let { pathname, search, hash } = window.location;\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly<Location>({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n// 执行listeners内部的一些函数（也就是跳转），后面也会详细解读\nfunction applyTx(nextAction: Action) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n\nfunction push(to: To, state?: State) {\n  \t// 这里是一个枚举值\n    let nextAction = Action.Push;\n  \t\n    let nextLocation = getNextLocation(to, state);\n  \t// 顾名思义，就是再来一次\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        // MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        // MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/Location/assign\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n```\n\n我在注释里面已经进行非常详细的解读了，用到的每个函数都有解释或者官方权威的url。\n\n总结一下：`history.push`的一个完整流程\n\n- 调用`history.pushState`\n  - 错误由`window.location.assign`来处理\n- 执行一下`listeners`里面的函数\n\n是的，你没有看错，就这么简单，只是里面有很多调用的函数，我都截取出来一一解释，做到每行代码都理解，所以显得比较长，概括来说就是这么简单。\n\n重点来看一下`listen`和被调用的`createBrowserHistory`\n\n##### replace\n\n这里面用的函数，在前面的push都有解析，可以往上面去找找，就不多赘述了。\n\n```typescript\nfunction replace(to: To, state?: State) {\n    let nextAction = Action.Replace;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, '', url);\n\n      applyTx(nextAction);\n    }\n  }\n```\n\n\n\n##### listen\n\n在`history`返回的`listen`是一个函数。这个函数我们之前在react-router的源码中发现，他是在构造函数和卸载的时候会用到。\n\n```javascript\nlisten(listener) {\n      return listeners.push(listener);\n    },\n```\n\n仔细看看，这个`listeners`是在做些什么。\n\n##### createEvents\n\n这个函数后面的blockers也会用到\n\n```typescript\nlet listeners = createEvents<Listener>();\n\nfunction createEvents<F extends Function>(): Events<F> {\n  let handlers: F[] = [];\n\n  return {\n    get length() {\n      return handlers.length;\n    },\n    push(fn: F) {\n      handlers.push(fn);\n      return function() {\n        handlers = handlers.filter(handler => handler !== fn);\n      };\n    },\n    call(arg) {\n      handlers.forEach(fn => fn && fn(arg));\n    }\n  };\n}\n```\n\n这个方法，顾名思义，就是创建事件。定义了一个变量 `handlers` 数组，用于存放要处理的回调函数事件。\n\n然后返回了一个对象。\n\n`push` 方法就是往 `handlers` 中添加要执行的函数。\n\n这块主要在 `history.listen()` 中使用，可以翻到开头看下 `history` 中返回了 `listen()` 方法，就是调用了`listeners.push(listener)` 。\n\n最后 `call()` 方法就比较容易理解，就是取出 `handlers` 里面的回调函数并逐个执行。\n\n总结一下，就是存储一下`push`进来的函数，并进行过滤。之后调用的时候会依次执行。`length`就是当前拥有的函数数量。\n\n再切回去，就会发现，每次调用这个`listen`就相当于`push`一个函数到内部的一个变量`handlers`中。\n\n##### block\n\n和`listeners`一样，也是用`createEvents`创建的，就不多说啦。说一下哪里会用到这个吧。\n\n```typescript\nlet blockers = createEvents<Blocker>();\n```\n\n- `block(prompt)` - (function) Prevents navigation (see [the history docs](https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md))\n\n这个是`react-router`官网的解释。\n\n我这里简单概括一下，就是用于关闭或者回退浏览器的误操作会用到的。详细的可以看点击进去查看。\n\n##### 总结\n\n至此，我们调用的`createBrowserHistory`所返回的一些属性的源码都已经了如指掌了。但是具体是怎么工作还是一知半解。\n\n#### 具体核心原理\n\n先秀一下源码。history的核心原理就是这个。先别被这么多行代码唬到了，很多都是我们在之前的push里面有解释的\n\n```typescript\nconst PopStateEventType = 'popstate';\nlet blockedPopTx: Transition | null = null;\nfunction handlePop() {\n  // 如果有\n  if (blockedPopTx) {\n    blockers.call(blockedPopTx);\n    blockedPopTx = null;\n  } else {\n    let nextAction = Action.Pop;\n    let [nextIndex, nextLocation] = getIndexAndLocation();\n\n    if (blockers.length) {\n      if (nextIndex != null) {\n        let delta = index - nextIndex;\n        if (delta) {\n          // Revert the POP\n          blockedPopTx = {\n            action: nextAction,\n            location: nextLocation,\n            retry() {\n              go(delta * -1);\n            }\n          };\n\n          go(delta);\n        }\n      } else {\n        // Trying to POP to a location with no index. We did not create\n        // this location, so we can't effectively block the navigation.\n        warning(\n          false,\n          // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          `You are trying to block a POP navigation to a location that was not ` +\n          `created by the history library. The block will fail silently in ` +\n          `production, but in general you should do all navigation with the ` +\n          `history library (instead of using window.history.pushState directly) ` +\n          `to avoid this situation.`\n        );\n      }\n    } else {\n      applyTx(nextAction);\n    }\n  }\n}\n\nwindow.addEventListener(PopStateEventType, handlePop);\n```\n\n重点说一下`window.addEventListener(PopStateEventType, handlePop)`\n\nMDN地址：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event\n\n其实就是监听路由的变化然后，执行回调函数\n\n### createHashHistory\n\n这个大体上与普通路由一致。这里我想强调一些问题。\n\n> 比如哈希路由的锚点问题，我自己已知的几个方案\n>\n> - ### [scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)\n>\n> - ### [scrollTop](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop)\n>\n> - ## [react-anchor-without-hash](https://github.com/kwzm/react-anchor-without-hash)\n\n感兴趣的自己查询一下，这个不在本次的讨论范围内。\n\n#### 具体核心原理\n\n之前说的到，`history`路由的核心是`window.addEventListener(PopStateEventType, handlePop);`\n\n而哈希路由的核心也是监听路由的变化，只是参数不同。\n\n```javascript\nwindow.addEventListener('hashchange',function(e){\n    /* 监听改变 */\n})\n```\n\n而对路由的改变。`history`路由是：`history.pushState`，`history.replaceState`。\n\n哈希路由是：\n\n`window.location.hash`\n\n通过`window.location.hash `属性获取和设置 `hash `值。\n\n具体的话很差不多，关心细节的伙伴可以去看其源码哦。\n\n# 核心API\n\n之前我们看了BrowserRouter。我们回过头来看看，demo中的实例代码还有多少没有解决：\n\n```react\nimport React from 'react';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nfunction Home() {\n  return (\n    <>\n      <h1>首页</h1>\n      <Link to=\"/login\">登录</Link>\n    </>\n  )\n}\n\nfunction Login() {\n  return (\n    <>\n      <h1>登录页</h1>\n      <Link to=\"/\">回首页</Link>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/login\" component={Login}/>\n        <Route path=\"/\" component={Home}/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\n我们已经看完了`BrowserRouter`（`Router`。下面还有`Switch`和`Route`。\n\n## Switch\n\n先上源码。我摘取最核心的一部分。\n\n```react\nclass Switch extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Switch> outside a <Router>\");\n\n          // 默认使用context.location，如果有特殊定制的location才会使用。\n          // 下面有介绍\n          const location = this.props.location || context.location;\n\n          let element, match;\n\n          // We use React.Children.forEach instead of React.Children.toArray().find()\n          // here because toArray adds keys to all child elements and we do not want\n          // to trigger an unmount/remount for two <Route>s that render the same\n          // component at different URLs.\n          // React.Children.forEach 对子元素做遍历\n          React.Children.forEach(this.props.children, child => {\n            // 只要找到一个 match，那么就不会再进来了\n            if (match == null && React.isValidElement(child)) {\n              element = child;\n\n              // child.props.path 就不多讲了， Route 的标准写法\n              // 需要注意的是，使用 from 也会被匹配到\n              // 任何组件，只要在 Switch 下，有 from 属性，并且和当前路径匹配，就会被渲染\n              // from具体是给<Redirect>使用的，后面会说到\n              const path = child.props.path || child.props.from;\n\n              // 判断组件是否匹配\n              match = path\n              // 下面有专属的介绍这个函数\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\n```\n\nSwitch中的location这个props怎么用？什么用？\n\n> ## 摘自官网\n>\n> ## [location: object](https://reactrouter.com/web/api/Switch/location-object)\n>\n> A [`location`](https://reactrouter.com/web/api/location) object to be used for matching children elements instead of the current history location (usually the current browser URL).\n>\n> 谷歌翻译：用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。\n\n### matchPath\n\n```javascript\nfunction matchPath(pathname, options = {}) {\n  // 规范结构体\n  // 如果 options 传的是个 string，那默认这个 string 代表 path\n  // 如果 options 传的是个 数组，那只要有一个匹配，就认为匹配\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  // 转化成数组进行判断\n  const paths = [].concat(path);\n\n  // 都是很简单的内容，难点就在这个reduce，这个很有意思，感兴趣或者不了解的赶紧去MDN了解一下！！！\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    // 只要有一个 match，直接返回，认为是 match\n    if (matched) return matched;\n\n    // regexp 是正则表达式\n    // keys 是切割出来的得 key 的值\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    // exec() 该方法如果找到了匹配的文本的话，则会返回一个结果数组，否则的话，会返回一个\n    const match = regexp.exec(pathname);\n    /* 匹配不成功，返回null */\n    if (!match) return null;\n\n    // url 表示匹配到的部分\n    const [url, ...values] = match;\n    // pathname === url 表示完全匹配\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n```\n\nmatchPath 函数也是由 react-router export 出去的函数，我们可以用来获得某个 url 中的指定的参数。\n\n\n\n## Route\n\nRoute 是用于声明路由映射到应用程序的组件层。\n\nRoute 有三种渲染的方法，当然，都配置的话只有一个会生效，优先级是 children > component > render\n\n\\1. <Route component>\n\\2. <Route render>\n\\3. <Route children>\n\n每个在不同的情况下都有用，大多数情况下，会使用 component。\n\n### component\n\ncomponent 表示只有当位置匹配时才会渲染的 React 组件。使用 component（而不是 render 或 children ）Route 使用从给定组件 React.createElement(element, props) 创建新的 React element。这意味着，使用 component 创建的组件能获得 router 中的 props。\n\n### children\n\n从源码中可以看出，children 的优先级是高于 component，而且可以是一个组件，也可以是一个函数，children 没有获得 router 的 props。\n\nchildren 有一个非常特殊的地方在于，当路由不匹配且 children 是一个函数的时候，会执行 children 方法，这就给了设计很大的灵活性。\n\n### render\n\nrender 必须是一个函数，优先级是最低的，当匹配成功的时候，执行这个函数。\n\n### exact & strict & sensitive\n\n这三者都是使用 path-to-regexp 做路径匹配需要的三个参数。\n\n1. exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。\n2. strict: 在确定为位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线。\n3. sensitive: 如果路径区分大小写，则为 true ，则匹配。\n\n### location\n\nRoute 元素尝试其匹配 path 到当前浏览器 URL，但是，也可以通过 location 实现与当前浏览器位置以外的位置相匹配。\n\n下面列出 Route 源码，并且删去了 dev 部分。\n\n```js\nimport React from \"react\";\nimport { isValidElementType } from \"react-is\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Route> outside a <Router>\");\n\n          // 可以看出，用户传的 location 覆盖掉了 context 中的 location\n          const location = this.props.location || context.location;\n\n          // 如果有 computedMatch 就用 computedMatch 作为结果\n          // 如果没有，则判断是否有 path 传参\n          // matchPath 是调用 path-to-regexp 判断是否匹配\n          // path-to-regexp 需要三个参数\n          // exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配\n          // strict: 如果为 true 当真实的路径具有一个斜线将只匹配一个斜线location.pathname\n          // sensitive: 如果路径区分大小写，则为 true ，则匹配\n          const match = this.props.computedMatch\n            ? this.props.computedMatch // <Switch> already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n\n          // props 就是更新后的 context\n          // location 做了更新（有可能是用户传入的location）\n          // match 做了更新\n          const props = { ...context, location, match };\n\n          // 三种渲染方式\n          let { children, component, render } = this.props;\n\n          // Preact uses an empty array as children by\n          // default, so use null if that's the case.\n          // children 默认是个空数组，如果是默认情况，置为 null\n          if (Array.isArray(children) && children.length === 0) {\n            children = null;\n          }\n\n          return (\n            // RouterContext 中更新了 location, match\n            <RouterContext.Provider value={props}>\n              {props.match\n              // 首先判断的是有无 children\n                ? children\n                  // 如果 children 是个函数，执行，否则直接返回 children\n                  ? typeof children === \"function\"\n                  : children(props)\n                  : children\n                  // 如果没有 children，判断有无 component\n                : component\n                  // 有 component，重新新建一个 component\n                  ? React.createElement(component, props)\n                  // 没有 component，判断有无 render\n                  : render\n                  // 有 render，执行 render 方法\n                  ? render(props)\n                  // 没有返回 null\n                  : null\n\n                // 这里是不 match 的情况，判断 children 是否函数\n                : typeof children === \"function\"\n                // 是的话执行\n                ? children(props)\n                : null}\n            </RouterContext.Provider>\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nexport default Route;\n```\n\nRoute 组件根据自身的传参，对上层 RouterContext 中的部分属性（location 和 match）进行了更新，并且如果当前路径和配置的 path 路径 match，则渲染该组件，渲染的方式有 children，component，render 三种方式，我们最常用的就是 component 方式，注意每种方式的区别。\n\n## Prompt\n\nPrompt 用于路由切换提示。这在某些场景下是非常有用的，比如用户在某个页面修改数据，离开时，提示用户是否保存，Prompt 组件有俩个属性：\n\n1. message：用于显示提示的文本信息。\n2. when：传递布尔值，相当于标签的开关，默认是 true，设置成 false 时，失效。\n\nPrompt 的本质是在 when 为 true 的时候，调用 context.history.block 方法，为全局注册路由监听，block 的原理看之前的 history 相关文章。路有变化的时候，默认使用 window.confirm 进行确认，我们也可以自定义 confirm 的形式，就是在 BrowserRouter 或者 HashRouter 传入 getUserConfirmation 这个参数，会替换掉 window.confirm。\n\n```react\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\nfunction Prompt({ message, when = true }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Prompt> outside a <Router>\");\n\n        if (!when || context.staticContext) return null;\n\n        // 调用了 history.block 方法\n        const method = context.history.block;\n\n        return (\n          <Lifecycle\n            onMount={self => {\n              self.release = method(message);\n            }}\n            onUpdate={(self, prevProps) => {\n              if (prevProps.message !== message) {\n                self.release();\n                self.release = method(message);\n              }\n            }}\n            onUnmount={self => {\n              self.release();\n            }}\n            message={message}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nexport default Prompt;\n```\n\n## Redirect\n\nRedirect 与其说是一个组件，不如说是有组件封装的一组方法，该组件在 componentDidMount 生命周期内，通过调用 history API 跳转到到新位置，默认情况下，新位置将覆盖历史堆栈中的当前位置。\n\n<Redirect to=\"/somewhere/else\"/> to 表示要重定向到的网址。to 也可以是一个 location 对象\n\n<Redirect push to=\"/somewhere/else\"/> push 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目。\n\n结合 Switch 和 Redirect 源码看，如果 Redirect 中有 from 属性，会被 Switch 获得，当 from 和当前路径匹配的时候，就会渲染 Redirect 组件，执行跳转。\n\n```js\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, locationsAreEqual } from \"history\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\nimport generatePath from \"./generatePath.js\";\n\n/**\n * The public API for navigating programmatically with a component.\n */\nfunction Redirect({ computedMatch, to, push = false }) {\n  return (\n    // 啥都有的大哥 RouterContext\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Redirect> outside a <Router>\");\n\n        const { history, staticContext } = context;\n\n        // 一般来说，Redirect 操作都不需要留有 history，所以选择选择 history.replace\n        const method = push ? history.push : history.replace;\n\n\n        const location = createLocation(\n          // computedMatch 就是看看 switch 有没有多管闲事\n          computedMatch\n            ? typeof to === \"string\"\n              ? generatePath(to, computedMatch.params)\n              : {\n                  ...to,\n                  pathname: generatePath(to.pathname, computedMatch.params)\n                }\n            : to\n        );\n\n        // When rendering in a static context,\n        // set the new location immediately.\n        // staticRouter 专用\n        if (staticContext) {\n          method(location);\n          return null;\n        }\n\n        return (\n          <Lifecycle\n            onMount={() => {\n              // componentDidMount 的时候执行 method(location)，也就是 history.replace 操作\n              method(location);\n            }}\n            onUpdate={(self, prevProps) => {\n              // componentDidUpdate 时候判断当前 location 和上一个 location 是否发生变化\n              // 只要发生变化，调用 method(location)\n              // 一般来讲，在 componentDidMount 的时候就跳走了，不会等到 componentDidUpdate\n              const prevLocation = createLocation(prevProps.to);\n              if (\n                !locationsAreEqual(prevLocation, {\n                  ...location,\n                  key: prevLocation.key\n                })\n              ) {\n                method(location);\n              }\n            }}\n\n            // 无效\n            to={to}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nexport default Redirect;\n```\n\nLifecycle 不 render 任何页面，只有生命周期函数，Lifecycle 提供了 onMount， onUpdate， onUnmount 三个生命周期函数。\n\n```js\nimport React from \"react\";\n\nclass Lifecycle extends React.Component {\n  componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  }\n\n  componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  }\n\n  render() {\n    return null;\n  }\n}\n\nexport default Lifecycle;\n```\n\n# 总结\n\n整个`react-router`是由`createBrowserHistory`或者`createHashHistory`来牵头，与我们的`React`组件绑定在一起，然后传递了一些属于`history`这个库的方法以及数值。当然，还有路由的匹配和渲染。\n\n在`history`这个库里面又有对于路由的监听，改变等等。\n\n## 流程\n\n以`history`模式做参考（也是我们重点阅读的。\n\n### 修改url\n\n当`url`改变的时候，会触发写在`window`上面的监听`window.addEventListener('popstate', handlePop)`。\n\n调用了我们的函数`handlePop`\n\n函数内部我们`setState`，修改了`location`，方便传递正确的值下去，并通过了`Switch`找出匹配的`Route`组件。\n\n触发了组件的渲染。\n\n> 当然也包括我们所谓的history.push，history.repalce等等这些方法，本质上也是修改url，然后就是重复上面的步骤\n\n\n\n\n\n\n\n","source":"_posts/【重识前端】React-Router源码阅读.md","raw":"---\ntitle: 【重识前端】React-Router源码阅读\ndate: 2020-11-14 20:29:17\ntags: [源码阅读, React]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n# 前言\n\n此处介绍一下React-Router的核心原理。特别细致的标点符号的不予讨论。\n\n# 学前小知识\n\n`React-Router`其实最核心的东西是`Route`组件和由统一作者开发的`History`库来建立的。接下来跟着镜头一起走进神秘的`ßReact-Router`世界吧。\n\n已经知道怎么使用的直接跳过，到下面的源码分析去┗|｀O′|┛ 嗷~~\n\n# 简单示例\n\n一起建一个简单的示例吧。先用`react`官网的`create-react-app`脚手架弄个`react`出来。\n\n```sh\nnpx create-react-app my-app\ncd my-app\nnpm start\n```\n\n安装[react-router-dom](https://reactrouter.com/web/guides/quick-start)\n\n```sh\nnpm install react-router-dom\n```\n\n在大家安装之余，我简答的介绍一下`react-router`和`react-router-dom`的区别。\n\n## react-router和react-router-dom的区别。\n\n### 先看提供的API\u0003\n\n```javascript\nimport { Switch, Route, Router } from 'react-router';\n\nimport { Swtich, Route, BrowserRouter, HashHistory, Link } from 'react-router-dom';\n```\n\n#### React-router\n\n提供了路由的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api；\n\n#### React-router-dom\n\n提供了`BrowserRouter`、`Route`、`Link`等api，可以通过dom操作触发事件控制路由。\n\n`Link`组件，会渲染一个a标签；`BrowserRouter`和`HashRouter`组件，前者使用`pushState`和`popState`事件构建路由，后者使用` hash `和 `hashchange `事件构建路由。\n\n`react-router-dom`在`react-router`的基础上扩展了可操作`dom`的`api`。\n\n`Swtich` 和 `Route` 都是从`react-router`中导入了相应的组件并重新导出，没做什么特殊处理。\n\n`react-router-dom`中`package.json`依赖中存在对`react-router`的依赖，故此，不需要`npm`安装`react-router`。\n\n> - 可直接 npm 安装 react-router-dom，使用其api。\n\n## 简单修改\n\n👌，大家🔥应该已经安装完了吧？接下来简单的修改一下脚手架里面的内容。主要是为了熟悉对手，知己知彼百战百胜。\n\n![demo](/image/router/demo.png)\n\n修改一下`src/app.js`\n\n```javascript\nimport React from 'react';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nfunction Home() {\n  return (\n    <>\n      <h1>首页</h1>\n      <Link to=\"/login\">登录</Link>\n    </>\n  )\n}\n\nfunction Login() {\n  return (\n    <>\n      <h1>登录页</h1>\n      <Link to=\"/\">回首页</Link>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/login\" component={Login}/>\n        <Route path=\"/\" component={Home}/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\n这样就完成了一个最简单的示例了。\n\n# SPA的核心思想\n\n- 监听`URL`的变化\n- 改变某些`context`的值\n- 获取对应的页面组件\n- `render`新的页面\n\n# 源码攻读\n\n## BrowserRouter\n\n从前面的简单示例中我们，发现有一个最外层的伙计，叫`BrowserRouter`。我们直接干到他的github源码去瞅瞅。\n\n链接：https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n\nif (__DEV__) {\n  BrowserRouter.propTypes = {\n    basename: PropTypes.string,\n    children: PropTypes.node,\n    forceRefresh: PropTypes.bool,\n    getUserConfirmation: PropTypes.func,\n    keyLength: PropTypes.number\n  };\n\n  BrowserRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<BrowserRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { BrowserRouter as Router }`.\"\n    );\n  };\n}\n\nexport default BrowserRouter;\n\n```\n\n抛开一些七七八八的判断。重新看。\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n```\n\n写着几个大字：《瓜子二手车》他只是一个中间商，他在赚差价。（打钱！\n\n`BrowserRouter`是依赖于两个库：分别为`history`和`react-router`。ok，我们一探究竟。\n\n## react-router\n\n源码链接：https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js\n\n\n\n```javascript\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\n```\n\n这两个东西其实很简单，都是引用了一个叫做`createContext`，目的也很简单，这里其实就是创建的普通context，只不过拥有特定的名称而已。源码如下。就几行。\n\n```javascript\n// TODO: Replace with React.createContext once we can assume React 16+\nimport createContext from \"mini-create-react-context\";\n\nconst createNamedContext = name => {\n  const context = createContext();\n  context.displayName = name;\n\n  return context;\n};\n\nexport default createNamedContext;\n```\n\nOK，重点是接下来，抛开context之后，我们需要关注的东西。我整理一下。\n\n先看构造函数\n\n### 构造函数\n\n```javascript\nconstructor(props) {\n  super(props);\n\n  this.state = {\n    location: props.history.location\n  };\n\n  // This is a bit of a hack. We have to start listening for location\n  // changes here in the constructor in case there are any <Redirect>s\n  // on the initial render. If there are, they will replace/push when\n  // they mount and since cDM fires in children before parents, we may\n  // get a new location before the <Router> is mounted.\n  \n  // _isMounted 表示组件是否加载完成\n  this._isMounted = false;\n  // 组件未加载完毕，但是 location 发生的变化，暂存在 _pendingLocation 字段中\n  this._pendingLocation = null;\n\n  // 没有 staticContext 属性，表示是 HashRouter 或是 BrowserRouter\n  if (!props.staticContext) {\n    this.unlisten = props.history.listen(location => {\n      if (this._isMounted) {\n        // 组件加载完毕，将变化的 location 方法 state 中\n        this.setState({ location });\n      } else {\n        this._pendingLocation = location;\n      }\n    });\n  }\n}\n```\n\n有两个值☞`_isMounted`和`_pendingLocation`\n\n分别是  是否挂载   待定\n\n内部维护了一个location，默认值是由外面传入的history，我找到传入的地方。\n\n其实就是之前看到的`BrowserRouter`\n\n```javascript\nimport React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n```\n\n不难发现，history的默认值就是由history这个库来提供的，这个后面会提到，我们继续看。\n\n先简单看一下注释的翻译(谷歌翻译)\n\n> 这有点hack。 我们必须开始在构造函数中监听位置更改，以防初始渲染中存在任何<Redirect>。 如果有的话，它们将在安装时替换/推动，并且由于cDM在父级之前在子级中触发，因此在安装<Router>之前，我们可能会获得一个新位置。 \n\n什么意思呢，我简单描述一下：\n\n> 因为子组件会比父组件更早渲染完成, 以及`<Redirect>`的存在, 若是在`<Router>`的`componentDidMount`生命周期中对`history.location`进行监听, 则有可能在监听事件注册之前, `history.location`已经由于`<Redirect>`发生了多次改变, 因此我们需要在`<Router>`的`constructor`中就注册监听事件\n\n收回来，进入`if`继续看。\n\n```javascript\nthis.unlisten = props.history.listen(location => {\n  if (this._isMounted) {\n  \tthis.setState({ location });\n  } else {\n  \tthis._pendingLocation = location;\n  }\n});\n```\n\n就是调用了`history`的`listen`方法。从代码中可以大致了解到就是对`history`进行监听，然后进行一些操作。\n\n### componentWillUnmount\n\n那么这个`unlisten`什么时候执行呢？\n\n```javascript\ncomponentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  }\n```\n\n在`Router`这个组件卸载的时候就执行啦。也就是说，取消了对`history`的监听。\n\n### componentDidUnmount\n\n然后看一下`conponentDidMount`\n\n```javascript\ncomponentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n```\n\n也很简单，就是修改一下是否挂载的值，以及继续之前在构造函数里面的判断。如果暂存数据有的话就把他存下来。\n\n### render\n\n```react\nrender() {\n    return (\n      <RouterContext.Provider\n        value={{\n          // 根据 HashRouter 还是 BrowserRouter，可判断 history 类型\n          history: this.props.history,\n          // 这个 location 就是监听 history 变化得到的 location\n          location: this.state.location,\n          // path url params isExact 四个属性\n          match: Router.computeRootMatch(this.state.location.pathname),\n          // 只有 StaticRouter 会传 staticContext\n          // HashRouter 和 BrowserRouter 都是 null\n          staticContext: this.props.staticContext\n        }}\n      >\n        <HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      </RouterContext.Provider>\n    );\n  }\n```\n\n### 总结\n\nRouter这个组件主要就是将一些数据进行存储。存到`Context`，之间不乏一些特殊情况的判断，比如子组件渲染比父组件早，以及`Redirect`的情况的处理。在卸载的时候要移除对`history`的监听。\n\n子组件作为消费者，就可以对页面进行修改，跳转，获取这些数值。\n\n\n\n## history\n\n### createBrowserHistory\n\n#### 返回的内容\n\n之前一直有不断提到的`history`，我们一起来看看它是谁\n\n源码连接：https://github.com/ReactTraining/history/blob/master/packages/history/index.ts\n\n我们之前用到的`createBrowserHistory`，他其实是返回的一个对象，这个对象里面有我们常用的一些方法。\n\n```javascript\nlet history: BrowserHistory = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(listener) {\n      return listeners.push(listener);\n    },\n    block(blocker) {\n      let unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n```\n\n大部分精髓就是这里。发现有多熟悉的伙伴！ => `push`、`replace`、`go`等等。有些其实都是`window`提供的。\n\n有些直接看代码就可以明白的就不解释了，比如`forward`，`back`。\n\n##### go\n\n比如上面提到的`go`方法，截取部分源码。\n\n```typescript\nlet globalHistory = window.history;\nfunction go(delta: number) {\n    globalHistory.go(delta);\n  }\n```\n\n\n\n##### createHref\n\n```typescript\n\n// 返回一个完整的url\nexport function createPath({\n  pathname = '/',\n  search = '',\n  hash = ''\n}: PartialPath) {\n  return pathname + search + hash;\n}\n\n// 返回一个url\nfunction createHref(to: To) {\n  \t// 看上面\n    return typeof to === 'string' ? to : createPath(to);\n  }\n```\n\n\n\n##### push\n\n`push`的源码，里面附带了一些会用到的函数。\n\n```typescript\n// 就是简单处理一下返回值。\nfunction getNextLocation(to: To, state: State = null): Location {\n  return readOnly<Location>({\n    ...location,\n    ...(typeof to === 'string' ? parsePath(to) : to),\n    state,\n    key: createKey()\n  });\n}\n\n// 进行判断\nfunction allowTx(action: Action, location: Location, retry: () => void) {\n    return (\n      // 长度为0就返回true，长度大于0就调用函数，并传入参数。这个blockers等一下仔细探讨一下\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n\n// 顾名思义获取state和url\nfunction getHistoryStateAndUrl(\n    nextLocation: Location,\n    index: number\n  ): [HistoryState, string] {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      // 看上面 有专门介绍\n      createHref(nextLocation)\n    ];\n  }\n\n// 返回一些关于location的信息\nfunction getIndexAndLocation(): [number, Location] {\n    let { pathname, search, hash } = window.location;\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly<Location>({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n// 执行listeners内部的一些函数（也就是跳转），后面也会详细解读\nfunction applyTx(nextAction: Action) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n\nfunction push(to: To, state?: State) {\n  \t// 这里是一个枚举值\n    let nextAction = Action.Push;\n  \t\n    let nextLocation = getNextLocation(to, state);\n  \t// 顾名思义，就是再来一次\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        // MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        // MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/Location/assign\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n```\n\n我在注释里面已经进行非常详细的解读了，用到的每个函数都有解释或者官方权威的url。\n\n总结一下：`history.push`的一个完整流程\n\n- 调用`history.pushState`\n  - 错误由`window.location.assign`来处理\n- 执行一下`listeners`里面的函数\n\n是的，你没有看错，就这么简单，只是里面有很多调用的函数，我都截取出来一一解释，做到每行代码都理解，所以显得比较长，概括来说就是这么简单。\n\n重点来看一下`listen`和被调用的`createBrowserHistory`\n\n##### replace\n\n这里面用的函数，在前面的push都有解析，可以往上面去找找，就不多赘述了。\n\n```typescript\nfunction replace(to: To, state?: State) {\n    let nextAction = Action.Replace;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, '', url);\n\n      applyTx(nextAction);\n    }\n  }\n```\n\n\n\n##### listen\n\n在`history`返回的`listen`是一个函数。这个函数我们之前在react-router的源码中发现，他是在构造函数和卸载的时候会用到。\n\n```javascript\nlisten(listener) {\n      return listeners.push(listener);\n    },\n```\n\n仔细看看，这个`listeners`是在做些什么。\n\n##### createEvents\n\n这个函数后面的blockers也会用到\n\n```typescript\nlet listeners = createEvents<Listener>();\n\nfunction createEvents<F extends Function>(): Events<F> {\n  let handlers: F[] = [];\n\n  return {\n    get length() {\n      return handlers.length;\n    },\n    push(fn: F) {\n      handlers.push(fn);\n      return function() {\n        handlers = handlers.filter(handler => handler !== fn);\n      };\n    },\n    call(arg) {\n      handlers.forEach(fn => fn && fn(arg));\n    }\n  };\n}\n```\n\n这个方法，顾名思义，就是创建事件。定义了一个变量 `handlers` 数组，用于存放要处理的回调函数事件。\n\n然后返回了一个对象。\n\n`push` 方法就是往 `handlers` 中添加要执行的函数。\n\n这块主要在 `history.listen()` 中使用，可以翻到开头看下 `history` 中返回了 `listen()` 方法，就是调用了`listeners.push(listener)` 。\n\n最后 `call()` 方法就比较容易理解，就是取出 `handlers` 里面的回调函数并逐个执行。\n\n总结一下，就是存储一下`push`进来的函数，并进行过滤。之后调用的时候会依次执行。`length`就是当前拥有的函数数量。\n\n再切回去，就会发现，每次调用这个`listen`就相当于`push`一个函数到内部的一个变量`handlers`中。\n\n##### block\n\n和`listeners`一样，也是用`createEvents`创建的，就不多说啦。说一下哪里会用到这个吧。\n\n```typescript\nlet blockers = createEvents<Blocker>();\n```\n\n- `block(prompt)` - (function) Prevents navigation (see [the history docs](https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md))\n\n这个是`react-router`官网的解释。\n\n我这里简单概括一下，就是用于关闭或者回退浏览器的误操作会用到的。详细的可以看点击进去查看。\n\n##### 总结\n\n至此，我们调用的`createBrowserHistory`所返回的一些属性的源码都已经了如指掌了。但是具体是怎么工作还是一知半解。\n\n#### 具体核心原理\n\n先秀一下源码。history的核心原理就是这个。先别被这么多行代码唬到了，很多都是我们在之前的push里面有解释的\n\n```typescript\nconst PopStateEventType = 'popstate';\nlet blockedPopTx: Transition | null = null;\nfunction handlePop() {\n  // 如果有\n  if (blockedPopTx) {\n    blockers.call(blockedPopTx);\n    blockedPopTx = null;\n  } else {\n    let nextAction = Action.Pop;\n    let [nextIndex, nextLocation] = getIndexAndLocation();\n\n    if (blockers.length) {\n      if (nextIndex != null) {\n        let delta = index - nextIndex;\n        if (delta) {\n          // Revert the POP\n          blockedPopTx = {\n            action: nextAction,\n            location: nextLocation,\n            retry() {\n              go(delta * -1);\n            }\n          };\n\n          go(delta);\n        }\n      } else {\n        // Trying to POP to a location with no index. We did not create\n        // this location, so we can't effectively block the navigation.\n        warning(\n          false,\n          // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          `You are trying to block a POP navigation to a location that was not ` +\n          `created by the history library. The block will fail silently in ` +\n          `production, but in general you should do all navigation with the ` +\n          `history library (instead of using window.history.pushState directly) ` +\n          `to avoid this situation.`\n        );\n      }\n    } else {\n      applyTx(nextAction);\n    }\n  }\n}\n\nwindow.addEventListener(PopStateEventType, handlePop);\n```\n\n重点说一下`window.addEventListener(PopStateEventType, handlePop)`\n\nMDN地址：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event\n\n其实就是监听路由的变化然后，执行回调函数\n\n### createHashHistory\n\n这个大体上与普通路由一致。这里我想强调一些问题。\n\n> 比如哈希路由的锚点问题，我自己已知的几个方案\n>\n> - ### [scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)\n>\n> - ### [scrollTop](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop)\n>\n> - ## [react-anchor-without-hash](https://github.com/kwzm/react-anchor-without-hash)\n\n感兴趣的自己查询一下，这个不在本次的讨论范围内。\n\n#### 具体核心原理\n\n之前说的到，`history`路由的核心是`window.addEventListener(PopStateEventType, handlePop);`\n\n而哈希路由的核心也是监听路由的变化，只是参数不同。\n\n```javascript\nwindow.addEventListener('hashchange',function(e){\n    /* 监听改变 */\n})\n```\n\n而对路由的改变。`history`路由是：`history.pushState`，`history.replaceState`。\n\n哈希路由是：\n\n`window.location.hash`\n\n通过`window.location.hash `属性获取和设置 `hash `值。\n\n具体的话很差不多，关心细节的伙伴可以去看其源码哦。\n\n# 核心API\n\n之前我们看了BrowserRouter。我们回过头来看看，demo中的实例代码还有多少没有解决：\n\n```react\nimport React from 'react';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nfunction Home() {\n  return (\n    <>\n      <h1>首页</h1>\n      <Link to=\"/login\">登录</Link>\n    </>\n  )\n}\n\nfunction Login() {\n  return (\n    <>\n      <h1>登录页</h1>\n      <Link to=\"/\">回首页</Link>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/login\" component={Login}/>\n        <Route path=\"/\" component={Home}/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\n我们已经看完了`BrowserRouter`（`Router`。下面还有`Switch`和`Route`。\n\n## Switch\n\n先上源码。我摘取最核心的一部分。\n\n```react\nclass Switch extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Switch> outside a <Router>\");\n\n          // 默认使用context.location，如果有特殊定制的location才会使用。\n          // 下面有介绍\n          const location = this.props.location || context.location;\n\n          let element, match;\n\n          // We use React.Children.forEach instead of React.Children.toArray().find()\n          // here because toArray adds keys to all child elements and we do not want\n          // to trigger an unmount/remount for two <Route>s that render the same\n          // component at different URLs.\n          // React.Children.forEach 对子元素做遍历\n          React.Children.forEach(this.props.children, child => {\n            // 只要找到一个 match，那么就不会再进来了\n            if (match == null && React.isValidElement(child)) {\n              element = child;\n\n              // child.props.path 就不多讲了， Route 的标准写法\n              // 需要注意的是，使用 from 也会被匹配到\n              // 任何组件，只要在 Switch 下，有 from 属性，并且和当前路径匹配，就会被渲染\n              // from具体是给<Redirect>使用的，后面会说到\n              const path = child.props.path || child.props.from;\n\n              // 判断组件是否匹配\n              match = path\n              // 下面有专属的介绍这个函数\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\n```\n\nSwitch中的location这个props怎么用？什么用？\n\n> ## 摘自官网\n>\n> ## [location: object](https://reactrouter.com/web/api/Switch/location-object)\n>\n> A [`location`](https://reactrouter.com/web/api/location) object to be used for matching children elements instead of the current history location (usually the current browser URL).\n>\n> 谷歌翻译：用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。\n\n### matchPath\n\n```javascript\nfunction matchPath(pathname, options = {}) {\n  // 规范结构体\n  // 如果 options 传的是个 string，那默认这个 string 代表 path\n  // 如果 options 传的是个 数组，那只要有一个匹配，就认为匹配\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  // 转化成数组进行判断\n  const paths = [].concat(path);\n\n  // 都是很简单的内容，难点就在这个reduce，这个很有意思，感兴趣或者不了解的赶紧去MDN了解一下！！！\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    // 只要有一个 match，直接返回，认为是 match\n    if (matched) return matched;\n\n    // regexp 是正则表达式\n    // keys 是切割出来的得 key 的值\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    // exec() 该方法如果找到了匹配的文本的话，则会返回一个结果数组，否则的话，会返回一个\n    const match = regexp.exec(pathname);\n    /* 匹配不成功，返回null */\n    if (!match) return null;\n\n    // url 表示匹配到的部分\n    const [url, ...values] = match;\n    // pathname === url 表示完全匹配\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n```\n\nmatchPath 函数也是由 react-router export 出去的函数，我们可以用来获得某个 url 中的指定的参数。\n\n\n\n## Route\n\nRoute 是用于声明路由映射到应用程序的组件层。\n\nRoute 有三种渲染的方法，当然，都配置的话只有一个会生效，优先级是 children > component > render\n\n\\1. <Route component>\n\\2. <Route render>\n\\3. <Route children>\n\n每个在不同的情况下都有用，大多数情况下，会使用 component。\n\n### component\n\ncomponent 表示只有当位置匹配时才会渲染的 React 组件。使用 component（而不是 render 或 children ）Route 使用从给定组件 React.createElement(element, props) 创建新的 React element。这意味着，使用 component 创建的组件能获得 router 中的 props。\n\n### children\n\n从源码中可以看出，children 的优先级是高于 component，而且可以是一个组件，也可以是一个函数，children 没有获得 router 的 props。\n\nchildren 有一个非常特殊的地方在于，当路由不匹配且 children 是一个函数的时候，会执行 children 方法，这就给了设计很大的灵活性。\n\n### render\n\nrender 必须是一个函数，优先级是最低的，当匹配成功的时候，执行这个函数。\n\n### exact & strict & sensitive\n\n这三者都是使用 path-to-regexp 做路径匹配需要的三个参数。\n\n1. exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。\n2. strict: 在确定为位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线。\n3. sensitive: 如果路径区分大小写，则为 true ，则匹配。\n\n### location\n\nRoute 元素尝试其匹配 path 到当前浏览器 URL，但是，也可以通过 location 实现与当前浏览器位置以外的位置相匹配。\n\n下面列出 Route 源码，并且删去了 dev 部分。\n\n```js\nimport React from \"react\";\nimport { isValidElementType } from \"react-is\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Route> outside a <Router>\");\n\n          // 可以看出，用户传的 location 覆盖掉了 context 中的 location\n          const location = this.props.location || context.location;\n\n          // 如果有 computedMatch 就用 computedMatch 作为结果\n          // 如果没有，则判断是否有 path 传参\n          // matchPath 是调用 path-to-regexp 判断是否匹配\n          // path-to-regexp 需要三个参数\n          // exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配\n          // strict: 如果为 true 当真实的路径具有一个斜线将只匹配一个斜线location.pathname\n          // sensitive: 如果路径区分大小写，则为 true ，则匹配\n          const match = this.props.computedMatch\n            ? this.props.computedMatch // <Switch> already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n\n          // props 就是更新后的 context\n          // location 做了更新（有可能是用户传入的location）\n          // match 做了更新\n          const props = { ...context, location, match };\n\n          // 三种渲染方式\n          let { children, component, render } = this.props;\n\n          // Preact uses an empty array as children by\n          // default, so use null if that's the case.\n          // children 默认是个空数组，如果是默认情况，置为 null\n          if (Array.isArray(children) && children.length === 0) {\n            children = null;\n          }\n\n          return (\n            // RouterContext 中更新了 location, match\n            <RouterContext.Provider value={props}>\n              {props.match\n              // 首先判断的是有无 children\n                ? children\n                  // 如果 children 是个函数，执行，否则直接返回 children\n                  ? typeof children === \"function\"\n                  : children(props)\n                  : children\n                  // 如果没有 children，判断有无 component\n                : component\n                  // 有 component，重新新建一个 component\n                  ? React.createElement(component, props)\n                  // 没有 component，判断有无 render\n                  : render\n                  // 有 render，执行 render 方法\n                  ? render(props)\n                  // 没有返回 null\n                  : null\n\n                // 这里是不 match 的情况，判断 children 是否函数\n                : typeof children === \"function\"\n                // 是的话执行\n                ? children(props)\n                : null}\n            </RouterContext.Provider>\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nexport default Route;\n```\n\nRoute 组件根据自身的传参，对上层 RouterContext 中的部分属性（location 和 match）进行了更新，并且如果当前路径和配置的 path 路径 match，则渲染该组件，渲染的方式有 children，component，render 三种方式，我们最常用的就是 component 方式，注意每种方式的区别。\n\n## Prompt\n\nPrompt 用于路由切换提示。这在某些场景下是非常有用的，比如用户在某个页面修改数据，离开时，提示用户是否保存，Prompt 组件有俩个属性：\n\n1. message：用于显示提示的文本信息。\n2. when：传递布尔值，相当于标签的开关，默认是 true，设置成 false 时，失效。\n\nPrompt 的本质是在 when 为 true 的时候，调用 context.history.block 方法，为全局注册路由监听，block 的原理看之前的 history 相关文章。路有变化的时候，默认使用 window.confirm 进行确认，我们也可以自定义 confirm 的形式，就是在 BrowserRouter 或者 HashRouter 传入 getUserConfirmation 这个参数，会替换掉 window.confirm。\n\n```react\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\nfunction Prompt({ message, when = true }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Prompt> outside a <Router>\");\n\n        if (!when || context.staticContext) return null;\n\n        // 调用了 history.block 方法\n        const method = context.history.block;\n\n        return (\n          <Lifecycle\n            onMount={self => {\n              self.release = method(message);\n            }}\n            onUpdate={(self, prevProps) => {\n              if (prevProps.message !== message) {\n                self.release();\n                self.release = method(message);\n              }\n            }}\n            onUnmount={self => {\n              self.release();\n            }}\n            message={message}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nexport default Prompt;\n```\n\n## Redirect\n\nRedirect 与其说是一个组件，不如说是有组件封装的一组方法，该组件在 componentDidMount 生命周期内，通过调用 history API 跳转到到新位置，默认情况下，新位置将覆盖历史堆栈中的当前位置。\n\n<Redirect to=\"/somewhere/else\"/> to 表示要重定向到的网址。to 也可以是一个 location 对象\n\n<Redirect push to=\"/somewhere/else\"/> push 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目。\n\n结合 Switch 和 Redirect 源码看，如果 Redirect 中有 from 属性，会被 Switch 获得，当 from 和当前路径匹配的时候，就会渲染 Redirect 组件，执行跳转。\n\n```js\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, locationsAreEqual } from \"history\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\nimport generatePath from \"./generatePath.js\";\n\n/**\n * The public API for navigating programmatically with a component.\n */\nfunction Redirect({ computedMatch, to, push = false }) {\n  return (\n    // 啥都有的大哥 RouterContext\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Redirect> outside a <Router>\");\n\n        const { history, staticContext } = context;\n\n        // 一般来说，Redirect 操作都不需要留有 history，所以选择选择 history.replace\n        const method = push ? history.push : history.replace;\n\n\n        const location = createLocation(\n          // computedMatch 就是看看 switch 有没有多管闲事\n          computedMatch\n            ? typeof to === \"string\"\n              ? generatePath(to, computedMatch.params)\n              : {\n                  ...to,\n                  pathname: generatePath(to.pathname, computedMatch.params)\n                }\n            : to\n        );\n\n        // When rendering in a static context,\n        // set the new location immediately.\n        // staticRouter 专用\n        if (staticContext) {\n          method(location);\n          return null;\n        }\n\n        return (\n          <Lifecycle\n            onMount={() => {\n              // componentDidMount 的时候执行 method(location)，也就是 history.replace 操作\n              method(location);\n            }}\n            onUpdate={(self, prevProps) => {\n              // componentDidUpdate 时候判断当前 location 和上一个 location 是否发生变化\n              // 只要发生变化，调用 method(location)\n              // 一般来讲，在 componentDidMount 的时候就跳走了，不会等到 componentDidUpdate\n              const prevLocation = createLocation(prevProps.to);\n              if (\n                !locationsAreEqual(prevLocation, {\n                  ...location,\n                  key: prevLocation.key\n                })\n              ) {\n                method(location);\n              }\n            }}\n\n            // 无效\n            to={to}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nexport default Redirect;\n```\n\nLifecycle 不 render 任何页面，只有生命周期函数，Lifecycle 提供了 onMount， onUpdate， onUnmount 三个生命周期函数。\n\n```js\nimport React from \"react\";\n\nclass Lifecycle extends React.Component {\n  componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  }\n\n  componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  }\n\n  render() {\n    return null;\n  }\n}\n\nexport default Lifecycle;\n```\n\n# 总结\n\n整个`react-router`是由`createBrowserHistory`或者`createHashHistory`来牵头，与我们的`React`组件绑定在一起，然后传递了一些属于`history`这个库的方法以及数值。当然，还有路由的匹配和渲染。\n\n在`history`这个库里面又有对于路由的监听，改变等等。\n\n## 流程\n\n以`history`模式做参考（也是我们重点阅读的。\n\n### 修改url\n\n当`url`改变的时候，会触发写在`window`上面的监听`window.addEventListener('popstate', handlePop)`。\n\n调用了我们的函数`handlePop`\n\n函数内部我们`setState`，修改了`location`，方便传递正确的值下去，并通过了`Switch`找出匹配的`Route`组件。\n\n触发了组件的渲染。\n\n> 当然也包括我们所谓的history.push，history.repalce等等这些方法，本质上也是修改url，然后就是重复上面的步骤\n\n\n\n\n\n\n\n","slug":"【重识前端】React-Router源码阅读","published":1,"updated":"2021-06-27T07:33:14.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra860018lwrdeqypcfqk","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>此处介绍一下React-Router的核心原理。特别细致的标点符号的不予讨论。</p>\n<h1 id=\"学前小知识\"><a href=\"#学前小知识\" class=\"headerlink\" title=\"学前小知识\"></a>学前小知识</h1><p><code>React-Router</code>其实最核心的东西是<code>Route</code>组件和由统一作者开发的<code>History</code>库来建立的。接下来跟着镜头一起走进神秘的<code>ßReact-Router</code>世界吧。</p>\n<p>已经知道怎么使用的直接跳过，到下面的源码分析去┗|｀O′|┛ 嗷~~</p>\n<h1 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h1><p>一起建一个简单的示例吧。先用<code>react</code>官网的<code>create-react-app</code>脚手架弄个<code>react</code>出来。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app my-app</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my-app</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n\n<p>安装<a href=\"https://reactrouter.com/web/guides/quick-start\" target=\"_blank\" rel=\"noopener\">react-router-dom</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom</span><br></pre></td></tr></table></figure>\n\n<p>在大家安装之余，我简答的介绍一下<code>react-router</code>和<code>react-router-dom</code>的区别。</p>\n<h2 id=\"react-router和react-router-dom的区别。\"><a href=\"#react-router和react-router-dom的区别。\" class=\"headerlink\" title=\"react-router和react-router-dom的区别。\"></a>react-router和react-router-dom的区别。</h2><h3 id=\"先看提供的API\"><a href=\"#先看提供的API\" class=\"headerlink\" title=\"先看提供的API\u0003\"></a>先看提供的API\u0003</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route, Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Swtich, Route, BrowserRouter, HashHistory, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"React-router\"><a href=\"#React-router\" class=\"headerlink\" title=\"React-router\"></a>React-router</h4><p>提供了路由的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api；</p>\n<h4 id=\"React-router-dom\"><a href=\"#React-router-dom\" class=\"headerlink\" title=\"React-router-dom\"></a>React-router-dom</h4><p>提供了<code>BrowserRouter</code>、<code>Route</code>、<code>Link</code>等api，可以通过dom操作触发事件控制路由。</p>\n<p><code>Link</code>组件，会渲染一个a标签；<code>BrowserRouter</code>和<code>HashRouter</code>组件，前者使用<code>pushState</code>和<code>popState</code>事件构建路由，后者使用<code>hash</code>和 <code>hashchange</code>事件构建路由。</p>\n<p><code>react-router-dom</code>在<code>react-router</code>的基础上扩展了可操作<code>dom</code>的<code>api</code>。</p>\n<p><code>Swtich</code> 和 <code>Route</code> 都是从<code>react-router</code>中导入了相应的组件并重新导出，没做什么特殊处理。</p>\n<p><code>react-router-dom</code>中<code>package.json</code>依赖中存在对<code>react-router</code>的依赖，故此，不需要<code>npm</code>安装<code>react-router</code>。</p>\n<blockquote>\n<ul>\n<li>可直接 npm 安装 react-router-dom，使用其api。</li>\n</ul>\n</blockquote>\n<h2 id=\"简单修改\"><a href=\"#简单修改\" class=\"headerlink\" title=\"简单修改\"></a>简单修改</h2><p>👌，大家🔥应该已经安装完了吧？接下来简单的修改一下脚手架里面的内容。主要是为了熟悉对手，知己知彼百战百胜。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/router/demo.png\"  alt=\"demo\"></p>\n<p>修改一下<code>src/app.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  BrowserRouter <span class=\"keyword\">as</span> Router,</span><br><span class=\"line\">  Switch,</span><br><span class=\"line\">  Route,</span><br><span class=\"line\">  Link,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Home</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;首页&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Link to=\"/</span>login<span class=\"string\">\"&gt;登录&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function Login() &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return (</span></span><br><span class=\"line\"><span class=\"string\">    &lt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;登录页&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;Link to=\"</span>/<span class=\"string\">\"&gt;回首页&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  );</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return (</span></span><br><span class=\"line\"><span class=\"string\">    &lt;Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Route path=\"</span>/login<span class=\"string\">\" component=&#123;Login&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Route path=\"</span>/<span class=\"string\">\" component=&#123;Home&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">  );</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export default App;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了一个最简单的示例了。</p>\n<h1 id=\"SPA的核心思想\"><a href=\"#SPA的核心思想\" class=\"headerlink\" title=\"SPA的核心思想\"></a>SPA的核心思想</h1><ul>\n<li>监听<code>URL</code>的变化</li>\n<li>改变某些<code>context</code>的值</li>\n<li>获取对应的页面组件</li>\n<li><code>render</code>新的页面</li>\n</ul>\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><h2 id=\"BrowserRouter\"><a href=\"#BrowserRouter\" class=\"headerlink\" title=\"BrowserRouter\"></a>BrowserRouter</h2><p>从前面的简单示例中我们，发现有一个最外层的伙计，叫<code>BrowserRouter</code>。我们直接干到他的github源码去瞅瞅。</p>\n<p>链接：<a href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> warning <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-warning\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for a &lt;Router&gt; that uses HTML5 history.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">  BrowserRouter.propTypes = &#123;</span><br><span class=\"line\">    basename: PropTypes.string,</span><br><span class=\"line\">    children: PropTypes.node,</span><br><span class=\"line\">    forceRefresh: PropTypes.bool,</span><br><span class=\"line\">    getUserConfirmation: PropTypes.func,</span><br><span class=\"line\">    keyLength: PropTypes.number</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  BrowserRouter.prototype.componentDidMount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    warning(</span><br><span class=\"line\">      !<span class=\"keyword\">this</span>.props.history,</span><br><span class=\"line\">      <span class=\"string\">\"&lt;BrowserRouter&gt; ignores the history prop. To use a custom history, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"use `import &#123; Router &#125;` instead of `import &#123; BrowserRouter as Router &#125;`.\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> BrowserRouter;</span><br></pre></td></tr></table></figure>\n\n<p>抛开一些七七八八的判断。重新看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写着几个大字：《瓜子二手车》他只是一个中间商，他在赚差价。（打钱！</p>\n<p><code>BrowserRouter</code>是依赖于两个库：分别为<code>history</code>和<code>react-router</code>。ok，我们一探究竟。</p>\n<h2 id=\"react-router\"><a href=\"#react-router\" class=\"headerlink\" title=\"react-router\"></a>react-router</h2><p>源码链接：<a href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> HistoryContext <span class=\"keyword\">from</span> <span class=\"string\">\"./HistoryContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这两个东西其实很简单，都是引用了一个叫做<code>createContext</code>，目的也很简单，这里其实就是创建的普通context，只不过拥有特定的名称而已。源码如下。就几行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> Replace with React.createContext once we can assume React 16+</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createContext <span class=\"keyword\">from</span> <span class=\"string\">\"mini-create-react-context\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNamedContext = <span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createContext();</span><br><span class=\"line\">  context.displayName = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> createNamedContext;</span><br></pre></td></tr></table></figure>\n\n<p>OK，重点是接下来，抛开context之后，我们需要关注的东西。我整理一下。</p>\n<p>先看构造函数</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">    location: props.history.location</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// This is a bit of a hack. We have to start listening for location</span></span><br><span class=\"line\">  <span class=\"comment\">// changes here in the constructor in case there are any &lt;Redirect&gt;s</span></span><br><span class=\"line\">  <span class=\"comment\">// on the initial render. If there are, they will replace/push when</span></span><br><span class=\"line\">  <span class=\"comment\">// they mount and since cDM fires in children before parents, we may</span></span><br><span class=\"line\">  <span class=\"comment\">// get a new location before the &lt;Router&gt; is mounted.</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// _isMounted 表示组件是否加载完成</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 组件未加载完毕，但是 location 发生的变化，暂存在 _pendingLocation 字段中</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._pendingLocation = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 staticContext 属性，表示是 HashRouter 或是 BrowserRouter</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!props.staticContext) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.unlisten = props.history.listen(<span class=\"function\"><span class=\"params\">location</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._isMounted) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 组件加载完毕，将变化的 location 方法 state 中</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; location &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._pendingLocation = location;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有两个值☞<code>_isMounted</code>和<code>_pendingLocation</code></p>\n<p>分别是  是否挂载   待定</p>\n<p>内部维护了一个location，默认值是由外面传入的history，我找到传入的地方。</p>\n<p>其实就是之前看到的<code>BrowserRouter</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难发现，history的默认值就是由history这个库来提供的，这个后面会提到，我们继续看。</p>\n<p>先简单看一下注释的翻译(谷歌翻译)</p>\n<blockquote>\n<p>这有点hack。 我们必须开始在构造函数中监听位置更改，以防初始渲染中存在任何<Redirect>。 如果有的话，它们将在安装时替换/推动，并且由于cDM在父级之前在子级中触发，因此在安装<Router>之前，我们可能会获得一个新位置。 </p>\n</blockquote>\n<p>什么意思呢，我简单描述一下：</p>\n<blockquote>\n<p>因为子组件会比父组件更早渲染完成, 以及<code>&lt;Redirect&gt;</code>的存在, 若是在<code>&lt;Router&gt;</code>的<code>componentDidMount</code>生命周期中对<code>history.location</code>进行监听, 则有可能在监听事件注册之前, <code>history.location</code>已经由于<code>&lt;Redirect&gt;</code>发生了多次改变, 因此我们需要在<code>&lt;Router&gt;</code>的<code>constructor</code>中就注册监听事件</p>\n</blockquote>\n<p>收回来，进入<code>if</code>继续看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.unlisten = props.history.listen(<span class=\"function\"><span class=\"params\">location</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._isMounted) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.setState(&#123; location &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>._pendingLocation = location;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>就是调用了<code>history</code>的<code>listen</code>方法。从代码中可以大致了解到就是对<code>history</code>进行监听，然后进行一些操作。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>那么这个<code>unlisten</code>什么时候执行呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.unlisten) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unlisten();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._pendingLocation = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Router</code>这个组件卸载的时候就执行啦。也就是说，取消了对<code>history</code>的监听。</p>\n<h3 id=\"componentDidUnmount\"><a href=\"#componentDidUnmount\" class=\"headerlink\" title=\"componentDidUnmount\"></a>componentDidUnmount</h3><p>然后看一下<code>conponentDidMount</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingLocation) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">location</span>: <span class=\"keyword\">this</span>._pendingLocation &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>也很简单，就是修改一下是否挂载的值，以及继续之前在构造函数里面的判断。如果暂存数据有的话就把他存下来。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;RouterContext.Provider</span><br><span class=\"line\">        value&#x3D;&#123;&#123;</span><br><span class=\"line\">          &#x2F;&#x2F; 根据 HashRouter 还是 BrowserRouter，可判断 history 类型</span><br><span class=\"line\">          history: this.props.history,</span><br><span class=\"line\">          &#x2F;&#x2F; 这个 location 就是监听 history 变化得到的 location</span><br><span class=\"line\">          location: this.state.location,</span><br><span class=\"line\">          &#x2F;&#x2F; path url params isExact 四个属性</span><br><span class=\"line\">          match: Router.computeRootMatch(this.state.location.pathname),</span><br><span class=\"line\">          &#x2F;&#x2F; 只有 StaticRouter 会传 staticContext</span><br><span class=\"line\">          &#x2F;&#x2F; HashRouter 和 BrowserRouter 都是 null</span><br><span class=\"line\">          staticContext: this.props.staticContext</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;HistoryContext.Provider</span><br><span class=\"line\">          children&#x3D;&#123;this.props.children || null&#125;</span><br><span class=\"line\">          value&#x3D;&#123;this.props.history&#125;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;RouterContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Router这个组件主要就是将一些数据进行存储。存到<code>Context</code>，之间不乏一些特殊情况的判断，比如子组件渲染比父组件早，以及<code>Redirect</code>的情况的处理。在卸载的时候要移除对<code>history</code>的监听。</p>\n<p>子组件作为消费者，就可以对页面进行修改，跳转，获取这些数值。</p>\n<h2 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h2><h3 id=\"createBrowserHistory\"><a href=\"#createBrowserHistory\" class=\"headerlink\" title=\"createBrowserHistory\"></a>createBrowserHistory</h3><h4 id=\"返回的内容\"><a href=\"#返回的内容\" class=\"headerlink\" title=\"返回的内容\"></a>返回的内容</h4><p>之前一直有不断提到的<code>history</code>，我们一起来看看它是谁</p>\n<p>源码连接：<a href=\"https://github.com/ReactTraining/history/blob/master/packages/history/index.ts\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/history/blob/master/packages/history/index.ts</a></p>\n<p>我们之前用到的<code>createBrowserHistory</code>，他其实是返回的一个对象，这个对象里面有我们常用的一些方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> history: BrowserHistory = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> action() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">get</span> location() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> location;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    createHref,</span><br><span class=\"line\">    push,</span><br><span class=\"line\">    replace,</span><br><span class=\"line\">    go,</span><br><span class=\"line\">    back() &#123;</span><br><span class=\"line\">      go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    forward() &#123;</span><br><span class=\"line\">      go(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    listen(listener) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> listeners.push(listener);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    block(blocker) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> unblock = blockers.push(blocker);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (blockers.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(BeforeUnloadEventType, promptBeforeUnload);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        unblock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove the beforeunload listener so the document may</span></span><br><span class=\"line\">        <span class=\"comment\">// still be salvageable in the pagehide event.</span></span><br><span class=\"line\">        <span class=\"comment\">// See https://html.spec.whatwg.org/#unloading-documents</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!blockers.length) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> history;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大部分精髓就是这里。发现有多熟悉的伙伴！ =&gt; <code>push</code>、<code>replace</code>、<code>go</code>等等。有些其实都是<code>window</code>提供的。</p>\n<p>有些直接看代码就可以明白的就不解释了，比如<code>forward</code>，<code>back</code>。</p>\n<h5 id=\"go\"><a href=\"#go\" class=\"headerlink\" title=\"go\"></a>go</h5><p>比如上面提到的<code>go</code>方法，截取部分源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalHistory = <span class=\"built_in\">window</span>.history;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    globalHistory.go(delta);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"createHref\"><a href=\"#createHref\" class=\"headerlink\" title=\"createHref\"></a>createHref</h5><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个完整的url</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPath</span>(<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pathname = '/',</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  search = '',</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hash = ''</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;: PartialPath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pathname + search + hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个url</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHref</span>(<span class=\"params\">to: To</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 看上面</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> to === <span class=\"string\">'string'</span> ? to : createPath(to);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h5><p><code>push</code>的源码，里面附带了一些会用到的函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 就是简单处理一下返回值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNextLocation</span>(<span class=\"params\">to: To, state: State = <span class=\"literal\">null</span></span>): <span class=\"title\">Location</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> readOnly&lt;Location&gt;(&#123;</span><br><span class=\"line\">    ...location,</span><br><span class=\"line\">    ...(<span class=\"keyword\">typeof</span> to === <span class=\"string\">'string'</span> ? parsePath(to) : to),</span><br><span class=\"line\">    state,</span><br><span class=\"line\">    key: createKey()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allowTx</span>(<span class=\"params\">action: Action, location: Location, retry: () =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 长度为0就返回true，长度大于0就调用函数，并传入参数。这个blockers等一下仔细探讨一下</span></span><br><span class=\"line\">      !blockers.length || (blockers.call(&#123; action, location, retry &#125;), <span class=\"literal\">false</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顾名思义获取state和url</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHistoryStateAndUrl</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    nextLocation: Location,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    index: <span class=\"built_in\">number</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>): [<span class=\"title\">HistoryState</span>, <span class=\"title\">string</span>] </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        usr: nextLocation.state,</span><br><span class=\"line\">        key: nextLocation.key,</span><br><span class=\"line\">        idx: index</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 看上面 有专门介绍</span></span><br><span class=\"line\">      createHref(nextLocation)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一些关于location的信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIndexAndLocation</span>(<span class=\"params\"></span>): [<span class=\"title\">number</span>, <span class=\"title\">Location</span>] </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; pathname, search, hash &#125; = <span class=\"built_in\">window</span>.location;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> state = globalHistory.state || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      state.idx,</span><br><span class=\"line\">      readOnly&lt;Location&gt;(&#123;</span><br><span class=\"line\">        pathname,</span><br><span class=\"line\">        search,</span><br><span class=\"line\">        hash,</span><br><span class=\"line\">        state: state.usr || <span class=\"literal\">null</span>,</span><br><span class=\"line\">        key: state.key || <span class=\"string\">'default'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行listeners内部的一些函数（也就是跳转），后面也会详细解读</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyTx</span>(<span class=\"params\">nextAction: Action</span>) </span>&#123;</span><br><span class=\"line\">    action = nextAction;</span><br><span class=\"line\">    [index, location] = getIndexAndLocation();</span><br><span class=\"line\">    listeners.call(&#123; action, location &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">to: To, state?: State</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 这里是一个枚举值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Push;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextLocation = getNextLocation(to, state);</span><br><span class=\"line\">  \t<span class=\"comment\">// 顾名思义，就是再来一次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      push(to, state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowTx(nextAction, nextLocation, retry)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> [historyState, url] = getHistoryStateAndUrl(nextLocation, index + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Support forced reloading</span></span><br><span class=\"line\">      <span class=\"comment\">// try...catch because iOS limits us to 100 pushState calls :/</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState</span></span><br><span class=\"line\">        globalHistory.pushState(historyState, <span class=\"string\">''</span>, url);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// They are going to lose state here, but there is no real</span></span><br><span class=\"line\">        <span class=\"comment\">// way to warn them about it since the page will refresh...</span></span><br><span class=\"line\">        <span class=\"comment\">// MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/Location/assign</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.location.assign(url);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在注释里面已经进行非常详细的解读了，用到的每个函数都有解释或者官方权威的url。</p>\n<p>总结一下：<code>history.push</code>的一个完整流程</p>\n<ul>\n<li>调用<code>history.pushState</code><ul>\n<li>错误由<code>window.location.assign</code>来处理</li>\n</ul>\n</li>\n<li>执行一下<code>listeners</code>里面的函数</li>\n</ul>\n<p>是的，你没有看错，就这么简单，只是里面有很多调用的函数，我都截取出来一一解释，做到每行代码都理解，所以显得比较长，概括来说就是这么简单。</p>\n<p>重点来看一下<code>listen</code>和被调用的<code>createBrowserHistory</code></p>\n<h5 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h5><p>这里面用的函数，在前面的push都有解析，可以往上面去找找，就不多赘述了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">to: To, state?: State</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Replace;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextLocation = getNextLocation(to, state);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      replace(to, state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowTx(nextAction, nextLocation, retry)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> [historyState, url] = getHistoryStateAndUrl(nextLocation, index);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Support forced reloading</span></span><br><span class=\"line\">      globalHistory.replaceState(historyState, <span class=\"string\">''</span>, url);</span><br><span class=\"line\"></span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen\"></a>listen</h5><p>在<code>history</code>返回的<code>listen</code>是一个函数。这个函数我们之前在react-router的源码中发现，他是在构造函数和卸载的时候会用到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(listener) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> listeners.push(listener);</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>仔细看看，这个<code>listeners</code>是在做些什么。</p>\n<h5 id=\"createEvents\"><a href=\"#createEvents\" class=\"headerlink\" title=\"createEvents\"></a>createEvents</h5><p>这个函数后面的blockers也会用到</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> listeners = createEvents&lt;Listener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createEvents</span>&lt;<span class=\"title\">F</span> <span class=\"title\">extends</span> <span class=\"title\">Function</span>&gt;(<span class=\"params\"></span>): <span class=\"title\">Events</span>&lt;<span class=\"title\">F</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handlers: F[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> length() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handlers.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    push(fn: F) &#123;</span><br><span class=\"line\">      handlers.push(fn);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        handlers = handlers.filter(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler !== fn);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    call(arg) &#123;</span><br><span class=\"line\">      handlers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn &amp;&amp; fn(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法，顾名思义，就是创建事件。定义了一个变量 <code>handlers</code> 数组，用于存放要处理的回调函数事件。</p>\n<p>然后返回了一个对象。</p>\n<p><code>push</code> 方法就是往 <code>handlers</code> 中添加要执行的函数。</p>\n<p>这块主要在 <code>history.listen()</code> 中使用，可以翻到开头看下 <code>history</code> 中返回了 <code>listen()</code> 方法，就是调用了<code>listeners.push(listener)</code> 。</p>\n<p>最后 <code>call()</code> 方法就比较容易理解，就是取出 <code>handlers</code> 里面的回调函数并逐个执行。</p>\n<p>总结一下，就是存储一下<code>push</code>进来的函数，并进行过滤。之后调用的时候会依次执行。<code>length</code>就是当前拥有的函数数量。</p>\n<p>再切回去，就会发现，每次调用这个<code>listen</code>就相当于<code>push</code>一个函数到内部的一个变量<code>handlers</code>中。</p>\n<h5 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"block\"></a>block</h5><p>和<code>listeners</code>一样，也是用<code>createEvents</code>创建的，就不多说啦。说一下哪里会用到这个吧。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> blockers = createEvents&lt;Blocker&gt;();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>block(prompt)</code> - (function) Prevents navigation (see <a href=\"https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md\" target=\"_blank\" rel=\"noopener\">the history docs</a>)</li>\n</ul>\n<p>这个是<code>react-router</code>官网的解释。</p>\n<p>我这里简单概括一下，就是用于关闭或者回退浏览器的误操作会用到的。详细的可以看点击进去查看。</p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>至此，我们调用的<code>createBrowserHistory</code>所返回的一些属性的源码都已经了如指掌了。但是具体是怎么工作还是一知半解。</p>\n<h4 id=\"具体核心原理\"><a href=\"#具体核心原理\" class=\"headerlink\" title=\"具体核心原理\"></a>具体核心原理</h4><p>先秀一下源码。history的核心原理就是这个。先别被这么多行代码唬到了，很多都是我们在之前的push里面有解释的</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PopStateEventType = <span class=\"string\">'popstate'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> blockedPopTx: Transition | <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handlePop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果有</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (blockedPopTx) &#123;</span><br><span class=\"line\">    blockers.call(blockedPopTx);</span><br><span class=\"line\">    blockedPopTx = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Pop;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> [nextIndex, nextLocation] = getIndexAndLocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (blockers.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nextIndex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> delta = index - nextIndex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Revert the POP</span></span><br><span class=\"line\">          blockedPopTx = &#123;</span><br><span class=\"line\">            action: nextAction,</span><br><span class=\"line\">            location: nextLocation,</span><br><span class=\"line\">            retry() &#123;</span><br><span class=\"line\">              go(delta * <span class=\"number\">-1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          go(delta);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Trying to POP to a location with no index. We did not create</span></span><br><span class=\"line\">        <span class=\"comment\">// this location, so we can't effectively block the navigation.</span></span><br><span class=\"line\">        warning(</span><br><span class=\"line\">          <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Write up a doc that explains our blocking strategy in</span></span><br><span class=\"line\">          <span class=\"comment\">// detail and link to it here so people can understand better what</span></span><br><span class=\"line\">          <span class=\"comment\">// is going on and how to avoid it.</span></span><br><span class=\"line\">          <span class=\"string\">`You are trying to block a POP navigation to a location that was not `</span> +</span><br><span class=\"line\">          <span class=\"string\">`created by the history library. The block will fail silently in `</span> +</span><br><span class=\"line\">          <span class=\"string\">`production, but in general you should do all navigation with the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`history library (instead of using window.history.pushState directly) `</span> +</span><br><span class=\"line\">          <span class=\"string\">`to avoid this situation.`</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(PopStateEventType, handlePop);</span><br></pre></td></tr></table></figure>\n\n<p>重点说一下<code>window.addEventListener(PopStateEventType, handlePop)</code></p>\n<p>MDN地址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event</a></p>\n<p>其实就是监听路由的变化然后，执行回调函数</p>\n<h3 id=\"createHashHistory\"><a href=\"#createHashHistory\" class=\"headerlink\" title=\"createHashHistory\"></a>createHashHistory</h3><p>这个大体上与普通路由一致。这里我想强调一些问题。</p>\n<blockquote>\n<p>比如哈希路由的锚点问题，我自己已知的几个方案</p>\n<ul>\n<li><h3 id=\"scrollIntoView\"><a href=\"#scrollIntoView\" class=\"headerlink\" title=\"scrollIntoView\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView\" target=\"_blank\" rel=\"noopener\">scrollIntoView</a></h3></li>\n<li><h3 id=\"scrollTop\"><a href=\"#scrollTop\" class=\"headerlink\" title=\"scrollTop\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\" target=\"_blank\" rel=\"noopener\">scrollTop</a></h3></li>\n<li><h2 id=\"react-anchor-without-hash\"><a href=\"#react-anchor-without-hash\" class=\"headerlink\" title=\"react-anchor-without-hash\"></a><a href=\"https://github.com/kwzm/react-anchor-without-hash\" target=\"_blank\" rel=\"noopener\">react-anchor-without-hash</a></h2></li>\n</ul>\n</blockquote>\n<p>感兴趣的自己查询一下，这个不在本次的讨论范围内。</p>\n<h4 id=\"具体核心原理-1\"><a href=\"#具体核心原理-1\" class=\"headerlink\" title=\"具体核心原理\"></a>具体核心原理</h4><p>之前说的到，<code>history</code>路由的核心是<code>window.addEventListener(PopStateEventType, handlePop);</code></p>\n<p>而哈希路由的核心也是监听路由的变化，只是参数不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听改变 */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而对路由的改变。<code>history</code>路由是：<code>history.pushState</code>，<code>history.replaceState</code>。</p>\n<p>哈希路由是：</p>\n<p><code>window.location.hash</code></p>\n<p>通过<code>window.location.hash</code>属性获取和设置 <code>hash</code>值。</p>\n<p>具体的话很差不多，关心细节的伙伴可以去看其源码哦。</p>\n<h1 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h1><p>之前我们看了BrowserRouter。我们回过头来看看，demo中的实例代码还有多少没有解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  BrowserRouter as Router,</span><br><span class=\"line\">  Switch,</span><br><span class=\"line\">  Route,</span><br><span class=\"line\">  Link,</span><br><span class=\"line\">&#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Home() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;首页&lt;&#x2F;h1&gt;</span><br><span class=\"line\">      &lt;Link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;Link&gt;</span><br><span class=\"line\">    &lt;&#x2F;&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Login() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;登录页&lt;&#x2F;h1&gt;</span><br><span class=\"line\">      &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;回首页&lt;&#x2F;Link&gt;</span><br><span class=\"line\">    &lt;&#x2F;&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;Router&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path&#x3D;&quot;&#x2F;login&quot; component&#x3D;&#123;Login&#125;&#x2F;&gt;</span><br><span class=\"line\">        &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;Switch&gt;</span><br><span class=\"line\">    &lt;&#x2F;Router&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经看完了<code>BrowserRouter</code>（<code>Router</code>。下面还有<code>Switch</code>和<code>Route</code>。</p>\n<h2 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h2><p>先上源码。我摘取最核心的一部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Switch extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">        &#123;context &#x3D;&gt; &#123;</span><br><span class=\"line\">          invariant(context, &quot;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">          &#x2F;&#x2F; 默认使用context.location，如果有特殊定制的location才会使用。</span><br><span class=\"line\">          &#x2F;&#x2F; 下面有介绍</span><br><span class=\"line\">          const location &#x3D; this.props.location || context.location;</span><br><span class=\"line\"></span><br><span class=\"line\">          let element, match;</span><br><span class=\"line\"></span><br><span class=\"line\">          &#x2F;&#x2F; We use React.Children.forEach instead of React.Children.toArray().find()</span><br><span class=\"line\">          &#x2F;&#x2F; here because toArray adds keys to all child elements and we do not want</span><br><span class=\"line\">          &#x2F;&#x2F; to trigger an unmount&#x2F;remount for two &lt;Route&gt;s that render the same</span><br><span class=\"line\">          &#x2F;&#x2F; component at different URLs.</span><br><span class=\"line\">          &#x2F;&#x2F; React.Children.forEach 对子元素做遍历</span><br><span class=\"line\">          React.Children.forEach(this.props.children, child &#x3D;&gt; &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 只要找到一个 match，那么就不会再进来了</span><br><span class=\"line\">            if (match &#x3D;&#x3D; null &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class=\"line\">              element &#x3D; child;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#x2F;&#x2F; child.props.path 就不多讲了， Route 的标准写法</span><br><span class=\"line\">              &#x2F;&#x2F; 需要注意的是，使用 from 也会被匹配到</span><br><span class=\"line\">              &#x2F;&#x2F; 任何组件，只要在 Switch 下，有 from 属性，并且和当前路径匹配，就会被渲染</span><br><span class=\"line\">              &#x2F;&#x2F; from具体是给&lt;Redirect&gt;使用的，后面会说到</span><br><span class=\"line\">              const path &#x3D; child.props.path || child.props.from;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#x2F;&#x2F; 判断组件是否匹配</span><br><span class=\"line\">              match &#x3D; path</span><br><span class=\"line\">              &#x2F;&#x2F; 下面有专属的介绍这个函数</span><br><span class=\"line\">                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class=\"line\">                : context.match;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">          return match</span><br><span class=\"line\">            ? React.cloneElement(element, &#123; location, computedMatch: match &#125;)</span><br><span class=\"line\">            : null;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &lt;&#x2F;RouterContext.Consumer&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Switch中的location这个props怎么用？什么用？</p>\n<blockquote>\n<h2 id=\"摘自官网\"><a href=\"#摘自官网\" class=\"headerlink\" title=\"摘自官网\"></a>摘自官网</h2><h2 id=\"location-object\"><a href=\"#location-object\" class=\"headerlink\" title=\"location: object\"></a><a href=\"https://reactrouter.com/web/api/Switch/location-object\" target=\"_blank\" rel=\"noopener\">location: object</a></h2><p>A <a href=\"https://reactrouter.com/web/api/location\" target=\"_blank\" rel=\"noopener\"><code>location</code></a> object to be used for matching children elements instead of the current history location (usually the current browser URL).</p>\n<p>谷歌翻译：用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。</p>\n</blockquote>\n<h3 id=\"matchPath\"><a href=\"#matchPath\" class=\"headerlink\" title=\"matchPath\"></a>matchPath</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchPath</span>(<span class=\"params\">pathname, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 规范结构体</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果 options 传的是个 string，那默认这个 string 代表 path</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果 options 传的是个 数组，那只要有一个匹配，就认为匹配</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> options === <span class=\"string\">\"string\"</span> || <span class=\"built_in\">Array</span>.isArray(options)) &#123;</span><br><span class=\"line\">    options = &#123; <span class=\"attr\">path</span>: options &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, exact = <span class=\"literal\">false</span>, strict = <span class=\"literal\">false</span>, sensitive = <span class=\"literal\">false</span> &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 转化成数组进行判断</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> paths = [].concat(path);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 都是很简单的内容，难点就在这个reduce，这个很有意思，感兴趣或者不了解的赶紧去MDN了解一下！！！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths.reduce(<span class=\"function\">(<span class=\"params\">matched, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!path &amp;&amp; path !== <span class=\"string\">\"\"</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 只要有一个 match，直接返回，认为是 match</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matched) <span class=\"keyword\">return</span> matched;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// regexp 是正则表达式</span></span><br><span class=\"line\">    <span class=\"comment\">// keys 是切割出来的得 key 的值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class=\"line\">      end: exact,</span><br><span class=\"line\">      strict,</span><br><span class=\"line\">      sensitive</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// exec() 该方法如果找到了匹配的文本的话，则会返回一个结果数组，否则的话，会返回一个</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> match = regexp.exec(pathname);</span><br><span class=\"line\">    <span class=\"comment\">/* 匹配不成功，返回null */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!match) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// url 表示匹配到的部分</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [url, ...values] = match;</span><br><span class=\"line\">    <span class=\"comment\">// pathname === url 表示完全匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> isExact = pathname === url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exact &amp;&amp; !isExact) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      path, <span class=\"comment\">// the path used to match</span></span><br><span class=\"line\">      url: path === <span class=\"string\">\"/\"</span> &amp;&amp; url === <span class=\"string\">\"\"</span> ? <span class=\"string\">\"/\"</span> : url, <span class=\"comment\">// the matched portion of the URL</span></span><br><span class=\"line\">      isExact, <span class=\"comment\">// whether or not we matched exactly</span></span><br><span class=\"line\">      params: keys.reduce(<span class=\"function\">(<span class=\"params\">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        memo[key.name] = values[index];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo;</span><br><span class=\"line\">      &#125;, &#123;&#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>matchPath 函数也是由 react-router export 出去的函数，我们可以用来获得某个 url 中的指定的参数。</p>\n<h2 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h2><p>Route 是用于声明路由映射到应用程序的组件层。</p>\n<p>Route 有三种渲染的方法，当然，都配置的话只有一个会生效，优先级是 children &gt; component &gt; render</p>\n<p>\\1. <Route component><br>\\2. <Route render><br>\\3. <Route children></p>\n<p>每个在不同的情况下都有用，大多数情况下，会使用 component。</p>\n<h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><p>component 表示只有当位置匹配时才会渲染的 React 组件。使用 component（而不是 render 或 children ）Route 使用从给定组件 React.createElement(element, props) 创建新的 React element。这意味着，使用 component 创建的组件能获得 router 中的 props。</p>\n<h3 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"children\"></a>children</h3><p>从源码中可以看出，children 的优先级是高于 component，而且可以是一个组件，也可以是一个函数，children 没有获得 router 的 props。</p>\n<p>children 有一个非常特殊的地方在于，当路由不匹配且 children 是一个函数的时候，会执行 children 方法，这就给了设计很大的灵活性。</p>\n<h3 id=\"render-1\"><a href=\"#render-1\" class=\"headerlink\" title=\"render\"></a>render</h3><p>render 必须是一个函数，优先级是最低的，当匹配成功的时候，执行这个函数。</p>\n<h3 id=\"exact-amp-strict-amp-sensitive\"><a href=\"#exact-amp-strict-amp-sensitive\" class=\"headerlink\" title=\"exact &amp; strict &amp; sensitive\"></a>exact &amp; strict &amp; sensitive</h3><p>这三者都是使用 path-to-regexp 做路径匹配需要的三个参数。</p>\n<ol>\n<li>exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。</li>\n<li>strict: 在确定为位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线。</li>\n<li>sensitive: 如果路径区分大小写，则为 true ，则匹配。</li>\n</ol>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p>Route 元素尝试其匹配 path 到当前浏览器 URL，但是，也可以通过 location 实现与当前浏览器位置以外的位置相匹配。</p>\n<p>下面列出 Route 源码，并且删去了 dev 部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; isValidElementType &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-is\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> invariant <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-invariant\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> warning <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-warning\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> matchPath <span class=\"keyword\">from</span> <span class=\"string\">\"./matchPath.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for matching a single path and rendering.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Route</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">        &#123;context =&gt; &#123;</span><br><span class=\"line\">          invariant(context, <span class=\"string\">\"You should not use &lt;Route&gt; outside a &lt;Router&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 可以看出，用户传的 location 覆盖掉了 context 中的 location</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> location = <span class=\"keyword\">this</span>.props.location || context.location;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 如果有 computedMatch 就用 computedMatch 作为结果</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果没有，则判断是否有 path 传参</span></span><br><span class=\"line\">          <span class=\"comment\">// matchPath 是调用 path-to-regexp 判断是否匹配</span></span><br><span class=\"line\">          <span class=\"comment\">// path-to-regexp 需要三个参数</span></span><br><span class=\"line\">          <span class=\"comment\">// exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配</span></span><br><span class=\"line\">          <span class=\"comment\">// strict: 如果为 true 当真实的路径具有一个斜线将只匹配一个斜线location.pathname</span></span><br><span class=\"line\">          <span class=\"comment\">// sensitive: 如果路径区分大小写，则为 true ，则匹配</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> match = <span class=\"keyword\">this</span>.props.computedMatch</span><br><span class=\"line\">            ? <span class=\"keyword\">this</span>.props.computedMatch <span class=\"comment\">// &lt;Switch&gt; already computed the match for us</span></span><br><span class=\"line\">            : <span class=\"keyword\">this</span>.props.path</span><br><span class=\"line\">            ? matchPath(location.pathname, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">            : context.match;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// props 就是更新后的 context</span></span><br><span class=\"line\">          <span class=\"comment\">// location 做了更新（有可能是用户传入的location）</span></span><br><span class=\"line\">          <span class=\"comment\">// match 做了更新</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> props = &#123; ...context, location, match &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 三种渲染方式</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> &#123; children, component, render &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// Preact uses an empty array as children by</span></span><br><span class=\"line\">          <span class=\"comment\">// default, so use null if that's the case.</span></span><br><span class=\"line\">          <span class=\"comment\">// children 默认是个空数组，如果是默认情况，置为 null</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children) &amp;&amp; children.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"comment\">// RouterContext 中更新了 location, match</span></span><br><span class=\"line\">            &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class=\"line\">              &#123;props.match</span><br><span class=\"line\">              <span class=\"comment\">// 首先判断的是有无 children</span></span><br><span class=\"line\">                ? children</span><br><span class=\"line\">                  <span class=\"comment\">// 如果 children 是个函数，执行，否则直接返回 children</span></span><br><span class=\"line\">                  ? <span class=\"keyword\">typeof</span> children === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">                  : children(props)</span><br><span class=\"line\">                  : children</span><br><span class=\"line\">                  <span class=\"comment\">// 如果没有 children，判断有无 component</span></span><br><span class=\"line\">                : component</span><br><span class=\"line\">                  <span class=\"comment\">// 有 component，重新新建一个 component</span></span><br><span class=\"line\">                  ? React.createElement(component, props)</span><br><span class=\"line\">                  <span class=\"comment\">// 没有 component，判断有无 render</span></span><br><span class=\"line\">                  : render</span><br><span class=\"line\">                  <span class=\"comment\">// 有 render，执行 render 方法</span></span><br><span class=\"line\">                  ? render(props)</span><br><span class=\"line\">                  <span class=\"comment\">// 没有返回 null</span></span><br><span class=\"line\">                  : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 这里是不 match 的情况，判断 children 是否函数</span></span><br><span class=\"line\">                : <span class=\"keyword\">typeof</span> children === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">                <span class=\"comment\">// 是的话执行</span></span><br><span class=\"line\">                ? children(props)</span><br><span class=\"line\">                : <span class=\"literal\">null</span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/RouterContext.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          );</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>RouterContext.Consumer&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Route;</span><br></pre></td></tr></table></figure>\n\n<p>Route 组件根据自身的传参，对上层 RouterContext 中的部分属性（location 和 match）进行了更新，并且如果当前路径和配置的 path 路径 match，则渲染该组件，渲染的方式有 children，component，render 三种方式，我们最常用的就是 component 方式，注意每种方式的区别。</p>\n<h2 id=\"Prompt\"><a href=\"#Prompt\" class=\"headerlink\" title=\"Prompt\"></a>Prompt</h2><p>Prompt 用于路由切换提示。这在某些场景下是非常有用的，比如用户在某个页面修改数据，离开时，提示用户是否保存，Prompt 组件有俩个属性：</p>\n<ol>\n<li>message：用于显示提示的文本信息。</li>\n<li>when：传递布尔值，相当于标签的开关，默认是 true，设置成 false 时，失效。</li>\n</ol>\n<p>Prompt 的本质是在 when 为 true 的时候，调用 context.history.block 方法，为全局注册路由监听，block 的原理看之前的 history 相关文章。路有变化的时候，默认使用 window.confirm 进行确认，我们也可以自定义 confirm 的形式，就是在 BrowserRouter 或者 HashRouter 传入 getUserConfirmation 这个参数，会替换掉 window.confirm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import PropTypes from &quot;prop-types&quot;;</span><br><span class=\"line\">import invariant from &quot;tiny-invariant&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Lifecycle from &quot;.&#x2F;Lifecycle.js&quot;;</span><br><span class=\"line\">import RouterContext from &quot;.&#x2F;RouterContext.js&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * The public API for prompting the user before navigating away from a screen.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function Prompt(&#123; message, when &#x3D; true &#125;) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">      &#123;context &#x3D;&gt; &#123;</span><br><span class=\"line\">        invariant(context, &quot;You should not use &lt;Prompt&gt; outside a &lt;Router&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!when || context.staticContext) return null;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 调用了 history.block 方法</span><br><span class=\"line\">        const method &#x3D; context.history.block;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;Lifecycle</span><br><span class=\"line\">            onMount&#x3D;&#123;self &#x3D;&gt; &#123;</span><br><span class=\"line\">              self.release &#x3D; method(message);</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUpdate&#x3D;&#123;(self, prevProps) &#x3D;&gt; &#123;</span><br><span class=\"line\">              if (prevProps.message !&#x3D;&#x3D; message) &#123;</span><br><span class=\"line\">                self.release();</span><br><span class=\"line\">                self.release &#x3D; method(message);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUnmount&#x3D;&#123;self &#x3D;&gt; &#123;</span><br><span class=\"line\">              self.release();</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            message&#x3D;&#123;message&#125;</span><br><span class=\"line\">          &#x2F;&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    &lt;&#x2F;RouterContext.Consumer&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Prompt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redirect\"><a href=\"#Redirect\" class=\"headerlink\" title=\"Redirect\"></a>Redirect</h2><p>Redirect 与其说是一个组件，不如说是有组件封装的一组方法，该组件在 componentDidMount 生命周期内，通过调用 history API 跳转到到新位置，默认情况下，新位置将覆盖历史堆栈中的当前位置。</p>\n<p><Redirect to=\"/somewhere/else\"/> to 表示要重定向到的网址。to 也可以是一个 location 对象</p>\n<p><Redirect push to=\"/somewhere/else\"/> push 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目。</p>\n<p>结合 Switch 和 Redirect 源码看，如果 Redirect 中有 from 属性，会被 Switch 获得，当 from 和当前路径匹配的时候，就会渲染 Redirect 组件，执行跳转。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createLocation, locationsAreEqual &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> invariant <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-invariant\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Lifecycle <span class=\"keyword\">from</span> <span class=\"string\">\"./Lifecycle.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> generatePath <span class=\"keyword\">from</span> <span class=\"string\">\"./generatePath.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for navigating programmatically with a component.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Redirect</span>(<span class=\"params\">&#123; computedMatch, to, push = false &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 啥都有的大哥 RouterContext</span></span><br><span class=\"line\">    &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">      &#123;context =&gt; &#123;</span><br><span class=\"line\">        invariant(context, <span class=\"string\">\"You should not use &lt;Redirect&gt; outside a &lt;Router&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; history, staticContext &#125; = context;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般来说，Redirect 操作都不需要留有 history，所以选择选择 history.replace</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> method = push ? history.push : history.replace;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> location = createLocation(</span><br><span class=\"line\">          <span class=\"comment\">// computedMatch 就是看看 switch 有没有多管闲事</span></span><br><span class=\"line\">          computedMatch</span><br><span class=\"line\">            ? <span class=\"keyword\">typeof</span> to === <span class=\"string\">\"string\"</span></span><br><span class=\"line\">              ? generatePath(to, computedMatch.params)</span><br><span class=\"line\">              : &#123;</span><br><span class=\"line\">                  ...to,</span><br><span class=\"line\">                  pathname: generatePath(to.pathname, computedMatch.params)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            : to</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// When rendering in a static context,</span></span><br><span class=\"line\">        <span class=\"comment\">// set the new location immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// staticRouter 专用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (staticContext) &#123;</span><br><span class=\"line\">          method(location);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;Lifecycle</span><br><span class=\"line\">            onMount=&#123;() =&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// componentDidMount 的时候执行 method(location)，也就是 history.replace 操作</span></span><br><span class=\"line\">              method(location);</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUpdate=&#123;(self, prevProps) =&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// componentDidUpdate 时候判断当前 location 和上一个 location 是否发生变化</span></span><br><span class=\"line\">              <span class=\"comment\">// 只要发生变化，调用 method(location)</span></span><br><span class=\"line\">              <span class=\"comment\">// 一般来讲，在 componentDidMount 的时候就跳走了，不会等到 componentDidUpdate</span></span><br><span class=\"line\">              <span class=\"keyword\">const</span> prevLocation = createLocation(prevProps.to);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !locationsAreEqual(prevLocation, &#123;</span><br><span class=\"line\">                  ...location,</span><br><span class=\"line\">                  key: prevLocation.key</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                method(location);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 无效</span></span><br><span class=\"line\">            to=&#123;to&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/RouterContext.Consumer&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Redirect;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lifecycle 不 render 任何页面，只有生命周期函数，Lifecycle 提供了 onMount， onUpdate， onUnmount 三个生命周期函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lifecycle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onMount) <span class=\"keyword\">this</span>.props.onMount.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidUpdate(prevProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onUpdate) <span class=\"keyword\">this</span>.props.onUpdate.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>, prevProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onUnmount) <span class=\"keyword\">this</span>.props.onUnmount.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Lifecycle;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个<code>react-router</code>是由<code>createBrowserHistory</code>或者<code>createHashHistory</code>来牵头，与我们的<code>React</code>组件绑定在一起，然后传递了一些属于<code>history</code>这个库的方法以及数值。当然，还有路由的匹配和渲染。</p>\n<p>在<code>history</code>这个库里面又有对于路由的监听，改变等等。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>以<code>history</code>模式做参考（也是我们重点阅读的。</p>\n<h3 id=\"修改url\"><a href=\"#修改url\" class=\"headerlink\" title=\"修改url\"></a>修改url</h3><p>当<code>url</code>改变的时候，会触发写在<code>window</code>上面的监听<code>window.addEventListener(&#39;popstate&#39;, handlePop)</code>。</p>\n<p>调用了我们的函数<code>handlePop</code></p>\n<p>函数内部我们<code>setState</code>，修改了<code>location</code>，方便传递正确的值下去，并通过了<code>Switch</code>找出匹配的<code>Route</code>组件。</p>\n<p>触发了组件的渲染。</p>\n<blockquote>\n<p>当然也包括我们所谓的history.push，history.repalce等等这些方法，本质上也是修改url，然后就是重复上面的步骤</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>此处介绍一下React-Router的核心原理。特别细致的标点符号的不予讨论。</p>\n<h1 id=\"学前小知识\"><a href=\"#学前小知识\" class=\"headerlink\" title=\"学前小知识\"></a>学前小知识</h1><p><code>React-Router</code>其实最核心的东西是<code>Route</code>组件和由统一作者开发的<code>History</code>库来建立的。接下来跟着镜头一起走进神秘的<code>ßReact-Router</code>世界吧。</p>\n<p>已经知道怎么使用的直接跳过，到下面的源码分析去┗|｀O′|┛ 嗷~~</p>\n<h1 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h1><p>一起建一个简单的示例吧。先用<code>react</code>官网的<code>create-react-app</code>脚手架弄个<code>react</code>出来。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app my-app</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my-app</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n\n<p>安装<a href=\"https://reactrouter.com/web/guides/quick-start\" target=\"_blank\" rel=\"noopener\">react-router-dom</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom</span><br></pre></td></tr></table></figure>\n\n<p>在大家安装之余，我简答的介绍一下<code>react-router</code>和<code>react-router-dom</code>的区别。</p>\n<h2 id=\"react-router和react-router-dom的区别。\"><a href=\"#react-router和react-router-dom的区别。\" class=\"headerlink\" title=\"react-router和react-router-dom的区别。\"></a>react-router和react-router-dom的区别。</h2><h3 id=\"先看提供的API\"><a href=\"#先看提供的API\" class=\"headerlink\" title=\"先看提供的API\u0003\"></a>先看提供的API\u0003</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route, Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Swtich, Route, BrowserRouter, HashHistory, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"React-router\"><a href=\"#React-router\" class=\"headerlink\" title=\"React-router\"></a>React-router</h4><p>提供了路由的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api；</p>\n<h4 id=\"React-router-dom\"><a href=\"#React-router-dom\" class=\"headerlink\" title=\"React-router-dom\"></a>React-router-dom</h4><p>提供了<code>BrowserRouter</code>、<code>Route</code>、<code>Link</code>等api，可以通过dom操作触发事件控制路由。</p>\n<p><code>Link</code>组件，会渲染一个a标签；<code>BrowserRouter</code>和<code>HashRouter</code>组件，前者使用<code>pushState</code>和<code>popState</code>事件构建路由，后者使用<code>hash</code>和 <code>hashchange</code>事件构建路由。</p>\n<p><code>react-router-dom</code>在<code>react-router</code>的基础上扩展了可操作<code>dom</code>的<code>api</code>。</p>\n<p><code>Swtich</code> 和 <code>Route</code> 都是从<code>react-router</code>中导入了相应的组件并重新导出，没做什么特殊处理。</p>\n<p><code>react-router-dom</code>中<code>package.json</code>依赖中存在对<code>react-router</code>的依赖，故此，不需要<code>npm</code>安装<code>react-router</code>。</p>\n<blockquote>\n<ul>\n<li>可直接 npm 安装 react-router-dom，使用其api。</li>\n</ul>\n</blockquote>\n<h2 id=\"简单修改\"><a href=\"#简单修改\" class=\"headerlink\" title=\"简单修改\"></a>简单修改</h2><p>👌，大家🔥应该已经安装完了吧？接下来简单的修改一下脚手架里面的内容。主要是为了熟悉对手，知己知彼百战百胜。</p>\n<p><img src=\"/image/router/demo.png\" alt=\"demo\"></p>\n<p>修改一下<code>src/app.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  BrowserRouter <span class=\"keyword\">as</span> Router,</span><br><span class=\"line\">  Switch,</span><br><span class=\"line\">  Route,</span><br><span class=\"line\">  Link,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Home</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;首页&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Link to=\"/</span>login<span class=\"string\">\"&gt;登录&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function Login() &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return (</span></span><br><span class=\"line\"><span class=\"string\">    &lt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;登录页&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;Link to=\"</span>/<span class=\"string\">\"&gt;回首页&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  );</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"string\">  return (</span></span><br><span class=\"line\"><span class=\"string\">    &lt;Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Route path=\"</span>/login<span class=\"string\">\" component=&#123;Login&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Route path=\"</span>/<span class=\"string\">\" component=&#123;Home&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">  );</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export default App;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了一个最简单的示例了。</p>\n<h1 id=\"SPA的核心思想\"><a href=\"#SPA的核心思想\" class=\"headerlink\" title=\"SPA的核心思想\"></a>SPA的核心思想</h1><ul>\n<li>监听<code>URL</code>的变化</li>\n<li>改变某些<code>context</code>的值</li>\n<li>获取对应的页面组件</li>\n<li><code>render</code>新的页面</li>\n</ul>\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><h2 id=\"BrowserRouter\"><a href=\"#BrowserRouter\" class=\"headerlink\" title=\"BrowserRouter\"></a>BrowserRouter</h2><p>从前面的简单示例中我们，发现有一个最外层的伙计，叫<code>BrowserRouter</code>。我们直接干到他的github源码去瞅瞅。</p>\n<p>链接：<a href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> warning <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-warning\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for a &lt;Router&gt; that uses HTML5 history.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">  BrowserRouter.propTypes = &#123;</span><br><span class=\"line\">    basename: PropTypes.string,</span><br><span class=\"line\">    children: PropTypes.node,</span><br><span class=\"line\">    forceRefresh: PropTypes.bool,</span><br><span class=\"line\">    getUserConfirmation: PropTypes.func,</span><br><span class=\"line\">    keyLength: PropTypes.number</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  BrowserRouter.prototype.componentDidMount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    warning(</span><br><span class=\"line\">      !<span class=\"keyword\">this</span>.props.history,</span><br><span class=\"line\">      <span class=\"string\">\"&lt;BrowserRouter&gt; ignores the history prop. To use a custom history, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"use `import &#123; Router &#125;` instead of `import &#123; BrowserRouter as Router &#125;`.\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> BrowserRouter;</span><br></pre></td></tr></table></figure>\n\n<p>抛开一些七七八八的判断。重新看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写着几个大字：《瓜子二手车》他只是一个中间商，他在赚差价。（打钱！</p>\n<p><code>BrowserRouter</code>是依赖于两个库：分别为<code>history</code>和<code>react-router</code>。ok，我们一探究竟。</p>\n<h2 id=\"react-router\"><a href=\"#react-router\" class=\"headerlink\" title=\"react-router\"></a>react-router</h2><p>源码链接：<a href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> HistoryContext <span class=\"keyword\">from</span> <span class=\"string\">\"./HistoryContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这两个东西其实很简单，都是引用了一个叫做<code>createContext</code>，目的也很简单，这里其实就是创建的普通context，只不过拥有特定的名称而已。源码如下。就几行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> Replace with React.createContext once we can assume React 16+</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createContext <span class=\"keyword\">from</span> <span class=\"string\">\"mini-create-react-context\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNamedContext = <span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createContext();</span><br><span class=\"line\">  context.displayName = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> createNamedContext;</span><br></pre></td></tr></table></figure>\n\n<p>OK，重点是接下来，抛开context之后，我们需要关注的东西。我整理一下。</p>\n<p>先看构造函数</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">    location: props.history.location</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// This is a bit of a hack. We have to start listening for location</span></span><br><span class=\"line\">  <span class=\"comment\">// changes here in the constructor in case there are any &lt;Redirect&gt;s</span></span><br><span class=\"line\">  <span class=\"comment\">// on the initial render. If there are, they will replace/push when</span></span><br><span class=\"line\">  <span class=\"comment\">// they mount and since cDM fires in children before parents, we may</span></span><br><span class=\"line\">  <span class=\"comment\">// get a new location before the &lt;Router&gt; is mounted.</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// _isMounted 表示组件是否加载完成</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 组件未加载完毕，但是 location 发生的变化，暂存在 _pendingLocation 字段中</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._pendingLocation = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 staticContext 属性，表示是 HashRouter 或是 BrowserRouter</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!props.staticContext) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.unlisten = props.history.listen(<span class=\"function\"><span class=\"params\">location</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._isMounted) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 组件加载完毕，将变化的 location 方法 state 中</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; location &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._pendingLocation = location;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有两个值☞<code>_isMounted</code>和<code>_pendingLocation</code></p>\n<p>分别是  是否挂载   待定</p>\n<p>内部维护了一个location，默认值是由外面传入的history，我找到传入的地方。</p>\n<p>其实就是之前看到的<code>BrowserRouter</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createBrowserHistory <span class=\"keyword\">as</span> createHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrowserRouter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  history = createHistory(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=<span class=\"string\">&#123;this.history&#125;</span> <span class=\"attr\">children</span>=<span class=\"string\">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难发现，history的默认值就是由history这个库来提供的，这个后面会提到，我们继续看。</p>\n<p>先简单看一下注释的翻译(谷歌翻译)</p>\n<blockquote>\n<p>这有点hack。 我们必须开始在构造函数中监听位置更改，以防初始渲染中存在任何<Redirect>。 如果有的话，它们将在安装时替换/推动，并且由于cDM在父级之前在子级中触发，因此在安装<Router>之前，我们可能会获得一个新位置。 </p>\n</blockquote>\n<p>什么意思呢，我简单描述一下：</p>\n<blockquote>\n<p>因为子组件会比父组件更早渲染完成, 以及<code>&lt;Redirect&gt;</code>的存在, 若是在<code>&lt;Router&gt;</code>的<code>componentDidMount</code>生命周期中对<code>history.location</code>进行监听, 则有可能在监听事件注册之前, <code>history.location</code>已经由于<code>&lt;Redirect&gt;</code>发生了多次改变, 因此我们需要在<code>&lt;Router&gt;</code>的<code>constructor</code>中就注册监听事件</p>\n</blockquote>\n<p>收回来，进入<code>if</code>继续看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.unlisten = props.history.listen(<span class=\"function\"><span class=\"params\">location</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._isMounted) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.setState(&#123; location &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>._pendingLocation = location;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>就是调用了<code>history</code>的<code>listen</code>方法。从代码中可以大致了解到就是对<code>history</code>进行监听，然后进行一些操作。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>那么这个<code>unlisten</code>什么时候执行呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.unlisten) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unlisten();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._pendingLocation = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Router</code>这个组件卸载的时候就执行啦。也就是说，取消了对<code>history</code>的监听。</p>\n<h3 id=\"componentDidUnmount\"><a href=\"#componentDidUnmount\" class=\"headerlink\" title=\"componentDidUnmount\"></a>componentDidUnmount</h3><p>然后看一下<code>conponentDidMount</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._isMounted = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingLocation) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">location</span>: <span class=\"keyword\">this</span>._pendingLocation &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>也很简单，就是修改一下是否挂载的值，以及继续之前在构造函数里面的判断。如果暂存数据有的话就把他存下来。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;RouterContext.Provider</span><br><span class=\"line\">        value&#x3D;&#123;&#123;</span><br><span class=\"line\">          &#x2F;&#x2F; 根据 HashRouter 还是 BrowserRouter，可判断 history 类型</span><br><span class=\"line\">          history: this.props.history,</span><br><span class=\"line\">          &#x2F;&#x2F; 这个 location 就是监听 history 变化得到的 location</span><br><span class=\"line\">          location: this.state.location,</span><br><span class=\"line\">          &#x2F;&#x2F; path url params isExact 四个属性</span><br><span class=\"line\">          match: Router.computeRootMatch(this.state.location.pathname),</span><br><span class=\"line\">          &#x2F;&#x2F; 只有 StaticRouter 会传 staticContext</span><br><span class=\"line\">          &#x2F;&#x2F; HashRouter 和 BrowserRouter 都是 null</span><br><span class=\"line\">          staticContext: this.props.staticContext</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;HistoryContext.Provider</span><br><span class=\"line\">          children&#x3D;&#123;this.props.children || null&#125;</span><br><span class=\"line\">          value&#x3D;&#123;this.props.history&#125;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;RouterContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Router这个组件主要就是将一些数据进行存储。存到<code>Context</code>，之间不乏一些特殊情况的判断，比如子组件渲染比父组件早，以及<code>Redirect</code>的情况的处理。在卸载的时候要移除对<code>history</code>的监听。</p>\n<p>子组件作为消费者，就可以对页面进行修改，跳转，获取这些数值。</p>\n<h2 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h2><h3 id=\"createBrowserHistory\"><a href=\"#createBrowserHistory\" class=\"headerlink\" title=\"createBrowserHistory\"></a>createBrowserHistory</h3><h4 id=\"返回的内容\"><a href=\"#返回的内容\" class=\"headerlink\" title=\"返回的内容\"></a>返回的内容</h4><p>之前一直有不断提到的<code>history</code>，我们一起来看看它是谁</p>\n<p>源码连接：<a href=\"https://github.com/ReactTraining/history/blob/master/packages/history/index.ts\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactTraining/history/blob/master/packages/history/index.ts</a></p>\n<p>我们之前用到的<code>createBrowserHistory</code>，他其实是返回的一个对象，这个对象里面有我们常用的一些方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> history: BrowserHistory = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> action() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">get</span> location() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> location;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    createHref,</span><br><span class=\"line\">    push,</span><br><span class=\"line\">    replace,</span><br><span class=\"line\">    go,</span><br><span class=\"line\">    back() &#123;</span><br><span class=\"line\">      go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    forward() &#123;</span><br><span class=\"line\">      go(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    listen(listener) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> listeners.push(listener);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    block(blocker) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> unblock = blockers.push(blocker);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (blockers.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(BeforeUnloadEventType, promptBeforeUnload);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        unblock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove the beforeunload listener so the document may</span></span><br><span class=\"line\">        <span class=\"comment\">// still be salvageable in the pagehide event.</span></span><br><span class=\"line\">        <span class=\"comment\">// See https://html.spec.whatwg.org/#unloading-documents</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!blockers.length) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> history;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大部分精髓就是这里。发现有多熟悉的伙伴！ =&gt; <code>push</code>、<code>replace</code>、<code>go</code>等等。有些其实都是<code>window</code>提供的。</p>\n<p>有些直接看代码就可以明白的就不解释了，比如<code>forward</code>，<code>back</code>。</p>\n<h5 id=\"go\"><a href=\"#go\" class=\"headerlink\" title=\"go\"></a>go</h5><p>比如上面提到的<code>go</code>方法，截取部分源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalHistory = <span class=\"built_in\">window</span>.history;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    globalHistory.go(delta);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"createHref\"><a href=\"#createHref\" class=\"headerlink\" title=\"createHref\"></a>createHref</h5><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个完整的url</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPath</span>(<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pathname = '/',</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  search = '',</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hash = ''</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;: PartialPath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pathname + search + hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个url</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHref</span>(<span class=\"params\">to: To</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 看上面</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> to === <span class=\"string\">'string'</span> ? to : createPath(to);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h5><p><code>push</code>的源码，里面附带了一些会用到的函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 就是简单处理一下返回值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNextLocation</span>(<span class=\"params\">to: To, state: State = <span class=\"literal\">null</span></span>): <span class=\"title\">Location</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> readOnly&lt;Location&gt;(&#123;</span><br><span class=\"line\">    ...location,</span><br><span class=\"line\">    ...(<span class=\"keyword\">typeof</span> to === <span class=\"string\">'string'</span> ? parsePath(to) : to),</span><br><span class=\"line\">    state,</span><br><span class=\"line\">    key: createKey()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allowTx</span>(<span class=\"params\">action: Action, location: Location, retry: () =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 长度为0就返回true，长度大于0就调用函数，并传入参数。这个blockers等一下仔细探讨一下</span></span><br><span class=\"line\">      !blockers.length || (blockers.call(&#123; action, location, retry &#125;), <span class=\"literal\">false</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顾名思义获取state和url</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHistoryStateAndUrl</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    nextLocation: Location,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    index: <span class=\"built_in\">number</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>): [<span class=\"title\">HistoryState</span>, <span class=\"title\">string</span>] </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        usr: nextLocation.state,</span><br><span class=\"line\">        key: nextLocation.key,</span><br><span class=\"line\">        idx: index</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 看上面 有专门介绍</span></span><br><span class=\"line\">      createHref(nextLocation)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一些关于location的信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIndexAndLocation</span>(<span class=\"params\"></span>): [<span class=\"title\">number</span>, <span class=\"title\">Location</span>] </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; pathname, search, hash &#125; = <span class=\"built_in\">window</span>.location;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> state = globalHistory.state || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      state.idx,</span><br><span class=\"line\">      readOnly&lt;Location&gt;(&#123;</span><br><span class=\"line\">        pathname,</span><br><span class=\"line\">        search,</span><br><span class=\"line\">        hash,</span><br><span class=\"line\">        state: state.usr || <span class=\"literal\">null</span>,</span><br><span class=\"line\">        key: state.key || <span class=\"string\">'default'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行listeners内部的一些函数（也就是跳转），后面也会详细解读</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyTx</span>(<span class=\"params\">nextAction: Action</span>) </span>&#123;</span><br><span class=\"line\">    action = nextAction;</span><br><span class=\"line\">    [index, location] = getIndexAndLocation();</span><br><span class=\"line\">    listeners.call(&#123; action, location &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">to: To, state?: State</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 这里是一个枚举值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Push;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextLocation = getNextLocation(to, state);</span><br><span class=\"line\">  \t<span class=\"comment\">// 顾名思义，就是再来一次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      push(to, state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowTx(nextAction, nextLocation, retry)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> [historyState, url] = getHistoryStateAndUrl(nextLocation, index + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Support forced reloading</span></span><br><span class=\"line\">      <span class=\"comment\">// try...catch because iOS limits us to 100 pushState calls :/</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState</span></span><br><span class=\"line\">        globalHistory.pushState(historyState, <span class=\"string\">''</span>, url);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// They are going to lose state here, but there is no real</span></span><br><span class=\"line\">        <span class=\"comment\">// way to warn them about it since the page will refresh...</span></span><br><span class=\"line\">        <span class=\"comment\">// MDN的地址: https://developer.mozilla.org/zh-CN/docs/Web/API/Location/assign</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.location.assign(url);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在注释里面已经进行非常详细的解读了，用到的每个函数都有解释或者官方权威的url。</p>\n<p>总结一下：<code>history.push</code>的一个完整流程</p>\n<ul>\n<li>调用<code>history.pushState</code><ul>\n<li>错误由<code>window.location.assign</code>来处理</li>\n</ul>\n</li>\n<li>执行一下<code>listeners</code>里面的函数</li>\n</ul>\n<p>是的，你没有看错，就这么简单，只是里面有很多调用的函数，我都截取出来一一解释，做到每行代码都理解，所以显得比较长，概括来说就是这么简单。</p>\n<p>重点来看一下<code>listen</code>和被调用的<code>createBrowserHistory</code></p>\n<h5 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h5><p>这里面用的函数，在前面的push都有解析，可以往上面去找找，就不多赘述了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">to: To, state?: State</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Replace;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextLocation = getNextLocation(to, state);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      replace(to, state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowTx(nextAction, nextLocation, retry)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> [historyState, url] = getHistoryStateAndUrl(nextLocation, index);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Support forced reloading</span></span><br><span class=\"line\">      globalHistory.replaceState(historyState, <span class=\"string\">''</span>, url);</span><br><span class=\"line\"></span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen\"></a>listen</h5><p>在<code>history</code>返回的<code>listen</code>是一个函数。这个函数我们之前在react-router的源码中发现，他是在构造函数和卸载的时候会用到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(listener) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> listeners.push(listener);</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>仔细看看，这个<code>listeners</code>是在做些什么。</p>\n<h5 id=\"createEvents\"><a href=\"#createEvents\" class=\"headerlink\" title=\"createEvents\"></a>createEvents</h5><p>这个函数后面的blockers也会用到</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> listeners = createEvents&lt;Listener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createEvents</span>&lt;<span class=\"title\">F</span> <span class=\"title\">extends</span> <span class=\"title\">Function</span>&gt;(<span class=\"params\"></span>): <span class=\"title\">Events</span>&lt;<span class=\"title\">F</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handlers: F[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> length() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handlers.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    push(fn: F) &#123;</span><br><span class=\"line\">      handlers.push(fn);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        handlers = handlers.filter(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler !== fn);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    call(arg) &#123;</span><br><span class=\"line\">      handlers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn &amp;&amp; fn(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法，顾名思义，就是创建事件。定义了一个变量 <code>handlers</code> 数组，用于存放要处理的回调函数事件。</p>\n<p>然后返回了一个对象。</p>\n<p><code>push</code> 方法就是往 <code>handlers</code> 中添加要执行的函数。</p>\n<p>这块主要在 <code>history.listen()</code> 中使用，可以翻到开头看下 <code>history</code> 中返回了 <code>listen()</code> 方法，就是调用了<code>listeners.push(listener)</code> 。</p>\n<p>最后 <code>call()</code> 方法就比较容易理解，就是取出 <code>handlers</code> 里面的回调函数并逐个执行。</p>\n<p>总结一下，就是存储一下<code>push</code>进来的函数，并进行过滤。之后调用的时候会依次执行。<code>length</code>就是当前拥有的函数数量。</p>\n<p>再切回去，就会发现，每次调用这个<code>listen</code>就相当于<code>push</code>一个函数到内部的一个变量<code>handlers</code>中。</p>\n<h5 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"block\"></a>block</h5><p>和<code>listeners</code>一样，也是用<code>createEvents</code>创建的，就不多说啦。说一下哪里会用到这个吧。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> blockers = createEvents&lt;Blocker&gt;();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>block(prompt)</code> - (function) Prevents navigation (see <a href=\"https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md\" target=\"_blank\" rel=\"noopener\">the history docs</a>)</li>\n</ul>\n<p>这个是<code>react-router</code>官网的解释。</p>\n<p>我这里简单概括一下，就是用于关闭或者回退浏览器的误操作会用到的。详细的可以看点击进去查看。</p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>至此，我们调用的<code>createBrowserHistory</code>所返回的一些属性的源码都已经了如指掌了。但是具体是怎么工作还是一知半解。</p>\n<h4 id=\"具体核心原理\"><a href=\"#具体核心原理\" class=\"headerlink\" title=\"具体核心原理\"></a>具体核心原理</h4><p>先秀一下源码。history的核心原理就是这个。先别被这么多行代码唬到了，很多都是我们在之前的push里面有解释的</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PopStateEventType = <span class=\"string\">'popstate'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> blockedPopTx: Transition | <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handlePop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果有</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (blockedPopTx) &#123;</span><br><span class=\"line\">    blockers.call(blockedPopTx);</span><br><span class=\"line\">    blockedPopTx = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextAction = Action.Pop;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> [nextIndex, nextLocation] = getIndexAndLocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (blockers.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nextIndex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> delta = index - nextIndex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Revert the POP</span></span><br><span class=\"line\">          blockedPopTx = &#123;</span><br><span class=\"line\">            action: nextAction,</span><br><span class=\"line\">            location: nextLocation,</span><br><span class=\"line\">            retry() &#123;</span><br><span class=\"line\">              go(delta * <span class=\"number\">-1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          go(delta);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Trying to POP to a location with no index. We did not create</span></span><br><span class=\"line\">        <span class=\"comment\">// this location, so we can't effectively block the navigation.</span></span><br><span class=\"line\">        warning(</span><br><span class=\"line\">          <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Write up a doc that explains our blocking strategy in</span></span><br><span class=\"line\">          <span class=\"comment\">// detail and link to it here so people can understand better what</span></span><br><span class=\"line\">          <span class=\"comment\">// is going on and how to avoid it.</span></span><br><span class=\"line\">          <span class=\"string\">`You are trying to block a POP navigation to a location that was not `</span> +</span><br><span class=\"line\">          <span class=\"string\">`created by the history library. The block will fail silently in `</span> +</span><br><span class=\"line\">          <span class=\"string\">`production, but in general you should do all navigation with the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`history library (instead of using window.history.pushState directly) `</span> +</span><br><span class=\"line\">          <span class=\"string\">`to avoid this situation.`</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      applyTx(nextAction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(PopStateEventType, handlePop);</span><br></pre></td></tr></table></figure>\n\n<p>重点说一下<code>window.addEventListener(PopStateEventType, handlePop)</code></p>\n<p>MDN地址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event</a></p>\n<p>其实就是监听路由的变化然后，执行回调函数</p>\n<h3 id=\"createHashHistory\"><a href=\"#createHashHistory\" class=\"headerlink\" title=\"createHashHistory\"></a>createHashHistory</h3><p>这个大体上与普通路由一致。这里我想强调一些问题。</p>\n<blockquote>\n<p>比如哈希路由的锚点问题，我自己已知的几个方案</p>\n<ul>\n<li><h3 id=\"scrollIntoView\"><a href=\"#scrollIntoView\" class=\"headerlink\" title=\"scrollIntoView\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView\" target=\"_blank\" rel=\"noopener\">scrollIntoView</a></h3></li>\n<li><h3 id=\"scrollTop\"><a href=\"#scrollTop\" class=\"headerlink\" title=\"scrollTop\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\" target=\"_blank\" rel=\"noopener\">scrollTop</a></h3></li>\n<li><h2 id=\"react-anchor-without-hash\"><a href=\"#react-anchor-without-hash\" class=\"headerlink\" title=\"react-anchor-without-hash\"></a><a href=\"https://github.com/kwzm/react-anchor-without-hash\" target=\"_blank\" rel=\"noopener\">react-anchor-without-hash</a></h2></li>\n</ul>\n</blockquote>\n<p>感兴趣的自己查询一下，这个不在本次的讨论范围内。</p>\n<h4 id=\"具体核心原理-1\"><a href=\"#具体核心原理-1\" class=\"headerlink\" title=\"具体核心原理\"></a>具体核心原理</h4><p>之前说的到，<code>history</code>路由的核心是<code>window.addEventListener(PopStateEventType, handlePop);</code></p>\n<p>而哈希路由的核心也是监听路由的变化，只是参数不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听改变 */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而对路由的改变。<code>history</code>路由是：<code>history.pushState</code>，<code>history.replaceState</code>。</p>\n<p>哈希路由是：</p>\n<p><code>window.location.hash</code></p>\n<p>通过<code>window.location.hash</code>属性获取和设置 <code>hash</code>值。</p>\n<p>具体的话很差不多，关心细节的伙伴可以去看其源码哦。</p>\n<h1 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h1><p>之前我们看了BrowserRouter。我们回过头来看看，demo中的实例代码还有多少没有解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  BrowserRouter as Router,</span><br><span class=\"line\">  Switch,</span><br><span class=\"line\">  Route,</span><br><span class=\"line\">  Link,</span><br><span class=\"line\">&#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Home() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;首页&lt;&#x2F;h1&gt;</span><br><span class=\"line\">      &lt;Link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;Link&gt;</span><br><span class=\"line\">    &lt;&#x2F;&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Login() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;h1&gt;登录页&lt;&#x2F;h1&gt;</span><br><span class=\"line\">      &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;回首页&lt;&#x2F;Link&gt;</span><br><span class=\"line\">    &lt;&#x2F;&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;Router&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path&#x3D;&quot;&#x2F;login&quot; component&#x3D;&#123;Login&#125;&#x2F;&gt;</span><br><span class=\"line\">        &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;Switch&gt;</span><br><span class=\"line\">    &lt;&#x2F;Router&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经看完了<code>BrowserRouter</code>（<code>Router</code>。下面还有<code>Switch</code>和<code>Route</code>。</p>\n<h2 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h2><p>先上源码。我摘取最核心的一部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Switch extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">        &#123;context &#x3D;&gt; &#123;</span><br><span class=\"line\">          invariant(context, &quot;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">          &#x2F;&#x2F; 默认使用context.location，如果有特殊定制的location才会使用。</span><br><span class=\"line\">          &#x2F;&#x2F; 下面有介绍</span><br><span class=\"line\">          const location &#x3D; this.props.location || context.location;</span><br><span class=\"line\"></span><br><span class=\"line\">          let element, match;</span><br><span class=\"line\"></span><br><span class=\"line\">          &#x2F;&#x2F; We use React.Children.forEach instead of React.Children.toArray().find()</span><br><span class=\"line\">          &#x2F;&#x2F; here because toArray adds keys to all child elements and we do not want</span><br><span class=\"line\">          &#x2F;&#x2F; to trigger an unmount&#x2F;remount for two &lt;Route&gt;s that render the same</span><br><span class=\"line\">          &#x2F;&#x2F; component at different URLs.</span><br><span class=\"line\">          &#x2F;&#x2F; React.Children.forEach 对子元素做遍历</span><br><span class=\"line\">          React.Children.forEach(this.props.children, child &#x3D;&gt; &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 只要找到一个 match，那么就不会再进来了</span><br><span class=\"line\">            if (match &#x3D;&#x3D; null &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class=\"line\">              element &#x3D; child;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#x2F;&#x2F; child.props.path 就不多讲了， Route 的标准写法</span><br><span class=\"line\">              &#x2F;&#x2F; 需要注意的是，使用 from 也会被匹配到</span><br><span class=\"line\">              &#x2F;&#x2F; 任何组件，只要在 Switch 下，有 from 属性，并且和当前路径匹配，就会被渲染</span><br><span class=\"line\">              &#x2F;&#x2F; from具体是给&lt;Redirect&gt;使用的，后面会说到</span><br><span class=\"line\">              const path &#x3D; child.props.path || child.props.from;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#x2F;&#x2F; 判断组件是否匹配</span><br><span class=\"line\">              match &#x3D; path</span><br><span class=\"line\">              &#x2F;&#x2F; 下面有专属的介绍这个函数</span><br><span class=\"line\">                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class=\"line\">                : context.match;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">          return match</span><br><span class=\"line\">            ? React.cloneElement(element, &#123; location, computedMatch: match &#125;)</span><br><span class=\"line\">            : null;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &lt;&#x2F;RouterContext.Consumer&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Switch中的location这个props怎么用？什么用？</p>\n<blockquote>\n<h2 id=\"摘自官网\"><a href=\"#摘自官网\" class=\"headerlink\" title=\"摘自官网\"></a>摘自官网</h2><h2 id=\"location-object\"><a href=\"#location-object\" class=\"headerlink\" title=\"location: object\"></a><a href=\"https://reactrouter.com/web/api/Switch/location-object\" target=\"_blank\" rel=\"noopener\">location: object</a></h2><p>A <a href=\"https://reactrouter.com/web/api/location\" target=\"_blank\" rel=\"noopener\"><code>location</code></a> object to be used for matching children elements instead of the current history location (usually the current browser URL).</p>\n<p>谷歌翻译：用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。</p>\n</blockquote>\n<h3 id=\"matchPath\"><a href=\"#matchPath\" class=\"headerlink\" title=\"matchPath\"></a>matchPath</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchPath</span>(<span class=\"params\">pathname, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 规范结构体</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果 options 传的是个 string，那默认这个 string 代表 path</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果 options 传的是个 数组，那只要有一个匹配，就认为匹配</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> options === <span class=\"string\">\"string\"</span> || <span class=\"built_in\">Array</span>.isArray(options)) &#123;</span><br><span class=\"line\">    options = &#123; <span class=\"attr\">path</span>: options &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, exact = <span class=\"literal\">false</span>, strict = <span class=\"literal\">false</span>, sensitive = <span class=\"literal\">false</span> &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 转化成数组进行判断</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> paths = [].concat(path);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 都是很简单的内容，难点就在这个reduce，这个很有意思，感兴趣或者不了解的赶紧去MDN了解一下！！！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths.reduce(<span class=\"function\">(<span class=\"params\">matched, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!path &amp;&amp; path !== <span class=\"string\">\"\"</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 只要有一个 match，直接返回，认为是 match</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matched) <span class=\"keyword\">return</span> matched;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// regexp 是正则表达式</span></span><br><span class=\"line\">    <span class=\"comment\">// keys 是切割出来的得 key 的值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; regexp, keys &#125; = compilePath(path, &#123;</span><br><span class=\"line\">      end: exact,</span><br><span class=\"line\">      strict,</span><br><span class=\"line\">      sensitive</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// exec() 该方法如果找到了匹配的文本的话，则会返回一个结果数组，否则的话，会返回一个</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> match = regexp.exec(pathname);</span><br><span class=\"line\">    <span class=\"comment\">/* 匹配不成功，返回null */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!match) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// url 表示匹配到的部分</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [url, ...values] = match;</span><br><span class=\"line\">    <span class=\"comment\">// pathname === url 表示完全匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> isExact = pathname === url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exact &amp;&amp; !isExact) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      path, <span class=\"comment\">// the path used to match</span></span><br><span class=\"line\">      url: path === <span class=\"string\">\"/\"</span> &amp;&amp; url === <span class=\"string\">\"\"</span> ? <span class=\"string\">\"/\"</span> : url, <span class=\"comment\">// the matched portion of the URL</span></span><br><span class=\"line\">      isExact, <span class=\"comment\">// whether or not we matched exactly</span></span><br><span class=\"line\">      params: keys.reduce(<span class=\"function\">(<span class=\"params\">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        memo[key.name] = values[index];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo;</span><br><span class=\"line\">      &#125;, &#123;&#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>matchPath 函数也是由 react-router export 出去的函数，我们可以用来获得某个 url 中的指定的参数。</p>\n<h2 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h2><p>Route 是用于声明路由映射到应用程序的组件层。</p>\n<p>Route 有三种渲染的方法，当然，都配置的话只有一个会生效，优先级是 children &gt; component &gt; render</p>\n<p>\\1. <Route component><br>\\2. <Route render><br>\\3. <Route children></p>\n<p>每个在不同的情况下都有用，大多数情况下，会使用 component。</p>\n<h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><p>component 表示只有当位置匹配时才会渲染的 React 组件。使用 component（而不是 render 或 children ）Route 使用从给定组件 React.createElement(element, props) 创建新的 React element。这意味着，使用 component 创建的组件能获得 router 中的 props。</p>\n<h3 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"children\"></a>children</h3><p>从源码中可以看出，children 的优先级是高于 component，而且可以是一个组件，也可以是一个函数，children 没有获得 router 的 props。</p>\n<p>children 有一个非常特殊的地方在于，当路由不匹配且 children 是一个函数的时候，会执行 children 方法，这就给了设计很大的灵活性。</p>\n<h3 id=\"render-1\"><a href=\"#render-1\" class=\"headerlink\" title=\"render\"></a>render</h3><p>render 必须是一个函数，优先级是最低的，当匹配成功的时候，执行这个函数。</p>\n<h3 id=\"exact-amp-strict-amp-sensitive\"><a href=\"#exact-amp-strict-amp-sensitive\" class=\"headerlink\" title=\"exact &amp; strict &amp; sensitive\"></a>exact &amp; strict &amp; sensitive</h3><p>这三者都是使用 path-to-regexp 做路径匹配需要的三个参数。</p>\n<ol>\n<li>exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。</li>\n<li>strict: 在确定为位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线。</li>\n<li>sensitive: 如果路径区分大小写，则为 true ，则匹配。</li>\n</ol>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p>Route 元素尝试其匹配 path 到当前浏览器 URL，但是，也可以通过 location 实现与当前浏览器位置以外的位置相匹配。</p>\n<p>下面列出 Route 源码，并且删去了 dev 部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; isValidElementType &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-is\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> invariant <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-invariant\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> warning <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-warning\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> matchPath <span class=\"keyword\">from</span> <span class=\"string\">\"./matchPath.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for matching a single path and rendering.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Route</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">        &#123;context =&gt; &#123;</span><br><span class=\"line\">          invariant(context, <span class=\"string\">\"You should not use &lt;Route&gt; outside a &lt;Router&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 可以看出，用户传的 location 覆盖掉了 context 中的 location</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> location = <span class=\"keyword\">this</span>.props.location || context.location;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 如果有 computedMatch 就用 computedMatch 作为结果</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果没有，则判断是否有 path 传参</span></span><br><span class=\"line\">          <span class=\"comment\">// matchPath 是调用 path-to-regexp 判断是否匹配</span></span><br><span class=\"line\">          <span class=\"comment\">// path-to-regexp 需要三个参数</span></span><br><span class=\"line\">          <span class=\"comment\">// exact: 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配</span></span><br><span class=\"line\">          <span class=\"comment\">// strict: 如果为 true 当真实的路径具有一个斜线将只匹配一个斜线location.pathname</span></span><br><span class=\"line\">          <span class=\"comment\">// sensitive: 如果路径区分大小写，则为 true ，则匹配</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> match = <span class=\"keyword\">this</span>.props.computedMatch</span><br><span class=\"line\">            ? <span class=\"keyword\">this</span>.props.computedMatch <span class=\"comment\">// &lt;Switch&gt; already computed the match for us</span></span><br><span class=\"line\">            : <span class=\"keyword\">this</span>.props.path</span><br><span class=\"line\">            ? matchPath(location.pathname, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">            : context.match;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// props 就是更新后的 context</span></span><br><span class=\"line\">          <span class=\"comment\">// location 做了更新（有可能是用户传入的location）</span></span><br><span class=\"line\">          <span class=\"comment\">// match 做了更新</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> props = &#123; ...context, location, match &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 三种渲染方式</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> &#123; children, component, render &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// Preact uses an empty array as children by</span></span><br><span class=\"line\">          <span class=\"comment\">// default, so use null if that's the case.</span></span><br><span class=\"line\">          <span class=\"comment\">// children 默认是个空数组，如果是默认情况，置为 null</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children) &amp;&amp; children.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"comment\">// RouterContext 中更新了 location, match</span></span><br><span class=\"line\">            &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class=\"line\">              &#123;props.match</span><br><span class=\"line\">              <span class=\"comment\">// 首先判断的是有无 children</span></span><br><span class=\"line\">                ? children</span><br><span class=\"line\">                  <span class=\"comment\">// 如果 children 是个函数，执行，否则直接返回 children</span></span><br><span class=\"line\">                  ? <span class=\"keyword\">typeof</span> children === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">                  : children(props)</span><br><span class=\"line\">                  : children</span><br><span class=\"line\">                  <span class=\"comment\">// 如果没有 children，判断有无 component</span></span><br><span class=\"line\">                : component</span><br><span class=\"line\">                  <span class=\"comment\">// 有 component，重新新建一个 component</span></span><br><span class=\"line\">                  ? React.createElement(component, props)</span><br><span class=\"line\">                  <span class=\"comment\">// 没有 component，判断有无 render</span></span><br><span class=\"line\">                  : render</span><br><span class=\"line\">                  <span class=\"comment\">// 有 render，执行 render 方法</span></span><br><span class=\"line\">                  ? render(props)</span><br><span class=\"line\">                  <span class=\"comment\">// 没有返回 null</span></span><br><span class=\"line\">                  : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 这里是不 match 的情况，判断 children 是否函数</span></span><br><span class=\"line\">                : <span class=\"keyword\">typeof</span> children === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">                <span class=\"comment\">// 是的话执行</span></span><br><span class=\"line\">                ? children(props)</span><br><span class=\"line\">                : <span class=\"literal\">null</span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/RouterContext.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          );</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>RouterContext.Consumer&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Route;</span><br></pre></td></tr></table></figure>\n\n<p>Route 组件根据自身的传参，对上层 RouterContext 中的部分属性（location 和 match）进行了更新，并且如果当前路径和配置的 path 路径 match，则渲染该组件，渲染的方式有 children，component，render 三种方式，我们最常用的就是 component 方式，注意每种方式的区别。</p>\n<h2 id=\"Prompt\"><a href=\"#Prompt\" class=\"headerlink\" title=\"Prompt\"></a>Prompt</h2><p>Prompt 用于路由切换提示。这在某些场景下是非常有用的，比如用户在某个页面修改数据，离开时，提示用户是否保存，Prompt 组件有俩个属性：</p>\n<ol>\n<li>message：用于显示提示的文本信息。</li>\n<li>when：传递布尔值，相当于标签的开关，默认是 true，设置成 false 时，失效。</li>\n</ol>\n<p>Prompt 的本质是在 when 为 true 的时候，调用 context.history.block 方法，为全局注册路由监听，block 的原理看之前的 history 相关文章。路有变化的时候，默认使用 window.confirm 进行确认，我们也可以自定义 confirm 的形式，就是在 BrowserRouter 或者 HashRouter 传入 getUserConfirmation 这个参数，会替换掉 window.confirm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import PropTypes from &quot;prop-types&quot;;</span><br><span class=\"line\">import invariant from &quot;tiny-invariant&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Lifecycle from &quot;.&#x2F;Lifecycle.js&quot;;</span><br><span class=\"line\">import RouterContext from &quot;.&#x2F;RouterContext.js&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * The public API for prompting the user before navigating away from a screen.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function Prompt(&#123; message, when &#x3D; true &#125;) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">      &#123;context &#x3D;&gt; &#123;</span><br><span class=\"line\">        invariant(context, &quot;You should not use &lt;Prompt&gt; outside a &lt;Router&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!when || context.staticContext) return null;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 调用了 history.block 方法</span><br><span class=\"line\">        const method &#x3D; context.history.block;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;Lifecycle</span><br><span class=\"line\">            onMount&#x3D;&#123;self &#x3D;&gt; &#123;</span><br><span class=\"line\">              self.release &#x3D; method(message);</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUpdate&#x3D;&#123;(self, prevProps) &#x3D;&gt; &#123;</span><br><span class=\"line\">              if (prevProps.message !&#x3D;&#x3D; message) &#123;</span><br><span class=\"line\">                self.release();</span><br><span class=\"line\">                self.release &#x3D; method(message);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUnmount&#x3D;&#123;self &#x3D;&gt; &#123;</span><br><span class=\"line\">              self.release();</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            message&#x3D;&#123;message&#125;</span><br><span class=\"line\">          &#x2F;&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    &lt;&#x2F;RouterContext.Consumer&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Prompt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redirect\"><a href=\"#Redirect\" class=\"headerlink\" title=\"Redirect\"></a>Redirect</h2><p>Redirect 与其说是一个组件，不如说是有组件封装的一组方法，该组件在 componentDidMount 生命周期内，通过调用 history API 跳转到到新位置，默认情况下，新位置将覆盖历史堆栈中的当前位置。</p>\n<p><Redirect to=\"/somewhere/else\"/> to 表示要重定向到的网址。to 也可以是一个 location 对象</p>\n<p><Redirect push to=\"/somewhere/else\"/> push 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目。</p>\n<p>结合 Switch 和 Redirect 源码看，如果 Redirect 中有 from 属性，会被 Switch 获得，当 from 和当前路径匹配的时候，就会渲染 Redirect 组件，执行跳转。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">\"prop-types\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createLocation, locationsAreEqual &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"history\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> invariant <span class=\"keyword\">from</span> <span class=\"string\">\"tiny-invariant\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Lifecycle <span class=\"keyword\">from</span> <span class=\"string\">\"./Lifecycle.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> RouterContext <span class=\"keyword\">from</span> <span class=\"string\">\"./RouterContext.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> generatePath <span class=\"keyword\">from</span> <span class=\"string\">\"./generatePath.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The public API for navigating programmatically with a component.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Redirect</span>(<span class=\"params\">&#123; computedMatch, to, push = false &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 啥都有的大哥 RouterContext</span></span><br><span class=\"line\">    &lt;RouterContext.Consumer&gt;</span><br><span class=\"line\">      &#123;context =&gt; &#123;</span><br><span class=\"line\">        invariant(context, <span class=\"string\">\"You should not use &lt;Redirect&gt; outside a &lt;Router&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; history, staticContext &#125; = context;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般来说，Redirect 操作都不需要留有 history，所以选择选择 history.replace</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> method = push ? history.push : history.replace;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> location = createLocation(</span><br><span class=\"line\">          <span class=\"comment\">// computedMatch 就是看看 switch 有没有多管闲事</span></span><br><span class=\"line\">          computedMatch</span><br><span class=\"line\">            ? <span class=\"keyword\">typeof</span> to === <span class=\"string\">\"string\"</span></span><br><span class=\"line\">              ? generatePath(to, computedMatch.params)</span><br><span class=\"line\">              : &#123;</span><br><span class=\"line\">                  ...to,</span><br><span class=\"line\">                  pathname: generatePath(to.pathname, computedMatch.params)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            : to</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// When rendering in a static context,</span></span><br><span class=\"line\">        <span class=\"comment\">// set the new location immediately.</span></span><br><span class=\"line\">        <span class=\"comment\">// staticRouter 专用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (staticContext) &#123;</span><br><span class=\"line\">          method(location);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;Lifecycle</span><br><span class=\"line\">            onMount=&#123;() =&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// componentDidMount 的时候执行 method(location)，也就是 history.replace 操作</span></span><br><span class=\"line\">              method(location);</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\">            onUpdate=&#123;(self, prevProps) =&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// componentDidUpdate 时候判断当前 location 和上一个 location 是否发生变化</span></span><br><span class=\"line\">              <span class=\"comment\">// 只要发生变化，调用 method(location)</span></span><br><span class=\"line\">              <span class=\"comment\">// 一般来讲，在 componentDidMount 的时候就跳走了，不会等到 componentDidUpdate</span></span><br><span class=\"line\">              <span class=\"keyword\">const</span> prevLocation = createLocation(prevProps.to);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !locationsAreEqual(prevLocation, &#123;</span><br><span class=\"line\">                  ...location,</span><br><span class=\"line\">                  key: prevLocation.key</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                method(location);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 无效</span></span><br><span class=\"line\">            to=&#123;to&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/RouterContext.Consumer&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Redirect;</span></span><br></pre></td></tr></table></figure>\n\n<p>Lifecycle 不 render 任何页面，只有生命周期函数，Lifecycle 提供了 onMount， onUpdate， onUnmount 三个生命周期函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lifecycle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onMount) <span class=\"keyword\">this</span>.props.onMount.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidUpdate(prevProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onUpdate) <span class=\"keyword\">this</span>.props.onUpdate.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>, prevProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.onUnmount) <span class=\"keyword\">this</span>.props.onUnmount.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Lifecycle;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个<code>react-router</code>是由<code>createBrowserHistory</code>或者<code>createHashHistory</code>来牵头，与我们的<code>React</code>组件绑定在一起，然后传递了一些属于<code>history</code>这个库的方法以及数值。当然，还有路由的匹配和渲染。</p>\n<p>在<code>history</code>这个库里面又有对于路由的监听，改变等等。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>以<code>history</code>模式做参考（也是我们重点阅读的。</p>\n<h3 id=\"修改url\"><a href=\"#修改url\" class=\"headerlink\" title=\"修改url\"></a>修改url</h3><p>当<code>url</code>改变的时候，会触发写在<code>window</code>上面的监听<code>window.addEventListener(&#39;popstate&#39;, handlePop)</code>。</p>\n<p>调用了我们的函数<code>handlePop</code></p>\n<p>函数内部我们<code>setState</code>，修改了<code>location</code>，方便传递正确的值下去，并通过了<code>Switch</code>找出匹配的<code>Route</code>组件。</p>\n<p>触发了组件的渲染。</p>\n<blockquote>\n<p>当然也包括我们所谓的history.push，history.repalce等等这些方法，本质上也是修改url，然后就是重复上面的步骤</p>\n</blockquote>\n"},{"title":"【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化","date":"2021-04-06T06:08:31.000Z","cover":"/image/cover/react.png","_content":"\n# 前言\n\n在第一章中，我们解读到ReactDOM.render之后就没有继续了。因为我看了一下设计到了Fiber的一些知识，所以在第二章补充了Fiber的基础知识之后，我将Fiber拆分成四块来讲\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\n现在是初始化阶段\n\n我们现在直接进入Fiber的初始化。Action！\n\n# 前情回顾\n\n回顾一下之前学习JSX的时候，阅读到ReactDOM.render。如果你没有阅读过之前的文章，强烈建议你到我的主页去阅读我之前的博客。下面我们开始。\n\nReactDOM.render的源码。\n\n```typescript\nexport function isValidContainer(node: mixed): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // 用于抛出错误的, 就是判断这个container是不是找得到\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  \n  // 这里面涉及到了fiber的一些架构，开始补坑\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n```\n\n最后return的这个函数有点意思。\n\n# 源码攻读\n\n## legacyRenderSubtreeIntoContainer\n\n我们首先翻译一下这个函数的名字，进行驼峰拆分：\n\n> Google翻译：legacy Render Subtree Into Container（旧版渲染子树放入容器\n\n先别急着翻译。我们先看看源码。\n\n```typescript\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // container 对应的是我们传入的真实 DOM 对象\n  var root = container._reactRootContainer;\n  // 初始化 fiberRoot 对象\n  var fiberRoot;\n  // DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空\n  if (!root) {\n    // 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root\n    // legacyCreateRootFromDOMContainer 主要的功能是创建，并且进行一些“脏判断”。感兴趣的，我在后面也会详细给出\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    // legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot\n    fiberRoot = root._internalRoot;\n\n    // 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } // Initial mount should not be batched.\n    // 进入 unbatchedUpdates 方法\n    unbatchedUpdates(function () {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    // else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(fiberRoot);\n        _originalCallback.call(instance);\n      };\n    } // Update\n\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n梳理一下整个流程，然后我们再一一看这些函数。\n\n以下流程是指初始化，也就是`if/else`判断里面的`if`。而不是`else`，`else`是非首次渲染，走的更新流程，注释里面写了。\n\n1. 创建`container._reactRootContainer`对象，并赋值给`root`\n2. 将`root`上的`_inernalRoot`赋值给`fiberRoot`\n3. 将`legacyRenderSubtreeIntoContainer`的一些参数和`fiberRoot`一起传给`updateContainer`\n4. `将updateConatiner`作为回调函数传给`unbatechedUpdates`\n\nok，现在看不太懂没关系。我们将里面用到的函数一一解读，然后再回来补充整个流程。\n\n## legacyCreateRootFromDOMContainer\n\n大家现在一定会晕头转向，因为我看的时候也是这样，他的名字和函数名字取的太像了，我们需要给他们独自用自己的方式命名。我会写下Google翻译， 帮助大家取名字。\n\n> Google翻译：legacy Create Root From DOM Container（从DOM容器创建根目录\n\n看了翻译之后是不是焕然大悟？别急，我们先看看源码。\n\n```typescript\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): RootType {\n    // 如果forceHydrate是false，就会调用后面的方法。\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    // 这个循环，是为了清理所有的内容，然后找到我们要渲染的最初的根div。通常我们的html会有一个\n    // <div id=\"root\"></div> 为的就是保障他的纯净。\n    while ((rootSibling = container.lastChild)) {\n      if (__DEV__) {\n        if (\n          !warned &&\n          rootSibling.nodeType === ELEMENT_NODE &&\n          (rootSibling: any).hasAttribute(ROOT_ATTRIBUTE_NAME)\n        ) {\n          warned = true;\n          console.error(\n            'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.',\n          );\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  if (__DEV__) {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      console.warn(\n        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +\n          'will stop working in React v18. Replace the ReactDOM.render() call ' +\n          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',\n      );\n    }\n  }\n\n  return createLegacyRoot(\n    container,\n    shouldHydrate\n      ? {\n          hydrate: true,\n        }\n      : undefined,\n  );\n}\n```\n\n里面又用到两个函数，我为大家召出来。\n\n### shouldHydrateDueToLegacyHeuristic\n\n\n\n```typescript\nfunction getReactRootElementInContainer(container: any) {\n  // 如果没有就返回null\n  if (!container) {\n    return null;\n  }\n  // 内部定义的一个常量\n  // export const DOCUMENT_NODE = 9;看名字就顾名思义了\n  // 如果是内部一个document节点就返回document节点\n  // 感兴趣可以看看MDN的介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/Document\n  // 常量的值也有：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    // 否则返回第一个元素\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  // 将container传入函数，进行判断类型，并得到节点（有可能为空，看注释\n  const rootElement = getReactRootElementInContainer(container);\n  // 强转为布尔值\n  return !!(\n    rootElement &&\n    rootElement.nodeType === ELEMENT_NODE &&\n    // export const ROOT_ATTRIBUTE_NAME = 'data-reactroot'; \n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)\n  );\n}\n```\n\n我们看到一个hasAttribute为\"data-reactroot\"。这是 React 在服务端渲染的时候加上去的。之前有说过Hydrate这个操作是服务端渲染的时候需要的东西。\n\n> Google翻译：getReactRootElementInContainer（获取容器中的React根元素\n>\n> Google翻译：shouldHydrateDueToLegacyHeuristic（应当因传统启发而水合\n>\n> 说人话就是是否需要进行hydrate操作\n\n所以`legacyCreateRootFromDOMContainer`这个函数是保障`container`的纯净。并且返回`createLegacyRoot`函数。ok继续看。\n\n### createLegacyRoot\n\n```typescript\nfunction ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {\n  // 是不是看见老朋友了。_internalRoot。继续看下面的内容，我们来解析一下createRootImpl\n  this._internalRoot = createRootImpl(container, LegacyRoot, options);\n}\n\nexport function createLegacyRoot(\n  container: Container,\n  options?: RootOptions,\n): RootType {\n  // 又是熟悉的操作，返回某个东西\n  return new ReactDOMLegacyRoot(container, options);\n}\n```\n\n### createRootImpl\n\n需要注意的是，我们通篇都是以非`hydrate`来看的，因为我们不是服务端渲染。但是我也会介绍如果有`hydrate`的内容。所以大家看的时候可以稍微带入一点去看，不然很容易走神！\n\n```typescript\n// 创建并返回一个fiberRoot\nfunction createRootImpl(\n  container: Container,\n  tag: RootTag,\n  options: void | RootOptions,\n) {\n  // Tag is either LegacyRoot or Concurrent Root\n  // 判断是否为hydrate模式\n  const hydrate = options != null && options.hydrate === true;\n  const hydrationCallbacks =\n    (options != null && options.hydrationOptions) || null;\n  const mutableSources =\n    (options != null &&\n      options.hydrationOptions != null &&\n      options.hydrationOptions.mutableSources) ||\n    null;\n  const strictModeLevelOverride =\n    options != null && options.unstable_strictModeLevel != null\n      ? options.unstable_strictModeLevel\n      : null;\n  // 创建一个fiberRoot\n  const root = createContainer(\n    container,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    strictModeLevelOverride,\n  );\n  // 给container附加一个内部属性用于指向fiberRoot的current属性对应的rootFiber节点\n  markContainerAsRoot(root.current, container);\n\n  const rootContainerElement =\n    container.nodeType === COMMENT_NODE ? container.parentNode : container;\n  listenToAllSupportedEvents(rootContainerElement);\n\n  if (mutableSources) {\n    for (let i = 0; i < mutableSources.length; i++) {\n      const mutableSource = mutableSources[i];\n      registerMutableSourceForHydration(root, mutableSource);\n    }\n  }\n\n  return root;\n}\n```\n\n为什么我在注释里面会加上「创建一个fiberRoot」，不是一个是创建一个container吗？我们看createContainer里面做了什么。\n\n\n\n### createContainer\n\n```typescript\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  strictModeLevelOverride: null | number,\n): FiberRoot {\n  // 通过FiberRootNode构造函数创建一个fiberRoot实例\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  // 如果有，就补充进这个回调函数\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // 通过createHostRootFiber方法创建fiber tree的根结点，即rootFiber\n  // fiber节点也会像DOM树结构一样形成一个fiber tree单链表树结构\n  // 每个DOM节点或者组件都会生成一个与之对应的fiber节点，在后续的调和(reconciliation)阶段起着至关重要的作用\n  const uninitializedFiber = createHostRootFiber(tag, strictModeLevelOverride);\n  // 创建完rootFiber之后，会将fiberRoot的实例的current属性指向刚创建的rootFiber\n  root.current = uninitializedFiber;\n  // 同时rootFiber的stateNode属性会指向fiberRoot实例，形成相互引用\n  uninitializedFiber.stateNode = root;\n\n  if (enableCache) {\n    const initialCache = new Map();\n    root.pooledCache = initialCache;\n    const initialState = {\n      element: null,\n      cache: initialCache,\n    };\n    uninitializedFiber.memoizedState = initialState;\n  } else {\n    const initialState = {\n      element: null,\n    };\n    uninitializedFiber.memoizedState = initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n\t// 最后将创建的fiberRoot实例返回\n  return root;\n}\n\n// 内部调用createFiberRoot方法返回一个fiberRoot实例\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  strictModeLevelOverride: null | number,\n): OpaqueRoot {\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    strictModeLevelOverride,\n  );\n}\n```\n\n这里也比较简单，只是单纯的调用函数，然后返回。真正的秘密就在这些函数里面，耐心点继续看！黎明就在眼前\n\n\n\n#### FiberRootNode\n\n一个非常恐怖的内容。但是看名字也能猜个大概。还记得我们之前说过。一个fiber节点要存的内容还蛮多的。比如被暂停时的状态，恢复时要做的事情，优先级等等....这里我尽可能的去写注释。帮助大家还要我自己理解。\n\n```typescript\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  //root 节点类型()\n  this.tag = tag;\n  //root根节点，render方法的第二个参数\n  this.containerInfo = containerInfo;\n  //在持久更新中会用到，不支持增量更新的平台，react-dom 是整个应用更新，所以用不到\n  this.pendingChildren = null;\n  //当前应用root节点对应的Fiber对象\n  this.current = null;\n  //缓存\n  this.pingCache = null;\n  //已经完成任务的FiberRoot对象，在commit(提交)阶段只会处理该值对应的任务\n  this.finishedWork = null;\n  //在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout\n  this.timeoutHandle = noTimeout;\n  //顶层 context 对象，只有主动调用renderSubtreeIntoContainer才会生效\n  this.context = null;\n  this.pendingContext = null;\n  // 老朋友了，用来确定第一次渲染的时候是否需要注水\n  this.hydrate = hydrate;\n  //回调节点\n  this.callbackNode = null;\n  //回调属性\n  this.callbackPriority = NoLane;\n  // export const NoLanes: Lanes = 0b0000000000000000000000000000000;\n  /*\n  export function createLaneMap<T>(initial: T): LaneMap<T> {\n    // Intentionally pushing one by one.\n    // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n    const laneMap = [];\n    for (let i = 0; i < TotalLanes; i++) {\n      laneMap.push(initial);\n    }\n    return laneMap;\n  }\n  */\n  //任务时间。由于该字段在未来会重构，当前我们不需要理解他。\n  this.eventTimes = createLaneMap(NoLanes);\n  // 过期时间。函数上面的注释有。export const NoTimestamp = -1;\n  this.expirationTimes = createLaneMap(NoTimestamp);\n\n  // 优先级的初始化\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = 'createRoot()';\n        break;\n      case LegacyRoot:\n        this._debugRootType = 'createLegacyRoot()';\n        break;\n    }\n  }\n}\n```\n\n\n\n#### createHostRootFiber\n\n通篇大论都是在判断mode类型。感兴趣的可以再深挖。这里我就略过了。眼睛已经看花了。。。\n\n```typescript\nexport function createHostRootFiber(\n  tag: RootTag,\n  strictModeLevelOverride: null | number,\n): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n    if (strictModeLevelOverride !== null) {\n      if (strictModeLevelOverride >= 1) {\n        mode |= StrictLegacyMode;\n      }\n      if (enableStrictEffects) {\n        if (strictModeLevelOverride >= 2) {\n          mode |= StrictEffectsMode;\n        }\n      }\n    } else {\n      if (enableStrictEffects && createRootStrictEffectsByDefault) {\n        mode |= StrictLegacyMode | StrictEffectsMode;\n      } else {\n        mode |= StrictLegacyMode;\n      }\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\t// export const HostRoot = 3;\n  return createFiber(HostRoot, null, null, mode);\n}\n```\n\n\n\n#### createFiber\n\n也是包一个壳子。主要还是为了创建FiberNode。\n\n```typescript\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\n```\n\n\n\n#### FiberNode\n\n官方其实已经注释了属性的要素。但是我还是会尽可能的完善。\n\n```typescript\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // 用于标记fiber节点的类型\n  this.tag = tag;\n  // 用于唯一标识一个fiber节点\n  this.key = key;\n  // 节点类型\n  this.elementType = null;\n  // ReactNode的节点类型\n  this.type = null;\n  // FiberNode会通过stateNode绑定一些其他的对象，例如FiberNode对应的Dom、FiberRoot、ReactComponent实例\n  this.stateNode = null;\n\n  // Fiber\n  // 表示父级 FiberNode\n  this.return = null;\n  // 表示第一个子 FiberNode\n  this.child = null;\n  // 表示紧紧相邻的下一个兄弟 FiberNode\n  this.sibling = null;\n  // 下标\n  this.index = 0;\n\n  this.ref = null;\n\n  // 表示新的props\n  this.pendingProps = pendingProps;\n  // 表示经过所有流程处理后的新props\n  this.memoizedProps = null;\n  // 更新队列\n  this.updateQueue = null;\n  // 表示经过所有流程处理后的新state\n  this.memoizedState = null;\n  // 依赖\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  // 标志更新的类型：删除、新增、修改。\n  this.flags = NoFlags;\n  // 子Fiber树的标志更新的类型：删除、新增、修改。\n  this.subtreeFlags = NoFlags;\n  // 需要删除的内容\n  this.deletions = null;\n\n  // 优先级\n  this.lanes = NoLanes;\n  // 子的优先级\n  this.childLanes = NoLanes;\n\n  // 双缓冲：防止数据丢失，提高效率（之后Dom-diff的时候可以直接比较或者使用\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  if (__DEV__) {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n```\n\n\n\n#### initializeUpdateQueue\n\ncreateContainer还有最后一个函数，初始化更新队列。\n\n```typescript\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n```\n\n\n\n# 小结一番\n\n大费周章的做这些阅读，其实回过神来看。就是为了创建`fiberNode`（`FiberRootNode实例`）和`rootFiber`对象。这两兄弟是整个Fiber树构建的起点。\n\n- `fiberNode`（`FiberRootNode实例`） -> 的关联对象是真实 DOM 的容器节点\n- `rootFiber` -> 虚拟 DOM 的根节点\n\n然后再回过神来看，确实。他们各自创建都是为他们所代表的东西而创建，无论是属性或者打入方法。\n\n# 收尾\n\n最后他们都会被`unbatchedUpdates`所收编（看看最上面梦开始的地方「legacyRenderSubtreeIntoContainer」）。最后我们所创建的都会归入到它的手上。一起看看最后一个函数吧。\n\n## 方便阅读\n\n```typescript\nunbatchedUpdates(function () {\n  updateContainer(children, fiberRoot, parentComponent, callback);\n});\n```\n\n\n\n## unbatchedUpdates\n\n```typescript\nfunction unbatchedUpdates(fn, a) {\n  // 这里是对上下文的处理，不必纠结\n  var prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  try {\n    // 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法\n    return fn(a);\n  } finally {\n    // finally 逻辑里是对回调队列的处理，此处不用太关注\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbackQueue();\n    }\n  }\n}\n```\n\n\n\n## updateContainer\n\n```typescript\nfunction updateContainer(element, container, parentComponent, callback) {\n  ......\n\n  // 这是一个 event 相关的入参，此处不必关注\n  var eventTime = requestEventTime();\n\n  ......\n\n  // 这是一个比较关键的入参，lane 表示优先级\n  var lane = requestUpdateLane(current);\n  // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新\n  var update = createUpdate(eventTime, lane); \n\n  // update 的 payload 对应的是一个 React 元素\n  update.payload = {\n    element: element\n  };\n\n  // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n    update.callback = callback;\n  }\n\n  // 将 update 入队\n  enqueueUpdate(current, update);\n  // 调度 fiberRoot \n  scheduleUpdateOnFiber(current, lane, eventTime);\n  // 返回当前节点（fiberRoot）的优先级\n  return lane;\n}\n```\n\n\n\nupdateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：\n\n- 请求当前 Fiber 节点的 lane（优先级）；\n\n- 结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；\n\n- 调度当前节点（rootFiber）。\n\n看到这里的伙伴，谢谢你的耐心。\n\n\n\n# 最后\n\n因为我也是在一边看，一边记录，如果有问题，大家一定要及时提出来。我也会及时更新的。这部分我应该会屡次阅读。毕竟大神写了几年，我不可能几天就看明白的。\n\n\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\n\n\n\n\n\n\n\n\n","source":"_posts/【重识前端】React源码阅读（三）Fiber 初始化.md","raw":"---\ntitle: 【重识前端】React源码阅读（三）4千字告诉你 Fiber 初始化\ndate: 2021-04-06 14:08:31\ntags: [react]\ncategory: [重拾前端]\ncover: /image/cover/react.png\n---\n\n# 前言\n\n在第一章中，我们解读到ReactDOM.render之后就没有继续了。因为我看了一下设计到了Fiber的一些知识，所以在第二章补充了Fiber的基础知识之后，我将Fiber拆分成四块来讲\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\n现在是初始化阶段\n\n我们现在直接进入Fiber的初始化。Action！\n\n# 前情回顾\n\n回顾一下之前学习JSX的时候，阅读到ReactDOM.render。如果你没有阅读过之前的文章，强烈建议你到我的主页去阅读我之前的博客。下面我们开始。\n\nReactDOM.render的源码。\n\n```typescript\nexport function isValidContainer(node: mixed): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // 用于抛出错误的, 就是判断这个container是不是找得到\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  \n  // 这里面涉及到了fiber的一些架构，开始补坑\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n```\n\n最后return的这个函数有点意思。\n\n# 源码攻读\n\n## legacyRenderSubtreeIntoContainer\n\n我们首先翻译一下这个函数的名字，进行驼峰拆分：\n\n> Google翻译：legacy Render Subtree Into Container（旧版渲染子树放入容器\n\n先别急着翻译。我们先看看源码。\n\n```typescript\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // container 对应的是我们传入的真实 DOM 对象\n  var root = container._reactRootContainer;\n  // 初始化 fiberRoot 对象\n  var fiberRoot;\n  // DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空\n  if (!root) {\n    // 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root\n    // legacyCreateRootFromDOMContainer 主要的功能是创建，并且进行一些“脏判断”。感兴趣的，我在后面也会详细给出\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    // legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot\n    fiberRoot = root._internalRoot;\n\n    // 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } // Initial mount should not be batched.\n    // 进入 unbatchedUpdates 方法\n    unbatchedUpdates(function () {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    // else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(fiberRoot);\n        _originalCallback.call(instance);\n      };\n    } // Update\n\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n梳理一下整个流程，然后我们再一一看这些函数。\n\n以下流程是指初始化，也就是`if/else`判断里面的`if`。而不是`else`，`else`是非首次渲染，走的更新流程，注释里面写了。\n\n1. 创建`container._reactRootContainer`对象，并赋值给`root`\n2. 将`root`上的`_inernalRoot`赋值给`fiberRoot`\n3. 将`legacyRenderSubtreeIntoContainer`的一些参数和`fiberRoot`一起传给`updateContainer`\n4. `将updateConatiner`作为回调函数传给`unbatechedUpdates`\n\nok，现在看不太懂没关系。我们将里面用到的函数一一解读，然后再回来补充整个流程。\n\n## legacyCreateRootFromDOMContainer\n\n大家现在一定会晕头转向，因为我看的时候也是这样，他的名字和函数名字取的太像了，我们需要给他们独自用自己的方式命名。我会写下Google翻译， 帮助大家取名字。\n\n> Google翻译：legacy Create Root From DOM Container（从DOM容器创建根目录\n\n看了翻译之后是不是焕然大悟？别急，我们先看看源码。\n\n```typescript\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): RootType {\n    // 如果forceHydrate是false，就会调用后面的方法。\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    // 这个循环，是为了清理所有的内容，然后找到我们要渲染的最初的根div。通常我们的html会有一个\n    // <div id=\"root\"></div> 为的就是保障他的纯净。\n    while ((rootSibling = container.lastChild)) {\n      if (__DEV__) {\n        if (\n          !warned &&\n          rootSibling.nodeType === ELEMENT_NODE &&\n          (rootSibling: any).hasAttribute(ROOT_ATTRIBUTE_NAME)\n        ) {\n          warned = true;\n          console.error(\n            'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.',\n          );\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  if (__DEV__) {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      console.warn(\n        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +\n          'will stop working in React v18. Replace the ReactDOM.render() call ' +\n          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',\n      );\n    }\n  }\n\n  return createLegacyRoot(\n    container,\n    shouldHydrate\n      ? {\n          hydrate: true,\n        }\n      : undefined,\n  );\n}\n```\n\n里面又用到两个函数，我为大家召出来。\n\n### shouldHydrateDueToLegacyHeuristic\n\n\n\n```typescript\nfunction getReactRootElementInContainer(container: any) {\n  // 如果没有就返回null\n  if (!container) {\n    return null;\n  }\n  // 内部定义的一个常量\n  // export const DOCUMENT_NODE = 9;看名字就顾名思义了\n  // 如果是内部一个document节点就返回document节点\n  // 感兴趣可以看看MDN的介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/Document\n  // 常量的值也有：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    // 否则返回第一个元素\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  // 将container传入函数，进行判断类型，并得到节点（有可能为空，看注释\n  const rootElement = getReactRootElementInContainer(container);\n  // 强转为布尔值\n  return !!(\n    rootElement &&\n    rootElement.nodeType === ELEMENT_NODE &&\n    // export const ROOT_ATTRIBUTE_NAME = 'data-reactroot'; \n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)\n  );\n}\n```\n\n我们看到一个hasAttribute为\"data-reactroot\"。这是 React 在服务端渲染的时候加上去的。之前有说过Hydrate这个操作是服务端渲染的时候需要的东西。\n\n> Google翻译：getReactRootElementInContainer（获取容器中的React根元素\n>\n> Google翻译：shouldHydrateDueToLegacyHeuristic（应当因传统启发而水合\n>\n> 说人话就是是否需要进行hydrate操作\n\n所以`legacyCreateRootFromDOMContainer`这个函数是保障`container`的纯净。并且返回`createLegacyRoot`函数。ok继续看。\n\n### createLegacyRoot\n\n```typescript\nfunction ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {\n  // 是不是看见老朋友了。_internalRoot。继续看下面的内容，我们来解析一下createRootImpl\n  this._internalRoot = createRootImpl(container, LegacyRoot, options);\n}\n\nexport function createLegacyRoot(\n  container: Container,\n  options?: RootOptions,\n): RootType {\n  // 又是熟悉的操作，返回某个东西\n  return new ReactDOMLegacyRoot(container, options);\n}\n```\n\n### createRootImpl\n\n需要注意的是，我们通篇都是以非`hydrate`来看的，因为我们不是服务端渲染。但是我也会介绍如果有`hydrate`的内容。所以大家看的时候可以稍微带入一点去看，不然很容易走神！\n\n```typescript\n// 创建并返回一个fiberRoot\nfunction createRootImpl(\n  container: Container,\n  tag: RootTag,\n  options: void | RootOptions,\n) {\n  // Tag is either LegacyRoot or Concurrent Root\n  // 判断是否为hydrate模式\n  const hydrate = options != null && options.hydrate === true;\n  const hydrationCallbacks =\n    (options != null && options.hydrationOptions) || null;\n  const mutableSources =\n    (options != null &&\n      options.hydrationOptions != null &&\n      options.hydrationOptions.mutableSources) ||\n    null;\n  const strictModeLevelOverride =\n    options != null && options.unstable_strictModeLevel != null\n      ? options.unstable_strictModeLevel\n      : null;\n  // 创建一个fiberRoot\n  const root = createContainer(\n    container,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    strictModeLevelOverride,\n  );\n  // 给container附加一个内部属性用于指向fiberRoot的current属性对应的rootFiber节点\n  markContainerAsRoot(root.current, container);\n\n  const rootContainerElement =\n    container.nodeType === COMMENT_NODE ? container.parentNode : container;\n  listenToAllSupportedEvents(rootContainerElement);\n\n  if (mutableSources) {\n    for (let i = 0; i < mutableSources.length; i++) {\n      const mutableSource = mutableSources[i];\n      registerMutableSourceForHydration(root, mutableSource);\n    }\n  }\n\n  return root;\n}\n```\n\n为什么我在注释里面会加上「创建一个fiberRoot」，不是一个是创建一个container吗？我们看createContainer里面做了什么。\n\n\n\n### createContainer\n\n```typescript\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  strictModeLevelOverride: null | number,\n): FiberRoot {\n  // 通过FiberRootNode构造函数创建一个fiberRoot实例\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  // 如果有，就补充进这个回调函数\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // 通过createHostRootFiber方法创建fiber tree的根结点，即rootFiber\n  // fiber节点也会像DOM树结构一样形成一个fiber tree单链表树结构\n  // 每个DOM节点或者组件都会生成一个与之对应的fiber节点，在后续的调和(reconciliation)阶段起着至关重要的作用\n  const uninitializedFiber = createHostRootFiber(tag, strictModeLevelOverride);\n  // 创建完rootFiber之后，会将fiberRoot的实例的current属性指向刚创建的rootFiber\n  root.current = uninitializedFiber;\n  // 同时rootFiber的stateNode属性会指向fiberRoot实例，形成相互引用\n  uninitializedFiber.stateNode = root;\n\n  if (enableCache) {\n    const initialCache = new Map();\n    root.pooledCache = initialCache;\n    const initialState = {\n      element: null,\n      cache: initialCache,\n    };\n    uninitializedFiber.memoizedState = initialState;\n  } else {\n    const initialState = {\n      element: null,\n    };\n    uninitializedFiber.memoizedState = initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n\t// 最后将创建的fiberRoot实例返回\n  return root;\n}\n\n// 内部调用createFiberRoot方法返回一个fiberRoot实例\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  strictModeLevelOverride: null | number,\n): OpaqueRoot {\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    strictModeLevelOverride,\n  );\n}\n```\n\n这里也比较简单，只是单纯的调用函数，然后返回。真正的秘密就在这些函数里面，耐心点继续看！黎明就在眼前\n\n\n\n#### FiberRootNode\n\n一个非常恐怖的内容。但是看名字也能猜个大概。还记得我们之前说过。一个fiber节点要存的内容还蛮多的。比如被暂停时的状态，恢复时要做的事情，优先级等等....这里我尽可能的去写注释。帮助大家还要我自己理解。\n\n```typescript\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  //root 节点类型()\n  this.tag = tag;\n  //root根节点，render方法的第二个参数\n  this.containerInfo = containerInfo;\n  //在持久更新中会用到，不支持增量更新的平台，react-dom 是整个应用更新，所以用不到\n  this.pendingChildren = null;\n  //当前应用root节点对应的Fiber对象\n  this.current = null;\n  //缓存\n  this.pingCache = null;\n  //已经完成任务的FiberRoot对象，在commit(提交)阶段只会处理该值对应的任务\n  this.finishedWork = null;\n  //在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout\n  this.timeoutHandle = noTimeout;\n  //顶层 context 对象，只有主动调用renderSubtreeIntoContainer才会生效\n  this.context = null;\n  this.pendingContext = null;\n  // 老朋友了，用来确定第一次渲染的时候是否需要注水\n  this.hydrate = hydrate;\n  //回调节点\n  this.callbackNode = null;\n  //回调属性\n  this.callbackPriority = NoLane;\n  // export const NoLanes: Lanes = 0b0000000000000000000000000000000;\n  /*\n  export function createLaneMap<T>(initial: T): LaneMap<T> {\n    // Intentionally pushing one by one.\n    // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n    const laneMap = [];\n    for (let i = 0; i < TotalLanes; i++) {\n      laneMap.push(initial);\n    }\n    return laneMap;\n  }\n  */\n  //任务时间。由于该字段在未来会重构，当前我们不需要理解他。\n  this.eventTimes = createLaneMap(NoLanes);\n  // 过期时间。函数上面的注释有。export const NoTimestamp = -1;\n  this.expirationTimes = createLaneMap(NoTimestamp);\n\n  // 优先级的初始化\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = 'createRoot()';\n        break;\n      case LegacyRoot:\n        this._debugRootType = 'createLegacyRoot()';\n        break;\n    }\n  }\n}\n```\n\n\n\n#### createHostRootFiber\n\n通篇大论都是在判断mode类型。感兴趣的可以再深挖。这里我就略过了。眼睛已经看花了。。。\n\n```typescript\nexport function createHostRootFiber(\n  tag: RootTag,\n  strictModeLevelOverride: null | number,\n): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n    if (strictModeLevelOverride !== null) {\n      if (strictModeLevelOverride >= 1) {\n        mode |= StrictLegacyMode;\n      }\n      if (enableStrictEffects) {\n        if (strictModeLevelOverride >= 2) {\n          mode |= StrictEffectsMode;\n        }\n      }\n    } else {\n      if (enableStrictEffects && createRootStrictEffectsByDefault) {\n        mode |= StrictLegacyMode | StrictEffectsMode;\n      } else {\n        mode |= StrictLegacyMode;\n      }\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\t// export const HostRoot = 3;\n  return createFiber(HostRoot, null, null, mode);\n}\n```\n\n\n\n#### createFiber\n\n也是包一个壳子。主要还是为了创建FiberNode。\n\n```typescript\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\n```\n\n\n\n#### FiberNode\n\n官方其实已经注释了属性的要素。但是我还是会尽可能的完善。\n\n```typescript\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // 用于标记fiber节点的类型\n  this.tag = tag;\n  // 用于唯一标识一个fiber节点\n  this.key = key;\n  // 节点类型\n  this.elementType = null;\n  // ReactNode的节点类型\n  this.type = null;\n  // FiberNode会通过stateNode绑定一些其他的对象，例如FiberNode对应的Dom、FiberRoot、ReactComponent实例\n  this.stateNode = null;\n\n  // Fiber\n  // 表示父级 FiberNode\n  this.return = null;\n  // 表示第一个子 FiberNode\n  this.child = null;\n  // 表示紧紧相邻的下一个兄弟 FiberNode\n  this.sibling = null;\n  // 下标\n  this.index = 0;\n\n  this.ref = null;\n\n  // 表示新的props\n  this.pendingProps = pendingProps;\n  // 表示经过所有流程处理后的新props\n  this.memoizedProps = null;\n  // 更新队列\n  this.updateQueue = null;\n  // 表示经过所有流程处理后的新state\n  this.memoizedState = null;\n  // 依赖\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  // 标志更新的类型：删除、新增、修改。\n  this.flags = NoFlags;\n  // 子Fiber树的标志更新的类型：删除、新增、修改。\n  this.subtreeFlags = NoFlags;\n  // 需要删除的内容\n  this.deletions = null;\n\n  // 优先级\n  this.lanes = NoLanes;\n  // 子的优先级\n  this.childLanes = NoLanes;\n\n  // 双缓冲：防止数据丢失，提高效率（之后Dom-diff的时候可以直接比较或者使用\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  if (__DEV__) {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n```\n\n\n\n#### initializeUpdateQueue\n\ncreateContainer还有最后一个函数，初始化更新队列。\n\n```typescript\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n```\n\n\n\n# 小结一番\n\n大费周章的做这些阅读，其实回过神来看。就是为了创建`fiberNode`（`FiberRootNode实例`）和`rootFiber`对象。这两兄弟是整个Fiber树构建的起点。\n\n- `fiberNode`（`FiberRootNode实例`） -> 的关联对象是真实 DOM 的容器节点\n- `rootFiber` -> 虚拟 DOM 的根节点\n\n然后再回过神来看，确实。他们各自创建都是为他们所代表的东西而创建，无论是属性或者打入方法。\n\n# 收尾\n\n最后他们都会被`unbatchedUpdates`所收编（看看最上面梦开始的地方「legacyRenderSubtreeIntoContainer」）。最后我们所创建的都会归入到它的手上。一起看看最后一个函数吧。\n\n## 方便阅读\n\n```typescript\nunbatchedUpdates(function () {\n  updateContainer(children, fiberRoot, parentComponent, callback);\n});\n```\n\n\n\n## unbatchedUpdates\n\n```typescript\nfunction unbatchedUpdates(fn, a) {\n  // 这里是对上下文的处理，不必纠结\n  var prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  try {\n    // 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法\n    return fn(a);\n  } finally {\n    // finally 逻辑里是对回调队列的处理，此处不用太关注\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbackQueue();\n    }\n  }\n}\n```\n\n\n\n## updateContainer\n\n```typescript\nfunction updateContainer(element, container, parentComponent, callback) {\n  ......\n\n  // 这是一个 event 相关的入参，此处不必关注\n  var eventTime = requestEventTime();\n\n  ......\n\n  // 这是一个比较关键的入参，lane 表示优先级\n  var lane = requestUpdateLane(current);\n  // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新\n  var update = createUpdate(eventTime, lane); \n\n  // update 的 payload 对应的是一个 React 元素\n  update.payload = {\n    element: element\n  };\n\n  // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n    update.callback = callback;\n  }\n\n  // 将 update 入队\n  enqueueUpdate(current, update);\n  // 调度 fiberRoot \n  scheduleUpdateOnFiber(current, lane, eventTime);\n  // 返回当前节点（fiberRoot）的优先级\n  return lane;\n}\n```\n\n\n\nupdateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：\n\n- 请求当前 Fiber 节点的 lane（优先级）；\n\n- 结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；\n\n- 调度当前节点（rootFiber）。\n\n看到这里的伙伴，谢谢你的耐心。\n\n\n\n# 最后\n\n因为我也是在一边看，一边记录，如果有问题，大家一定要及时提出来。我也会及时更新的。这部分我应该会屡次阅读。毕竟大神写了几年，我不可能几天就看明白的。\n\n\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\n\n\n\n\n\n\n\n\n","slug":"【重识前端】React源码阅读（三）Fiber 初始化","published":1,"updated":"2021-06-24T14:00:06.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra88001clwrd2xc0bzy5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在第一章中，我们解读到ReactDOM.render之后就没有继续了。因为我看了一下设计到了Fiber的一些知识，所以在第二章补充了Fiber的基础知识之后，我将Fiber拆分成四块来讲</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>现在是初始化阶段</p>\n<p>我们现在直接进入Fiber的初始化。Action！</p>\n<h1 id=\"前情回顾\"><a href=\"#前情回顾\" class=\"headerlink\" title=\"前情回顾\"></a>前情回顾</h1><p>回顾一下之前学习JSX的时候，阅读到ReactDOM.render。如果你没有阅读过之前的文章，强烈建议你到我的主页去阅读我之前的博客。下面我们开始。</p>\n<p>ReactDOM.render的源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValidContainer</span>(<span class=\"params\">node: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    node &amp;&amp;</span><br><span class=\"line\">    (node.nodeType === ELEMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_FRAGMENT_NODE ||</span><br><span class=\"line\">      (node.nodeType === COMMENT_NODE &amp;&amp;</span><br><span class=\"line\">        (node: <span class=\"built_in\">any</span>).nodeValue === <span class=\"string\">' react-mount-point-unstable '</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: React$Element&lt;<span class=\"built_in\">any</span>&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?<span class=\"built_in\">Function</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于抛出错误的, 就是判断这个container是不是找得到</span></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainer(container),</span><br><span class=\"line\">    <span class=\"string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer === <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isModernRoot) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'You are calling ReactDOM.render() on a container that was previously '</span> +</span><br><span class=\"line\">          <span class=\"string\">'passed to ReactDOM.createRoot(). This is not supported. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Did you mean to call root.render(element)?'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里面涉及到了fiber的一些架构，开始补坑</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后return的这个函数有点意思。</p>\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><h2 id=\"legacyRenderSubtreeIntoContainer\"><a href=\"#legacyRenderSubtreeIntoContainer\" class=\"headerlink\" title=\"legacyRenderSubtreeIntoContainer\"></a>legacyRenderSubtreeIntoContainer</h2><p>我们首先翻译一下这个函数的名字，进行驼峰拆分：</p>\n<blockquote>\n<p>Google翻译：legacy Render Subtree Into Container（旧版渲染子树放入容器</p>\n</blockquote>\n<p>先别急着翻译。我们先看看源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"params\">parentComponent, children, container, forceHydrate, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// container 对应的是我们传入的真实 DOM 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> root = container._reactRootContainer;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化 fiberRoot 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fiberRoot;</span><br><span class=\"line\">  <span class=\"comment\">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span><br><span class=\"line\">    <span class=\"comment\">// legacyCreateRootFromDOMContainer 主要的功能是创建，并且进行一些“脏判断”。感兴趣的，我在后面也会详细给出</span></span><br><span class=\"line\">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class=\"line\">    <span class=\"comment\">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    <span class=\"comment\">// 进入 unbatchedUpdates 方法</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> _originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        _originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// Update</span></span><br><span class=\"line\"></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>梳理一下整个流程，然后我们再一一看这些函数。</p>\n<p>以下流程是指初始化，也就是<code>if/else</code>判断里面的<code>if</code>。而不是<code>else</code>，<code>else</code>是非首次渲染，走的更新流程，注释里面写了。</p>\n<ol>\n<li>创建<code>container._reactRootContainer</code>对象，并赋值给<code>root</code></li>\n<li>将<code>root</code>上的<code>_inernalRoot</code>赋值给<code>fiberRoot</code></li>\n<li>将<code>legacyRenderSubtreeIntoContainer</code>的一些参数和<code>fiberRoot</code>一起传给<code>updateContainer</code></li>\n<li><code>将updateConatiner</code>作为回调函数传给<code>unbatechedUpdates</code></li>\n</ol>\n<p>ok，现在看不太懂没关系。我们将里面用到的函数一一解读，然后再回来补充整个流程。</p>\n<h2 id=\"legacyCreateRootFromDOMContainer\"><a href=\"#legacyCreateRootFromDOMContainer\" class=\"headerlink\" title=\"legacyCreateRootFromDOMContainer\"></a>legacyCreateRootFromDOMContainer</h2><p>大家现在一定会晕头转向，因为我看的时候也是这样，他的名字和函数名字取的太像了，我们需要给他们独自用自己的方式命名。我会写下Google翻译， 帮助大家取名字。</p>\n<blockquote>\n<p>Google翻译：legacy Create Root From DOM Container（从DOM容器创建根目录</p>\n</blockquote>\n<p>看了翻译之后是不是焕然大悟？别急，我们先看看源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyCreateRootFromDOMContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  forceHydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果forceHydrate是false，就会调用后面的方法。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldHydrate =</span><br><span class=\"line\">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class=\"line\">  <span class=\"comment\">// First clear any existing content.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!shouldHydrate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> warned = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rootSibling;</span><br><span class=\"line\">    <span class=\"comment\">// 这个循环，是为了清理所有的内容，然后找到我们要渲染的最初的根div。通常我们的html会有一个</span></span><br><span class=\"line\">    <span class=\"comment\">// &lt;div id=\"root\"&gt;&lt;/div&gt; 为的就是保障他的纯净。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          !warned &amp;&amp;</span><br><span class=\"line\">          rootSibling.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class=\"line\">          (rootSibling: <span class=\"built_in\">any</span>).hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          warned = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">            <span class=\"string\">'render(): Target node has markup rendered by React, but there '</span> +</span><br><span class=\"line\">              <span class=\"string\">'are unrelated nodes as well. This is most commonly caused by '</span> +</span><br><span class=\"line\">              <span class=\"string\">'white-space inserted around server-rendered markup.'</span>,</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      container.removeChild(rootSibling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123;</span><br><span class=\"line\">      warnedAboutHydrateAPI = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">        <span class=\"string\">'render(): Calling ReactDOM.render() to hydrate server-rendered markup '</span> +</span><br><span class=\"line\">          <span class=\"string\">'will stop working in React v18. Replace the ReactDOM.render() call '</span> +</span><br><span class=\"line\">          <span class=\"string\">'with ReactDOM.hydrate() if you want React to attach to the server HTML.'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createLegacyRoot(</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    shouldHydrate</span><br><span class=\"line\">      ? &#123;</span><br><span class=\"line\">          hydrate: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面又用到两个函数，我为大家召出来。</p>\n<h3 id=\"shouldHydrateDueToLegacyHeuristic\"><a href=\"#shouldHydrateDueToLegacyHeuristic\" class=\"headerlink\" title=\"shouldHydrateDueToLegacyHeuristic\"></a>shouldHydrateDueToLegacyHeuristic</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getReactRootElementInContainer</span>(<span class=\"params\">container: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有就返回null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!container) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 内部定义的一个常量</span></span><br><span class=\"line\">  <span class=\"comment\">// export const DOCUMENT_NODE = 9;看名字就顾名思义了</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是内部一个document节点就返回document节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 感兴趣可以看看MDN的介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/Document</span></span><br><span class=\"line\">  <span class=\"comment\">// 常量的值也有：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.nodeType === DOCUMENT_NODE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> container.documentElement;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则返回第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> container.firstChild;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldHydrateDueToLegacyHeuristic</span>(<span class=\"params\">container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将container传入函数，进行判断类型，并得到节点（有可能为空，看注释</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootElement = getReactRootElementInContainer(container);</span><br><span class=\"line\">  <span class=\"comment\">// 强转为布尔值</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    rootElement &amp;&amp;</span><br><span class=\"line\">    rootElement.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class=\"line\">    <span class=\"comment\">// export const ROOT_ATTRIBUTE_NAME = 'data-reactroot'; </span></span><br><span class=\"line\">    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到一个hasAttribute为”data-reactroot”。这是 React 在服务端渲染的时候加上去的。之前有说过Hydrate这个操作是服务端渲染的时候需要的东西。</p>\n<blockquote>\n<p>Google翻译：getReactRootElementInContainer（获取容器中的React根元素</p>\n<p>Google翻译：shouldHydrateDueToLegacyHeuristic（应当因传统启发而水合</p>\n<p>说人话就是是否需要进行hydrate操作</p>\n</blockquote>\n<p>所以<code>legacyCreateRootFromDOMContainer</code>这个函数是保障<code>container</code>的纯净。并且返回<code>createLegacyRoot</code>函数。ok继续看。</p>\n<h3 id=\"createLegacyRoot\"><a href=\"#createLegacyRoot\" class=\"headerlink\" title=\"createLegacyRoot\"></a>createLegacyRoot</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReactDOMLegacyRoot</span>(<span class=\"params\">container: Container, options: <span class=\"built_in\">void</span> | RootOptions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是不是看见老朋友了。_internalRoot。继续看下面的内容，我们来解析一下createRootImpl</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._internalRoot = createRootImpl(container, LegacyRoot, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLegacyRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options?: RootOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 又是熟悉的操作，返回某个东西</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReactDOMLegacyRoot(container, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"createRootImpl\"><a href=\"#createRootImpl\" class=\"headerlink\" title=\"createRootImpl\"></a>createRootImpl</h3><p>需要注意的是，我们通篇都是以非<code>hydrate</code>来看的，因为我们不是服务端渲染。但是我也会介绍如果有<code>hydrate</code>的内容。所以大家看的时候可以稍微带入一点去看，不然很容易走神！</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并返回一个fiberRoot</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRootImpl</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: <span class=\"built_in\">void</span> | RootOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断是否为hydrate模式</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hydrate = options != <span class=\"literal\">null</span> &amp;&amp; options.hydrate === <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hydrationCallbacks =</span><br><span class=\"line\">    (options != <span class=\"literal\">null</span> &amp;&amp; options.hydrationOptions) || <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutableSources =</span><br><span class=\"line\">    (options != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">      options.hydrationOptions != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">      options.hydrationOptions.mutableSources) ||</span><br><span class=\"line\">    <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> strictModeLevelOverride =</span><br><span class=\"line\">    options != <span class=\"literal\">null</span> &amp;&amp; options.unstable_strictModeLevel != <span class=\"literal\">null</span></span><br><span class=\"line\">      ? options.unstable_strictModeLevel</span><br><span class=\"line\">      : <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个fiberRoot</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = createContainer(</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    hydrationCallbacks,</span><br><span class=\"line\">    strictModeLevelOverride,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"comment\">// 给container附加一个内部属性用于指向fiberRoot的current属性对应的rootFiber节点</span></span><br><span class=\"line\">  markContainerAsRoot(root.current, container);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootContainerElement =</span><br><span class=\"line\">    container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class=\"line\">  listenToAllSupportedEvents(rootContainerElement);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mutableSources) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; mutableSources.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> mutableSource = mutableSources[i];</span><br><span class=\"line\">      registerMutableSourceForHydration(root, mutableSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我在注释里面会加上「创建一个fiberRoot」，不是一个是创建一个container吗？我们看createContainer里面做了什么。</p>\n<h3 id=\"createContainer\"><a href=\"#createContainer\" class=\"headerlink\" title=\"createContainer\"></a>createContainer</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFiberRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: <span class=\"built_in\">any</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrationCallbacks: <span class=\"literal\">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">FiberRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过FiberRootNode构造函数创建一个fiberRoot实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root: FiberRoot = (<span class=\"keyword\">new</span> FiberRootNode(containerInfo, tag, hydrate): <span class=\"built_in\">any</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有，就补充进这个回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSuspenseCallback) &#123;</span><br><span class=\"line\">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cyclic construction. This cheats the type system right now because</span></span><br><span class=\"line\">  <span class=\"comment\">// stateNode is any.</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过createHostRootFiber方法创建fiber tree的根结点，即rootFiber</span></span><br><span class=\"line\">  <span class=\"comment\">// fiber节点也会像DOM树结构一样形成一个fiber tree单链表树结构</span></span><br><span class=\"line\">  <span class=\"comment\">// 每个DOM节点或者组件都会生成一个与之对应的fiber节点，在后续的调和(reconciliation)阶段起着至关重要的作用</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> uninitializedFiber = createHostRootFiber(tag, strictModeLevelOverride);</span><br><span class=\"line\">  <span class=\"comment\">// 创建完rootFiber之后，会将fiberRoot的实例的current属性指向刚创建的rootFiber</span></span><br><span class=\"line\">  root.current = uninitializedFiber;</span><br><span class=\"line\">  <span class=\"comment\">// 同时rootFiber的stateNode属性会指向fiberRoot实例，形成相互引用</span></span><br><span class=\"line\">  uninitializedFiber.stateNode = root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableCache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialCache = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">    root.pooledCache = initialCache;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      element: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      cache: initialCache,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uninitializedFiber.memoizedState = initialState;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      element: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uninitializedFiber.memoizedState = initialState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  initializeUpdateQueue(uninitializedFiber);</span><br><span class=\"line\">\t<span class=\"comment\">// 最后将创建的fiberRoot实例返回</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内部调用createFiberRoot方法返回一个fiberRoot实例</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrationCallbacks: <span class=\"literal\">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">OpaqueRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiberRoot(</span><br><span class=\"line\">    containerInfo,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    hydrationCallbacks,</span><br><span class=\"line\">    strictModeLevelOverride,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里也比较简单，只是单纯的调用函数，然后返回。真正的秘密就在这些函数里面，耐心点继续看！黎明就在眼前</p>\n<h4 id=\"FiberRootNode\"><a href=\"#FiberRootNode\" class=\"headerlink\" title=\"FiberRootNode\"></a>FiberRootNode</h4><p>一个非常恐怖的内容。但是看名字也能猜个大概。还记得我们之前说过。一个fiber节点要存的内容还蛮多的。比如被暂停时的状态，恢复时要做的事情，优先级等等….这里我尽可能的去写注释。帮助大家还要我自己理解。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberRootNode</span>(<span class=\"params\">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//root 节点类型()</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"comment\">//root根节点，render方法的第二个参数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.containerInfo = containerInfo;</span><br><span class=\"line\">  <span class=\"comment\">//在持久更新中会用到，不支持增量更新的平台，react-dom 是整个应用更新，所以用不到</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingChildren = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//当前应用root节点对应的Fiber对象</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.current = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//已经完成任务的FiberRoot对象，在commit(提交)阶段只会处理该值对应的任务</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedWork = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeoutHandle = noTimeout;</span><br><span class=\"line\">  <span class=\"comment\">//顶层 context 对象，只有主动调用renderSubtreeIntoContainer才会生效</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.context = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingContext = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 老朋友了，用来确定第一次渲染的时候是否需要注水</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.hydrate = hydrate;</span><br><span class=\"line\">  <span class=\"comment\">//回调节点</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//回调属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackPriority = NoLane;</span><br><span class=\"line\">  <span class=\"comment\">// export const NoLanes: Lanes = 0b0000000000000000000000000000000;</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  export function createLaneMap&lt;T&gt;(initial: T): LaneMap&lt;T&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // Intentionally pushing one by one.</span></span><br><span class=\"line\"><span class=\"comment\">    // https://v8.dev/blog/elements-kinds#avoid-creating-holes</span></span><br><span class=\"line\"><span class=\"comment\">    const laneMap = [];</span></span><br><span class=\"line\"><span class=\"comment\">    for (let i = 0; i &lt; TotalLanes; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      laneMap.push(initial);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    return laneMap;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"comment\">//任务时间。由于该字段在未来会重构，当前我们不需要理解他。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.eventTimes = createLaneMap(NoLanes);</span><br><span class=\"line\">  <span class=\"comment\">// 过期时间。函数上面的注释有。export const NoTimestamp = -1;</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优先级的初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.suspendedLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingedLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mutableReadLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedLanes = NoLanes;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.entangledLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.entanglements = createLaneMap(NoLanes);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableCache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pooledCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pooledCacheLanes = NoLanes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (supportsHydration) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mutableSourceEagerHydrationData = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSchedulerTracing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.memoizedInteractions = <span class=\"keyword\">new</span> Set();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pendingInteractionMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSuspenseCallback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hydrationCallbacks = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer &amp;&amp; enableProfilerCommitHooks) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.effectDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.passiveEffectDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (tag) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> ConcurrentRoot:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._debugRootType = <span class=\"string\">'createRoot()'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> LegacyRoot:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._debugRootType = <span class=\"string\">'createLegacyRoot()'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"createHostRootFiber\"><a href=\"#createHostRootFiber\" class=\"headerlink\" title=\"createHostRootFiber\"></a>createHostRootFiber</h4><p>通篇大论都是在判断mode类型。感兴趣的可以再深挖。这里我就略过了。眼睛已经看花了。。。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHostRootFiber</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class=\"line\">    mode = ConcurrentMode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strictModeLevelOverride !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strictModeLevelOverride &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (enableStrictEffects) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strictModeLevelOverride &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          mode |= StrictEffectsMode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (enableStrictEffects &amp;&amp; createRootStrictEffectsByDefault) &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode | StrictEffectsMode;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    mode = NoMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Always collect profile timings when DevTools are present.</span></span><br><span class=\"line\">    <span class=\"comment\">// This enables DevTools to start capturing timing at any point–</span></span><br><span class=\"line\">    <span class=\"comment\">// Without some nodes in the tree having empty base times.</span></span><br><span class=\"line\">    mode |= ProfileMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// export const HostRoot = 3;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiber(HostRoot, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"createFiber\"><a href=\"#createFiber\" class=\"headerlink\" title=\"createFiber\"></a>createFiber</h4><p>也是包一个壳子。主要还是为了创建FiberNode。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createFiber = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"literal\">null</span> | <span class=\"built_in\">string</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"FiberNode\"><a href=\"#FiberNode\" class=\"headerlink\" title=\"FiberNode\"></a>FiberNode</h4><p>官方其实已经注释了属性的要素。但是我还是会尽可能的完善。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberNode</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"literal\">null</span> | <span class=\"built_in\">string</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 用于标记fiber节点的类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"comment\">// 用于唯一标识一个fiber节点</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"comment\">// 节点类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elementType = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ReactNode的节点类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.type = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// FiberNode会通过stateNode绑定一些其他的对象，例如FiberNode对应的Dom、FiberRoot、ReactComponent实例</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.stateNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"comment\">// 表示父级 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.return = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示第一个子 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.child = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示紧紧相邻的下一个兄弟 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sibling = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 下标</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 表示新的props</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingProps = pendingProps;</span><br><span class=\"line\">  <span class=\"comment\">// 表示经过所有流程处理后的新props</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedProps = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 更新队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updateQueue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示经过所有流程处理后的新state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedState = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 依赖</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dependencies = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mode = mode;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Effects</span></span><br><span class=\"line\">  <span class=\"comment\">// 标志更新的类型：删除、新增、修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.flags = NoFlags;</span><br><span class=\"line\">  <span class=\"comment\">// 子Fiber树的标志更新的类型：删除、新增、修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subtreeFlags = NoFlags;</span><br><span class=\"line\">  <span class=\"comment\">// 需要删除的内容</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.deletions = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lanes = NoLanes;</span><br><span class=\"line\">  <span class=\"comment\">// 子的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.childLanes = NoLanes;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 双缓冲：防止数据丢失，提高效率（之后Dom-diff的时候可以直接比较或者使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alternate = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Initializing the fields below to smis and later updating them with</span></span><br><span class=\"line\">    <span class=\"comment\">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class=\"line\">    <span class=\"comment\">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class=\"line\">    <span class=\"comment\">// Fortunately this only impacts DEV builds.</span></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class=\"line\">    <span class=\"comment\">// To work around this, initialize the fields below with doubles.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Learn more about this here:</span></span><br><span class=\"line\">    <span class=\"comment\">// https://github.com/facebook/react/issues/14365</span></span><br><span class=\"line\">    <span class=\"comment\">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This isn't directly used but is handy for debugging internals:</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugID = debugCounter++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugSource = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugOwner = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugNeedsRemount = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugHookTypes = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasBadMapPolyfill &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.preventExtensions === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.preventExtensions(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"initializeUpdateQueue\"><a href=\"#initializeUpdateQueue\" class=\"headerlink\" title=\"initializeUpdateQueue\"></a>initializeUpdateQueue</h4><p>createContainer还有最后一个函数，初始化更新队列。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">fiber: Fiber</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: fiber.memoizedState,</span><br><span class=\"line\">    firstBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shared: &#123;</span><br><span class=\"line\">      pending: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      interleaved: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      lanes: NoLanes,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    effects: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  fiber.updateQueue = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"小结一番\"><a href=\"#小结一番\" class=\"headerlink\" title=\"小结一番\"></a>小结一番</h1><p>大费周章的做这些阅读，其实回过神来看。就是为了创建<code>fiberNode</code>（<code>FiberRootNode实例</code>）和<code>rootFiber</code>对象。这两兄弟是整个Fiber树构建的起点。</p>\n<ul>\n<li><code>fiberNode</code>（<code>FiberRootNode实例</code>） -&gt; 的关联对象是真实 DOM 的容器节点</li>\n<li><code>rootFiber</code> -&gt; 虚拟 DOM 的根节点</li>\n</ul>\n<p>然后再回过神来看，确实。他们各自创建都是为他们所代表的东西而创建，无论是属性或者打入方法。</p>\n<h1 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h1><p>最后他们都会被<code>unbatchedUpdates</code>所收编（看看最上面梦开始的地方「legacyRenderSubtreeIntoContainer」）。最后我们所创建的都会归入到它的手上。一起看看最后一个函数吧。</p>\n<h2 id=\"方便阅读\"><a href=\"#方便阅读\" class=\"headerlink\" title=\"方便阅读\"></a>方便阅读</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unbatchedUpdates(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"unbatchedUpdates\"><a href=\"#unbatchedUpdates\" class=\"headerlink\" title=\"unbatchedUpdates\"></a>unbatchedUpdates</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unbatchedUpdates</span>(<span class=\"params\">fn, a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是对上下文的处理，不必纠结</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prevExecutionContext = executionContext;</span><br><span class=\"line\">  executionContext &amp;= ~BatchedContext;</span><br><span class=\"line\">  executionContext |= LegacyUnbatchedContext;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(a);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span><br><span class=\"line\">    executionContext = prevExecutionContext;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executionContext === NoContext) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class=\"line\">      resetRenderTimer();</span><br><span class=\"line\">      flushSyncCallbackQueue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"updateContainer\"><a href=\"#updateContainer\" class=\"headerlink\" title=\"updateContainer\"></a>updateContainer</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainer</span>(<span class=\"params\">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个 event 相关的入参，此处不必关注</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> eventTime = requestEventTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个比较关键的入参，lane 表示优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> lane = requestUpdateLane(current);</span><br><span class=\"line\">  <span class=\"comment\">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> update = createUpdate(eventTime, lane); </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// update 的 payload 对应的是一个 React 元素</span></span><br><span class=\"line\">  update.payload = &#123;</span><br><span class=\"line\">    element: element</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span><br><span class=\"line\">  callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class=\"string\">'function. Instead received: %s.'</span>, callback);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 update 入队</span></span><br><span class=\"line\">  enqueueUpdate(current, update);</span><br><span class=\"line\">  <span class=\"comment\">// 调度 fiberRoot </span></span><br><span class=\"line\">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class=\"line\">  <span class=\"comment\">// 返回当前节点（fiberRoot）的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lane;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>\n<ul>\n<li><p>请求当前 Fiber 节点的 lane（优先级）；</p>\n</li>\n<li><p>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p>\n</li>\n<li><p>调度当前节点（rootFiber）。</p>\n</li>\n</ul>\n<p>看到这里的伙伴，谢谢你的耐心。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>因为我也是在一边看，一边记录，如果有问题，大家一定要及时提出来。我也会及时更新的。这部分我应该会屡次阅读。毕竟大神写了几年，我不可能几天就看明白的。</p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在第一章中，我们解读到ReactDOM.render之后就没有继续了。因为我看了一下设计到了Fiber的一些知识，所以在第二章补充了Fiber的基础知识之后，我将Fiber拆分成四块来讲</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>现在是初始化阶段</p>\n<p>我们现在直接进入Fiber的初始化。Action！</p>\n<h1 id=\"前情回顾\"><a href=\"#前情回顾\" class=\"headerlink\" title=\"前情回顾\"></a>前情回顾</h1><p>回顾一下之前学习JSX的时候，阅读到ReactDOM.render。如果你没有阅读过之前的文章，强烈建议你到我的主页去阅读我之前的博客。下面我们开始。</p>\n<p>ReactDOM.render的源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValidContainer</span>(<span class=\"params\">node: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    node &amp;&amp;</span><br><span class=\"line\">    (node.nodeType === ELEMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_NODE ||</span><br><span class=\"line\">      node.nodeType === DOCUMENT_FRAGMENT_NODE ||</span><br><span class=\"line\">      (node.nodeType === COMMENT_NODE &amp;&amp;</span><br><span class=\"line\">        (node: <span class=\"built_in\">any</span>).nodeValue === <span class=\"string\">' react-mount-point-unstable '</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: React$Element&lt;<span class=\"built_in\">any</span>&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?<span class=\"built_in\">Function</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于抛出错误的, 就是判断这个container是不是找得到</span></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainer(container),</span><br><span class=\"line\">    <span class=\"string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer === <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isModernRoot) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'You are calling ReactDOM.render() on a container that was previously '</span> +</span><br><span class=\"line\">          <span class=\"string\">'passed to ReactDOM.createRoot(). This is not supported. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Did you mean to call root.render(element)?'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里面涉及到了fiber的一些架构，开始补坑</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后return的这个函数有点意思。</p>\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><h2 id=\"legacyRenderSubtreeIntoContainer\"><a href=\"#legacyRenderSubtreeIntoContainer\" class=\"headerlink\" title=\"legacyRenderSubtreeIntoContainer\"></a>legacyRenderSubtreeIntoContainer</h2><p>我们首先翻译一下这个函数的名字，进行驼峰拆分：</p>\n<blockquote>\n<p>Google翻译：legacy Render Subtree Into Container（旧版渲染子树放入容器</p>\n</blockquote>\n<p>先别急着翻译。我们先看看源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"params\">parentComponent, children, container, forceHydrate, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// container 对应的是我们传入的真实 DOM 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> root = container._reactRootContainer;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化 fiberRoot 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fiberRoot;</span><br><span class=\"line\">  <span class=\"comment\">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span><br><span class=\"line\">    <span class=\"comment\">// legacyCreateRootFromDOMContainer 主要的功能是创建，并且进行一些“脏判断”。感兴趣的，我在后面也会详细给出</span></span><br><span class=\"line\">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class=\"line\">    <span class=\"comment\">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    <span class=\"comment\">// 进入 unbatchedUpdates 方法</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> _originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        _originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// Update</span></span><br><span class=\"line\"></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>梳理一下整个流程，然后我们再一一看这些函数。</p>\n<p>以下流程是指初始化，也就是<code>if/else</code>判断里面的<code>if</code>。而不是<code>else</code>，<code>else</code>是非首次渲染，走的更新流程，注释里面写了。</p>\n<ol>\n<li>创建<code>container._reactRootContainer</code>对象，并赋值给<code>root</code></li>\n<li>将<code>root</code>上的<code>_inernalRoot</code>赋值给<code>fiberRoot</code></li>\n<li>将<code>legacyRenderSubtreeIntoContainer</code>的一些参数和<code>fiberRoot</code>一起传给<code>updateContainer</code></li>\n<li><code>将updateConatiner</code>作为回调函数传给<code>unbatechedUpdates</code></li>\n</ol>\n<p>ok，现在看不太懂没关系。我们将里面用到的函数一一解读，然后再回来补充整个流程。</p>\n<h2 id=\"legacyCreateRootFromDOMContainer\"><a href=\"#legacyCreateRootFromDOMContainer\" class=\"headerlink\" title=\"legacyCreateRootFromDOMContainer\"></a>legacyCreateRootFromDOMContainer</h2><p>大家现在一定会晕头转向，因为我看的时候也是这样，他的名字和函数名字取的太像了，我们需要给他们独自用自己的方式命名。我会写下Google翻译， 帮助大家取名字。</p>\n<blockquote>\n<p>Google翻译：legacy Create Root From DOM Container（从DOM容器创建根目录</p>\n</blockquote>\n<p>看了翻译之后是不是焕然大悟？别急，我们先看看源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyCreateRootFromDOMContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  forceHydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果forceHydrate是false，就会调用后面的方法。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldHydrate =</span><br><span class=\"line\">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class=\"line\">  <span class=\"comment\">// First clear any existing content.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!shouldHydrate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> warned = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rootSibling;</span><br><span class=\"line\">    <span class=\"comment\">// 这个循环，是为了清理所有的内容，然后找到我们要渲染的最初的根div。通常我们的html会有一个</span></span><br><span class=\"line\">    <span class=\"comment\">// &lt;div id=\"root\"&gt;&lt;/div&gt; 为的就是保障他的纯净。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          !warned &amp;&amp;</span><br><span class=\"line\">          rootSibling.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class=\"line\">          (rootSibling: <span class=\"built_in\">any</span>).hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          warned = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">            <span class=\"string\">'render(): Target node has markup rendered by React, but there '</span> +</span><br><span class=\"line\">              <span class=\"string\">'are unrelated nodes as well. This is most commonly caused by '</span> +</span><br><span class=\"line\">              <span class=\"string\">'white-space inserted around server-rendered markup.'</span>,</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      container.removeChild(rootSibling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123;</span><br><span class=\"line\">      warnedAboutHydrateAPI = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">        <span class=\"string\">'render(): Calling ReactDOM.render() to hydrate server-rendered markup '</span> +</span><br><span class=\"line\">          <span class=\"string\">'will stop working in React v18. Replace the ReactDOM.render() call '</span> +</span><br><span class=\"line\">          <span class=\"string\">'with ReactDOM.hydrate() if you want React to attach to the server HTML.'</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createLegacyRoot(</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    shouldHydrate</span><br><span class=\"line\">      ? &#123;</span><br><span class=\"line\">          hydrate: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面又用到两个函数，我为大家召出来。</p>\n<h3 id=\"shouldHydrateDueToLegacyHeuristic\"><a href=\"#shouldHydrateDueToLegacyHeuristic\" class=\"headerlink\" title=\"shouldHydrateDueToLegacyHeuristic\"></a>shouldHydrateDueToLegacyHeuristic</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getReactRootElementInContainer</span>(<span class=\"params\">container: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有就返回null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!container) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 内部定义的一个常量</span></span><br><span class=\"line\">  <span class=\"comment\">// export const DOCUMENT_NODE = 9;看名字就顾名思义了</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是内部一个document节点就返回document节点</span></span><br><span class=\"line\">  <span class=\"comment\">// 感兴趣可以看看MDN的介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/Document</span></span><br><span class=\"line\">  <span class=\"comment\">// 常量的值也有：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.nodeType === DOCUMENT_NODE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> container.documentElement;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则返回第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> container.firstChild;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldHydrateDueToLegacyHeuristic</span>(<span class=\"params\">container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将container传入函数，进行判断类型，并得到节点（有可能为空，看注释</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootElement = getReactRootElementInContainer(container);</span><br><span class=\"line\">  <span class=\"comment\">// 强转为布尔值</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(</span><br><span class=\"line\">    rootElement &amp;&amp;</span><br><span class=\"line\">    rootElement.nodeType === ELEMENT_NODE &amp;&amp;</span><br><span class=\"line\">    <span class=\"comment\">// export const ROOT_ATTRIBUTE_NAME = 'data-reactroot'; </span></span><br><span class=\"line\">    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到一个hasAttribute为”data-reactroot”。这是 React 在服务端渲染的时候加上去的。之前有说过Hydrate这个操作是服务端渲染的时候需要的东西。</p>\n<blockquote>\n<p>Google翻译：getReactRootElementInContainer（获取容器中的React根元素</p>\n<p>Google翻译：shouldHydrateDueToLegacyHeuristic（应当因传统启发而水合</p>\n<p>说人话就是是否需要进行hydrate操作</p>\n</blockquote>\n<p>所以<code>legacyCreateRootFromDOMContainer</code>这个函数是保障<code>container</code>的纯净。并且返回<code>createLegacyRoot</code>函数。ok继续看。</p>\n<h3 id=\"createLegacyRoot\"><a href=\"#createLegacyRoot\" class=\"headerlink\" title=\"createLegacyRoot\"></a>createLegacyRoot</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReactDOMLegacyRoot</span>(<span class=\"params\">container: Container, options: <span class=\"built_in\">void</span> | RootOptions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是不是看见老朋友了。_internalRoot。继续看下面的内容，我们来解析一下createRootImpl</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._internalRoot = createRootImpl(container, LegacyRoot, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLegacyRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options?: RootOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 又是熟悉的操作，返回某个东西</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReactDOMLegacyRoot(container, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"createRootImpl\"><a href=\"#createRootImpl\" class=\"headerlink\" title=\"createRootImpl\"></a>createRootImpl</h3><p>需要注意的是，我们通篇都是以非<code>hydrate</code>来看的，因为我们不是服务端渲染。但是我也会介绍如果有<code>hydrate</code>的内容。所以大家看的时候可以稍微带入一点去看，不然很容易走神！</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并返回一个fiberRoot</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRootImpl</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: <span class=\"built_in\">void</span> | RootOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断是否为hydrate模式</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hydrate = options != <span class=\"literal\">null</span> &amp;&amp; options.hydrate === <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hydrationCallbacks =</span><br><span class=\"line\">    (options != <span class=\"literal\">null</span> &amp;&amp; options.hydrationOptions) || <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutableSources =</span><br><span class=\"line\">    (options != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">      options.hydrationOptions != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">      options.hydrationOptions.mutableSources) ||</span><br><span class=\"line\">    <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> strictModeLevelOverride =</span><br><span class=\"line\">    options != <span class=\"literal\">null</span> &amp;&amp; options.unstable_strictModeLevel != <span class=\"literal\">null</span></span><br><span class=\"line\">      ? options.unstable_strictModeLevel</span><br><span class=\"line\">      : <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个fiberRoot</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = createContainer(</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    hydrationCallbacks,</span><br><span class=\"line\">    strictModeLevelOverride,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"comment\">// 给container附加一个内部属性用于指向fiberRoot的current属性对应的rootFiber节点</span></span><br><span class=\"line\">  markContainerAsRoot(root.current, container);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootContainerElement =</span><br><span class=\"line\">    container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class=\"line\">  listenToAllSupportedEvents(rootContainerElement);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mutableSources) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; mutableSources.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> mutableSource = mutableSources[i];</span><br><span class=\"line\">      registerMutableSourceForHydration(root, mutableSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我在注释里面会加上「创建一个fiberRoot」，不是一个是创建一个container吗？我们看createContainer里面做了什么。</p>\n<h3 id=\"createContainer\"><a href=\"#createContainer\" class=\"headerlink\" title=\"createContainer\"></a>createContainer</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFiberRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: <span class=\"built_in\">any</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrationCallbacks: <span class=\"literal\">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">FiberRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过FiberRootNode构造函数创建一个fiberRoot实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root: FiberRoot = (<span class=\"keyword\">new</span> FiberRootNode(containerInfo, tag, hydrate): <span class=\"built_in\">any</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有，就补充进这个回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSuspenseCallback) &#123;</span><br><span class=\"line\">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cyclic construction. This cheats the type system right now because</span></span><br><span class=\"line\">  <span class=\"comment\">// stateNode is any.</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过createHostRootFiber方法创建fiber tree的根结点，即rootFiber</span></span><br><span class=\"line\">  <span class=\"comment\">// fiber节点也会像DOM树结构一样形成一个fiber tree单链表树结构</span></span><br><span class=\"line\">  <span class=\"comment\">// 每个DOM节点或者组件都会生成一个与之对应的fiber节点，在后续的调和(reconciliation)阶段起着至关重要的作用</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> uninitializedFiber = createHostRootFiber(tag, strictModeLevelOverride);</span><br><span class=\"line\">  <span class=\"comment\">// 创建完rootFiber之后，会将fiberRoot的实例的current属性指向刚创建的rootFiber</span></span><br><span class=\"line\">  root.current = uninitializedFiber;</span><br><span class=\"line\">  <span class=\"comment\">// 同时rootFiber的stateNode属性会指向fiberRoot实例，形成相互引用</span></span><br><span class=\"line\">  uninitializedFiber.stateNode = root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableCache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialCache = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">    root.pooledCache = initialCache;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      element: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      cache: initialCache,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uninitializedFiber.memoizedState = initialState;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      element: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uninitializedFiber.memoizedState = initialState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  initializeUpdateQueue(uninitializedFiber);</span><br><span class=\"line\">\t<span class=\"comment\">// 最后将创建的fiberRoot实例返回</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内部调用createFiberRoot方法返回一个fiberRoot实例</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrationCallbacks: <span class=\"literal\">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">OpaqueRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiberRoot(</span><br><span class=\"line\">    containerInfo,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    hydrationCallbacks,</span><br><span class=\"line\">    strictModeLevelOverride,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里也比较简单，只是单纯的调用函数，然后返回。真正的秘密就在这些函数里面，耐心点继续看！黎明就在眼前</p>\n<h4 id=\"FiberRootNode\"><a href=\"#FiberRootNode\" class=\"headerlink\" title=\"FiberRootNode\"></a>FiberRootNode</h4><p>一个非常恐怖的内容。但是看名字也能猜个大概。还记得我们之前说过。一个fiber节点要存的内容还蛮多的。比如被暂停时的状态，恢复时要做的事情，优先级等等….这里我尽可能的去写注释。帮助大家还要我自己理解。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberRootNode</span>(<span class=\"params\">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//root 节点类型()</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"comment\">//root根节点，render方法的第二个参数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.containerInfo = containerInfo;</span><br><span class=\"line\">  <span class=\"comment\">//在持久更新中会用到，不支持增量更新的平台，react-dom 是整个应用更新，所以用不到</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingChildren = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//当前应用root节点对应的Fiber对象</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.current = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//已经完成任务的FiberRoot对象，在commit(提交)阶段只会处理该值对应的任务</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedWork = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeoutHandle = noTimeout;</span><br><span class=\"line\">  <span class=\"comment\">//顶层 context 对象，只有主动调用renderSubtreeIntoContainer才会生效</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.context = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingContext = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 老朋友了，用来确定第一次渲染的时候是否需要注水</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.hydrate = hydrate;</span><br><span class=\"line\">  <span class=\"comment\">//回调节点</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//回调属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackPriority = NoLane;</span><br><span class=\"line\">  <span class=\"comment\">// export const NoLanes: Lanes = 0b0000000000000000000000000000000;</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  export function createLaneMap&lt;T&gt;(initial: T): LaneMap&lt;T&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // Intentionally pushing one by one.</span></span><br><span class=\"line\"><span class=\"comment\">    // https://v8.dev/blog/elements-kinds#avoid-creating-holes</span></span><br><span class=\"line\"><span class=\"comment\">    const laneMap = [];</span></span><br><span class=\"line\"><span class=\"comment\">    for (let i = 0; i &lt; TotalLanes; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      laneMap.push(initial);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    return laneMap;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"comment\">//任务时间。由于该字段在未来会重构，当前我们不需要理解他。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.eventTimes = createLaneMap(NoLanes);</span><br><span class=\"line\">  <span class=\"comment\">// 过期时间。函数上面的注释有。export const NoTimestamp = -1;</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优先级的初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.suspendedLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingedLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mutableReadLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedLanes = NoLanes;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.entangledLanes = NoLanes;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.entanglements = createLaneMap(NoLanes);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableCache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pooledCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pooledCacheLanes = NoLanes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (supportsHydration) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mutableSourceEagerHydrationData = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSchedulerTracing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.memoizedInteractions = <span class=\"keyword\">new</span> Set();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pendingInteractionMap = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSuspenseCallback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hydrationCallbacks = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer &amp;&amp; enableProfilerCommitHooks) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.effectDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.passiveEffectDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (tag) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> ConcurrentRoot:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._debugRootType = <span class=\"string\">'createRoot()'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> LegacyRoot:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._debugRootType = <span class=\"string\">'createLegacyRoot()'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"createHostRootFiber\"><a href=\"#createHostRootFiber\" class=\"headerlink\" title=\"createHostRootFiber\"></a>createHostRootFiber</h4><p>通篇大论都是在判断mode类型。感兴趣的可以再深挖。这里我就略过了。眼睛已经看花了。。。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHostRootFiber</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  strictModeLevelOverride: <span class=\"literal\">null</span> | <span class=\"built_in\">number</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class=\"line\">    mode = ConcurrentMode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strictModeLevelOverride !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strictModeLevelOverride &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (enableStrictEffects) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strictModeLevelOverride &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          mode |= StrictEffectsMode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (enableStrictEffects &amp;&amp; createRootStrictEffectsByDefault) &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode | StrictEffectsMode;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mode |= StrictLegacyMode;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    mode = NoMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Always collect profile timings when DevTools are present.</span></span><br><span class=\"line\">    <span class=\"comment\">// This enables DevTools to start capturing timing at any point–</span></span><br><span class=\"line\">    <span class=\"comment\">// Without some nodes in the tree having empty base times.</span></span><br><span class=\"line\">    mode |= ProfileMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// export const HostRoot = 3;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiber(HostRoot, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"createFiber\"><a href=\"#createFiber\" class=\"headerlink\" title=\"createFiber\"></a>createFiber</h4><p>也是包一个壳子。主要还是为了创建FiberNode。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createFiber = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"literal\">null</span> | <span class=\"built_in\">string</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"FiberNode\"><a href=\"#FiberNode\" class=\"headerlink\" title=\"FiberNode\"></a>FiberNode</h4><p>官方其实已经注释了属性的要素。但是我还是会尽可能的完善。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberNode</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"literal\">null</span> | <span class=\"built_in\">string</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"comment\">// 用于标记fiber节点的类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"comment\">// 用于唯一标识一个fiber节点</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"comment\">// 节点类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elementType = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ReactNode的节点类型</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.type = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// FiberNode会通过stateNode绑定一些其他的对象，例如FiberNode对应的Dom、FiberRoot、ReactComponent实例</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.stateNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"comment\">// 表示父级 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.return = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示第一个子 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.child = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示紧紧相邻的下一个兄弟 FiberNode</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sibling = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 下标</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 表示新的props</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingProps = pendingProps;</span><br><span class=\"line\">  <span class=\"comment\">// 表示经过所有流程处理后的新props</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedProps = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 更新队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updateQueue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 表示经过所有流程处理后的新state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedState = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 依赖</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dependencies = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mode = mode;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Effects</span></span><br><span class=\"line\">  <span class=\"comment\">// 标志更新的类型：删除、新增、修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.flags = NoFlags;</span><br><span class=\"line\">  <span class=\"comment\">// 子Fiber树的标志更新的类型：删除、新增、修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subtreeFlags = NoFlags;</span><br><span class=\"line\">  <span class=\"comment\">// 需要删除的内容</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.deletions = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lanes = NoLanes;</span><br><span class=\"line\">  <span class=\"comment\">// 子的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.childLanes = NoLanes;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 双缓冲：防止数据丢失，提高效率（之后Dom-diff的时候可以直接比较或者使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alternate = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Initializing the fields below to smis and later updating them with</span></span><br><span class=\"line\">    <span class=\"comment\">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class=\"line\">    <span class=\"comment\">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class=\"line\">    <span class=\"comment\">// Fortunately this only impacts DEV builds.</span></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class=\"line\">    <span class=\"comment\">// To work around this, initialize the fields below with doubles.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Learn more about this here:</span></span><br><span class=\"line\">    <span class=\"comment\">// https://github.com/facebook/react/issues/14365</span></span><br><span class=\"line\">    <span class=\"comment\">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This isn't directly used but is handy for debugging internals:</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugID = debugCounter++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugSource = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugOwner = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugNeedsRemount = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._debugHookTypes = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasBadMapPolyfill &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.preventExtensions === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.preventExtensions(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"initializeUpdateQueue\"><a href=\"#initializeUpdateQueue\" class=\"headerlink\" title=\"initializeUpdateQueue\"></a>initializeUpdateQueue</h4><p>createContainer还有最后一个函数，初始化更新队列。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">fiber: Fiber</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: fiber.memoizedState,</span><br><span class=\"line\">    firstBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shared: &#123;</span><br><span class=\"line\">      pending: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      interleaved: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      lanes: NoLanes,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    effects: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  fiber.updateQueue = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"小结一番\"><a href=\"#小结一番\" class=\"headerlink\" title=\"小结一番\"></a>小结一番</h1><p>大费周章的做这些阅读，其实回过神来看。就是为了创建<code>fiberNode</code>（<code>FiberRootNode实例</code>）和<code>rootFiber</code>对象。这两兄弟是整个Fiber树构建的起点。</p>\n<ul>\n<li><code>fiberNode</code>（<code>FiberRootNode实例</code>） -&gt; 的关联对象是真实 DOM 的容器节点</li>\n<li><code>rootFiber</code> -&gt; 虚拟 DOM 的根节点</li>\n</ul>\n<p>然后再回过神来看，确实。他们各自创建都是为他们所代表的东西而创建，无论是属性或者打入方法。</p>\n<h1 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h1><p>最后他们都会被<code>unbatchedUpdates</code>所收编（看看最上面梦开始的地方「legacyRenderSubtreeIntoContainer」）。最后我们所创建的都会归入到它的手上。一起看看最后一个函数吧。</p>\n<h2 id=\"方便阅读\"><a href=\"#方便阅读\" class=\"headerlink\" title=\"方便阅读\"></a>方便阅读</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unbatchedUpdates(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"unbatchedUpdates\"><a href=\"#unbatchedUpdates\" class=\"headerlink\" title=\"unbatchedUpdates\"></a>unbatchedUpdates</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unbatchedUpdates</span>(<span class=\"params\">fn, a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是对上下文的处理，不必纠结</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prevExecutionContext = executionContext;</span><br><span class=\"line\">  executionContext &amp;= ~BatchedContext;</span><br><span class=\"line\">  executionContext |= LegacyUnbatchedContext;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(a);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span><br><span class=\"line\">    executionContext = prevExecutionContext;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executionContext === NoContext) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class=\"line\">      resetRenderTimer();</span><br><span class=\"line\">      flushSyncCallbackQueue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"updateContainer\"><a href=\"#updateContainer\" class=\"headerlink\" title=\"updateContainer\"></a>updateContainer</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainer</span>(<span class=\"params\">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个 event 相关的入参，此处不必关注</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> eventTime = requestEventTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个比较关键的入参，lane 表示优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> lane = requestUpdateLane(current);</span><br><span class=\"line\">  <span class=\"comment\">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> update = createUpdate(eventTime, lane); </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// update 的 payload 对应的是一个 React 元素</span></span><br><span class=\"line\">  update.payload = &#123;</span><br><span class=\"line\">    element: element</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span><br><span class=\"line\">  callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class=\"string\">'function. Instead received: %s.'</span>, callback);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 update 入队</span></span><br><span class=\"line\">  enqueueUpdate(current, update);</span><br><span class=\"line\">  <span class=\"comment\">// 调度 fiberRoot </span></span><br><span class=\"line\">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class=\"line\">  <span class=\"comment\">// 返回当前节点（fiberRoot）的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lane;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>\n<ul>\n<li><p>请求当前 Fiber 节点的 lane（优先级）；</p>\n</li>\n<li><p>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p>\n</li>\n<li><p>调度当前节点（rootFiber）。</p>\n</li>\n</ul>\n<p>看到这里的伙伴，谢谢你的耐心。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>因为我也是在一边看，一边记录，如果有问题，大家一定要及时提出来。我也会及时更新的。这部分我应该会屡次阅读。毕竟大神写了几年，我不可能几天就看明白的。</p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n"},{"title":"【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机","date":"2021-04-05T02:08:31.000Z","cover":"/image/cover/react.png","_content":"\n# 前言\n\n上一篇挖的坑几乎都是`Fiber`有关的，本来想先学习一下`Hooks`，发现也和`FIber`密切相关了，决定先搞定一下`Fiber`。不了解的可以查看我的主页。`Fiber`架构`React`写了几年时间，一篇文章肯定是讲不完的，我决定分为四个阶段介绍。\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\n看了网上的文章大都浅尝辄止，就写了一些简单的介绍，我也照猫画虎然后去面试，被打回了。比如几个问题，如果你能答的不错说明你的`Fiber`知识还不错。\n\n1. 都说`Fiber`是有优先级，有打断任务的机制，但是`JavaScript`他是单线程的，在计算的时候如何打断呢？\n2. 数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？\n3. 为什么有的时候`render`会执行多次？\n4. `Fiber`架构一定是异步的吗？\n5. `Fiber`树和虚拟DOM树有什么区别？\n\n\n\n这些都是我面试遇到的问题...太深了，网上的文章几乎没有提到，所以我决定自己来学习一下，然后分享并记录我的学习过程。如果有错误的地方，还请一起讨论。有任何问题都可以添加我的v：「DerrickTel」    和我讨论。\n\n麻烦写一下备注，谢谢。\n\n# 前置小知识\n\n## 进程和线程\n\n多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n因为不是核心，所以我这里给一个简单的例子帮助理解：\n\n进程是火车头，线程是火车的车厢。没有火车头，车厢无法自己运行。一个火车头可以拉多个车厢。\n\n## 单线程的JavaScript和多线程的浏览器\n\n大家第一次接触到JavaScript听到最多的恐怕就是JavaScript 是单线程的，更有甚者会知道为什么JavaScript要是单线程的。\n\n> 试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。这就决定了JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。\n\n所以JavaScript是单线程的。那为什么浏览器又是多线程的？因为在早期的单线程浏览器会碰到几个问题：\n\n1. 不稳定\n   1. 比如一个Web视频或Web游戏，这些可能都需要强大的插件来帮助解决问题。但是插件最容易出现BUG，一个BUG崩溃了，那就会导致整个浏览器的崩溃\n2. 不流畅\n   1. 就一个线程，如果被一个任务占据了大量的事情，甚至是死循环，也会让浏览器处于停滞状态\n3. 不安全\n   1. 如果单线程的插线在运行时，是一个病毒或者恶意程序，你的电脑将面临巨大的风险\n\n所以浏览器就需要多线程来处理这些遗留问题，并且可以保证速度的同时保证安全。比如网络线程，可以把数据都弄清楚了，等待JavaScript来提取，就好像洗衣服，我放洗衣店洗，我吃完饭来拿就好了。不需要我自己手动的去洗。但是也会带来几个问题\n\n1. 更多的系统资源占用。\n2. 更复杂的浏览器架构。（不是本文重点\n\n> 单线程的JavaScript有自己的运行机制「事件循环」。可以在我的主业查看文章进行阅读。\n\n\n\n# React的卡顿\n\n在`React15`及之前的版本。都是进行两颗树的比较，然后找到需要更新的地方，最后更新到真实的DOM树上。而这个算法是在数据结构中的两棵树的比较中优化而来。也从原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)。我们称之为「 Stack Reconciler 」。在很长的一段时间风光无限。\n\n但是，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 Stack Reconciler 也渐渐在体验方面显出疲态。\n\n为什么会出现乏力的感觉？\n\n因为从本质上来说，栈调和机制下的 Diff 算法，其实是树的深度优先遍历的过程。而树的深度优先遍历，总是和递归脱不了关系。\n\n递归就是除非碰到了他的返回条件，否则，将无线的循环下去。这个问题最致命的就是，无法停止。加入足够大，将会出现「页面卡死」。\n\n# FIber的出现\n\n首先Fiber的翻译是：「纤维」。\n\n维基百科：「**纤维**（英语：fiber）是指由连续或不连续的细丝组成的物质。」\n\n简单来说就是非常的细的东西，也就是对整个渲染过程进行纤维级别的控制。\n\n## Fiber如何解决问题\n\nFiber是对整个React的调度算法的重写，又是一个React自创的数据结构，里面保存了一个虚拟DOM的节点，也保存了需要更新的状态，以及副作用。\n\n我们知道，用户在使用的时候最怕的是什么？没反应，也就是「页面卡死」。而我们玩游戏觉得卡是因为他一秒钟的帧数少于60帧，所以我们觉得卡，而浏览器的页面也一样。React只需要一秒钟能够保证60帧的流畅出现就可以了，用户就不觉得「页面卡死」了。\n\n所以Fiber的任务肯定是，在保证至少60帧每秒的情况下，才去做别的事情。\n\n## Fiber架构核心：“可中断”“可恢复”“优先级”\n\nFiber所做的这一系列操作都是为了用户的丝滑体验。\n\n想象一下，打断现在非常冗长的计算，通过优先级的判断，优先渲染页面或者别的什么。然后再恢复冗长的计算。是不是脑中基本有一个模糊的概念了？\n\n在进一步，React其实为很多任务进行了切片，这些每一个细小的片，我们可以成为「Fiber」。在执行完一个「Fiber」的时候，会检查队列中最高优先级的任务。如果有比目前的这个优先级高的，先把数据和状态保存在「Fiber」节点上，然后进行那个「更高优先级任务」。之后再检查，如果没有就恢复任务。\n\n在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：\n\n- componentWillMount\n\n- componentWillUpdate\n\n- shouldComponentUpdate\n\n- componentWillReceiveProps\n\n其中 shouldComponentUpdate 的作用是通过返回 true 或者 false，来帮助我们判断更新的必要性，一般在这个函数中不会进行副作用操作，因此风险不大。\n\n而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”。\n\n\n\n# 思考\n\n之前的问题，现在是否有的已经有答案了？有的还没有？欢迎讨论\n\n1. 都说`Fiber`是有优先级，有打断任务的机制，但是`JavaScript`他是单线程的，在计算的时候如何打断呢？\n2. 数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？\n3. 为什么有的时候`render`会执行多次？\n4. `Fiber`架构一定是异步的吗？\n5. `Fiber`树和虚拟DOM树有什么区别？\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\n\n\n\n\n\n\n\n\n","source":"_posts/【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机.md","raw":"---\ntitle: 【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机\ndate: 2021-04-05 10:08:31\ntags: [react]\ncategory: [重拾前端]\ncover: /image/cover/react.png\n---\n\n# 前言\n\n上一篇挖的坑几乎都是`Fiber`有关的，本来想先学习一下`Hooks`，发现也和`FIber`密切相关了，决定先搞定一下`Fiber`。不了解的可以查看我的主页。`Fiber`架构`React`写了几年时间，一篇文章肯定是讲不完的，我决定分为四个阶段介绍。\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\n看了网上的文章大都浅尝辄止，就写了一些简单的介绍，我也照猫画虎然后去面试，被打回了。比如几个问题，如果你能答的不错说明你的`Fiber`知识还不错。\n\n1. 都说`Fiber`是有优先级，有打断任务的机制，但是`JavaScript`他是单线程的，在计算的时候如何打断呢？\n2. 数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？\n3. 为什么有的时候`render`会执行多次？\n4. `Fiber`架构一定是异步的吗？\n5. `Fiber`树和虚拟DOM树有什么区别？\n\n\n\n这些都是我面试遇到的问题...太深了，网上的文章几乎没有提到，所以我决定自己来学习一下，然后分享并记录我的学习过程。如果有错误的地方，还请一起讨论。有任何问题都可以添加我的v：「DerrickTel」    和我讨论。\n\n麻烦写一下备注，谢谢。\n\n# 前置小知识\n\n## 进程和线程\n\n多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n因为不是核心，所以我这里给一个简单的例子帮助理解：\n\n进程是火车头，线程是火车的车厢。没有火车头，车厢无法自己运行。一个火车头可以拉多个车厢。\n\n## 单线程的JavaScript和多线程的浏览器\n\n大家第一次接触到JavaScript听到最多的恐怕就是JavaScript 是单线程的，更有甚者会知道为什么JavaScript要是单线程的。\n\n> 试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。这就决定了JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。\n\n所以JavaScript是单线程的。那为什么浏览器又是多线程的？因为在早期的单线程浏览器会碰到几个问题：\n\n1. 不稳定\n   1. 比如一个Web视频或Web游戏，这些可能都需要强大的插件来帮助解决问题。但是插件最容易出现BUG，一个BUG崩溃了，那就会导致整个浏览器的崩溃\n2. 不流畅\n   1. 就一个线程，如果被一个任务占据了大量的事情，甚至是死循环，也会让浏览器处于停滞状态\n3. 不安全\n   1. 如果单线程的插线在运行时，是一个病毒或者恶意程序，你的电脑将面临巨大的风险\n\n所以浏览器就需要多线程来处理这些遗留问题，并且可以保证速度的同时保证安全。比如网络线程，可以把数据都弄清楚了，等待JavaScript来提取，就好像洗衣服，我放洗衣店洗，我吃完饭来拿就好了。不需要我自己手动的去洗。但是也会带来几个问题\n\n1. 更多的系统资源占用。\n2. 更复杂的浏览器架构。（不是本文重点\n\n> 单线程的JavaScript有自己的运行机制「事件循环」。可以在我的主业查看文章进行阅读。\n\n\n\n# React的卡顿\n\n在`React15`及之前的版本。都是进行两颗树的比较，然后找到需要更新的地方，最后更新到真实的DOM树上。而这个算法是在数据结构中的两棵树的比较中优化而来。也从原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)。我们称之为「 Stack Reconciler 」。在很长的一段时间风光无限。\n\n但是，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 Stack Reconciler 也渐渐在体验方面显出疲态。\n\n为什么会出现乏力的感觉？\n\n因为从本质上来说，栈调和机制下的 Diff 算法，其实是树的深度优先遍历的过程。而树的深度优先遍历，总是和递归脱不了关系。\n\n递归就是除非碰到了他的返回条件，否则，将无线的循环下去。这个问题最致命的就是，无法停止。加入足够大，将会出现「页面卡死」。\n\n# FIber的出现\n\n首先Fiber的翻译是：「纤维」。\n\n维基百科：「**纤维**（英语：fiber）是指由连续或不连续的细丝组成的物质。」\n\n简单来说就是非常的细的东西，也就是对整个渲染过程进行纤维级别的控制。\n\n## Fiber如何解决问题\n\nFiber是对整个React的调度算法的重写，又是一个React自创的数据结构，里面保存了一个虚拟DOM的节点，也保存了需要更新的状态，以及副作用。\n\n我们知道，用户在使用的时候最怕的是什么？没反应，也就是「页面卡死」。而我们玩游戏觉得卡是因为他一秒钟的帧数少于60帧，所以我们觉得卡，而浏览器的页面也一样。React只需要一秒钟能够保证60帧的流畅出现就可以了，用户就不觉得「页面卡死」了。\n\n所以Fiber的任务肯定是，在保证至少60帧每秒的情况下，才去做别的事情。\n\n## Fiber架构核心：“可中断”“可恢复”“优先级”\n\nFiber所做的这一系列操作都是为了用户的丝滑体验。\n\n想象一下，打断现在非常冗长的计算，通过优先级的判断，优先渲染页面或者别的什么。然后再恢复冗长的计算。是不是脑中基本有一个模糊的概念了？\n\n在进一步，React其实为很多任务进行了切片，这些每一个细小的片，我们可以成为「Fiber」。在执行完一个「Fiber」的时候，会检查队列中最高优先级的任务。如果有比目前的这个优先级高的，先把数据和状态保存在「Fiber」节点上，然后进行那个「更高优先级任务」。之后再检查，如果没有就恢复任务。\n\n在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：\n\n- componentWillMount\n\n- componentWillUpdate\n\n- shouldComponentUpdate\n\n- componentWillReceiveProps\n\n其中 shouldComponentUpdate 的作用是通过返回 true 或者 false，来帮助我们判断更新的必要性，一般在这个函数中不会进行副作用操作，因此风险不大。\n\n而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”。\n\n\n\n# 思考\n\n之前的问题，现在是否有的已经有答案了？有的还没有？欢迎讨论\n\n1. 都说`Fiber`是有优先级，有打断任务的机制，但是`JavaScript`他是单线程的，在计算的时候如何打断呢？\n2. 数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？\n3. 为什么有的时候`render`会执行多次？\n4. `Fiber`架构一定是异步的吗？\n5. `Fiber`树和虚拟DOM树有什么区别？\n\n# 索引\n\nhttps://zh-hans.reactjs.org/docs\n\n\n\n\n\n\n\n\n\n","slug":"【重识前端】React源码阅读（二）2000字告诉你Fiber设计动机","published":1,"updated":"2021-06-24T14:00:06.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8c001elwrd296whmen","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上一篇挖的坑几乎都是<code>Fiber</code>有关的，本来想先学习一下<code>Hooks</code>，发现也和<code>FIber</code>密切相关了，决定先搞定一下<code>Fiber</code>。不了解的可以查看我的主页。<code>Fiber</code>架构<code>React</code>写了几年时间，一篇文章肯定是讲不完的，我决定分为四个阶段介绍。</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>看了网上的文章大都浅尝辄止，就写了一些简单的介绍，我也照猫画虎然后去面试，被打回了。比如几个问题，如果你能答的不错说明你的<code>Fiber</code>知识还不错。</p>\n<ol>\n<li>都说<code>Fiber</code>是有优先级，有打断任务的机制，但是<code>JavaScript</code>他是单线程的，在计算的时候如何打断呢？</li>\n<li>数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？</li>\n<li>为什么有的时候<code>render</code>会执行多次？</li>\n<li><code>Fiber</code>架构一定是异步的吗？</li>\n<li><code>Fiber</code>树和虚拟DOM树有什么区别？</li>\n</ol>\n<p>这些都是我面试遇到的问题…太深了，网上的文章几乎没有提到，所以我决定自己来学习一下，然后分享并记录我的学习过程。如果有错误的地方，还请一起讨论。有任何问题都可以添加我的v：「DerrickTel」    和我讨论。</p>\n<p>麻烦写一下备注，谢谢。</p>\n<h1 id=\"前置小知识\"><a href=\"#前置小知识\" class=\"headerlink\" title=\"前置小知识\"></a>前置小知识</h1><h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？</p>\n<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p>\n<p>因为不是核心，所以我这里给一个简单的例子帮助理解：</p>\n<p>进程是火车头，线程是火车的车厢。没有火车头，车厢无法自己运行。一个火车头可以拉多个车厢。</p>\n<h2 id=\"单线程的JavaScript和多线程的浏览器\"><a href=\"#单线程的JavaScript和多线程的浏览器\" class=\"headerlink\" title=\"单线程的JavaScript和多线程的浏览器\"></a>单线程的JavaScript和多线程的浏览器</h2><p>大家第一次接触到JavaScript听到最多的恐怕就是JavaScript 是单线程的，更有甚者会知道为什么JavaScript要是单线程的。</p>\n<blockquote>\n<p>试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。这就决定了JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。</p>\n</blockquote>\n<p>所以JavaScript是单线程的。那为什么浏览器又是多线程的？因为在早期的单线程浏览器会碰到几个问题：</p>\n<ol>\n<li>不稳定<ol>\n<li>比如一个Web视频或Web游戏，这些可能都需要强大的插件来帮助解决问题。但是插件最容易出现BUG，一个BUG崩溃了，那就会导致整个浏览器的崩溃</li>\n</ol>\n</li>\n<li>不流畅<ol>\n<li>就一个线程，如果被一个任务占据了大量的事情，甚至是死循环，也会让浏览器处于停滞状态</li>\n</ol>\n</li>\n<li>不安全<ol>\n<li>如果单线程的插线在运行时，是一个病毒或者恶意程序，你的电脑将面临巨大的风险</li>\n</ol>\n</li>\n</ol>\n<p>所以浏览器就需要多线程来处理这些遗留问题，并且可以保证速度的同时保证安全。比如网络线程，可以把数据都弄清楚了，等待JavaScript来提取，就好像洗衣服，我放洗衣店洗，我吃完饭来拿就好了。不需要我自己手动的去洗。但是也会带来几个问题</p>\n<ol>\n<li>更多的系统资源占用。</li>\n<li>更复杂的浏览器架构。（不是本文重点</li>\n</ol>\n<blockquote>\n<p>单线程的JavaScript有自己的运行机制「事件循环」。可以在我的主业查看文章进行阅读。</p>\n</blockquote>\n<h1 id=\"React的卡顿\"><a href=\"#React的卡顿\" class=\"headerlink\" title=\"React的卡顿\"></a>React的卡顿</h1><p>在<code>React15</code>及之前的版本。都是进行两颗树的比较，然后找到需要更新的地方，最后更新到真实的DOM树上。而这个算法是在数据结构中的两棵树的比较中优化而来。也从原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)。我们称之为「 Stack Reconciler 」。在很长的一段时间风光无限。</p>\n<p>但是，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 Stack Reconciler 也渐渐在体验方面显出疲态。</p>\n<p>为什么会出现乏力的感觉？</p>\n<p>因为从本质上来说，栈调和机制下的 Diff 算法，其实是树的深度优先遍历的过程。而树的深度优先遍历，总是和递归脱不了关系。</p>\n<p>递归就是除非碰到了他的返回条件，否则，将无线的循环下去。这个问题最致命的就是，无法停止。加入足够大，将会出现「页面卡死」。</p>\n<h1 id=\"FIber的出现\"><a href=\"#FIber的出现\" class=\"headerlink\" title=\"FIber的出现\"></a>FIber的出现</h1><p>首先Fiber的翻译是：「纤维」。</p>\n<p>维基百科：「<strong>纤维</strong>（英语：fiber）是指由连续或不连续的细丝组成的物质。」</p>\n<p>简单来说就是非常的细的东西，也就是对整个渲染过程进行纤维级别的控制。</p>\n<h2 id=\"Fiber如何解决问题\"><a href=\"#Fiber如何解决问题\" class=\"headerlink\" title=\"Fiber如何解决问题\"></a>Fiber如何解决问题</h2><p>Fiber是对整个React的调度算法的重写，又是一个React自创的数据结构，里面保存了一个虚拟DOM的节点，也保存了需要更新的状态，以及副作用。</p>\n<p>我们知道，用户在使用的时候最怕的是什么？没反应，也就是「页面卡死」。而我们玩游戏觉得卡是因为他一秒钟的帧数少于60帧，所以我们觉得卡，而浏览器的页面也一样。React只需要一秒钟能够保证60帧的流畅出现就可以了，用户就不觉得「页面卡死」了。</p>\n<p>所以Fiber的任务肯定是，在保证至少60帧每秒的情况下，才去做别的事情。</p>\n<h2 id=\"Fiber架构核心：“可中断”“可恢复”“优先级”\"><a href=\"#Fiber架构核心：“可中断”“可恢复”“优先级”\" class=\"headerlink\" title=\"Fiber架构核心：“可中断”“可恢复”“优先级”\"></a>Fiber架构核心：“可中断”“可恢复”“优先级”</h2><p>Fiber所做的这一系列操作都是为了用户的丝滑体验。</p>\n<p>想象一下，打断现在非常冗长的计算，通过优先级的判断，优先渲染页面或者别的什么。然后再恢复冗长的计算。是不是脑中基本有一个模糊的概念了？</p>\n<p>在进一步，React其实为很多任务进行了切片，这些每一个细小的片，我们可以成为「Fiber」。在执行完一个「Fiber」的时候，会检查队列中最高优先级的任务。如果有比目前的这个优先级高的，先把数据和状态保存在「Fiber」节点上，然后进行那个「更高优先级任务」。之后再检查，如果没有就恢复任务。</p>\n<p>在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：</p>\n<ul>\n<li><p>componentWillMount</p>\n</li>\n<li><p>componentWillUpdate</p>\n</li>\n<li><p>shouldComponentUpdate</p>\n</li>\n<li><p>componentWillReceiveProps</p>\n</li>\n</ul>\n<p>其中 shouldComponentUpdate 的作用是通过返回 true 或者 false，来帮助我们判断更新的必要性，一般在这个函数中不会进行副作用操作，因此风险不大。</p>\n<p>而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”。</p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>之前的问题，现在是否有的已经有答案了？有的还没有？欢迎讨论</p>\n<ol>\n<li>都说<code>Fiber</code>是有优先级，有打断任务的机制，但是<code>JavaScript</code>他是单线程的，在计算的时候如何打断呢？</li>\n<li>数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？</li>\n<li>为什么有的时候<code>render</code>会执行多次？</li>\n<li><code>Fiber</code>架构一定是异步的吗？</li>\n<li><code>Fiber</code>树和虚拟DOM树有什么区别？</li>\n</ol>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上一篇挖的坑几乎都是<code>Fiber</code>有关的，本来想先学习一下<code>Hooks</code>，发现也和<code>FIber</code>密切相关了，决定先搞定一下<code>Fiber</code>。不了解的可以查看我的主页。<code>Fiber</code>架构<code>React</code>写了几年时间，一篇文章肯定是讲不完的，我决定分为四个阶段介绍。</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>看了网上的文章大都浅尝辄止，就写了一些简单的介绍，我也照猫画虎然后去面试，被打回了。比如几个问题，如果你能答的不错说明你的<code>Fiber</code>知识还不错。</p>\n<ol>\n<li>都说<code>Fiber</code>是有优先级，有打断任务的机制，但是<code>JavaScript</code>他是单线程的，在计算的时候如何打断呢？</li>\n<li>数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？</li>\n<li>为什么有的时候<code>render</code>会执行多次？</li>\n<li><code>Fiber</code>架构一定是异步的吗？</li>\n<li><code>Fiber</code>树和虚拟DOM树有什么区别？</li>\n</ol>\n<p>这些都是我面试遇到的问题…太深了，网上的文章几乎没有提到，所以我决定自己来学习一下，然后分享并记录我的学习过程。如果有错误的地方，还请一起讨论。有任何问题都可以添加我的v：「DerrickTel」    和我讨论。</p>\n<p>麻烦写一下备注，谢谢。</p>\n<h1 id=\"前置小知识\"><a href=\"#前置小知识\" class=\"headerlink\" title=\"前置小知识\"></a>前置小知识</h1><h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？</p>\n<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p>\n<p>因为不是核心，所以我这里给一个简单的例子帮助理解：</p>\n<p>进程是火车头，线程是火车的车厢。没有火车头，车厢无法自己运行。一个火车头可以拉多个车厢。</p>\n<h2 id=\"单线程的JavaScript和多线程的浏览器\"><a href=\"#单线程的JavaScript和多线程的浏览器\" class=\"headerlink\" title=\"单线程的JavaScript和多线程的浏览器\"></a>单线程的JavaScript和多线程的浏览器</h2><p>大家第一次接触到JavaScript听到最多的恐怕就是JavaScript 是单线程的，更有甚者会知道为什么JavaScript要是单线程的。</p>\n<blockquote>\n<p>试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。这就决定了JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。</p>\n</blockquote>\n<p>所以JavaScript是单线程的。那为什么浏览器又是多线程的？因为在早期的单线程浏览器会碰到几个问题：</p>\n<ol>\n<li>不稳定<ol>\n<li>比如一个Web视频或Web游戏，这些可能都需要强大的插件来帮助解决问题。但是插件最容易出现BUG，一个BUG崩溃了，那就会导致整个浏览器的崩溃</li>\n</ol>\n</li>\n<li>不流畅<ol>\n<li>就一个线程，如果被一个任务占据了大量的事情，甚至是死循环，也会让浏览器处于停滞状态</li>\n</ol>\n</li>\n<li>不安全<ol>\n<li>如果单线程的插线在运行时，是一个病毒或者恶意程序，你的电脑将面临巨大的风险</li>\n</ol>\n</li>\n</ol>\n<p>所以浏览器就需要多线程来处理这些遗留问题，并且可以保证速度的同时保证安全。比如网络线程，可以把数据都弄清楚了，等待JavaScript来提取，就好像洗衣服，我放洗衣店洗，我吃完饭来拿就好了。不需要我自己手动的去洗。但是也会带来几个问题</p>\n<ol>\n<li>更多的系统资源占用。</li>\n<li>更复杂的浏览器架构。（不是本文重点</li>\n</ol>\n<blockquote>\n<p>单线程的JavaScript有自己的运行机制「事件循环」。可以在我的主业查看文章进行阅读。</p>\n</blockquote>\n<h1 id=\"React的卡顿\"><a href=\"#React的卡顿\" class=\"headerlink\" title=\"React的卡顿\"></a>React的卡顿</h1><p>在<code>React15</code>及之前的版本。都是进行两颗树的比较，然后找到需要更新的地方，最后更新到真实的DOM树上。而这个算法是在数据结构中的两棵树的比较中优化而来。也从原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)。我们称之为「 Stack Reconciler 」。在很长的一段时间风光无限。</p>\n<p>但是，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 Stack Reconciler 也渐渐在体验方面显出疲态。</p>\n<p>为什么会出现乏力的感觉？</p>\n<p>因为从本质上来说，栈调和机制下的 Diff 算法，其实是树的深度优先遍历的过程。而树的深度优先遍历，总是和递归脱不了关系。</p>\n<p>递归就是除非碰到了他的返回条件，否则，将无线的循环下去。这个问题最致命的就是，无法停止。加入足够大，将会出现「页面卡死」。</p>\n<h1 id=\"FIber的出现\"><a href=\"#FIber的出现\" class=\"headerlink\" title=\"FIber的出现\"></a>FIber的出现</h1><p>首先Fiber的翻译是：「纤维」。</p>\n<p>维基百科：「<strong>纤维</strong>（英语：fiber）是指由连续或不连续的细丝组成的物质。」</p>\n<p>简单来说就是非常的细的东西，也就是对整个渲染过程进行纤维级别的控制。</p>\n<h2 id=\"Fiber如何解决问题\"><a href=\"#Fiber如何解决问题\" class=\"headerlink\" title=\"Fiber如何解决问题\"></a>Fiber如何解决问题</h2><p>Fiber是对整个React的调度算法的重写，又是一个React自创的数据结构，里面保存了一个虚拟DOM的节点，也保存了需要更新的状态，以及副作用。</p>\n<p>我们知道，用户在使用的时候最怕的是什么？没反应，也就是「页面卡死」。而我们玩游戏觉得卡是因为他一秒钟的帧数少于60帧，所以我们觉得卡，而浏览器的页面也一样。React只需要一秒钟能够保证60帧的流畅出现就可以了，用户就不觉得「页面卡死」了。</p>\n<p>所以Fiber的任务肯定是，在保证至少60帧每秒的情况下，才去做别的事情。</p>\n<h2 id=\"Fiber架构核心：“可中断”“可恢复”“优先级”\"><a href=\"#Fiber架构核心：“可中断”“可恢复”“优先级”\" class=\"headerlink\" title=\"Fiber架构核心：“可中断”“可恢复”“优先级”\"></a>Fiber架构核心：“可中断”“可恢复”“优先级”</h2><p>Fiber所做的这一系列操作都是为了用户的丝滑体验。</p>\n<p>想象一下，打断现在非常冗长的计算，通过优先级的判断，优先渲染页面或者别的什么。然后再恢复冗长的计算。是不是脑中基本有一个模糊的概念了？</p>\n<p>在进一步，React其实为很多任务进行了切片，这些每一个细小的片，我们可以成为「Fiber」。在执行完一个「Fiber」的时候，会检查队列中最高优先级的任务。如果有比目前的这个优先级高的，先把数据和状态保存在「Fiber」节点上，然后进行那个「更高优先级任务」。之后再检查，如果没有就恢复任务。</p>\n<p>在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：</p>\n<ul>\n<li><p>componentWillMount</p>\n</li>\n<li><p>componentWillUpdate</p>\n</li>\n<li><p>shouldComponentUpdate</p>\n</li>\n<li><p>componentWillReceiveProps</p>\n</li>\n</ul>\n<p>其中 shouldComponentUpdate 的作用是通过返回 true 或者 false，来帮助我们判断更新的必要性，一般在这个函数中不会进行副作用操作，因此风险不大。</p>\n<p>而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”。</p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>之前的问题，现在是否有的已经有答案了？有的还没有？欢迎讨论</p>\n<ol>\n<li>都说<code>Fiber</code>是有优先级，有打断任务的机制，但是<code>JavaScript</code>他是单线程的，在计算的时候如何打断呢？</li>\n<li>数据结构为什么选择了链表作为数据结构？别的不可以吗？比如，数组？</li>\n<li>为什么有的时候<code>render</code>会执行多次？</li>\n<li><code>Fiber</code>架构一定是异步的吗？</li>\n<li><code>Fiber</code>树和虚拟DOM树有什么区别？</li>\n</ol>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><a href=\"https://zh-hans.reactjs.org/docs\" target=\"_blank\" rel=\"noopener\">https://zh-hans.reactjs.org/docs</a></p>\n"},{"title":"【重识前端】redux源码阅读","date":"2020-09-11T08:10:35.000Z","cover":"/image/cover/web.jpeg","_content":"\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n[【重识前端】暴走的异步编程](https://juejin.im/post/6867814019055484942)\n\n[【重识前端】redux源码阅读](https://juejin.im/post/6877910314110140423/)\n\n# 前言\n\n之前一直在使用redux，后来出了hooks，用的比较少了，但是还是会使用，他们不冲突，各自对应的场景不同。听说redux源码比较少，也比较好懂（不是贬低，越强的代码其实越简洁明了）\n\n所以准备阅读一下，也算是重识前端系列的一员吧。\n\n注意一下，其实我们写react的时候用到的其实是redux-react。后面也会一起介绍。\n\n更好的阅读体验其实是在项目里面打断点，这里是我的[GitHub地址](https://github.com/DerrickTel/redux-source-analyse)，喜欢的同学可以fork或者star一下哦。里面我把源码都拉出来放到文件夹里面然后由create-react-app来调用，而不是直接用npm装。这有助于理解与调试，里面也有我的注释，其实可以直接阅读源码的注释会更快。\n\nredux和rdux-react的代码也是目前最新（2020-09-13）的master分支上面的。\n\n# 开始\n\nredux是用的rollup打包的。\n\n打开根目录下面的`rollup.config.js`可以看到入口是src目录下的index文件。\n\n可以看到他导出的一些东西\n\n```js\nexport {\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  __DO_NOT_USE__ActionTypes\n}\n```\n\n我们一个个开始。首先映入眼帘的是createStore\n\n## createStore\n\n开始之前，我们先看看是怎么用。以下采用[我的源码](https://github.com/DerrickTel/redux-source-analyse)阅读里面的代码：\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  let result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nlet store = createStore(rootReducer, applyMiddleware(logger));\n```\n\n再看看源码的createStore。\n\n### 参数\n\n```js\nexport default function createStore<\n  S,\n  A extends Action,\n  Ext = {},\n  StateExt = never\n>(\n  reducer: Reducer<S, A>,\n  preloadedState?: PreloadedState<S> | StoreEnhancer<Ext, StateExt>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext {\n  //.. 一些校验的源码就不介绍了，想了解的可以看我的GitHub，上面有注释\n  let currentReducer = reducer // 临时存放 reducer 的地方\n  let currentState = preloadedState as S // 临时存放 state 的地方\n  let currentListeners: (() => void)[] | null = [] // 监听队列\n  let nextListeners = currentListeners // 引用赋值, 和正式的队列进行区分, 别有他用\n  let isDispatching = false // 是不是正在dispatch\n  // ... \n}\n```\n\ncreateStore接收3个参数`reducer`，`preloadedState`，`enhancer`。\n\n我们一一剖析他们分别是做什么的。\n\n#### reducer\n\n这个大家太熟悉了。就是一个函数，然后我们在里面写`switch`，`switch` `dispatch`过来 `action`的`type`。然后做对应的操作。最后返回一个新的对象，也就是全新的`store`的数据。为什么是返回一个全新的`store`，是为了防止js的引用。\n\n忘记的，或者不太懂的同学可以看一下下面的demo：\n\n```js\nconst initState = {\n  todos: []\n}\n\n// 这里面我们一般会赋值上默认的state，因为后续可能会用到默认的情况，像数组之类的就非常常见。\nconst todos = (state = initState, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state\n      }\n    case 'TOGGLE_TODO':\n      return state.map(\n        todo =>\n          todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      )\n    default: {\n      return state\n    }\n      \n  }\n}\n\nexport default todos\n```\n\n\n\n#### preloadedState\n\n这个其实我们用的不是很多，因为我们一般预存的都直接卸载`reducer`里面了。像👆🌰里面的`state = initState`就省去了我们的传递这个参数的过程。而且数据放在`reducer`里面也更加清晰。\n\n哪怕是在[阮一峰老师的日志](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)里面也是这样教的。\n\n```js\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2\n});\n```\n\n中文翻译就是：预存的`state`。也可以理解为初始的，默认的。因为我们一般在也页面里面直接拿`store`里面的值，或者`map`或者什么。很有可能就会报错，因为如果没有默认值我们直接用`map`就会报错....相信刚刚开始用的小伙伴应该有这样的困惑。\n\n但是，我们通常都是传两个参数，那咋办？我看他好像是顺序读取的诶...\n\nredux兼容我们啦，我们可以看到前面有一段代码是为了做这个的\n\n```js\n// preloadedState为function enhancer为undefined的时候说明initState没有初始化, 但是有middleware\nif (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n  enhancer = preloadedState // 把 preloadedState 赋值给 enhancer\n  preloadedState = undefined // preloadedState赋值undeifined\n}\n```\n\n\n\n#### enhancer\n\n中文翻译是：增强。其实就是我们常用的中间件，用于增强我们的`redux`。常见有的有`log`，`redux-thunk`，`redux-saga`等等。\n\n我们发现代码里面有一段是这样的：\n\n```js\n// debugger\n// 如果参数enhancer存在\n  if (typeof enhancer !== 'undefined') {\n    // 如果enhancer存在，那他必须是个function, 否则throw Error哈\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    /**\n     * 传入符合参数类型的参数，就可以执行 enhancer,\n     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能\n     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore\n     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料\n     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，\n     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined\n     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore\n     * * */\n    // debugger\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n```\n\n这个重点其实在于`applyMiddleware`，后续我们会介绍到的。\n\n### 内置变量\n\n这个比较简单，我就都写在注释里面了\n\n```js\nlet currentReducer = reducer // 临时存放 reducer 的地方\nlet currentState = preloadedState as S // 临时存放 state 的地方\nlet currentListeners: (() => void)[] | null = [] // 监听队列\nlet nextListeners = currentListeners // 引用赋值, 和正式的队列进行区分, 别有他用\nlet isDispatching = false // 是不是正在dispatch\n```\n\n\n\n### 内置方法\n\n#### ensureCanMutateNextListeners\n\n这里其实是为了弄两个数组，一个操作一个原数组而抽象的一个方法。\n\n有一个小的知识点，`===`对于数组的判断只能用于判断是否是同一个内存地址，不信的话大家可以试试。\n\n```js\nconst a = [1, 2];\nconst b = [1, 2];\nconst c = a;\nconsole.log(a === b);\nconsole.log(a === c);\nconsole.log(b === c);\n```\n\n\n\n所以下面的操作的就变得很好理解了。在我们操作`listener`之前会先存储一下快照。大家要多理解一下，因为后面很多地方会用到这个函数。\n\n```js\n// Google翻译: 确保可以使下一个侦听器突变\n  // 我的理解是存储一下快照, 以为接下来可能会进行操作.\n  function ensureCanMutateNextListeners() {\n    // 是否相同, 是不是简单的引用赋值, 是的话就浅拷贝一份\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n```\n\n\n\n#### getState\n\n这个函数很简单，首先判断一下是否是在dispatch，然后返回当前的state。\n\n```js\n// 获取当前的state\n  function getState(): S {\n    // 如果正在dispatch 就报错,因为要获取最新的state, dispatch很有可能会改变state\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      )\n    }\n\n    return currentState as S\n  }\n```\n\n有没有感觉redux好像也不过如此~~接着看哦。\n\n#### subscribe\n\n中文翻译：订阅者。\n\n其实也很好理解。可能有用过`redux`的同学都有用过这个。\n\n我举一个怎么用的🌰：\n\n```js\nconst unSubscribe = store.subscribe(() => {\n  console.log('store.subscribe', store.getState())\n})\n// 取消订阅就直接调用这个函数就好了\n// unSubscribe();\n```\n\n一旦触发了`dispatch`就会触发这个函数，也就是我们写上去的`console.log()`\n\n然后我们再来看这个函数。\n\n```js\nfunction subscribe(listener: () => void) {\n    // listener必须为函数，因为要以回调函数的方式来触发。\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n\n    // 如果正在dispatch中则抛错，和getState同理\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\n      )\n    }\n\n    // 是否有监听者,或者是否被订阅\n    let isSubscribed = true\n\n    // 保存快照, 拷贝一份监听队列到nextListeners(如果是引用的话)\n    ensureCanMutateNextListeners()\n    // 往监听队列里面推入一个监听者\n    nextListeners.push(listener)\n\n    // 返回一个取消订阅的方法\n    return function unsubscribe() {\n      // 如果没有被订阅, 直接shut down\n      if (!isSubscribed) {\n        return\n      }\n\n      // 如果正在dispatch 报错，和上面👆同理\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\n        )\n      }\n\n      // 取消订阅\n      isSubscribed = false\n\n      // 依旧是拿下当前的监听队列，不然等一下删除的时候，会删掉所有的队列。其实我们只需要删掉监听者就好了\n      ensureCanMutateNextListeners()\n      // 找到监听者\n      const index = nextListeners.indexOf(listener)\n      // 删除这个监听者\n      nextListeners.splice(index, 1)\n      // 清空当前的监听队列\n      currentListeners = null\n    }\n  }\n```\n\n\n\n#### dispatch\n\n这个函数可以说是史上最TM常用的函数的，最TM重要之重中之重，而且还是更新store的唯一方法，注意这个唯一。但是又非常好理解。\n\n我们还是先看一个🌰吧：\n\n```js\nprops.dispatch({\n  type: 'TEST',\n  test1: 1,\n  test2: 2,\n  // ...\n})\n```\n\n然后，我们的store就改变了，就会更新props，来触发render，视图可能就会更新之类的。\n\n👌，现在我们有一个一点点了解，来看一下源码。\n\n```js\n// 修改store的唯一方法\n  function dispatch(action: A) {\n    // action必须是一个对象\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      )\n    }\n\n    // action必须拥有一个type\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      )\n    }\n\n    // 如果正在dispatching，那么不执行dispatch操作。\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    // 设置dispatching状态为true，并使用reducer生成新的状态树。\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      // 当获取新的状态树完成后，设置状态为false.\n      isDispatching = false\n    }\n\n    // 将目前最新的监听方法放置到即将执行的队列中遍历并且执行\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    // 将触发的action返回\n    return action\n  }\n```\n\n其实看下来，我们发现他就是简单的将我们的参数转发给了`reducer`，然后执行了我们之前建立的监听队列。\n\n有没有同学会和我想的一样，那为什么不直接执行`reducer`？因为我们里面有订阅函数需要执行，对吧，而且还有`dispatch`的状态需要通知`store`，不然`getState`之类的，我们之前有看到判断`dispatch`状态的很可能出现偏差。\n\n我们只需要`connect`一下就可以直接在`props`里面拿到`dispatch`，不需要`import`之类的，很简洁。\n\n#### replaceReducer\n\n这个函数顾名思义，也很好理解，我就不多做解释了，直接看注释吧。\n\n```js\n// 这个其实很少用到, 官方的介绍是主要是用于动态替换reducer的时候会用到\n  function replaceReducer<NewState, NewActions extends A>(\n    nextReducer: Reducer<NewState, NewActions>\n  ): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    // 修改reducer\n    // 当前的currentReducer更新为参数nextReducer\n    // TODO: do this more elegantly\n    ;((currentReducer as unknown) as Reducer<\n      NewState,\n      NewActions\n    >) = nextReducer\n\n    // This action has a similar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n    // 和INIT的dispatch相同，发送一个dispatch初始化state，表明一下是REPLACE\n    // 自己👀看一下utils方法的ActionTypes， 随性的随机数\n    dispatch({ type: ActionTypes.REPLACE } as A)\n    // change the type of the store by casting it to the new store\n    return (store as unknown) as Store<\n      ExtendState<NewState, StateExt>,\n      NewActions,\n      StateExt,\n      Ext\n    > &\n      Ext\n  }\n```\n\n发现两个很有趣的点：\n\n1. 大佬们也会写`todo`，关键是！他们的`TODO`年头有点久了，哈哈哈哈，5年了，看样子不是只有我不会继续优化的，哈哈哈哈。也有可能是没有想到更好的方法。。。\n2. 里面他自己`dispatch`了一个，`ActionTypes.REPLACE`。\n\nok，我们一探究竟，这个`ActionTypes.REPLACE`\n\n扒开衣服！直接开看👀！\n\n```js\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nconst randomString = () =>\n  Math.random().toString(36).substring(7).split('').join('.')\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${/* #__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* #__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n}\n\nexport default ActionTypes\n\n```\n\n其实就是一个不想和我们的`type`冲突的随机数，告诉`redux`，这个是他们内部的一个`dispatch`而已。\n\n#### observable\n\n这个玩意，其实我是不太懂他是干什么的。。。全局搜也没有搜出来，而且我也没用过。。。\n\n大家看注释吧，不过多解释，如果有懂哥，欢迎一起交流讨论呀。\n\n```js\n// 查询之后,也没发现有什么特别的用处...暂时跳过,如果有帅哥看到的话可以不吝赐教\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /**\n       The minimal observable subscription method.\n       @param observer Any object that can be used as an observer.\n       The observer object should have a `next` method.\n       @returns An object with an `unsubscribe` method that can\n       be used to unsubscribe the observable from the store, and prevent further\n       emission of values from the observable.\n       */\n      subscribe(observer: unknown) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.')\n        }\n\n        //获取观察着的状态\n        function observeState() {\n          const observerAsObserver = observer as Observer<S>\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState())\n          }\n        }\n\n        observeState()\n        //返回取消订阅的方法\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n```\n\n\n\n其实他内部还自己执行了一下`dispatch`，在`createStore`的最后。\n\n```js\ndispatch({ type: ActionTypes.INIT } as A)\n```\n\n其实也很好理解，我们`createStore`的时候，初始的`state`就是这样来的~\n\n里面的`INIT`，在我们之前`REPLACE`里面也有介绍，也是一个随机数而已。\n\n## applyMiddleware\n\n这个坑，是之前在`createStore`的`ensureCanMutateNextListeners`埋下的，现在我们一起来看看这个。\n\n这个redux拓展dispatch的唯一的标准的方法。\n\n首先，我们得知道怎么用。我贴下我自己demo。\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n```\n\n这个是官方的demo，不了解的，[点我快速了解](https://www.redux.org.cn/docs/advanced/Middleware.html)\n\nok，我们直接贴源码，很短，但是有很多奥妙（奥妙打钱！）。\n\n```js\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer<any> {\n  return (createStore: StoreEnhancerStoreCreator) => <S, A extends AnyAction>(\n    reducer: Reducer<S, A>,\n    preloadedState?: PreloadedState<S>\n  ) => {\n    const store = createStore(reducer, preloadedState)\n    let dispatch: Dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose<typeof dispatch>(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n看起来很短，但是却有很多深奥的地方。一个个来。\n\n在开始之前，我们需要先了解一下函数柯里化。直接上demo帮助理解\n\n```js\nfunction test(a) {\n  return function test2(b){\n    console.log(a + b)\n  }\n}\n\nconst t = test(1);\nt(2); // 3\n```\n\n这里就是一个简单的函数柯里化，我们可以先存储一下第一次传入的参数，后面如果这个`1`会复用的话，那么我们定义的变量`t`就可以在很多地方使用，里面用到了闭包的知识，而且是非常典型的闭包，存储形参`a`，实参`1`。\n\n还记得我们的使用用例吗？\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n```\n\n这里面第一个参数`store`就是对应到我们`createStore`源码里面我们挖的坑。\n\n```js\nif (typeof enhancer !== 'undefined') {\n    // 如果enhancer存在，那他必须是个function, 否则throw Error哈\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    /**\n     * 传入符合参数类型的参数，就可以执行 enhancer,\n     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能\n     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore\n     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料\n     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，\n     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined\n     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore\n     * * */\n    // debugger\n\n    return enhancer(createStore)(\n      reducer,\n      preloadedState as PreloadedState<S>\n    ) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\n  }\n```\n\n第二个`next`，其实就是`middlewareAPI`里面的`dispatch`\n\n```js\nconst middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args),\n      test:2,\n    }\n```\n\n增加一个`log`在`middleware`里面就可以知道了\n\n```js\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next===',next)\n  console.log(action)\n  console.info('dispatching', action)\n  // const result = next(action);\n  console.log('next state', store.getState())\n  // return result\n}\n```\n\n这个时候`log`的是我们在`createStore`里面的`dispatch`，还出现了我们的注释\n\n说明`next`这个参数就是对应的`middlewareAPI`里面的`dispatch`也就是说是`createStore`里面的`dispatch`。\n\n\n\n第三个参数`action`\n\n很简单，其实就是普普通通的一个`action`。不过是从我们`middleaware`里面得到的。这个没有疑惑。\n\n\n\n> 我们会发现一个很有趣的事情就是，如果我们注释掉调用`next(action)`，并且不将结果`return`的话，这个`action`就会被卡住，没有发出去，被我们打断了，所以这就是我们为什么需要做这个的原因。那么就可以引申出我们可以自定义打断某些情况下的action，然后需要在那些情况下给action里面加些什么，都可以办到。\n\n\n\nok，我们看了之后好像知道`applyMiddleware`里面的参数都对应这哪些东西了，但是似乎不知道为什么是一种柯里化的形式来展示的。我们看下面的代码就会知道了。\n\n```js\n// 调用每一个这样形式的middleware = store => next => action =>{}, \n// 组成一个这样[f(next)=>acticon=>next(action)...]的array，赋值给chain\nconst chain = middlewares.map(middleware => middleware(middlewareAPI))\n// debugger\n// compose看 -> compose.js文件\n// compose(...chain)会形成一个调用链, next指代下一个函数的注册, 这就是中间件的返回值要是next(action)的原因\n// 如果执行到了最后next就是原生的store.dispatch方法\ndispatch = compose(...chain)(store.dispatch) \n```\n\n里面提到了`compose`这个函数，其实这个函数就是整个中间件的精髓所在。柯里化的奥义！\n\n```js\nexport default function compose(...funcs: Function[]) {\n  if (funcs.length === 0) {\n    // infer the argument type so it is usable in inference down the line\n    return <T>(arg: T) => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args: any) => a(b(...args)))\n}\n```\n\n不了解reduce的同学可以[点这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)。\n\n这个compose其实是一个调用链，我们的所有的中间件都会按顺序加载，然后是👇这种形式\n\n```js\nmiddleware = middleware1 => middleware2 => middleware3 => middleware4 //...\n```\n\n我们通过一下代码知道，确实是往下传递的。\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next===',next)\n  console.log(action)\n  console.info('dispatching', action)\n  action.aa = 2\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nconst logger2 = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next2===',next)\n  console.log('logger2==-=-=-=-=-=-=',action)\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nconst store = createStore(rootReducer, {todos:[]}, applyMiddleware(logger, logger2));\n```\n\n在`logger2`里面确实打印出来`aa`这个属性的值，而`logger`却没有\n\n\n\n## compose\n\n这个在上面介绍applyMiddleware的时候说过了。就不多说了。\n\n\n\n## combineReducers\n\n这个中文翻译就是《组合reducer》。\n\n其实就是 字面意思，我们看一下怎么用就了解了。\n\n```js\nexport default combineReducers({\n  firstReducer: todos,\n  secondReducer: visibilityFilter\n})\n```\n\n然后我们看一下`log`出来的`props`是什么样子的。\n\n```js\n{\n\tfirstReducer: {todos: Array(0)}\n\tsecondReducer: \"SHOW_ALL\"\n}\n```\n\n也就是我们一开始设置进去的`key`值，返回的时候也是按这个格式返回的。\n\n里面有许多函数，我们先看他到处的函数`combineReducers`\n\n### combineReducers\n\n```js\n// 用于合并reducer 一般是这样combineReducers({a,b,c})\nexport default function combineReducers(reducers: ReducersMapObject) {\n  // reducers中key的数组\n  const reducerKeys = Object.keys(reducers)\n  // 最终的reducer\n  const finalReducers: ReducersMapObject = {}\n\n  // 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer\n  for (let i = 0; i < reducerKeys.length; i++) {\n    // 接受当前的key\n    const key = reducerKeys[i]\n\n    // 如果不是生产环境， 当前的reducer是undefined会给出warning\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    // reducer要是一个function\n    if (typeof reducers[key] === 'function') {\n      // 赋值给finalReducers\n      finalReducers[key] = reducers[key]\n    }\n  }\n  // 符合规范的reducer的key数组\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  // 意想不到的key， 先往下看看\n  let unexpectedKeyCache: { [key: string]: true }\n  // production环境为{}\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError: Error\n  try {\n    // 看这个function\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  // 返回function， 即为createStore中的reducer参数既currentReducer\n  // 自然有state和action两个参数， 可以回createStore文件看看currentReducer(currentState, action)\n  return function combination(\n    state: StateFromReducersMapObject<typeof reducers> = {},\n    action: AnyAction\n  ) {\n    // reducer不规范报错\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    // 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState: StateFromReducersMapObject<typeof reducers> = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n\n      // 获取finalReducerKeys的key和value（function）\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      // 当前key的state值\n      const previousStateForKey = state[key]\n      // 执行reducer， 返回当前state\n      const nextStateForKey = reducer(previousStateForKey, action)\n      // 不存在返回值报错\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新的state放在nextState对应的key里\n      nextState[key] = nextStateForKey\n      // 判断新的state是不是同一引用， 以检验reducer是不是纯函数\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n      // 改变了返回nextState\n    return hasChanged ? nextState : state\n  }\n  /*\n  *  新版本的redux这部分改变了实现方法\n  *  老版本的redux使用的reduce函数实现的\n  *  简单例子如下\n  * function combineReducers(reducers) {\n  *    return (state = {}, action) => {\n  *        return Object.keys(reducers).reduce((currentState, key) => {\n  *            currentState[key] = reducers[key](state[key], action);\n  *             return currentState;\n  *         }, {})\n  *      };\n  *    }\n  * \n  * */\n}\n```\n\n上面是主要源码，一个个剖析进去。\n\n先是对数据进行清洗，第一次筛选出符合要求的`reducer`们\n\n```js\n// reducers中key的数组\n  const reducerKeys = Object.keys(reducers)\n  // 最终的reducer\n  const finalReducers: ReducersMapObject = {}\n\n  // 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer\n  for (let i = 0; i < reducerKeys.length; i++) {\n    // 接受当前的key\n    const key = reducerKeys[i]\n\n    // 如果不是生产环境， 当前的reducer是undefined会给出warning\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    // reducer要是一个function\n    if (typeof reducers[key] === 'function') {\n      // 赋值给finalReducers\n      finalReducers[key] = reducers[key]\n    }\n  }\n```\n\n\n\n### assertReducerShape\n\n初筛之后的finalReducers会交由assertReducerShape再一次进行检验。里面就是一个判断，然后给出警告⚠️之类的。就不多说了。\n\n```js\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n   // reducer返回值\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n    // undefined throw Error\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    // 很明显assertReducerShape是用于reducer的规范\n    // 回到combineReducers\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle ${\n            ActionTypes.INIT\n          } or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n```\n\n\n\n### combination\n\n然后就是返回combination这个函数。参数的意义就是他的名字。就不多说了。\n\n```js\nreturn function combination(state = {}, action) {\n    // reducer不规范报错\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    // 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      // 获取finalReducerKeys的key和value（function）\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      // 当前key的state值\n      const previousStateForKey = state[key]\n      // 执行reducer， 返回当前state\n      const nextStateForKey = reducer(previousStateForKey, action)\n      // 不存在返回值报错\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新的state放在nextState对应的key里\n      nextState[key] = nextStateForKey\n      // 判断新的state是不是同一引用， 以检验reducer是不是纯函数\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 改变了返回nextState\n    return hasChanged ? nextState : state\n  }\n  /*\n  *  新版本的redux这部分改变了实现方法\n  *  老版本的redux使用的reduce函数实现的\n  *  简单例子如下\n  * function combineReducers(reducers) {\n  *    return (state = {}, action) => {\n  *        return Object.keys(reducers).reduce((currentState, key) => {\n  *            currentState[key] = reducers[key](state[key], action);\n  *             return currentState;\n  *         }, {})\n  *      };\n  *    }\n  * \n  * */\n```\n\n\n\n其实就是执行reducer，然后把值拿出来比对，如果是引用的话就返回之前的state，如果不是就使用新的。他的比对和之前说的数组比对一样，都是比对内存地址。\n\n为什么要这么做呢？\n\n好问题！\n\n这样做的好处其实就是为了纯函数，为了一切可预测。而且简单的比较内存地址比递归的性能好太多了。\n\n那么我们怎么样才可以契合这样的理念呢？\n\n就是我们在写reducer返回的时候，需要返回一个全新的对象，通常是\n\n```js\nreturn{\n\t...state,\n\txx: xx\n}\n```\n\n类似这样。这样的话js就会新开辟一个内存地址出来。在比对的时候内存地址就不会相同了。\n\n\n\n## bindActionCreators\n\n这个函数其实非常少用到，而且也没有什么特别晦涩的东西，只是一个封装。但是是一种更为优雅的方式。\n\n直接看代码，很少。\n\n```js\nexport default function bindActionCreators(actionCreators, dispatch) {\n  // actionCreators为function\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  // 不是object throw Error\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        actionCreators === null ? 'null' : typeof actionCreators\n      }. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    )\n  }\n\n  // object 转为数组\n  const keys = Object.keys(actionCreators)\n  // 定义return 的props\n  const boundActionCreators = {}\n  for (let i = 0; i < keys.length; i++) {\n    // actionCreators的key 通常为actionCreators function的name（方法名）\n    const key = keys[i]\n    // function => actionCreators工厂方法本身\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      // 参数为{actions：function xxx}是返回相同的类型\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  // return 的props\n  return boundActionCreators\n}\n```\n\n代码很简单也很清晰，就是弄一个新的对象，然后把`actionCreators`里面的`value`变成`bindActionCreator(actionCreator, dispatch)`的值，那么一起看一下`bindActionCreator`\n\n```js\nfunction bindActionCreator<A extends AnyAction = AnyAction>(\n  actionCreator: ActionCreator<A>,\n  dispatch: Dispatch\n) {\n  return function (this: any, ...args: any[]) {\n    return dispatch(actionCreator.apply(this, args))\n  }\n}\n```\n\n其实这里看起来有点迷糊，看也是能看懂，其实就是返回一个方法，这个方法是干什么的呢？返回执行dispatch之后的返回值。这么搞这么一圈究竟有什么秘密呢？\n\n我们写一个demo就会知道了。\n\n假如我们要做一个动态的增加的action，分别为点击一次+1，点击一次+2，点击一次+3。\n\n我们需要\n\n```js\nconst counterIncActionCreator = function(step) {\n  return {\n    type: 'INCREMENT',\n    step: step || 1\n  }\n}\n\n// 为了简化代码我把dispatch函数定义为只有打印功能的函数\nconst dispatch = function(action) {\n  console.log(action)\n}\n\nconst action1 = counterIncActionCreator()\ndispatch(action1) // { type: 'INCREMENT', step: 1 }\n\nconst action2 = counterIncActionCreator(2)\ndispatch(action2) // { type: 'INCREMENT', step: 2 }\n\nconst action3 = counterIncActionCreator(3)\ndispatch(action3) // { type: 'INCREMENT', step: 3 }\n\n```\n\n有点难受其实，但是我们用了`bindActionCreator`之后\n\n```js\nconst increment = bindActionCreator(counterIncActionCreator, dispatch)\n\nincrement() // { type: 'INCREMENT', step: 1 }\n\nincrement(2) // { type: 'INCREMENT', step: 2 }\n\nincrement(3) // { type: 'INCREMENT', step: 3 }\n\n```\n\n就整个帅起来，有没有？！更加优雅了。\n\n而且我们还可以制作增和减的两个工厂🏭\n\n```js\nconst MyActionCreators = {\n  increment: function(step) {\n    return {\n      type: 'INCREMENT',\n      step: step || 1\n    }\n  },\n\n  decrement: function(step) {\n    return {\n      type: 'DECREMENT',\n      step: - (step || 1)\n    }\n  }\n}\n\n```\n\n\n\n老方法\n\n```js\n// 原始的调度方式\ndispatch(MyActionCreators.increment()) // { type: 'INCREMENT', step: 1 }\ndispatch(MyActionCreators.increment(2)) // { type: 'INCREMENT', step: 2 }\ndispatch(MyActionCreators.increment(3)) // { type: 'INCREMENT', step: 3 }\ndispatch(MyActionCreators.decrement()) // { type: 'DECREMENT', step: -1 }\ndispatch(MyActionCreators.decrement(2)) // { type: 'DECREMENT', step: -2 }\ndispatch(MyActionCreators.decrement(3)) // { type: 'DECREMENT', step: -3 }\n\n```\n\n进化之后\n\n```js\nMyNewActionCreators.increment() // { type: 'INCREMENT', step: 1 }\nMyNewActionCreators.increment(2) // { type: 'INCREMENT', step: 2 }\nMyNewActionCreators.increment(3) // { type: 'INCREMENT', step: 3 }\nMyNewActionCreators.decrement() // { type: 'DECREMENT', step: -1 }\nMyNewActionCreators.decrement(2) // { type: 'DECREMENT', step: -2 }\nMyNewActionCreators.decrement(3) // { type: 'DECREMENT', step: -3 }\n\n```\n\n\n\n## Redux总结\n\n至此我们的redux源码阅读就到此为止。\n\n接下来我们一起学习一下和redux配合使用的react-redux\n\n## react-redux\n\nReact 原本和redux没有关系，redux只是负责数据处理，理论上无论是vue或者angular都可以使用。\n\n但是react-redux将react和redux紧密的联系在了一起。用更符合react的方式来调用redux。\n\n后续会出一篇介绍react-redux的文章。\n\n# 总结\n\n自此redux源码阅读算是告一段落了。其实源码很简单，但是思想却很高级。\n\n如果有不懂的，或者哪里说错了，小伙伴欢迎在评论区讨论。\n\n# 索引\n\n>https://juejin.im/post/6844903638377185288\n>\n>https://www.redux.org.cn/\n\n\n\n\n\n> 实在是没有地方吐槽，我在这里说一下最近的事情吧。先是部门黄了，然后大领导换人了，大领导不知道是不是新官上任三把火，非要搞什么提效，其实就是把人弄走，然后加大工作量，刚刚开始换组我就去写很老的vue项目，没有鄙视vue的意思，是因为我之前都在写react，然后一下让我写，也不太适应而已，还是很少的版本。那就写就写吧，反正做前端的都得学不是？可是，大领导为了给做给老板看，然后让我们下班不要走，就是没有事情做就干坐着的那种。本着90后的性子我就走了，然后我走了之后，有些小伙伴可能也开始走了，然后我就被抓去劝退了....我也没有死皮赖脸的赖着。借口也非常的奇葩\"你活在自己的世界里面，没有关心周围同事忙不忙，改bug不积极，代码质量低\"之类的。。。可是我只是工作的时候戴着而已，因为经常有产品上来就在旁边开始讨论了，然后我自己的工作都做不完，怎么关心同事啊。。强行加了工作量之后我都很晚走或者回家工作了。因为在公司赖着真的很难受，为什么不在自己舒适的家中工作呢？还可以马上睡觉那种，音乐还可以外放。。。再说了我之前的代码，因为项目黄了，应该没人看了吧....唉，其实就是 劝退。我都懂。\n>\n> 但是我的简历其实变得极其丑陋了，因为我年初的才跳槽过来的。现在这个时间非常尴尬....而且我来的第一天听说要996，马上提了离职申请，我的领导同意了，可以之前的大领导和我说以后不会996了就是正常上下班。。然后他就跳槽了。。。\n>\n> 算是自己不认真审查公司，不过他们也太骗人了吧...唉。\n>\n> 现在在家里也很焦虑，不知道找不找得到工作，杭州的公司看了一圈都是996，学阿里的加班不学阿里的工资。。。\n>\n> 国庆以后再说吧，希望早点把重识前端系列更完。\n\n","source":"_posts/【重识前端】redux源码阅读.md","raw":"---\ntitle: 【重识前端】redux源码阅读\ndate: 2020-09-11 16:10:35\ntags: [源码阅读, React]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n[【重识前端】暴走的异步编程](https://juejin.im/post/6867814019055484942)\n\n[【重识前端】redux源码阅读](https://juejin.im/post/6877910314110140423/)\n\n# 前言\n\n之前一直在使用redux，后来出了hooks，用的比较少了，但是还是会使用，他们不冲突，各自对应的场景不同。听说redux源码比较少，也比较好懂（不是贬低，越强的代码其实越简洁明了）\n\n所以准备阅读一下，也算是重识前端系列的一员吧。\n\n注意一下，其实我们写react的时候用到的其实是redux-react。后面也会一起介绍。\n\n更好的阅读体验其实是在项目里面打断点，这里是我的[GitHub地址](https://github.com/DerrickTel/redux-source-analyse)，喜欢的同学可以fork或者star一下哦。里面我把源码都拉出来放到文件夹里面然后由create-react-app来调用，而不是直接用npm装。这有助于理解与调试，里面也有我的注释，其实可以直接阅读源码的注释会更快。\n\nredux和rdux-react的代码也是目前最新（2020-09-13）的master分支上面的。\n\n# 开始\n\nredux是用的rollup打包的。\n\n打开根目录下面的`rollup.config.js`可以看到入口是src目录下的index文件。\n\n可以看到他导出的一些东西\n\n```js\nexport {\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  __DO_NOT_USE__ActionTypes\n}\n```\n\n我们一个个开始。首先映入眼帘的是createStore\n\n## createStore\n\n开始之前，我们先看看是怎么用。以下采用[我的源码](https://github.com/DerrickTel/redux-source-analyse)阅读里面的代码：\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  let result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nlet store = createStore(rootReducer, applyMiddleware(logger));\n```\n\n再看看源码的createStore。\n\n### 参数\n\n```js\nexport default function createStore<\n  S,\n  A extends Action,\n  Ext = {},\n  StateExt = never\n>(\n  reducer: Reducer<S, A>,\n  preloadedState?: PreloadedState<S> | StoreEnhancer<Ext, StateExt>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext {\n  //.. 一些校验的源码就不介绍了，想了解的可以看我的GitHub，上面有注释\n  let currentReducer = reducer // 临时存放 reducer 的地方\n  let currentState = preloadedState as S // 临时存放 state 的地方\n  let currentListeners: (() => void)[] | null = [] // 监听队列\n  let nextListeners = currentListeners // 引用赋值, 和正式的队列进行区分, 别有他用\n  let isDispatching = false // 是不是正在dispatch\n  // ... \n}\n```\n\ncreateStore接收3个参数`reducer`，`preloadedState`，`enhancer`。\n\n我们一一剖析他们分别是做什么的。\n\n#### reducer\n\n这个大家太熟悉了。就是一个函数，然后我们在里面写`switch`，`switch` `dispatch`过来 `action`的`type`。然后做对应的操作。最后返回一个新的对象，也就是全新的`store`的数据。为什么是返回一个全新的`store`，是为了防止js的引用。\n\n忘记的，或者不太懂的同学可以看一下下面的demo：\n\n```js\nconst initState = {\n  todos: []\n}\n\n// 这里面我们一般会赋值上默认的state，因为后续可能会用到默认的情况，像数组之类的就非常常见。\nconst todos = (state = initState, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state\n      }\n    case 'TOGGLE_TODO':\n      return state.map(\n        todo =>\n          todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      )\n    default: {\n      return state\n    }\n      \n  }\n}\n\nexport default todos\n```\n\n\n\n#### preloadedState\n\n这个其实我们用的不是很多，因为我们一般预存的都直接卸载`reducer`里面了。像👆🌰里面的`state = initState`就省去了我们的传递这个参数的过程。而且数据放在`reducer`里面也更加清晰。\n\n哪怕是在[阮一峰老师的日志](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)里面也是这样教的。\n\n```js\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2\n});\n```\n\n中文翻译就是：预存的`state`。也可以理解为初始的，默认的。因为我们一般在也页面里面直接拿`store`里面的值，或者`map`或者什么。很有可能就会报错，因为如果没有默认值我们直接用`map`就会报错....相信刚刚开始用的小伙伴应该有这样的困惑。\n\n但是，我们通常都是传两个参数，那咋办？我看他好像是顺序读取的诶...\n\nredux兼容我们啦，我们可以看到前面有一段代码是为了做这个的\n\n```js\n// preloadedState为function enhancer为undefined的时候说明initState没有初始化, 但是有middleware\nif (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n  enhancer = preloadedState // 把 preloadedState 赋值给 enhancer\n  preloadedState = undefined // preloadedState赋值undeifined\n}\n```\n\n\n\n#### enhancer\n\n中文翻译是：增强。其实就是我们常用的中间件，用于增强我们的`redux`。常见有的有`log`，`redux-thunk`，`redux-saga`等等。\n\n我们发现代码里面有一段是这样的：\n\n```js\n// debugger\n// 如果参数enhancer存在\n  if (typeof enhancer !== 'undefined') {\n    // 如果enhancer存在，那他必须是个function, 否则throw Error哈\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    /**\n     * 传入符合参数类型的参数，就可以执行 enhancer,\n     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能\n     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore\n     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料\n     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，\n     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined\n     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore\n     * * */\n    // debugger\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n```\n\n这个重点其实在于`applyMiddleware`，后续我们会介绍到的。\n\n### 内置变量\n\n这个比较简单，我就都写在注释里面了\n\n```js\nlet currentReducer = reducer // 临时存放 reducer 的地方\nlet currentState = preloadedState as S // 临时存放 state 的地方\nlet currentListeners: (() => void)[] | null = [] // 监听队列\nlet nextListeners = currentListeners // 引用赋值, 和正式的队列进行区分, 别有他用\nlet isDispatching = false // 是不是正在dispatch\n```\n\n\n\n### 内置方法\n\n#### ensureCanMutateNextListeners\n\n这里其实是为了弄两个数组，一个操作一个原数组而抽象的一个方法。\n\n有一个小的知识点，`===`对于数组的判断只能用于判断是否是同一个内存地址，不信的话大家可以试试。\n\n```js\nconst a = [1, 2];\nconst b = [1, 2];\nconst c = a;\nconsole.log(a === b);\nconsole.log(a === c);\nconsole.log(b === c);\n```\n\n\n\n所以下面的操作的就变得很好理解了。在我们操作`listener`之前会先存储一下快照。大家要多理解一下，因为后面很多地方会用到这个函数。\n\n```js\n// Google翻译: 确保可以使下一个侦听器突变\n  // 我的理解是存储一下快照, 以为接下来可能会进行操作.\n  function ensureCanMutateNextListeners() {\n    // 是否相同, 是不是简单的引用赋值, 是的话就浅拷贝一份\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n```\n\n\n\n#### getState\n\n这个函数很简单，首先判断一下是否是在dispatch，然后返回当前的state。\n\n```js\n// 获取当前的state\n  function getState(): S {\n    // 如果正在dispatch 就报错,因为要获取最新的state, dispatch很有可能会改变state\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      )\n    }\n\n    return currentState as S\n  }\n```\n\n有没有感觉redux好像也不过如此~~接着看哦。\n\n#### subscribe\n\n中文翻译：订阅者。\n\n其实也很好理解。可能有用过`redux`的同学都有用过这个。\n\n我举一个怎么用的🌰：\n\n```js\nconst unSubscribe = store.subscribe(() => {\n  console.log('store.subscribe', store.getState())\n})\n// 取消订阅就直接调用这个函数就好了\n// unSubscribe();\n```\n\n一旦触发了`dispatch`就会触发这个函数，也就是我们写上去的`console.log()`\n\n然后我们再来看这个函数。\n\n```js\nfunction subscribe(listener: () => void) {\n    // listener必须为函数，因为要以回调函数的方式来触发。\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n\n    // 如果正在dispatch中则抛错，和getState同理\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\n      )\n    }\n\n    // 是否有监听者,或者是否被订阅\n    let isSubscribed = true\n\n    // 保存快照, 拷贝一份监听队列到nextListeners(如果是引用的话)\n    ensureCanMutateNextListeners()\n    // 往监听队列里面推入一个监听者\n    nextListeners.push(listener)\n\n    // 返回一个取消订阅的方法\n    return function unsubscribe() {\n      // 如果没有被订阅, 直接shut down\n      if (!isSubscribed) {\n        return\n      }\n\n      // 如果正在dispatch 报错，和上面👆同理\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\n        )\n      }\n\n      // 取消订阅\n      isSubscribed = false\n\n      // 依旧是拿下当前的监听队列，不然等一下删除的时候，会删掉所有的队列。其实我们只需要删掉监听者就好了\n      ensureCanMutateNextListeners()\n      // 找到监听者\n      const index = nextListeners.indexOf(listener)\n      // 删除这个监听者\n      nextListeners.splice(index, 1)\n      // 清空当前的监听队列\n      currentListeners = null\n    }\n  }\n```\n\n\n\n#### dispatch\n\n这个函数可以说是史上最TM常用的函数的，最TM重要之重中之重，而且还是更新store的唯一方法，注意这个唯一。但是又非常好理解。\n\n我们还是先看一个🌰吧：\n\n```js\nprops.dispatch({\n  type: 'TEST',\n  test1: 1,\n  test2: 2,\n  // ...\n})\n```\n\n然后，我们的store就改变了，就会更新props，来触发render，视图可能就会更新之类的。\n\n👌，现在我们有一个一点点了解，来看一下源码。\n\n```js\n// 修改store的唯一方法\n  function dispatch(action: A) {\n    // action必须是一个对象\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      )\n    }\n\n    // action必须拥有一个type\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      )\n    }\n\n    // 如果正在dispatching，那么不执行dispatch操作。\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    // 设置dispatching状态为true，并使用reducer生成新的状态树。\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      // 当获取新的状态树完成后，设置状态为false.\n      isDispatching = false\n    }\n\n    // 将目前最新的监听方法放置到即将执行的队列中遍历并且执行\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    // 将触发的action返回\n    return action\n  }\n```\n\n其实看下来，我们发现他就是简单的将我们的参数转发给了`reducer`，然后执行了我们之前建立的监听队列。\n\n有没有同学会和我想的一样，那为什么不直接执行`reducer`？因为我们里面有订阅函数需要执行，对吧，而且还有`dispatch`的状态需要通知`store`，不然`getState`之类的，我们之前有看到判断`dispatch`状态的很可能出现偏差。\n\n我们只需要`connect`一下就可以直接在`props`里面拿到`dispatch`，不需要`import`之类的，很简洁。\n\n#### replaceReducer\n\n这个函数顾名思义，也很好理解，我就不多做解释了，直接看注释吧。\n\n```js\n// 这个其实很少用到, 官方的介绍是主要是用于动态替换reducer的时候会用到\n  function replaceReducer<NewState, NewActions extends A>(\n    nextReducer: Reducer<NewState, NewActions>\n  ): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    // 修改reducer\n    // 当前的currentReducer更新为参数nextReducer\n    // TODO: do this more elegantly\n    ;((currentReducer as unknown) as Reducer<\n      NewState,\n      NewActions\n    >) = nextReducer\n\n    // This action has a similar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n    // 和INIT的dispatch相同，发送一个dispatch初始化state，表明一下是REPLACE\n    // 自己👀看一下utils方法的ActionTypes， 随性的随机数\n    dispatch({ type: ActionTypes.REPLACE } as A)\n    // change the type of the store by casting it to the new store\n    return (store as unknown) as Store<\n      ExtendState<NewState, StateExt>,\n      NewActions,\n      StateExt,\n      Ext\n    > &\n      Ext\n  }\n```\n\n发现两个很有趣的点：\n\n1. 大佬们也会写`todo`，关键是！他们的`TODO`年头有点久了，哈哈哈哈，5年了，看样子不是只有我不会继续优化的，哈哈哈哈。也有可能是没有想到更好的方法。。。\n2. 里面他自己`dispatch`了一个，`ActionTypes.REPLACE`。\n\nok，我们一探究竟，这个`ActionTypes.REPLACE`\n\n扒开衣服！直接开看👀！\n\n```js\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nconst randomString = () =>\n  Math.random().toString(36).substring(7).split('').join('.')\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${/* #__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* #__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n}\n\nexport default ActionTypes\n\n```\n\n其实就是一个不想和我们的`type`冲突的随机数，告诉`redux`，这个是他们内部的一个`dispatch`而已。\n\n#### observable\n\n这个玩意，其实我是不太懂他是干什么的。。。全局搜也没有搜出来，而且我也没用过。。。\n\n大家看注释吧，不过多解释，如果有懂哥，欢迎一起交流讨论呀。\n\n```js\n// 查询之后,也没发现有什么特别的用处...暂时跳过,如果有帅哥看到的话可以不吝赐教\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /**\n       The minimal observable subscription method.\n       @param observer Any object that can be used as an observer.\n       The observer object should have a `next` method.\n       @returns An object with an `unsubscribe` method that can\n       be used to unsubscribe the observable from the store, and prevent further\n       emission of values from the observable.\n       */\n      subscribe(observer: unknown) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.')\n        }\n\n        //获取观察着的状态\n        function observeState() {\n          const observerAsObserver = observer as Observer<S>\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState())\n          }\n        }\n\n        observeState()\n        //返回取消订阅的方法\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n```\n\n\n\n其实他内部还自己执行了一下`dispatch`，在`createStore`的最后。\n\n```js\ndispatch({ type: ActionTypes.INIT } as A)\n```\n\n其实也很好理解，我们`createStore`的时候，初始的`state`就是这样来的~\n\n里面的`INIT`，在我们之前`REPLACE`里面也有介绍，也是一个随机数而已。\n\n## applyMiddleware\n\n这个坑，是之前在`createStore`的`ensureCanMutateNextListeners`埋下的，现在我们一起来看看这个。\n\n这个redux拓展dispatch的唯一的标准的方法。\n\n首先，我们得知道怎么用。我贴下我自己demo。\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n```\n\n这个是官方的demo，不了解的，[点我快速了解](https://www.redux.org.cn/docs/advanced/Middleware.html)\n\nok，我们直接贴源码，很短，但是有很多奥妙（奥妙打钱！）。\n\n```js\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer<any> {\n  return (createStore: StoreEnhancerStoreCreator) => <S, A extends AnyAction>(\n    reducer: Reducer<S, A>,\n    preloadedState?: PreloadedState<S>\n  ) => {\n    const store = createStore(reducer, preloadedState)\n    let dispatch: Dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose<typeof dispatch>(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n看起来很短，但是却有很多深奥的地方。一个个来。\n\n在开始之前，我们需要先了解一下函数柯里化。直接上demo帮助理解\n\n```js\nfunction test(a) {\n  return function test2(b){\n    console.log(a + b)\n  }\n}\n\nconst t = test(1);\nt(2); // 3\n```\n\n这里就是一个简单的函数柯里化，我们可以先存储一下第一次传入的参数，后面如果这个`1`会复用的话，那么我们定义的变量`t`就可以在很多地方使用，里面用到了闭包的知识，而且是非常典型的闭包，存储形参`a`，实参`1`。\n\n还记得我们的使用用例吗？\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n```\n\n这里面第一个参数`store`就是对应到我们`createStore`源码里面我们挖的坑。\n\n```js\nif (typeof enhancer !== 'undefined') {\n    // 如果enhancer存在，那他必须是个function, 否则throw Error哈\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    /**\n     * 传入符合参数类型的参数，就可以执行 enhancer,\n     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能\n     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore\n     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料\n     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，\n     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined\n     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore\n     * * */\n    // debugger\n\n    return enhancer(createStore)(\n      reducer,\n      preloadedState as PreloadedState<S>\n    ) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\n  }\n```\n\n第二个`next`，其实就是`middlewareAPI`里面的`dispatch`\n\n```js\nconst middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args),\n      test:2,\n    }\n```\n\n增加一个`log`在`middleware`里面就可以知道了\n\n```js\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next===',next)\n  console.log(action)\n  console.info('dispatching', action)\n  // const result = next(action);\n  console.log('next state', store.getState())\n  // return result\n}\n```\n\n这个时候`log`的是我们在`createStore`里面的`dispatch`，还出现了我们的注释\n\n说明`next`这个参数就是对应的`middlewareAPI`里面的`dispatch`也就是说是`createStore`里面的`dispatch`。\n\n\n\n第三个参数`action`\n\n很简单，其实就是普普通通的一个`action`。不过是从我们`middleaware`里面得到的。这个没有疑惑。\n\n\n\n> 我们会发现一个很有趣的事情就是，如果我们注释掉调用`next(action)`，并且不将结果`return`的话，这个`action`就会被卡住，没有发出去，被我们打断了，所以这就是我们为什么需要做这个的原因。那么就可以引申出我们可以自定义打断某些情况下的action，然后需要在那些情况下给action里面加些什么，都可以办到。\n\n\n\nok，我们看了之后好像知道`applyMiddleware`里面的参数都对应这哪些东西了，但是似乎不知道为什么是一种柯里化的形式来展示的。我们看下面的代码就会知道了。\n\n```js\n// 调用每一个这样形式的middleware = store => next => action =>{}, \n// 组成一个这样[f(next)=>acticon=>next(action)...]的array，赋值给chain\nconst chain = middlewares.map(middleware => middleware(middlewareAPI))\n// debugger\n// compose看 -> compose.js文件\n// compose(...chain)会形成一个调用链, next指代下一个函数的注册, 这就是中间件的返回值要是next(action)的原因\n// 如果执行到了最后next就是原生的store.dispatch方法\ndispatch = compose(...chain)(store.dispatch) \n```\n\n里面提到了`compose`这个函数，其实这个函数就是整个中间件的精髓所在。柯里化的奥义！\n\n```js\nexport default function compose(...funcs: Function[]) {\n  if (funcs.length === 0) {\n    // infer the argument type so it is usable in inference down the line\n    return <T>(arg: T) => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args: any) => a(b(...args)))\n}\n```\n\n不了解reduce的同学可以[点这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)。\n\n这个compose其实是一个调用链，我们的所有的中间件都会按顺序加载，然后是👇这种形式\n\n```js\nmiddleware = middleware1 => middleware2 => middleware3 => middleware4 //...\n```\n\n我们通过一下代码知道，确实是往下传递的。\n\n```js\n// middleware\nconst logger = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next===',next)\n  console.log(action)\n  console.info('dispatching', action)\n  action.aa = 2\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nconst logger2 = (store:any) => (next:any) => (action:any) => {\n  // debugger\n  \n  console.log(store)\n  console.log('next2===',next)\n  console.log('logger2==-=-=-=-=-=-=',action)\n  console.info('dispatching', action)\n  const result = next(action);\n  console.log('next state', store.getState())\n  return result\n}\n\nconst store = createStore(rootReducer, {todos:[]}, applyMiddleware(logger, logger2));\n```\n\n在`logger2`里面确实打印出来`aa`这个属性的值，而`logger`却没有\n\n\n\n## compose\n\n这个在上面介绍applyMiddleware的时候说过了。就不多说了。\n\n\n\n## combineReducers\n\n这个中文翻译就是《组合reducer》。\n\n其实就是 字面意思，我们看一下怎么用就了解了。\n\n```js\nexport default combineReducers({\n  firstReducer: todos,\n  secondReducer: visibilityFilter\n})\n```\n\n然后我们看一下`log`出来的`props`是什么样子的。\n\n```js\n{\n\tfirstReducer: {todos: Array(0)}\n\tsecondReducer: \"SHOW_ALL\"\n}\n```\n\n也就是我们一开始设置进去的`key`值，返回的时候也是按这个格式返回的。\n\n里面有许多函数，我们先看他到处的函数`combineReducers`\n\n### combineReducers\n\n```js\n// 用于合并reducer 一般是这样combineReducers({a,b,c})\nexport default function combineReducers(reducers: ReducersMapObject) {\n  // reducers中key的数组\n  const reducerKeys = Object.keys(reducers)\n  // 最终的reducer\n  const finalReducers: ReducersMapObject = {}\n\n  // 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer\n  for (let i = 0; i < reducerKeys.length; i++) {\n    // 接受当前的key\n    const key = reducerKeys[i]\n\n    // 如果不是生产环境， 当前的reducer是undefined会给出warning\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    // reducer要是一个function\n    if (typeof reducers[key] === 'function') {\n      // 赋值给finalReducers\n      finalReducers[key] = reducers[key]\n    }\n  }\n  // 符合规范的reducer的key数组\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  // 意想不到的key， 先往下看看\n  let unexpectedKeyCache: { [key: string]: true }\n  // production环境为{}\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError: Error\n  try {\n    // 看这个function\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  // 返回function， 即为createStore中的reducer参数既currentReducer\n  // 自然有state和action两个参数， 可以回createStore文件看看currentReducer(currentState, action)\n  return function combination(\n    state: StateFromReducersMapObject<typeof reducers> = {},\n    action: AnyAction\n  ) {\n    // reducer不规范报错\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    // 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState: StateFromReducersMapObject<typeof reducers> = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n\n      // 获取finalReducerKeys的key和value（function）\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      // 当前key的state值\n      const previousStateForKey = state[key]\n      // 执行reducer， 返回当前state\n      const nextStateForKey = reducer(previousStateForKey, action)\n      // 不存在返回值报错\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新的state放在nextState对应的key里\n      nextState[key] = nextStateForKey\n      // 判断新的state是不是同一引用， 以检验reducer是不是纯函数\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n      // 改变了返回nextState\n    return hasChanged ? nextState : state\n  }\n  /*\n  *  新版本的redux这部分改变了实现方法\n  *  老版本的redux使用的reduce函数实现的\n  *  简单例子如下\n  * function combineReducers(reducers) {\n  *    return (state = {}, action) => {\n  *        return Object.keys(reducers).reduce((currentState, key) => {\n  *            currentState[key] = reducers[key](state[key], action);\n  *             return currentState;\n  *         }, {})\n  *      };\n  *    }\n  * \n  * */\n}\n```\n\n上面是主要源码，一个个剖析进去。\n\n先是对数据进行清洗，第一次筛选出符合要求的`reducer`们\n\n```js\n// reducers中key的数组\n  const reducerKeys = Object.keys(reducers)\n  // 最终的reducer\n  const finalReducers: ReducersMapObject = {}\n\n  // 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer\n  for (let i = 0; i < reducerKeys.length; i++) {\n    // 接受当前的key\n    const key = reducerKeys[i]\n\n    // 如果不是生产环境， 当前的reducer是undefined会给出warning\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    // reducer要是一个function\n    if (typeof reducers[key] === 'function') {\n      // 赋值给finalReducers\n      finalReducers[key] = reducers[key]\n    }\n  }\n```\n\n\n\n### assertReducerShape\n\n初筛之后的finalReducers会交由assertReducerShape再一次进行检验。里面就是一个判断，然后给出警告⚠️之类的。就不多说了。\n\n```js\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n   // reducer返回值\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n    // undefined throw Error\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    // 很明显assertReducerShape是用于reducer的规范\n    // 回到combineReducers\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle ${\n            ActionTypes.INIT\n          } or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n```\n\n\n\n### combination\n\n然后就是返回combination这个函数。参数的意义就是他的名字。就不多说了。\n\n```js\nreturn function combination(state = {}, action) {\n    // reducer不规范报错\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    // 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      // 获取finalReducerKeys的key和value（function）\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      // 当前key的state值\n      const previousStateForKey = state[key]\n      // 执行reducer， 返回当前state\n      const nextStateForKey = reducer(previousStateForKey, action)\n      // 不存在返回值报错\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新的state放在nextState对应的key里\n      nextState[key] = nextStateForKey\n      // 判断新的state是不是同一引用， 以检验reducer是不是纯函数\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 改变了返回nextState\n    return hasChanged ? nextState : state\n  }\n  /*\n  *  新版本的redux这部分改变了实现方法\n  *  老版本的redux使用的reduce函数实现的\n  *  简单例子如下\n  * function combineReducers(reducers) {\n  *    return (state = {}, action) => {\n  *        return Object.keys(reducers).reduce((currentState, key) => {\n  *            currentState[key] = reducers[key](state[key], action);\n  *             return currentState;\n  *         }, {})\n  *      };\n  *    }\n  * \n  * */\n```\n\n\n\n其实就是执行reducer，然后把值拿出来比对，如果是引用的话就返回之前的state，如果不是就使用新的。他的比对和之前说的数组比对一样，都是比对内存地址。\n\n为什么要这么做呢？\n\n好问题！\n\n这样做的好处其实就是为了纯函数，为了一切可预测。而且简单的比较内存地址比递归的性能好太多了。\n\n那么我们怎么样才可以契合这样的理念呢？\n\n就是我们在写reducer返回的时候，需要返回一个全新的对象，通常是\n\n```js\nreturn{\n\t...state,\n\txx: xx\n}\n```\n\n类似这样。这样的话js就会新开辟一个内存地址出来。在比对的时候内存地址就不会相同了。\n\n\n\n## bindActionCreators\n\n这个函数其实非常少用到，而且也没有什么特别晦涩的东西，只是一个封装。但是是一种更为优雅的方式。\n\n直接看代码，很少。\n\n```js\nexport default function bindActionCreators(actionCreators, dispatch) {\n  // actionCreators为function\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  // 不是object throw Error\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        actionCreators === null ? 'null' : typeof actionCreators\n      }. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    )\n  }\n\n  // object 转为数组\n  const keys = Object.keys(actionCreators)\n  // 定义return 的props\n  const boundActionCreators = {}\n  for (let i = 0; i < keys.length; i++) {\n    // actionCreators的key 通常为actionCreators function的name（方法名）\n    const key = keys[i]\n    // function => actionCreators工厂方法本身\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      // 参数为{actions：function xxx}是返回相同的类型\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  // return 的props\n  return boundActionCreators\n}\n```\n\n代码很简单也很清晰，就是弄一个新的对象，然后把`actionCreators`里面的`value`变成`bindActionCreator(actionCreator, dispatch)`的值，那么一起看一下`bindActionCreator`\n\n```js\nfunction bindActionCreator<A extends AnyAction = AnyAction>(\n  actionCreator: ActionCreator<A>,\n  dispatch: Dispatch\n) {\n  return function (this: any, ...args: any[]) {\n    return dispatch(actionCreator.apply(this, args))\n  }\n}\n```\n\n其实这里看起来有点迷糊，看也是能看懂，其实就是返回一个方法，这个方法是干什么的呢？返回执行dispatch之后的返回值。这么搞这么一圈究竟有什么秘密呢？\n\n我们写一个demo就会知道了。\n\n假如我们要做一个动态的增加的action，分别为点击一次+1，点击一次+2，点击一次+3。\n\n我们需要\n\n```js\nconst counterIncActionCreator = function(step) {\n  return {\n    type: 'INCREMENT',\n    step: step || 1\n  }\n}\n\n// 为了简化代码我把dispatch函数定义为只有打印功能的函数\nconst dispatch = function(action) {\n  console.log(action)\n}\n\nconst action1 = counterIncActionCreator()\ndispatch(action1) // { type: 'INCREMENT', step: 1 }\n\nconst action2 = counterIncActionCreator(2)\ndispatch(action2) // { type: 'INCREMENT', step: 2 }\n\nconst action3 = counterIncActionCreator(3)\ndispatch(action3) // { type: 'INCREMENT', step: 3 }\n\n```\n\n有点难受其实，但是我们用了`bindActionCreator`之后\n\n```js\nconst increment = bindActionCreator(counterIncActionCreator, dispatch)\n\nincrement() // { type: 'INCREMENT', step: 1 }\n\nincrement(2) // { type: 'INCREMENT', step: 2 }\n\nincrement(3) // { type: 'INCREMENT', step: 3 }\n\n```\n\n就整个帅起来，有没有？！更加优雅了。\n\n而且我们还可以制作增和减的两个工厂🏭\n\n```js\nconst MyActionCreators = {\n  increment: function(step) {\n    return {\n      type: 'INCREMENT',\n      step: step || 1\n    }\n  },\n\n  decrement: function(step) {\n    return {\n      type: 'DECREMENT',\n      step: - (step || 1)\n    }\n  }\n}\n\n```\n\n\n\n老方法\n\n```js\n// 原始的调度方式\ndispatch(MyActionCreators.increment()) // { type: 'INCREMENT', step: 1 }\ndispatch(MyActionCreators.increment(2)) // { type: 'INCREMENT', step: 2 }\ndispatch(MyActionCreators.increment(3)) // { type: 'INCREMENT', step: 3 }\ndispatch(MyActionCreators.decrement()) // { type: 'DECREMENT', step: -1 }\ndispatch(MyActionCreators.decrement(2)) // { type: 'DECREMENT', step: -2 }\ndispatch(MyActionCreators.decrement(3)) // { type: 'DECREMENT', step: -3 }\n\n```\n\n进化之后\n\n```js\nMyNewActionCreators.increment() // { type: 'INCREMENT', step: 1 }\nMyNewActionCreators.increment(2) // { type: 'INCREMENT', step: 2 }\nMyNewActionCreators.increment(3) // { type: 'INCREMENT', step: 3 }\nMyNewActionCreators.decrement() // { type: 'DECREMENT', step: -1 }\nMyNewActionCreators.decrement(2) // { type: 'DECREMENT', step: -2 }\nMyNewActionCreators.decrement(3) // { type: 'DECREMENT', step: -3 }\n\n```\n\n\n\n## Redux总结\n\n至此我们的redux源码阅读就到此为止。\n\n接下来我们一起学习一下和redux配合使用的react-redux\n\n## react-redux\n\nReact 原本和redux没有关系，redux只是负责数据处理，理论上无论是vue或者angular都可以使用。\n\n但是react-redux将react和redux紧密的联系在了一起。用更符合react的方式来调用redux。\n\n后续会出一篇介绍react-redux的文章。\n\n# 总结\n\n自此redux源码阅读算是告一段落了。其实源码很简单，但是思想却很高级。\n\n如果有不懂的，或者哪里说错了，小伙伴欢迎在评论区讨论。\n\n# 索引\n\n>https://juejin.im/post/6844903638377185288\n>\n>https://www.redux.org.cn/\n\n\n\n\n\n> 实在是没有地方吐槽，我在这里说一下最近的事情吧。先是部门黄了，然后大领导换人了，大领导不知道是不是新官上任三把火，非要搞什么提效，其实就是把人弄走，然后加大工作量，刚刚开始换组我就去写很老的vue项目，没有鄙视vue的意思，是因为我之前都在写react，然后一下让我写，也不太适应而已，还是很少的版本。那就写就写吧，反正做前端的都得学不是？可是，大领导为了给做给老板看，然后让我们下班不要走，就是没有事情做就干坐着的那种。本着90后的性子我就走了，然后我走了之后，有些小伙伴可能也开始走了，然后我就被抓去劝退了....我也没有死皮赖脸的赖着。借口也非常的奇葩\"你活在自己的世界里面，没有关心周围同事忙不忙，改bug不积极，代码质量低\"之类的。。。可是我只是工作的时候戴着而已，因为经常有产品上来就在旁边开始讨论了，然后我自己的工作都做不完，怎么关心同事啊。。强行加了工作量之后我都很晚走或者回家工作了。因为在公司赖着真的很难受，为什么不在自己舒适的家中工作呢？还可以马上睡觉那种，音乐还可以外放。。。再说了我之前的代码，因为项目黄了，应该没人看了吧....唉，其实就是 劝退。我都懂。\n>\n> 但是我的简历其实变得极其丑陋了，因为我年初的才跳槽过来的。现在这个时间非常尴尬....而且我来的第一天听说要996，马上提了离职申请，我的领导同意了，可以之前的大领导和我说以后不会996了就是正常上下班。。然后他就跳槽了。。。\n>\n> 算是自己不认真审查公司，不过他们也太骗人了吧...唉。\n>\n> 现在在家里也很焦虑，不知道找不找得到工作，杭州的公司看了一圈都是996，学阿里的加班不学阿里的工资。。。\n>\n> 国庆以后再说吧，希望早点把重识前端系列更完。\n\n","slug":"【重识前端】redux源码阅读","published":1,"updated":"2021-06-24T14:00:06.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8g001jlwrde1xq9gj8","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<p><a href=\"https://juejin.im/post/6867814019055484942\" target=\"_blank\" rel=\"noopener\">【重识前端】暴走的异步编程</a></p>\n<p><a href=\"https://juejin.im/post/6877910314110140423/\" target=\"_blank\" rel=\"noopener\">【重识前端】redux源码阅读</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前一直在使用redux，后来出了hooks，用的比较少了，但是还是会使用，他们不冲突，各自对应的场景不同。听说redux源码比较少，也比较好懂（不是贬低，越强的代码其实越简洁明了）</p>\n<p>所以准备阅读一下，也算是重识前端系列的一员吧。</p>\n<p>注意一下，其实我们写react的时候用到的其实是redux-react。后面也会一起介绍。</p>\n<p>更好的阅读体验其实是在项目里面打断点，这里是我的<a href=\"https://github.com/DerrickTel/redux-source-analyse\" target=\"_blank\" rel=\"noopener\">GitHub地址</a>，喜欢的同学可以fork或者star一下哦。里面我把源码都拉出来放到文件夹里面然后由create-react-app来调用，而不是直接用npm装。这有助于理解与调试，里面也有我的注释，其实可以直接阅读源码的注释会更快。</p>\n<p>redux和rdux-react的代码也是目前最新（2020-09-13）的master分支上面的。</p>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>redux是用的rollup打包的。</p>\n<p>打开根目录下面的<code>rollup.config.js</code>可以看到入口是src目录下的index文件。</p>\n<p>可以看到他导出的一些东西</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  createStore,</span><br><span class=\"line\">  combineReducers,</span><br><span class=\"line\">  bindActionCreators,</span><br><span class=\"line\">  applyMiddleware,</span><br><span class=\"line\">  compose,</span><br><span class=\"line\">  __DO_NOT_USE__ActionTypes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们一个个开始。首先映入眼帘的是createStore</p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>开始之前，我们先看看是怎么用。以下采用<a href=\"https://github.com/DerrickTel/redux-source-analyse\" target=\"_blank\" rel=\"noopener\">我的源码</a>阅读里面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(rootReducer, applyMiddleware(logger));</span><br></pre></td></tr></table></figure>\n\n<p>再看看源码的createStore。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>&lt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">S</span>,</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Action</span>,</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">Ext</span> = </span>&#123;&#125;,</span><br><span class=\"line\">  StateExt = never</span><br><span class=\"line\">&gt;(</span><br><span class=\"line\">  reducer: Reducer&lt;S, A&gt;,</span><br><span class=\"line\">  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;,</span><br><span class=\"line\">  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;</span><br><span class=\"line\">): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;</span><br><span class=\"line\">  <span class=\"comment\">//.. 一些校验的源码就不介绍了，想了解的可以看我的GitHub，上面有注释</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer <span class=\"comment\">// 临时存放 reducer 的地方</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState <span class=\"keyword\">as</span> S <span class=\"comment\">// 临时存放 state 的地方</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners: <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">void</span>)[] | <span class=\"literal\">null</span> = [] <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners <span class=\"comment\">// 引用赋值, 和正式的队列进行区分, 别有他用</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span> <span class=\"comment\">// 是不是正在dispatch</span></span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>createStore接收3个参数<code>reducer</code>，<code>preloadedState</code>，<code>enhancer</code>。</p>\n<p>我们一一剖析他们分别是做什么的。</p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p>这个大家太熟悉了。就是一个函数，然后我们在里面写<code>switch</code>，<code>switch</code> <code>dispatch</code>过来 <code>action</code>的<code>type</code>。然后做对应的操作。最后返回一个新的对象，也就是全新的<code>store</code>的数据。为什么是返回一个全新的<code>store</code>，是为了防止js的引用。</p>\n<p>忘记的，或者不太懂的同学可以看一下下面的demo：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = &#123;</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里面我们一般会赋值上默认的state，因为后续可能会用到默认的情况，像数组之类的就非常常见。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = initState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'TOGGLE_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.map(</span><br><span class=\"line\">        todo =&gt;</span><br><span class=\"line\">          todo.id === action.id ? &#123; ...todo, <span class=\"attr\">completed</span>: !todo.completed &#125; : todo</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todos</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"preloadedState\"><a href=\"#preloadedState\" class=\"headerlink\" title=\"preloadedState\"></a>preloadedState</h4><p>这个其实我们用的不是很多，因为我们一般预存的都直接卸载<code>reducer</code>里面了。像👆🌰里面的<code>state = initState</code>就省去了我们的传递这个参数的过程。而且数据放在<code>reducer</code>里面也更加清晰。</p>\n<p>哪怕是在<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">阮一峰老师的日志</a>里面也是这样教的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultState = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> reducer = <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + action.payload;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: </span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reducer(<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD'</span>,</span><br><span class=\"line\">  payload: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>中文翻译就是：预存的<code>state</code>。也可以理解为初始的，默认的。因为我们一般在也页面里面直接拿<code>store</code>里面的值，或者<code>map</code>或者什么。很有可能就会报错，因为如果没有默认值我们直接用<code>map</code>就会报错….相信刚刚开始用的小伙伴应该有这样的困惑。</p>\n<p>但是，我们通常都是传两个参数，那咋办？我看他好像是顺序读取的诶…</p>\n<p>redux兼容我们啦，我们可以看到前面有一段代码是为了做这个的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// preloadedState为function enhancer为undefined的时候说明initState没有初始化, 但是有middleware</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  enhancer = preloadedState <span class=\"comment\">// 把 preloadedState 赋值给 enhancer</span></span><br><span class=\"line\">  preloadedState = <span class=\"literal\">undefined</span> <span class=\"comment\">// preloadedState赋值undeifined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"enhancer\"><a href=\"#enhancer\" class=\"headerlink\" title=\"enhancer\"></a>enhancer</h4><p>中文翻译是：增强。其实就是我们常用的中间件，用于增强我们的<code>redux</code>。常见有的有<code>log</code>，<code>redux-thunk</code>，<code>redux-saga</code>等等。</p>\n<p>我们发现代码里面有一段是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// debugger</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数enhancer存在</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 传入符合参数类型的参数，就可以执行 enhancer,</span></span><br><span class=\"line\"><span class=\"comment\">     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能</span></span><br><span class=\"line\"><span class=\"comment\">     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料</span></span><br><span class=\"line\"><span class=\"comment\">     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，</span></span><br><span class=\"line\"><span class=\"comment\">     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined</span></span><br><span class=\"line\"><span class=\"comment\">     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * * */</span></span><br><span class=\"line\">    <span class=\"comment\">// debugger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个重点其实在于<code>applyMiddleware</code>，后续我们会介绍到的。</p>\n<h3 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h3><p>这个比较简单，我就都写在注释里面了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentReducer = reducer <span class=\"comment\">// 临时存放 reducer 的地方</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentState = preloadedState <span class=\"keyword\">as</span> S <span class=\"comment\">// 临时存放 state 的地方</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentListeners: <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">void</span>)[] | <span class=\"literal\">null</span> = [] <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextListeners = currentListeners <span class=\"comment\">// 引用赋值, 和正式的队列进行区分, 别有他用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span> <span class=\"comment\">// 是不是正在dispatch</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"内置方法\"><a href=\"#内置方法\" class=\"headerlink\" title=\"内置方法\"></a>内置方法</h3><h4 id=\"ensureCanMutateNextListeners\"><a href=\"#ensureCanMutateNextListeners\" class=\"headerlink\" title=\"ensureCanMutateNextListeners\"></a>ensureCanMutateNextListeners</h4><p>这里其实是为了弄两个数组，一个操作一个原数组而抽象的一个方法。</p>\n<p>有一个小的知识点，<code>===</code>对于数组的判断只能用于判断是否是同一个内存地址，不信的话大家可以试试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === c);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b === c);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以下面的操作的就变得很好理解了。在我们操作<code>listener</code>之前会先存储一下快照。大家要多理解一下，因为后面很多地方会用到这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Google翻译: 确保可以使下一个侦听器突变</span></span><br><span class=\"line\">  <span class=\"comment\">// 我的理解是存储一下快照, 以为接下来可能会进行操作.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否相同, 是不是简单的引用赋值, 是的话就浅拷贝一份</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</span><br><span class=\"line\">      nextListeners = currentListeners.slice()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"getState\"><a href=\"#getState\" class=\"headerlink\" title=\"getState\"></a>getState</h4><p>这个函数很简单，首先判断一下是否是在dispatch，然后返回当前的state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取当前的state</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>): <span class=\"title\">S</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatch 就报错,因为要获取最新的state, dispatch很有可能会改变state</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'You may not call store.getState() while the reducer is executing. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'The reducer has already received the state as an argument. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Pass it down from the top reducer instead of reading it from the store.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState <span class=\"keyword\">as</span> S</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>有没有感觉redux好像也不过如此~~接着看哦。</p>\n<h4 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h4><p>中文翻译：订阅者。</p>\n<p>其实也很好理解。可能有用过<code>redux</code>的同学都有用过这个。</p>\n<p>我举一个怎么用的🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unSubscribe = store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'store.subscribe'</span>, store.getState())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 取消订阅就直接调用这个函数就好了</span></span><br><span class=\"line\"><span class=\"comment\">// unSubscribe();</span></span><br></pre></td></tr></table></figure>\n\n<p>一旦触发了<code>dispatch</code>就会触发这个函数，也就是我们写上去的<code>console.log()</code></p>\n<p>然后我们再来看这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener: (</span>) =&gt; <span class=\"title\">void</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// listener必须为函数，因为要以回调函数的方式来触发。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the listener to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatch中则抛错，和getState同理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class=\"line\">          <span class=\"string\">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'See https://redux.js.org/api/store#subscribelistener for more details.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否有监听者,或者是否被订阅</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存快照, 拷贝一份监听队列到nextListeners(如果是引用的话)</span></span><br><span class=\"line\">    ensureCanMutateNextListeners()</span><br><span class=\"line\">    <span class=\"comment\">// 往监听队列里面推入一个监听者</span></span><br><span class=\"line\">    nextListeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回一个取消订阅的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有被订阅, 直接shut down</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果正在dispatch 报错，和上面👆同理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">'You may not unsubscribe from a store listener while the reducer is executing. '</span> +</span><br><span class=\"line\">            <span class=\"string\">'See https://redux.js.org/api/store#subscribelistener for more details.'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">      isSubscribed = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 依旧是拿下当前的监听队列，不然等一下删除的时候，会删掉所有的队列。其实我们只需要删掉监听者就好了</span></span><br><span class=\"line\">      ensureCanMutateNextListeners()</span><br><span class=\"line\">      <span class=\"comment\">// 找到监听者</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</span><br><span class=\"line\">      <span class=\"comment\">// 删除这个监听者</span></span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 清空当前的监听队列</span></span><br><span class=\"line\">      currentListeners = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h4><p>这个函数可以说是史上最TM常用的函数的，最TM重要之重中之重，而且还是更新store的唯一方法，注意这个唯一。但是又非常好理解。</p>\n<p>我们还是先看一个🌰吧：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'TEST'</span>,</span><br><span class=\"line\">  test1: <span class=\"number\">1</span>,</span><br><span class=\"line\">  test2: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们的store就改变了，就会更新props，来触发render，视图可能就会更新之类的。</p>\n<p>👌，现在我们有一个一点点了解，来看一下源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改store的唯一方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action: A</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// action必须是一个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Actions must be plain objects. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Use custom middleware for async actions.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// action必须拥有一个type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Actions may not have an undefined \"type\" property. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Have you misspelled a constant?'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatching，那么不执行dispatch操作。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置dispatching状态为true，并使用reducer生成新的状态树。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      isDispatching = <span class=\"literal\">true</span></span><br><span class=\"line\">      currentState = currentReducer(currentState, action)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当获取新的状态树完成后，设置状态为false.</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将目前最新的监听方法放置到即将执行的队列中遍历并且执行</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i]</span><br><span class=\"line\">      listener()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发的action返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> action</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实看下来，我们发现他就是简单的将我们的参数转发给了<code>reducer</code>，然后执行了我们之前建立的监听队列。</p>\n<p>有没有同学会和我想的一样，那为什么不直接执行<code>reducer</code>？因为我们里面有订阅函数需要执行，对吧，而且还有<code>dispatch</code>的状态需要通知<code>store</code>，不然<code>getState</code>之类的，我们之前有看到判断<code>dispatch</code>状态的很可能出现偏差。</p>\n<p>我们只需要<code>connect</code>一下就可以直接在<code>props</code>里面拿到<code>dispatch</code>，不需要<code>import</code>之类的，很简洁。</p>\n<h4 id=\"replaceReducer\"><a href=\"#replaceReducer\" class=\"headerlink\" title=\"replaceReducer\"></a>replaceReducer</h4><p>这个函数顾名思义，也很好理解，我就不多做解释了，直接看注释吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个其实很少用到, 官方的介绍是主要是用于动态替换reducer的时候会用到</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>&lt;<span class=\"title\">NewState</span>, <span class=\"title\">NewActions</span> <span class=\"title\">extends</span> <span class=\"title\">A</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    nextReducer: Reducer&lt;NewState, NewActions&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>): <span class=\"title\">Store</span>&lt;<span class=\"title\">ExtendState</span>&lt;<span class=\"title\">NewState</span>, <span class=\"title\">StateExt</span>&gt;, <span class=\"title\">NewActions</span>, <span class=\"title\">StateExt</span>, <span class=\"title\">Ext</span>&gt; &amp; <span class=\"title\">Ext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改reducer</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前的currentReducer更新为参数nextReducer</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> do this more elegantly</span></span><br><span class=\"line\">    ;((currentReducer <span class=\"keyword\">as</span> unknown) <span class=\"keyword\">as</span> Reducer&lt;</span><br><span class=\"line\">      NewState,</span><br><span class=\"line\">      NewActions</span><br><span class=\"line\">    &gt;) = nextReducer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This action has a similar effect to ActionTypes.INIT.</span></span><br><span class=\"line\">    <span class=\"comment\">// Any reducers that existed in both the new and old rootReducer</span></span><br><span class=\"line\">    <span class=\"comment\">// will receive the previous state. This effectively populates</span></span><br><span class=\"line\">    <span class=\"comment\">// the new state tree with any relevant data from the old one.</span></span><br><span class=\"line\">    <span class=\"comment\">// 和INIT的dispatch相同，发送一个dispatch初始化state，表明一下是REPLACE</span></span><br><span class=\"line\">    <span class=\"comment\">// 自己👀看一下utils方法的ActionTypes， 随性的随机数</span></span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125; <span class=\"keyword\">as</span> A)</span><br><span class=\"line\">    <span class=\"comment\">// change the type of the store by casting it to the new store</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (store <span class=\"keyword\">as</span> unknown) <span class=\"keyword\">as</span> Store&lt;</span><br><span class=\"line\">      ExtendState&lt;NewState, StateExt&gt;,</span><br><span class=\"line\">      NewActions,</span><br><span class=\"line\">      StateExt,</span><br><span class=\"line\">      Ext</span><br><span class=\"line\">    &gt; &amp;</span><br><span class=\"line\">      Ext</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现两个很有趣的点：</p>\n<ol>\n<li>大佬们也会写<code>todo</code>，关键是！他们的<code>TODO</code>年头有点久了，哈哈哈哈，5年了，看样子不是只有我不会继续优化的，哈哈哈哈。也有可能是没有想到更好的方法。。。</li>\n<li>里面他自己<code>dispatch</code>了一个，<code>ActionTypes.REPLACE</code>。</li>\n</ol>\n<p>ok，我们一探究竟，这个<code>ActionTypes.REPLACE</code></p>\n<p>扒开衣服！直接开看👀！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * These are private action types reserved by Redux.</span></span><br><span class=\"line\"><span class=\"comment\"> * For any unknown actions, you must return the current state.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the current state is undefined, you must return the initial state.</span></span><br><span class=\"line\"><span class=\"comment\"> * Do not reference these action types directly in your code.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> randomString = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substring(<span class=\"number\">7</span>).split(<span class=\"string\">''</span>).join(<span class=\"string\">'.'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ActionTypes = &#123;</span><br><span class=\"line\">  INIT: <span class=\"string\">`@@redux/INIT<span class=\"subst\">$&#123;<span class=\"regexp\">/* #__PURE__ */</span> randomString()&#125;</span>`</span>,</span><br><span class=\"line\">  REPLACE: <span class=\"string\">`@@redux/REPLACE<span class=\"subst\">$&#123;<span class=\"regexp\">/* #__PURE__ */</span> randomString()&#125;</span>`</span>,</span><br><span class=\"line\">  PROBE_UNKNOWN_ACTION: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`@@redux/PROBE_UNKNOWN_ACTION<span class=\"subst\">$&#123;randomString()&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ActionTypes</span><br></pre></td></tr></table></figure>\n\n<p>其实就是一个不想和我们的<code>type</code>冲突的随机数，告诉<code>redux</code>，这个是他们内部的一个<code>dispatch</code>而已。</p>\n<h4 id=\"observable\"><a href=\"#observable\" class=\"headerlink\" title=\"observable\"></a>observable</h4><p>这个玩意，其实我是不太懂他是干什么的。。。全局搜也没有搜出来，而且我也没用过。。。</p>\n<p>大家看注释吧，不过多解释，如果有懂哥，欢迎一起交流讨论呀。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询之后,也没发现有什么特别的用处...暂时跳过,如果有帅哥看到的话可以不吝赐教</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> outerSubscribe = subscribe</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       The minimal observable subscription method.</span></span><br><span class=\"line\"><span class=\"comment\">       <span class=\"doctag\">@param </span>observer Any object that can be used as an observer.</span></span><br><span class=\"line\"><span class=\"comment\">       The observer object should have a `next` method.</span></span><br><span class=\"line\"><span class=\"comment\">       <span class=\"doctag\">@returns </span>An object with an `unsubscribe` method that can</span></span><br><span class=\"line\"><span class=\"comment\">       be used to unsubscribe the observable from the store, and prevent further</span></span><br><span class=\"line\"><span class=\"comment\">       emission of values from the observable.</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      subscribe(observer: unknown) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> observer !== <span class=\"string\">'object'</span> || observer === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Expected the observer to be an object.'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取观察着的状态</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observeState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> observerAsObserver = observer <span class=\"keyword\">as</span> Observer&lt;S&gt;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (observerAsObserver.next) &#123;</span><br><span class=\"line\">            observerAsObserver.next(getState())</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        observeState()</span><br><span class=\"line\">        <span class=\"comment\">//返回取消订阅的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> unsubscribe = outerSubscribe(observeState)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; unsubscribe &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      [$$observable]() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实他内部还自己执行了一下<code>dispatch</code>，在<code>createStore</code>的最后。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125; <span class=\"keyword\">as</span> A)</span><br></pre></td></tr></table></figure>\n\n<p>其实也很好理解，我们<code>createStore</code>的时候，初始的<code>state</code>就是这样来的~</p>\n<p>里面的<code>INIT</code>，在我们之前<code>REPLACE</code>里面也有介绍，也是一个随机数而已。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>这个坑，是之前在<code>createStore</code>的<code>ensureCanMutateNextListeners</code>埋下的，现在我们一起来看看这个。</p>\n<p>这个redux拓展dispatch的唯一的标准的方法。</p>\n<p>首先，我们得知道怎么用。我贴下我自己demo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个是官方的demo，不了解的，<a href=\"https://www.redux.org.cn/docs/advanced/Middleware.html\" target=\"_blank\" rel=\"noopener\">点我快速了解</a></p>\n<p>ok，我们直接贴源码，很短，但是有很多奥妙（奥妙打钱！）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  ...middlewares: Middleware[]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">StoreEnhancer</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore: StoreEnhancerStoreCreator</span>) =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">S,</span> <span class=\"attr\">A</span> <span class=\"attr\">extends</span> <span class=\"attr\">AnyAction</span>&gt;</span>(</span></span><br><span class=\"line\">    reducer: Reducer&lt;S, A&gt;,</span><br><span class=\"line\">    preloadedState?: PreloadedState&lt;S&gt;</span><br><span class=\"line\">  ) =&gt; &#123;</span><br><span class=\"line\">    const store = createStore(reducer, preloadedState)</span><br><span class=\"line\">    let dispatch: Dispatch = () =&gt; &#123;</span><br><span class=\"line\">      throw new Error(</span><br><span class=\"line\">        'Dispatching while constructing your middleware is not allowed. ' +</span><br><span class=\"line\">          'Other middleware would not be applied to this dispatch.'</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const middlewareAPI: MiddlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: (action, ...args) =&gt; dispatch(action, ...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class=\"line\">    dispatch = compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很短，但是却有很多深奥的地方。一个个来。</p>\n<p>在开始之前，我们需要先了解一下函数柯里化。直接上demo帮助理解</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> t = test(<span class=\"number\">1</span>);</span><br><span class=\"line\">t(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>这里就是一个简单的函数柯里化，我们可以先存储一下第一次传入的参数，后面如果这个<code>1</code>会复用的话，那么我们定义的变量<code>t</code>就可以在很多地方使用，里面用到了闭包的知识，而且是非常典型的闭包，存储形参<code>a</code>，实参<code>1</code>。</p>\n<p>还记得我们的使用用例吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面第一个参数<code>store</code>就是对应到我们<code>createStore</code>源码里面我们挖的坑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 传入符合参数类型的参数，就可以执行 enhancer,</span></span><br><span class=\"line\"><span class=\"comment\">     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能</span></span><br><span class=\"line\"><span class=\"comment\">     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料</span></span><br><span class=\"line\"><span class=\"comment\">     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，</span></span><br><span class=\"line\"><span class=\"comment\">     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined</span></span><br><span class=\"line\"><span class=\"comment\">     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * * */</span></span><br><span class=\"line\">    <span class=\"comment\">// debugger</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(</span><br><span class=\"line\">      reducer,</span><br><span class=\"line\">      preloadedState <span class=\"keyword\">as</span> PreloadedState&lt;S&gt;</span><br><span class=\"line\">    ) <span class=\"keyword\">as</span> Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个<code>next</code>，其实就是<code>middlewareAPI</code>里面的<code>dispatch</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">action, ...args</span>) =&gt;</span> dispatch(action, ...args),</span><br><span class=\"line\">      test:<span class=\"number\">2</span>,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>增加一个<code>log</code>在<code>middleware</code>里面就可以知道了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"comment\">// const result = next(action);</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"comment\">// return result</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候<code>log</code>的是我们在<code>createStore</code>里面的<code>dispatch</code>，还出现了我们的注释</p>\n<p>说明<code>next</code>这个参数就是对应的<code>middlewareAPI</code>里面的<code>dispatch</code>也就是说是<code>createStore</code>里面的<code>dispatch</code>。</p>\n<p>第三个参数<code>action</code></p>\n<p>很简单，其实就是普普通通的一个<code>action</code>。不过是从我们<code>middleaware</code>里面得到的。这个没有疑惑。</p>\n<blockquote>\n<p>我们会发现一个很有趣的事情就是，如果我们注释掉调用<code>next(action)</code>，并且不将结果<code>return</code>的话，这个<code>action</code>就会被卡住，没有发出去，被我们打断了，所以这就是我们为什么需要做这个的原因。那么就可以引申出我们可以自定义打断某些情况下的action，然后需要在那些情况下给action里面加些什么，都可以办到。</p>\n</blockquote>\n<p>ok，我们看了之后好像知道<code>applyMiddleware</code>里面的参数都对应这哪些东西了，但是似乎不知道为什么是一种柯里化的形式来展示的。我们看下面的代码就会知道了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用每一个这样形式的middleware = store =&gt; next =&gt; action =&gt;&#123;&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">// 组成一个这样[f(next)=&gt;acticon=&gt;next(action)...]的array，赋值给chain</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\"><span class=\"comment\">// debugger</span></span><br><span class=\"line\"><span class=\"comment\">// compose看 -&gt; compose.js文件</span></span><br><span class=\"line\"><span class=\"comment\">// compose(...chain)会形成一个调用链, next指代下一个函数的注册, 这就是中间件的返回值要是next(action)的原因</span></span><br><span class=\"line\"><span class=\"comment\">// 如果执行到了最后next就是原生的store.dispatch方法</span></span><br><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n\n<p>里面提到了<code>compose</code>这个函数，其实这个函数就是整个中间件的精髓所在。柯里化的奥义！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs: Function[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// infer the argument type so it is usable in inference down the line</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">T</span>&gt;</span>(arg: T) =&gt; arg</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">  if (funcs.length === 1) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    return funcs[0]</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">  return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>不了解reduce的同学可以<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">点这里</a>。</p>\n<p>这个compose其实是一个调用链，我们的所有的中间件都会按顺序加载，然后是👇这种形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middleware = <span class=\"function\"><span class=\"params\">middleware1</span> =&gt;</span> <span class=\"function\"><span class=\"params\">middleware2</span> =&gt;</span> <span class=\"function\"><span class=\"params\">middleware3</span> =&gt;</span> middleware4 <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过一下代码知道，确实是往下传递的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  action.aa = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger2 = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next2==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'logger2==-=-=-=-=-=-='</span>,action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer, &#123;<span class=\"attr\">todos</span>:[]&#125;, applyMiddleware(logger, logger2));</span><br></pre></td></tr></table></figure>\n\n<p>在<code>logger2</code>里面确实打印出来<code>aa</code>这个属性的值，而<code>logger</code>却没有</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p>这个在上面介绍applyMiddleware的时候说过了。就不多说了。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>这个中文翻译就是《组合reducer》。</p>\n<p>其实就是 字面意思，我们看一下怎么用就了解了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  firstReducer: todos,</span><br><span class=\"line\">  secondReducer: visibilityFilter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后我们看一下<code>log</code>出来的<code>props</code>是什么样子的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tfirstReducer: &#123;<span class=\"attr\">todos</span>: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">\tsecondReducer: <span class=\"string\">\"SHOW_ALL\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是我们一开始设置进去的<code>key</code>值，返回的时候也是按这个格式返回的。</p>\n<p>里面有许多函数，我们先看他到处的函数<code>combineReducers</code></p>\n<h3 id=\"combineReducers-1\"><a href=\"#combineReducers-1\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于合并reducer 一般是这样combineReducers(&#123;a,b,c&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers: ReducersMapObject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// reducers中key的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\">  <span class=\"comment\">// 最终的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducers: ReducersMapObject = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接受当前的key</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = reducerKeys[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是生产环境， 当前的reducer是undefined会给出warning</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        warning(<span class=\"string\">`No reducer provided for key \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reducer要是一个function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 赋值给finalReducers</span></span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 符合规范的reducer的key数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// This is used to make sure we don't warn about the same</span></span><br><span class=\"line\">  <span class=\"comment\">// keys multiple times.</span></span><br><span class=\"line\">  <span class=\"comment\">// 意想不到的key， 先往下看看</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> unexpectedKeyCache: &#123; [key: string]: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  <span class=\"comment\">// production环境为&#123;&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">    unexpectedKeyCache = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> shapeAssertionError: <span class=\"built_in\">Error</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 看这个function</span></span><br><span class=\"line\">    assertReducerShape(finalReducers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    shapeAssertionError = e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回function， 即为createStore中的reducer参数既currentReducer</span></span><br><span class=\"line\">  <span class=\"comment\">// 自然有state和action两个参数， 可以回createStore文件看看currentReducer(currentState, action)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    state: StateFromReducersMapObject&lt;typeof reducers&gt; = &#123;&#125;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    action: AnyAction</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reducer不规范报错</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shapeAssertionError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> shapeAssertionError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class=\"line\">        state,</span><br><span class=\"line\">        finalReducers,</span><br><span class=\"line\">        action,</span><br><span class=\"line\">        unexpectedKeyCache</span><br><span class=\"line\">      )</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState: StateFromReducersMapObject&lt;<span class=\"keyword\">typeof</span> reducers&gt; = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 获取finalReducerKeys的key和value（function）</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 当前key的state值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 执行reducer， 返回当前state</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不存在返回值报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新的state放在nextState对应的key里</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 判断新的state是不是同一引用， 以检验reducer是不是纯函数</span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hasChanged =</span><br><span class=\"line\">      hasChanged || finalReducerKeys.length !== <span class=\"built_in\">Object</span>.keys(state).length</span><br><span class=\"line\">      <span class=\"comment\">// 改变了返回nextState</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  *  新版本的redux这部分改变了实现方法</span></span><br><span class=\"line\"><span class=\"comment\">  *  老版本的redux使用的reduce函数实现的</span></span><br><span class=\"line\"><span class=\"comment\">  *  简单例子如下</span></span><br><span class=\"line\"><span class=\"comment\">  * function combineReducers(reducers) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *    return (state = &#123;&#125;, action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *        return Object.keys(reducers).reduce((currentState, key) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *            currentState[key] = reducers[key](state[key], action);</span></span><br><span class=\"line\"><span class=\"comment\">  *             return currentState;</span></span><br><span class=\"line\"><span class=\"comment\">  *         &#125;, &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * </span></span><br><span class=\"line\"><span class=\"comment\">  * */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面是主要源码，一个个剖析进去。</p>\n<p>先是对数据进行清洗，第一次筛选出符合要求的<code>reducer</code>们</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reducers中key的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\">  <span class=\"comment\">// 最终的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducers: ReducersMapObject = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接受当前的key</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = reducerKeys[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是生产环境， 当前的reducer是undefined会给出warning</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        warning(<span class=\"string\">`No reducer provided for key \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reducer要是一个function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 赋值给finalReducers</span></span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"assertReducerShape\"><a href=\"#assertReducerShape\" class=\"headerlink\" title=\"assertReducerShape\"></a>assertReducerShape</h3><p>初筛之后的finalReducers会交由assertReducerShape再一次进行检验。里面就是一个判断，然后给出警告⚠️之类的。就不多说了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertReducerShape</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(reducers).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> reducer = reducers[key]</span><br><span class=\"line\">   <span class=\"comment\">// reducer返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = reducer(<span class=\"literal\">undefined</span>, &#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// undefined throw Error</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> initialState === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Reducer \"<span class=\"subst\">$&#123;key&#125;</span>\" returned undefined during initialization. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`If the state passed to the reducer is undefined, you must `</span> +</span><br><span class=\"line\">          <span class=\"string\">`explicitly return the initial state. The initial state may `</span> +</span><br><span class=\"line\">          <span class=\"string\">`not be undefined. If you don't want to set a value for this reducer, `</span> +</span><br><span class=\"line\">          <span class=\"string\">`you can use null instead of undefined.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 很明显assertReducerShape是用于reducer的规范</span></span><br><span class=\"line\">    <span class=\"comment\">// 回到combineReducers</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> reducer(<span class=\"literal\">undefined</span>, &#123;</span><br><span class=\"line\">        type: ActionTypes.PROBE_UNKNOWN_ACTION()</span><br><span class=\"line\">      &#125;) === <span class=\"string\">'undefined'</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Reducer \"<span class=\"subst\">$&#123;key&#125;</span>\" returned undefined when probed with a random type. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Don't try to handle <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">            ActionTypes.INIT</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">          &#125;</span> or other actions in \"redux/*\" `</span> +</span><br><span class=\"line\">          <span class=\"string\">`namespace. They are considered private. Instead, you must return the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`current state for any unknown actions, unless it is undefined, `</span> +</span><br><span class=\"line\">          <span class=\"string\">`in which case you must return the initial state, regardless of the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`action type. The initial state may not be undefined, but can be null.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"combination\"><a href=\"#combination\" class=\"headerlink\" title=\"combination\"></a>combination</h3><p>然后就是返回combination这个函数。参数的意义就是他的名字。就不多说了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reducer不规范报错</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shapeAssertionError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> shapeAssertionError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class=\"line\">        state,</span><br><span class=\"line\">        finalReducers,</span><br><span class=\"line\">        action,</span><br><span class=\"line\">        unexpectedKeyCache</span><br><span class=\"line\">      )</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取finalReducerKeys的key和value（function）</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 当前key的state值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 执行reducer， 返回当前state</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不存在返回值报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新的state放在nextState对应的key里</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 判断新的state是不是同一引用， 以检验reducer是不是纯函数</span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 改变了返回nextState</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  *  新版本的redux这部分改变了实现方法</span></span><br><span class=\"line\"><span class=\"comment\">  *  老版本的redux使用的reduce函数实现的</span></span><br><span class=\"line\"><span class=\"comment\">  *  简单例子如下</span></span><br><span class=\"line\"><span class=\"comment\">  * function combineReducers(reducers) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *    return (state = &#123;&#125;, action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *        return Object.keys(reducers).reduce((currentState, key) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *            currentState[key] = reducers[key](state[key], action);</span></span><br><span class=\"line\"><span class=\"comment\">  *             return currentState;</span></span><br><span class=\"line\"><span class=\"comment\">  *         &#125;, &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * </span></span><br><span class=\"line\"><span class=\"comment\">  * */</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实就是执行reducer，然后把值拿出来比对，如果是引用的话就返回之前的state，如果不是就使用新的。他的比对和之前说的数组比对一样，都是比对内存地址。</p>\n<p>为什么要这么做呢？</p>\n<p>好问题！</p>\n<p>这样做的好处其实就是为了纯函数，为了一切可预测。而且简单的比较内存地址比递归的性能好太多了。</p>\n<p>那么我们怎么样才可以契合这样的理念呢？</p>\n<p>就是我们在写reducer返回的时候，需要返回一个全新的对象，通常是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">\t...state,</span><br><span class=\"line\">\txx: xx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似这样。这样的话js就会新开辟一个内存地址出来。在比对的时候内存地址就不会相同了。</p>\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators\"></a>bindActionCreators</h2><p>这个函数其实非常少用到，而且也没有什么特别晦涩的东西，只是一个封装。但是是一种更为优雅的方式。</p>\n<p>直接看代码，很少。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">actionCreators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// actionCreators为function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不是object throw Error</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">`bindActionCreators expected an object or a function, instead received <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        actionCreators === <span class=\"literal\">null</span> ? <span class=\"string\">'null'</span> : <span class=\"keyword\">typeof</span> actionCreators</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>. `</span> +</span><br><span class=\"line\">        <span class=\"string\">`Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// object 转为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\">  <span class=\"comment\">// 定义return 的props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// actionCreators的key 通常为actionCreators function的name（方法名）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"comment\">// function =&gt; actionCreators工厂方法本身</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 参数为&#123;actions：function xxx&#125;是返回相同的类型</span></span><br><span class=\"line\">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// return 的props</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> boundActionCreators</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单也很清晰，就是弄一个新的对象，然后把<code>actionCreators</code>里面的<code>value</code>变成<code>bindActionCreator(actionCreator, dispatch)</code>的值，那么一起看一下<code>bindActionCreator</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">AnyAction</span> = <span class=\"title\">AnyAction</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  actionCreator: ActionCreator&lt;A&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  dispatch: Dispatch</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">this: any, ...args: any[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator.apply(<span class=\"keyword\">this</span>, args))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里看起来有点迷糊，看也是能看懂，其实就是返回一个方法，这个方法是干什么的呢？返回执行dispatch之后的返回值。这么搞这么一圈究竟有什么秘密呢？</p>\n<p>我们写一个demo就会知道了。</p>\n<p>假如我们要做一个动态的增加的action，分别为点击一次+1，点击一次+2，点击一次+3。</p>\n<p>我们需要</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterIncActionCreator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'INCREMENT'</span>,</span><br><span class=\"line\">    step: step || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了简化代码我把dispatch函数定义为只有打印功能的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dispatch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action1 = counterIncActionCreator()</span><br><span class=\"line\">dispatch(action1) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action2 = counterIncActionCreator(<span class=\"number\">2</span>)</span><br><span class=\"line\">dispatch(action2) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action3 = counterIncActionCreator(<span class=\"number\">3</span>)</span><br><span class=\"line\">dispatch(action3) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>有点难受其实，但是我们用了<code>bindActionCreator</code>之后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> increment = bindActionCreator(counterIncActionCreator, dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">increment() <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>就整个帅起来，有没有？！更加优雅了。</p>\n<p>而且我们还可以制作增和减的两个工厂🏭</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyActionCreators = &#123;</span><br><span class=\"line\">  increment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'INCREMENT'</span>,</span><br><span class=\"line\">      step: step || <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  decrement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'DECREMENT'</span>,</span><br><span class=\"line\">      step: - (step || <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>老方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原始的调度方式</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment()) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment(<span class=\"number\">2</span>)) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment(<span class=\"number\">3</span>)) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement()) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -1 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement(<span class=\"number\">2</span>)) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -2 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement(<span class=\"number\">3</span>)) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>进化之后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyNewActionCreators.increment() <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.increment(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.increment(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement() <span class=\"comment\">// &#123; type: 'DECREMENT', step: -1 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -2 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Redux总结\"><a href=\"#Redux总结\" class=\"headerlink\" title=\"Redux总结\"></a>Redux总结</h2><p>至此我们的redux源码阅读就到此为止。</p>\n<p>接下来我们一起学习一下和redux配合使用的react-redux</p>\n<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><p>React 原本和redux没有关系，redux只是负责数据处理，理论上无论是vue或者angular都可以使用。</p>\n<p>但是react-redux将react和redux紧密的联系在了一起。用更符合react的方式来调用redux。</p>\n<p>后续会出一篇介绍react-redux的文章。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>自此redux源码阅读算是告一段落了。其实源码很简单，但是思想却很高级。</p>\n<p>如果有不懂的，或者哪里说错了，小伙伴欢迎在评论区讨论。</p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><blockquote>\n<p><a href=\"https://juejin.im/post/6844903638377185288\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903638377185288</a></p>\n<p><a href=\"https://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">https://www.redux.org.cn/</a></p>\n</blockquote>\n<blockquote>\n<p>实在是没有地方吐槽，我在这里说一下最近的事情吧。先是部门黄了，然后大领导换人了，大领导不知道是不是新官上任三把火，非要搞什么提效，其实就是把人弄走，然后加大工作量，刚刚开始换组我就去写很老的vue项目，没有鄙视vue的意思，是因为我之前都在写react，然后一下让我写，也不太适应而已，还是很少的版本。那就写就写吧，反正做前端的都得学不是？可是，大领导为了给做给老板看，然后让我们下班不要走，就是没有事情做就干坐着的那种。本着90后的性子我就走了，然后我走了之后，有些小伙伴可能也开始走了，然后我就被抓去劝退了….我也没有死皮赖脸的赖着。借口也非常的奇葩”你活在自己的世界里面，没有关心周围同事忙不忙，改bug不积极，代码质量低”之类的。。。可是我只是工作的时候戴着而已，因为经常有产品上来就在旁边开始讨论了，然后我自己的工作都做不完，怎么关心同事啊。。强行加了工作量之后我都很晚走或者回家工作了。因为在公司赖着真的很难受，为什么不在自己舒适的家中工作呢？还可以马上睡觉那种，音乐还可以外放。。。再说了我之前的代码，因为项目黄了，应该没人看了吧….唉，其实就是 劝退。我都懂。</p>\n<p>但是我的简历其实变得极其丑陋了，因为我年初的才跳槽过来的。现在这个时间非常尴尬….而且我来的第一天听说要996，马上提了离职申请，我的领导同意了，可以之前的大领导和我说以后不会996了就是正常上下班。。然后他就跳槽了。。。</p>\n<p>算是自己不认真审查公司，不过他们也太骗人了吧…唉。</p>\n<p>现在在家里也很焦虑，不知道找不找得到工作，杭州的公司看了一圈都是996，学阿里的加班不学阿里的工资。。。</p>\n<p>国庆以后再说吧，希望早点把重识前端系列更完。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<p><a href=\"https://juejin.im/post/6867814019055484942\" target=\"_blank\" rel=\"noopener\">【重识前端】暴走的异步编程</a></p>\n<p><a href=\"https://juejin.im/post/6877910314110140423/\" target=\"_blank\" rel=\"noopener\">【重识前端】redux源码阅读</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前一直在使用redux，后来出了hooks，用的比较少了，但是还是会使用，他们不冲突，各自对应的场景不同。听说redux源码比较少，也比较好懂（不是贬低，越强的代码其实越简洁明了）</p>\n<p>所以准备阅读一下，也算是重识前端系列的一员吧。</p>\n<p>注意一下，其实我们写react的时候用到的其实是redux-react。后面也会一起介绍。</p>\n<p>更好的阅读体验其实是在项目里面打断点，这里是我的<a href=\"https://github.com/DerrickTel/redux-source-analyse\" target=\"_blank\" rel=\"noopener\">GitHub地址</a>，喜欢的同学可以fork或者star一下哦。里面我把源码都拉出来放到文件夹里面然后由create-react-app来调用，而不是直接用npm装。这有助于理解与调试，里面也有我的注释，其实可以直接阅读源码的注释会更快。</p>\n<p>redux和rdux-react的代码也是目前最新（2020-09-13）的master分支上面的。</p>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>redux是用的rollup打包的。</p>\n<p>打开根目录下面的<code>rollup.config.js</code>可以看到入口是src目录下的index文件。</p>\n<p>可以看到他导出的一些东西</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  createStore,</span><br><span class=\"line\">  combineReducers,</span><br><span class=\"line\">  bindActionCreators,</span><br><span class=\"line\">  applyMiddleware,</span><br><span class=\"line\">  compose,</span><br><span class=\"line\">  __DO_NOT_USE__ActionTypes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们一个个开始。首先映入眼帘的是createStore</p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p>开始之前，我们先看看是怎么用。以下采用<a href=\"https://github.com/DerrickTel/redux-source-analyse\" target=\"_blank\" rel=\"noopener\">我的源码</a>阅读里面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(rootReducer, applyMiddleware(logger));</span><br></pre></td></tr></table></figure>\n\n<p>再看看源码的createStore。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>&lt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">S</span>,</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Action</span>,</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">Ext</span> = </span>&#123;&#125;,</span><br><span class=\"line\">  StateExt = never</span><br><span class=\"line\">&gt;(</span><br><span class=\"line\">  reducer: Reducer&lt;S, A&gt;,</span><br><span class=\"line\">  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;,</span><br><span class=\"line\">  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;</span><br><span class=\"line\">): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;</span><br><span class=\"line\">  <span class=\"comment\">//.. 一些校验的源码就不介绍了，想了解的可以看我的GitHub，上面有注释</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer <span class=\"comment\">// 临时存放 reducer 的地方</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState <span class=\"keyword\">as</span> S <span class=\"comment\">// 临时存放 state 的地方</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners: <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">void</span>)[] | <span class=\"literal\">null</span> = [] <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners <span class=\"comment\">// 引用赋值, 和正式的队列进行区分, 别有他用</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span> <span class=\"comment\">// 是不是正在dispatch</span></span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>createStore接收3个参数<code>reducer</code>，<code>preloadedState</code>，<code>enhancer</code>。</p>\n<p>我们一一剖析他们分别是做什么的。</p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p>这个大家太熟悉了。就是一个函数，然后我们在里面写<code>switch</code>，<code>switch</code> <code>dispatch</code>过来 <code>action</code>的<code>type</code>。然后做对应的操作。最后返回一个新的对象，也就是全新的<code>store</code>的数据。为什么是返回一个全新的<code>store</code>，是为了防止js的引用。</p>\n<p>忘记的，或者不太懂的同学可以看一下下面的demo：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = &#123;</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里面我们一般会赋值上默认的state，因为后续可能会用到默认的情况，像数组之类的就非常常见。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = initState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'TOGGLE_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.map(</span><br><span class=\"line\">        todo =&gt;</span><br><span class=\"line\">          todo.id === action.id ? &#123; ...todo, <span class=\"attr\">completed</span>: !todo.completed &#125; : todo</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todos</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"preloadedState\"><a href=\"#preloadedState\" class=\"headerlink\" title=\"preloadedState\"></a>preloadedState</h4><p>这个其实我们用的不是很多，因为我们一般预存的都直接卸载<code>reducer</code>里面了。像👆🌰里面的<code>state = initState</code>就省去了我们的传递这个参数的过程。而且数据放在<code>reducer</code>里面也更加清晰。</p>\n<p>哪怕是在<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">阮一峰老师的日志</a>里面也是这样教的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultState = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> reducer = <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + action.payload;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: </span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reducer(<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD'</span>,</span><br><span class=\"line\">  payload: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>中文翻译就是：预存的<code>state</code>。也可以理解为初始的，默认的。因为我们一般在也页面里面直接拿<code>store</code>里面的值，或者<code>map</code>或者什么。很有可能就会报错，因为如果没有默认值我们直接用<code>map</code>就会报错….相信刚刚开始用的小伙伴应该有这样的困惑。</p>\n<p>但是，我们通常都是传两个参数，那咋办？我看他好像是顺序读取的诶…</p>\n<p>redux兼容我们啦，我们可以看到前面有一段代码是为了做这个的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// preloadedState为function enhancer为undefined的时候说明initState没有初始化, 但是有middleware</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  enhancer = preloadedState <span class=\"comment\">// 把 preloadedState 赋值给 enhancer</span></span><br><span class=\"line\">  preloadedState = <span class=\"literal\">undefined</span> <span class=\"comment\">// preloadedState赋值undeifined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"enhancer\"><a href=\"#enhancer\" class=\"headerlink\" title=\"enhancer\"></a>enhancer</h4><p>中文翻译是：增强。其实就是我们常用的中间件，用于增强我们的<code>redux</code>。常见有的有<code>log</code>，<code>redux-thunk</code>，<code>redux-saga</code>等等。</p>\n<p>我们发现代码里面有一段是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// debugger</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数enhancer存在</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 传入符合参数类型的参数，就可以执行 enhancer,</span></span><br><span class=\"line\"><span class=\"comment\">     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能</span></span><br><span class=\"line\"><span class=\"comment\">     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料</span></span><br><span class=\"line\"><span class=\"comment\">     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，</span></span><br><span class=\"line\"><span class=\"comment\">     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined</span></span><br><span class=\"line\"><span class=\"comment\">     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * * */</span></span><br><span class=\"line\">    <span class=\"comment\">// debugger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个重点其实在于<code>applyMiddleware</code>，后续我们会介绍到的。</p>\n<h3 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h3><p>这个比较简单，我就都写在注释里面了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentReducer = reducer <span class=\"comment\">// 临时存放 reducer 的地方</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentState = preloadedState <span class=\"keyword\">as</span> S <span class=\"comment\">// 临时存放 state 的地方</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentListeners: <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">void</span>)[] | <span class=\"literal\">null</span> = [] <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextListeners = currentListeners <span class=\"comment\">// 引用赋值, 和正式的队列进行区分, 别有他用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span> <span class=\"comment\">// 是不是正在dispatch</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"内置方法\"><a href=\"#内置方法\" class=\"headerlink\" title=\"内置方法\"></a>内置方法</h3><h4 id=\"ensureCanMutateNextListeners\"><a href=\"#ensureCanMutateNextListeners\" class=\"headerlink\" title=\"ensureCanMutateNextListeners\"></a>ensureCanMutateNextListeners</h4><p>这里其实是为了弄两个数组，一个操作一个原数组而抽象的一个方法。</p>\n<p>有一个小的知识点，<code>===</code>对于数组的判断只能用于判断是否是同一个内存地址，不信的话大家可以试试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === c);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b === c);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以下面的操作的就变得很好理解了。在我们操作<code>listener</code>之前会先存储一下快照。大家要多理解一下，因为后面很多地方会用到这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Google翻译: 确保可以使下一个侦听器突变</span></span><br><span class=\"line\">  <span class=\"comment\">// 我的理解是存储一下快照, 以为接下来可能会进行操作.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否相同, 是不是简单的引用赋值, 是的话就浅拷贝一份</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</span><br><span class=\"line\">      nextListeners = currentListeners.slice()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"getState\"><a href=\"#getState\" class=\"headerlink\" title=\"getState\"></a>getState</h4><p>这个函数很简单，首先判断一下是否是在dispatch，然后返回当前的state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取当前的state</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>): <span class=\"title\">S</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatch 就报错,因为要获取最新的state, dispatch很有可能会改变state</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'You may not call store.getState() while the reducer is executing. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'The reducer has already received the state as an argument. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Pass it down from the top reducer instead of reading it from the store.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState <span class=\"keyword\">as</span> S</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>有没有感觉redux好像也不过如此~~接着看哦。</p>\n<h4 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h4><p>中文翻译：订阅者。</p>\n<p>其实也很好理解。可能有用过<code>redux</code>的同学都有用过这个。</p>\n<p>我举一个怎么用的🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unSubscribe = store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'store.subscribe'</span>, store.getState())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 取消订阅就直接调用这个函数就好了</span></span><br><span class=\"line\"><span class=\"comment\">// unSubscribe();</span></span><br></pre></td></tr></table></figure>\n\n<p>一旦触发了<code>dispatch</code>就会触发这个函数，也就是我们写上去的<code>console.log()</code></p>\n<p>然后我们再来看这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener: (</span>) =&gt; <span class=\"title\">void</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// listener必须为函数，因为要以回调函数的方式来触发。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the listener to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatch中则抛错，和getState同理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class=\"line\">          <span class=\"string\">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'See https://redux.js.org/api/store#subscribelistener for more details.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否有监听者,或者是否被订阅</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存快照, 拷贝一份监听队列到nextListeners(如果是引用的话)</span></span><br><span class=\"line\">    ensureCanMutateNextListeners()</span><br><span class=\"line\">    <span class=\"comment\">// 往监听队列里面推入一个监听者</span></span><br><span class=\"line\">    nextListeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回一个取消订阅的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有被订阅, 直接shut down</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果正在dispatch 报错，和上面👆同理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">'You may not unsubscribe from a store listener while the reducer is executing. '</span> +</span><br><span class=\"line\">            <span class=\"string\">'See https://redux.js.org/api/store#subscribelistener for more details.'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">      isSubscribed = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 依旧是拿下当前的监听队列，不然等一下删除的时候，会删掉所有的队列。其实我们只需要删掉监听者就好了</span></span><br><span class=\"line\">      ensureCanMutateNextListeners()</span><br><span class=\"line\">      <span class=\"comment\">// 找到监听者</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</span><br><span class=\"line\">      <span class=\"comment\">// 删除这个监听者</span></span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 清空当前的监听队列</span></span><br><span class=\"line\">      currentListeners = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a>dispatch</h4><p>这个函数可以说是史上最TM常用的函数的，最TM重要之重中之重，而且还是更新store的唯一方法，注意这个唯一。但是又非常好理解。</p>\n<p>我们还是先看一个🌰吧：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'TEST'</span>,</span><br><span class=\"line\">  test1: <span class=\"number\">1</span>,</span><br><span class=\"line\">  test2: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们的store就改变了，就会更新props，来触发render，视图可能就会更新之类的。</p>\n<p>👌，现在我们有一个一点点了解，来看一下源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改store的唯一方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action: A</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// action必须是一个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Actions must be plain objects. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Use custom middleware for async actions.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// action必须拥有一个type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Actions may not have an undefined \"type\" property. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'Have you misspelled a constant?'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果正在dispatching，那么不执行dispatch操作。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置dispatching状态为true，并使用reducer生成新的状态树。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      isDispatching = <span class=\"literal\">true</span></span><br><span class=\"line\">      currentState = currentReducer(currentState, action)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当获取新的状态树完成后，设置状态为false.</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将目前最新的监听方法放置到即将执行的队列中遍历并且执行</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i]</span><br><span class=\"line\">      listener()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发的action返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> action</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实看下来，我们发现他就是简单的将我们的参数转发给了<code>reducer</code>，然后执行了我们之前建立的监听队列。</p>\n<p>有没有同学会和我想的一样，那为什么不直接执行<code>reducer</code>？因为我们里面有订阅函数需要执行，对吧，而且还有<code>dispatch</code>的状态需要通知<code>store</code>，不然<code>getState</code>之类的，我们之前有看到判断<code>dispatch</code>状态的很可能出现偏差。</p>\n<p>我们只需要<code>connect</code>一下就可以直接在<code>props</code>里面拿到<code>dispatch</code>，不需要<code>import</code>之类的，很简洁。</p>\n<h4 id=\"replaceReducer\"><a href=\"#replaceReducer\" class=\"headerlink\" title=\"replaceReducer\"></a>replaceReducer</h4><p>这个函数顾名思义，也很好理解，我就不多做解释了，直接看注释吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个其实很少用到, 官方的介绍是主要是用于动态替换reducer的时候会用到</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>&lt;<span class=\"title\">NewState</span>, <span class=\"title\">NewActions</span> <span class=\"title\">extends</span> <span class=\"title\">A</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    nextReducer: Reducer&lt;NewState, NewActions&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>): <span class=\"title\">Store</span>&lt;<span class=\"title\">ExtendState</span>&lt;<span class=\"title\">NewState</span>, <span class=\"title\">StateExt</span>&gt;, <span class=\"title\">NewActions</span>, <span class=\"title\">StateExt</span>, <span class=\"title\">Ext</span>&gt; &amp; <span class=\"title\">Ext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改reducer</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前的currentReducer更新为参数nextReducer</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> do this more elegantly</span></span><br><span class=\"line\">    ;((currentReducer <span class=\"keyword\">as</span> unknown) <span class=\"keyword\">as</span> Reducer&lt;</span><br><span class=\"line\">      NewState,</span><br><span class=\"line\">      NewActions</span><br><span class=\"line\">    &gt;) = nextReducer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This action has a similar effect to ActionTypes.INIT.</span></span><br><span class=\"line\">    <span class=\"comment\">// Any reducers that existed in both the new and old rootReducer</span></span><br><span class=\"line\">    <span class=\"comment\">// will receive the previous state. This effectively populates</span></span><br><span class=\"line\">    <span class=\"comment\">// the new state tree with any relevant data from the old one.</span></span><br><span class=\"line\">    <span class=\"comment\">// 和INIT的dispatch相同，发送一个dispatch初始化state，表明一下是REPLACE</span></span><br><span class=\"line\">    <span class=\"comment\">// 自己👀看一下utils方法的ActionTypes， 随性的随机数</span></span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125; <span class=\"keyword\">as</span> A)</span><br><span class=\"line\">    <span class=\"comment\">// change the type of the store by casting it to the new store</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (store <span class=\"keyword\">as</span> unknown) <span class=\"keyword\">as</span> Store&lt;</span><br><span class=\"line\">      ExtendState&lt;NewState, StateExt&gt;,</span><br><span class=\"line\">      NewActions,</span><br><span class=\"line\">      StateExt,</span><br><span class=\"line\">      Ext</span><br><span class=\"line\">    &gt; &amp;</span><br><span class=\"line\">      Ext</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现两个很有趣的点：</p>\n<ol>\n<li>大佬们也会写<code>todo</code>，关键是！他们的<code>TODO</code>年头有点久了，哈哈哈哈，5年了，看样子不是只有我不会继续优化的，哈哈哈哈。也有可能是没有想到更好的方法。。。</li>\n<li>里面他自己<code>dispatch</code>了一个，<code>ActionTypes.REPLACE</code>。</li>\n</ol>\n<p>ok，我们一探究竟，这个<code>ActionTypes.REPLACE</code></p>\n<p>扒开衣服！直接开看👀！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * These are private action types reserved by Redux.</span></span><br><span class=\"line\"><span class=\"comment\"> * For any unknown actions, you must return the current state.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the current state is undefined, you must return the initial state.</span></span><br><span class=\"line\"><span class=\"comment\"> * Do not reference these action types directly in your code.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> randomString = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substring(<span class=\"number\">7</span>).split(<span class=\"string\">''</span>).join(<span class=\"string\">'.'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ActionTypes = &#123;</span><br><span class=\"line\">  INIT: <span class=\"string\">`@@redux/INIT<span class=\"subst\">$&#123;<span class=\"regexp\">/* #__PURE__ */</span> randomString()&#125;</span>`</span>,</span><br><span class=\"line\">  REPLACE: <span class=\"string\">`@@redux/REPLACE<span class=\"subst\">$&#123;<span class=\"regexp\">/* #__PURE__ */</span> randomString()&#125;</span>`</span>,</span><br><span class=\"line\">  PROBE_UNKNOWN_ACTION: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`@@redux/PROBE_UNKNOWN_ACTION<span class=\"subst\">$&#123;randomString()&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ActionTypes</span><br></pre></td></tr></table></figure>\n\n<p>其实就是一个不想和我们的<code>type</code>冲突的随机数，告诉<code>redux</code>，这个是他们内部的一个<code>dispatch</code>而已。</p>\n<h4 id=\"observable\"><a href=\"#observable\" class=\"headerlink\" title=\"observable\"></a>observable</h4><p>这个玩意，其实我是不太懂他是干什么的。。。全局搜也没有搜出来，而且我也没用过。。。</p>\n<p>大家看注释吧，不过多解释，如果有懂哥，欢迎一起交流讨论呀。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询之后,也没发现有什么特别的用处...暂时跳过,如果有帅哥看到的话可以不吝赐教</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> outerSubscribe = subscribe</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       The minimal observable subscription method.</span></span><br><span class=\"line\"><span class=\"comment\">       <span class=\"doctag\">@param </span>observer Any object that can be used as an observer.</span></span><br><span class=\"line\"><span class=\"comment\">       The observer object should have a `next` method.</span></span><br><span class=\"line\"><span class=\"comment\">       <span class=\"doctag\">@returns </span>An object with an `unsubscribe` method that can</span></span><br><span class=\"line\"><span class=\"comment\">       be used to unsubscribe the observable from the store, and prevent further</span></span><br><span class=\"line\"><span class=\"comment\">       emission of values from the observable.</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      subscribe(observer: unknown) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> observer !== <span class=\"string\">'object'</span> || observer === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Expected the observer to be an object.'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取观察着的状态</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observeState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> observerAsObserver = observer <span class=\"keyword\">as</span> Observer&lt;S&gt;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (observerAsObserver.next) &#123;</span><br><span class=\"line\">            observerAsObserver.next(getState())</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        observeState()</span><br><span class=\"line\">        <span class=\"comment\">//返回取消订阅的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> unsubscribe = outerSubscribe(observeState)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; unsubscribe &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      [$$observable]() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实他内部还自己执行了一下<code>dispatch</code>，在<code>createStore</code>的最后。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125; <span class=\"keyword\">as</span> A)</span><br></pre></td></tr></table></figure>\n\n<p>其实也很好理解，我们<code>createStore</code>的时候，初始的<code>state</code>就是这样来的~</p>\n<p>里面的<code>INIT</code>，在我们之前<code>REPLACE</code>里面也有介绍，也是一个随机数而已。</p>\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><p>这个坑，是之前在<code>createStore</code>的<code>ensureCanMutateNextListeners</code>埋下的，现在我们一起来看看这个。</p>\n<p>这个redux拓展dispatch的唯一的标准的方法。</p>\n<p>首先，我们得知道怎么用。我贴下我自己demo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个是官方的demo，不了解的，<a href=\"https://www.redux.org.cn/docs/advanced/Middleware.html\" target=\"_blank\" rel=\"noopener\">点我快速了解</a></p>\n<p>ok，我们直接贴源码，很短，但是有很多奥妙（奥妙打钱！）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  ...middlewares: Middleware[]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">StoreEnhancer</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore: StoreEnhancerStoreCreator</span>) =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">S,</span> <span class=\"attr\">A</span> <span class=\"attr\">extends</span> <span class=\"attr\">AnyAction</span>&gt;</span>(</span></span><br><span class=\"line\">    reducer: Reducer&lt;S, A&gt;,</span><br><span class=\"line\">    preloadedState?: PreloadedState&lt;S&gt;</span><br><span class=\"line\">  ) =&gt; &#123;</span><br><span class=\"line\">    const store = createStore(reducer, preloadedState)</span><br><span class=\"line\">    let dispatch: Dispatch = () =&gt; &#123;</span><br><span class=\"line\">      throw new Error(</span><br><span class=\"line\">        'Dispatching while constructing your middleware is not allowed. ' +</span><br><span class=\"line\">          'Other middleware would not be applied to this dispatch.'</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const middlewareAPI: MiddlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: (action, ...args) =&gt; dispatch(action, ...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class=\"line\">    dispatch = compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很短，但是却有很多深奥的地方。一个个来。</p>\n<p>在开始之前，我们需要先了解一下函数柯里化。直接上demo帮助理解</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> t = test(<span class=\"number\">1</span>);</span><br><span class=\"line\">t(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>这里就是一个简单的函数柯里化，我们可以先存储一下第一次传入的参数，后面如果这个<code>1</code>会复用的话，那么我们定义的变量<code>t</code>就可以在很多地方使用，里面用到了闭包的知识，而且是非常典型的闭包，存储形参<code>a</code>，实参<code>1</code>。</p>\n<p>还记得我们的使用用例吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面第一个参数<code>store</code>就是对应到我们<code>createStore</code>源码里面我们挖的坑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 传入符合参数类型的参数，就可以执行 enhancer,</span></span><br><span class=\"line\"><span class=\"comment\">     * 但是这个return深深的吸引了我, 因为说明有applyMiddleware的时候后面的都不用看了 ??? 当然\u001d不可能</span></span><br><span class=\"line\"><span class=\"comment\">     * 可是applyMiddleware其实是必用项，所以猜想一下applyMiddleware强化store之后会enhancer赋值undefined，再次调用createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下打个debugger看一下执行顺序(debugger位置以注释)，果然不出所料</span></span><br><span class=\"line\"><span class=\"comment\">     * 好了， 假设我们还不知道applyMiddleware()这个funcrion具体干了什么，</span></span><br><span class=\"line\"><span class=\"comment\">     * 只知道他做了一些处理然后重新调用了createStore并且enhancer参数为undefined</span></span><br><span class=\"line\"><span class=\"comment\">     * 先记下，后续在看applyMiddleware， 因为我们现在要看的是createStore</span></span><br><span class=\"line\"><span class=\"comment\">     * * */</span></span><br><span class=\"line\">    <span class=\"comment\">// debugger</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(</span><br><span class=\"line\">      reducer,</span><br><span class=\"line\">      preloadedState <span class=\"keyword\">as</span> PreloadedState&lt;S&gt;</span><br><span class=\"line\">    ) <span class=\"keyword\">as</span> Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个<code>next</code>，其实就是<code>middlewareAPI</code>里面的<code>dispatch</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">action, ...args</span>) =&gt;</span> dispatch(action, ...args),</span><br><span class=\"line\">      test:<span class=\"number\">2</span>,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>增加一个<code>log</code>在<code>middleware</code>里面就可以知道了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"comment\">// const result = next(action);</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"comment\">// return result</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候<code>log</code>的是我们在<code>createStore</code>里面的<code>dispatch</code>，还出现了我们的注释</p>\n<p>说明<code>next</code>这个参数就是对应的<code>middlewareAPI</code>里面的<code>dispatch</code>也就是说是<code>createStore</code>里面的<code>dispatch</code>。</p>\n<p>第三个参数<code>action</code></p>\n<p>很简单，其实就是普普通通的一个<code>action</code>。不过是从我们<code>middleaware</code>里面得到的。这个没有疑惑。</p>\n<blockquote>\n<p>我们会发现一个很有趣的事情就是，如果我们注释掉调用<code>next(action)</code>，并且不将结果<code>return</code>的话，这个<code>action</code>就会被卡住，没有发出去，被我们打断了，所以这就是我们为什么需要做这个的原因。那么就可以引申出我们可以自定义打断某些情况下的action，然后需要在那些情况下给action里面加些什么，都可以办到。</p>\n</blockquote>\n<p>ok，我们看了之后好像知道<code>applyMiddleware</code>里面的参数都对应这哪些东西了，但是似乎不知道为什么是一种柯里化的形式来展示的。我们看下面的代码就会知道了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用每一个这样形式的middleware = store =&gt; next =&gt; action =&gt;&#123;&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">// 组成一个这样[f(next)=&gt;acticon=&gt;next(action)...]的array，赋值给chain</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\"><span class=\"comment\">// debugger</span></span><br><span class=\"line\"><span class=\"comment\">// compose看 -&gt; compose.js文件</span></span><br><span class=\"line\"><span class=\"comment\">// compose(...chain)会形成一个调用链, next指代下一个函数的注册, 这就是中间件的返回值要是next(action)的原因</span></span><br><span class=\"line\"><span class=\"comment\">// 如果执行到了最后next就是原生的store.dispatch方法</span></span><br><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n\n<p>里面提到了<code>compose</code>这个函数，其实这个函数就是整个中间件的精髓所在。柯里化的奥义！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs: Function[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// infer the argument type so it is usable in inference down the line</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">T</span>&gt;</span>(arg: T) =&gt; arg</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">  if (funcs.length === 1) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    return funcs[0]</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">  return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>不了解reduce的同学可以<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">点这里</a>。</p>\n<p>这个compose其实是一个调用链，我们的所有的中间件都会按顺序加载，然后是👇这种形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middleware = <span class=\"function\"><span class=\"params\">middleware1</span> =&gt;</span> <span class=\"function\"><span class=\"params\">middleware2</span> =&gt;</span> <span class=\"function\"><span class=\"params\">middleware3</span> =&gt;</span> middleware4 <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过一下代码知道，确实是往下传递的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  action.aa = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger2 = <span class=\"function\">(<span class=\"params\">store:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next:any</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action:any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next2==='</span>,next)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'logger2==-=-=-=-=-=-='</span>,action)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'dispatching'</span>, action)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = next(action);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer, &#123;<span class=\"attr\">todos</span>:[]&#125;, applyMiddleware(logger, logger2));</span><br></pre></td></tr></table></figure>\n\n<p>在<code>logger2</code>里面确实打印出来<code>aa</code>这个属性的值，而<code>logger</code>却没有</p>\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><p>这个在上面介绍applyMiddleware的时候说过了。就不多说了。</p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>这个中文翻译就是《组合reducer》。</p>\n<p>其实就是 字面意思，我们看一下怎么用就了解了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  firstReducer: todos,</span><br><span class=\"line\">  secondReducer: visibilityFilter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后我们看一下<code>log</code>出来的<code>props</code>是什么样子的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tfirstReducer: &#123;<span class=\"attr\">todos</span>: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">\tsecondReducer: <span class=\"string\">\"SHOW_ALL\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是我们一开始设置进去的<code>key</code>值，返回的时候也是按这个格式返回的。</p>\n<p>里面有许多函数，我们先看他到处的函数<code>combineReducers</code></p>\n<h3 id=\"combineReducers-1\"><a href=\"#combineReducers-1\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于合并reducer 一般是这样combineReducers(&#123;a,b,c&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers: ReducersMapObject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// reducers中key的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\">  <span class=\"comment\">// 最终的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducers: ReducersMapObject = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接受当前的key</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = reducerKeys[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是生产环境， 当前的reducer是undefined会给出warning</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        warning(<span class=\"string\">`No reducer provided for key \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reducer要是一个function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 赋值给finalReducers</span></span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 符合规范的reducer的key数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// This is used to make sure we don't warn about the same</span></span><br><span class=\"line\">  <span class=\"comment\">// keys multiple times.</span></span><br><span class=\"line\">  <span class=\"comment\">// 意想不到的key， 先往下看看</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> unexpectedKeyCache: &#123; [key: string]: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  <span class=\"comment\">// production环境为&#123;&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">    unexpectedKeyCache = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> shapeAssertionError: <span class=\"built_in\">Error</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 看这个function</span></span><br><span class=\"line\">    assertReducerShape(finalReducers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    shapeAssertionError = e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回function， 即为createStore中的reducer参数既currentReducer</span></span><br><span class=\"line\">  <span class=\"comment\">// 自然有state和action两个参数， 可以回createStore文件看看currentReducer(currentState, action)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    state: StateFromReducersMapObject&lt;typeof reducers&gt; = &#123;&#125;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    action: AnyAction</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reducer不规范报错</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shapeAssertionError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> shapeAssertionError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class=\"line\">        state,</span><br><span class=\"line\">        finalReducers,</span><br><span class=\"line\">        action,</span><br><span class=\"line\">        unexpectedKeyCache</span><br><span class=\"line\">      )</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState: StateFromReducersMapObject&lt;<span class=\"keyword\">typeof</span> reducers&gt; = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 获取finalReducerKeys的key和value（function）</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 当前key的state值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 执行reducer， 返回当前state</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不存在返回值报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新的state放在nextState对应的key里</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 判断新的state是不是同一引用， 以检验reducer是不是纯函数</span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hasChanged =</span><br><span class=\"line\">      hasChanged || finalReducerKeys.length !== <span class=\"built_in\">Object</span>.keys(state).length</span><br><span class=\"line\">      <span class=\"comment\">// 改变了返回nextState</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  *  新版本的redux这部分改变了实现方法</span></span><br><span class=\"line\"><span class=\"comment\">  *  老版本的redux使用的reduce函数实现的</span></span><br><span class=\"line\"><span class=\"comment\">  *  简单例子如下</span></span><br><span class=\"line\"><span class=\"comment\">  * function combineReducers(reducers) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *    return (state = &#123;&#125;, action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *        return Object.keys(reducers).reduce((currentState, key) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *            currentState[key] = reducers[key](state[key], action);</span></span><br><span class=\"line\"><span class=\"comment\">  *             return currentState;</span></span><br><span class=\"line\"><span class=\"comment\">  *         &#125;, &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * </span></span><br><span class=\"line\"><span class=\"comment\">  * */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面是主要源码，一个个剖析进去。</p>\n<p>先是对数据进行清洗，第一次筛选出符合要求的<code>reducer</code>们</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reducers中key的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\">  <span class=\"comment\">// 最终的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducers: ReducersMapObject = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环， 目的为了给finalReducers赋值， 过虑了不符合规范的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接受当前的key</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = reducerKeys[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是生产环境， 当前的reducer是undefined会给出warning</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        warning(<span class=\"string\">`No reducer provided for key \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reducer要是一个function</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 赋值给finalReducers</span></span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"assertReducerShape\"><a href=\"#assertReducerShape\" class=\"headerlink\" title=\"assertReducerShape\"></a>assertReducerShape</h3><p>初筛之后的finalReducers会交由assertReducerShape再一次进行检验。里面就是一个判断，然后给出警告⚠️之类的。就不多说了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertReducerShape</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(reducers).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> reducer = reducers[key]</span><br><span class=\"line\">   <span class=\"comment\">// reducer返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = reducer(<span class=\"literal\">undefined</span>, &#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// undefined throw Error</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> initialState === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Reducer \"<span class=\"subst\">$&#123;key&#125;</span>\" returned undefined during initialization. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`If the state passed to the reducer is undefined, you must `</span> +</span><br><span class=\"line\">          <span class=\"string\">`explicitly return the initial state. The initial state may `</span> +</span><br><span class=\"line\">          <span class=\"string\">`not be undefined. If you don't want to set a value for this reducer, `</span> +</span><br><span class=\"line\">          <span class=\"string\">`you can use null instead of undefined.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 很明显assertReducerShape是用于reducer的规范</span></span><br><span class=\"line\">    <span class=\"comment\">// 回到combineReducers</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> reducer(<span class=\"literal\">undefined</span>, &#123;</span><br><span class=\"line\">        type: ActionTypes.PROBE_UNKNOWN_ACTION()</span><br><span class=\"line\">      &#125;) === <span class=\"string\">'undefined'</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Reducer \"<span class=\"subst\">$&#123;key&#125;</span>\" returned undefined when probed with a random type. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Don't try to handle <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">            ActionTypes.INIT</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">          &#125;</span> or other actions in \"redux/*\" `</span> +</span><br><span class=\"line\">          <span class=\"string\">`namespace. They are considered private. Instead, you must return the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`current state for any unknown actions, unless it is undefined, `</span> +</span><br><span class=\"line\">          <span class=\"string\">`in which case you must return the initial state, regardless of the `</span> +</span><br><span class=\"line\">          <span class=\"string\">`action type. The initial state may not be undefined, but can be null.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"combination\"><a href=\"#combination\" class=\"headerlink\" title=\"combination\"></a>combination</h3><p>然后就是返回combination这个函数。参数的意义就是他的名字。就不多说了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reducer不规范报错</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shapeAssertionError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> shapeAssertionError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 比较细致的❌信息，顺便看了一下getUndefinedStateErrorMessage，都是用于提示warning和error的， 不过多解释了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class=\"line\">        state,</span><br><span class=\"line\">        finalReducers,</span><br><span class=\"line\">        action,</span><br><span class=\"line\">        unexpectedKeyCache</span><br><span class=\"line\">      )</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取finalReducerKeys的key和value（function）</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 当前key的state值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 执行reducer， 返回当前state</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不存在返回值报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新的state放在nextState对应的key里</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 判断新的state是不是同一引用， 以检验reducer是不是纯函数</span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 改变了返回nextState</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  *  新版本的redux这部分改变了实现方法</span></span><br><span class=\"line\"><span class=\"comment\">  *  老版本的redux使用的reduce函数实现的</span></span><br><span class=\"line\"><span class=\"comment\">  *  简单例子如下</span></span><br><span class=\"line\"><span class=\"comment\">  * function combineReducers(reducers) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *    return (state = &#123;&#125;, action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *        return Object.keys(reducers).reduce((currentState, key) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *            currentState[key] = reducers[key](state[key], action);</span></span><br><span class=\"line\"><span class=\"comment\">  *             return currentState;</span></span><br><span class=\"line\"><span class=\"comment\">  *         &#125;, &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * </span></span><br><span class=\"line\"><span class=\"comment\">  * */</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实就是执行reducer，然后把值拿出来比对，如果是引用的话就返回之前的state，如果不是就使用新的。他的比对和之前说的数组比对一样，都是比对内存地址。</p>\n<p>为什么要这么做呢？</p>\n<p>好问题！</p>\n<p>这样做的好处其实就是为了纯函数，为了一切可预测。而且简单的比较内存地址比递归的性能好太多了。</p>\n<p>那么我们怎么样才可以契合这样的理念呢？</p>\n<p>就是我们在写reducer返回的时候，需要返回一个全新的对象，通常是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">\t...state,</span><br><span class=\"line\">\txx: xx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似这样。这样的话js就会新开辟一个内存地址出来。在比对的时候内存地址就不会相同了。</p>\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators\"></a>bindActionCreators</h2><p>这个函数其实非常少用到，而且也没有什么特别晦涩的东西，只是一个封装。但是是一种更为优雅的方式。</p>\n<p>直接看代码，很少。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">actionCreators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// actionCreators为function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不是object throw Error</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">`bindActionCreators expected an object or a function, instead received <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        actionCreators === <span class=\"literal\">null</span> ? <span class=\"string\">'null'</span> : <span class=\"keyword\">typeof</span> actionCreators</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>. `</span> +</span><br><span class=\"line\">        <span class=\"string\">`Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// object 转为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\">  <span class=\"comment\">// 定义return 的props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// actionCreators的key 通常为actionCreators function的name（方法名）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"comment\">// function =&gt; actionCreators工厂方法本身</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 参数为&#123;actions：function xxx&#125;是返回相同的类型</span></span><br><span class=\"line\">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// return 的props</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> boundActionCreators</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单也很清晰，就是弄一个新的对象，然后把<code>actionCreators</code>里面的<code>value</code>变成<code>bindActionCreator(actionCreator, dispatch)</code>的值，那么一起看一下<code>bindActionCreator</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">AnyAction</span> = <span class=\"title\">AnyAction</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  actionCreator: ActionCreator&lt;A&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  dispatch: Dispatch</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">this: any, ...args: any[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator.apply(<span class=\"keyword\">this</span>, args))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里看起来有点迷糊，看也是能看懂，其实就是返回一个方法，这个方法是干什么的呢？返回执行dispatch之后的返回值。这么搞这么一圈究竟有什么秘密呢？</p>\n<p>我们写一个demo就会知道了。</p>\n<p>假如我们要做一个动态的增加的action，分别为点击一次+1，点击一次+2，点击一次+3。</p>\n<p>我们需要</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counterIncActionCreator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'INCREMENT'</span>,</span><br><span class=\"line\">    step: step || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了简化代码我把dispatch函数定义为只有打印功能的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dispatch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action1 = counterIncActionCreator()</span><br><span class=\"line\">dispatch(action1) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action2 = counterIncActionCreator(<span class=\"number\">2</span>)</span><br><span class=\"line\">dispatch(action2) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action3 = counterIncActionCreator(<span class=\"number\">3</span>)</span><br><span class=\"line\">dispatch(action3) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>有点难受其实，但是我们用了<code>bindActionCreator</code>之后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> increment = bindActionCreator(counterIncActionCreator, dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">increment() <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>就整个帅起来，有没有？！更加优雅了。</p>\n<p>而且我们还可以制作增和减的两个工厂🏭</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyActionCreators = &#123;</span><br><span class=\"line\">  increment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'INCREMENT'</span>,</span><br><span class=\"line\">      step: step || <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  decrement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'DECREMENT'</span>,</span><br><span class=\"line\">      step: - (step || <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>老方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原始的调度方式</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment()) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment(<span class=\"number\">2</span>)) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.increment(<span class=\"number\">3</span>)) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement()) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -1 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement(<span class=\"number\">2</span>)) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -2 &#125;</span></span><br><span class=\"line\">dispatch(MyActionCreators.decrement(<span class=\"number\">3</span>)) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>进化之后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyNewActionCreators.increment() <span class=\"comment\">// &#123; type: 'INCREMENT', step: 1 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.increment(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 2 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.increment(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'INCREMENT', step: 3 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement() <span class=\"comment\">// &#123; type: 'DECREMENT', step: -1 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement(<span class=\"number\">2</span>) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -2 &#125;</span></span><br><span class=\"line\">MyNewActionCreators.decrement(<span class=\"number\">3</span>) <span class=\"comment\">// &#123; type: 'DECREMENT', step: -3 &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Redux总结\"><a href=\"#Redux总结\" class=\"headerlink\" title=\"Redux总结\"></a>Redux总结</h2><p>至此我们的redux源码阅读就到此为止。</p>\n<p>接下来我们一起学习一下和redux配合使用的react-redux</p>\n<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><p>React 原本和redux没有关系，redux只是负责数据处理，理论上无论是vue或者angular都可以使用。</p>\n<p>但是react-redux将react和redux紧密的联系在了一起。用更符合react的方式来调用redux。</p>\n<p>后续会出一篇介绍react-redux的文章。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>自此redux源码阅读算是告一段落了。其实源码很简单，但是思想却很高级。</p>\n<p>如果有不懂的，或者哪里说错了，小伙伴欢迎在评论区讨论。</p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><blockquote>\n<p><a href=\"https://juejin.im/post/6844903638377185288\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903638377185288</a></p>\n<p><a href=\"https://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">https://www.redux.org.cn/</a></p>\n</blockquote>\n<blockquote>\n<p>实在是没有地方吐槽，我在这里说一下最近的事情吧。先是部门黄了，然后大领导换人了，大领导不知道是不是新官上任三把火，非要搞什么提效，其实就是把人弄走，然后加大工作量，刚刚开始换组我就去写很老的vue项目，没有鄙视vue的意思，是因为我之前都在写react，然后一下让我写，也不太适应而已，还是很少的版本。那就写就写吧，反正做前端的都得学不是？可是，大领导为了给做给老板看，然后让我们下班不要走，就是没有事情做就干坐着的那种。本着90后的性子我就走了，然后我走了之后，有些小伙伴可能也开始走了，然后我就被抓去劝退了….我也没有死皮赖脸的赖着。借口也非常的奇葩”你活在自己的世界里面，没有关心周围同事忙不忙，改bug不积极，代码质量低”之类的。。。可是我只是工作的时候戴着而已，因为经常有产品上来就在旁边开始讨论了，然后我自己的工作都做不完，怎么关心同事啊。。强行加了工作量之后我都很晚走或者回家工作了。因为在公司赖着真的很难受，为什么不在自己舒适的家中工作呢？还可以马上睡觉那种，音乐还可以外放。。。再说了我之前的代码，因为项目黄了，应该没人看了吧….唉，其实就是 劝退。我都懂。</p>\n<p>但是我的简历其实变得极其丑陋了，因为我年初的才跳槽过来的。现在这个时间非常尴尬….而且我来的第一天听说要996，马上提了离职申请，我的领导同意了，可以之前的大领导和我说以后不会996了就是正常上下班。。然后他就跳槽了。。。</p>\n<p>算是自己不认真审查公司，不过他们也太骗人了吧…唉。</p>\n<p>现在在家里也很焦虑，不知道找不找得到工作，杭州的公司看了一圈都是996，学阿里的加班不学阿里的工资。。。</p>\n<p>国庆以后再说吧，希望早点把重识前端系列更完。</p>\n</blockquote>\n"},{"title":"【重识前端】React源码阅读（四）","date":"2021-06-30T06:08:31.000Z","cover":"/image/cover/react.png","_content":"\n# 前言\n\n我将Fiber拆分成四块来讲\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\nrender-Fiber树的构建\n\nFiber树的构建。Action！\n\n## 一些废话，可以跳过\n\n距离上一篇文章也有2个多月的时间了。（确实搬砖比较忙没空）现在回头看，确实一脸懵逼。但是有些原理确实是刻在脑子里的，重新捡起来也很快。\n\n# 前景回顾\n\n我们知道一个最普通的React代码是这样的：\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nclass App extends React.Component {\n  render() {\n    const text = \"哈哈哈\"\n    return (\n      <div>\n        <p>{text}</p>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n然后我们阅读了ReactDOM.render的源码。知道了render内部其实是调用`legacyRenderSubtreeIntoContainer`这里面其实是在做为Fiber树做初始化。\n\n然后我们`updateContainer`的最后两个函数还没有解读，继续看。\n\n## updateContainer\n\n```typescript\nfunction updateContainer(element, container, parentComponent, callback) {\n  ......\n\n  // 这是一个 event 相关的入参，此处不必关注\n  var eventTime = requestEventTime();\n\n  ......\n\n  // 这是一个比较关键的入参，lane 表示优先级\n  var lane = requestUpdateLane(current);\n  // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新\n  var update = createUpdate(eventTime, lane); \n\n  // update 的 payload 对应的是一个 React 元素\n  update.payload = {\n    element: element\n  };\n\n  // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n    update.callback = callback;\n  }\n\n  // 将 update 入队\n  enqueueUpdate(current, update, lane);\n  // 调度 fiberRoot \n  scheduleUpdateOnFiber(current, lane, eventTime);\n  // 返回当前节点（fiberRoot）的优先级\n  return lane;\n}\n```\n\n# 源码攻读\n\n还剩下两个函数`enqueueUpdate`和`scheduleUpdateOnFiber`\n\n这两个兄弟弄完不知道后面还剩下什么，一起看看吧。\n\n这里先补充一下，`initializeUpdateQueue`内部的东西，因为也有会用了，肯定会有疑问。\n\n```typescript\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n```\n\n\n\n## enqueueUpdate\n\n```tsx\nexport function enqueueUpdate<State>(\n  fiber: Fiber,\n  update: Update<State>,\n  lane: Lane,\n) {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // 只在fiber 卸载的时候会发生\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\n  // 比较fiber lane和lane，相同时更新，具体内容可以看下面的源码。这里不加讨论\n  // render初始化时不执行\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = sharedQueue.interleaved;\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n      // At the end of the current render, this queue's interleaved updates will\n      // be transfered to the pending queue.\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n    sharedQueue.interleaved = update;\n  } else {\n    const pending = sharedQueue.pending;\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    sharedQueue.pending = update;\n  }\n\t// 开发模式\n  if (__DEV__) {\n    if (\n      currentlyProcessingQueue === sharedQueue &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      console.error(\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n```\n\n\n\n### isInterleavedUpdate\n\n```typescript\nexport function isInterleavedUpdate(fiber: Fiber, lane: Lane) {\n  return (\n    // TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    workInProgressRoot !== null &&\n    (fiber.mode & ConcurrentMode) !== NoMode &&\n    // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n    (deferRenderPhaseUpdateToNextBatch ||\n      (executionContext & RenderContext) === NoContext)\n  );\n}\n```\n\n上面提到的。函数的大概是判断是否是交错更新。\n\n","source":"_posts/【重识前端】React源码阅读（四）.md","raw":"---\ntitle: 【重识前端】React源码阅读（四）\ndate: 2021-06-30 14:08:31\ntags: [react]\ncategory: [重拾前端]\ncover: /image/cover/react.png\n---\n\n# 前言\n\n我将Fiber拆分成四块来讲\n\n- 动机（或者说初衷\n- 初始化-Fiber树的准备工作\n- render-Fiber树的构建\n- commit-Fiber树映射到DOM\n\nrender-Fiber树的构建\n\nFiber树的构建。Action！\n\n## 一些废话，可以跳过\n\n距离上一篇文章也有2个多月的时间了。（确实搬砖比较忙没空）现在回头看，确实一脸懵逼。但是有些原理确实是刻在脑子里的，重新捡起来也很快。\n\n# 前景回顾\n\n我们知道一个最普通的React代码是这样的：\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nclass App extends React.Component {\n  render() {\n    const text = \"哈哈哈\"\n    return (\n      <div>\n        <p>{text}</p>\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n然后我们阅读了ReactDOM.render的源码。知道了render内部其实是调用`legacyRenderSubtreeIntoContainer`这里面其实是在做为Fiber树做初始化。\n\n然后我们`updateContainer`的最后两个函数还没有解读，继续看。\n\n## updateContainer\n\n```typescript\nfunction updateContainer(element, container, parentComponent, callback) {\n  ......\n\n  // 这是一个 event 相关的入参，此处不必关注\n  var eventTime = requestEventTime();\n\n  ......\n\n  // 这是一个比较关键的入参，lane 表示优先级\n  var lane = requestUpdateLane(current);\n  // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新\n  var update = createUpdate(eventTime, lane); \n\n  // update 的 payload 对应的是一个 React 元素\n  update.payload = {\n    element: element\n  };\n\n  // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n    update.callback = callback;\n  }\n\n  // 将 update 入队\n  enqueueUpdate(current, update, lane);\n  // 调度 fiberRoot \n  scheduleUpdateOnFiber(current, lane, eventTime);\n  // 返回当前节点（fiberRoot）的优先级\n  return lane;\n}\n```\n\n# 源码攻读\n\n还剩下两个函数`enqueueUpdate`和`scheduleUpdateOnFiber`\n\n这两个兄弟弄完不知道后面还剩下什么，一起看看吧。\n\n这里先补充一下，`initializeUpdateQueue`内部的东西，因为也有会用了，肯定会有疑问。\n\n```typescript\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n```\n\n\n\n## enqueueUpdate\n\n```tsx\nexport function enqueueUpdate<State>(\n  fiber: Fiber,\n  update: Update<State>,\n  lane: Lane,\n) {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // 只在fiber 卸载的时候会发生\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\n  // 比较fiber lane和lane，相同时更新，具体内容可以看下面的源码。这里不加讨论\n  // render初始化时不执行\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = sharedQueue.interleaved;\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n      // At the end of the current render, this queue's interleaved updates will\n      // be transfered to the pending queue.\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n    sharedQueue.interleaved = update;\n  } else {\n    const pending = sharedQueue.pending;\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    sharedQueue.pending = update;\n  }\n\t// 开发模式\n  if (__DEV__) {\n    if (\n      currentlyProcessingQueue === sharedQueue &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      console.error(\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n```\n\n\n\n### isInterleavedUpdate\n\n```typescript\nexport function isInterleavedUpdate(fiber: Fiber, lane: Lane) {\n  return (\n    // TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    workInProgressRoot !== null &&\n    (fiber.mode & ConcurrentMode) !== NoMode &&\n    // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n    (deferRenderPhaseUpdateToNextBatch ||\n      (executionContext & RenderContext) === NoContext)\n  );\n}\n```\n\n上面提到的。函数的大概是判断是否是交错更新。\n\n","slug":"【重识前端】React源码阅读（四）","published":1,"updated":"2021-06-24T14:00:06.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8h001klwrdbmdu5adq","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我将Fiber拆分成四块来讲</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>render-Fiber树的构建</p>\n<p>Fiber树的构建。Action！</p>\n<h2 id=\"一些废话，可以跳过\"><a href=\"#一些废话，可以跳过\" class=\"headerlink\" title=\"一些废话，可以跳过\"></a>一些废话，可以跳过</h2><p>距离上一篇文章也有2个多月的时间了。（确实搬砖比较忙没空）现在回头看，确实一脸懵逼。但是有些原理确实是刻在脑子里的，重新捡起来也很快。</p>\n<h1 id=\"前景回顾\"><a href=\"#前景回顾\" class=\"headerlink\" title=\"前景回顾\"></a>前景回顾</h1><p>我们知道一个最普通的React代码是这样的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">\"react-dom\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> text = <span class=\"string\">\"哈哈哈\"</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;text&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>\n\n<p>然后我们阅读了ReactDOM.render的源码。知道了render内部其实是调用<code>legacyRenderSubtreeIntoContainer</code>这里面其实是在做为Fiber树做初始化。</p>\n<p>然后我们<code>updateContainer</code>的最后两个函数还没有解读，继续看。</p>\n<h2 id=\"updateContainer\"><a href=\"#updateContainer\" class=\"headerlink\" title=\"updateContainer\"></a>updateContainer</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainer</span>(<span class=\"params\">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个 event 相关的入参，此处不必关注</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> eventTime = requestEventTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个比较关键的入参，lane 表示优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> lane = requestUpdateLane(current);</span><br><span class=\"line\">  <span class=\"comment\">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> update = createUpdate(eventTime, lane); </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// update 的 payload 对应的是一个 React 元素</span></span><br><span class=\"line\">  update.payload = &#123;</span><br><span class=\"line\">    element: element</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span><br><span class=\"line\">  callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class=\"string\">'function. Instead received: %s.'</span>, callback);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 update 入队</span></span><br><span class=\"line\">  enqueueUpdate(current, update, lane);</span><br><span class=\"line\">  <span class=\"comment\">// 调度 fiberRoot </span></span><br><span class=\"line\">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class=\"line\">  <span class=\"comment\">// 返回当前节点（fiberRoot）的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lane;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><p>还剩下两个函数<code>enqueueUpdate</code>和<code>scheduleUpdateOnFiber</code></p>\n<p>这两个兄弟弄完不知道后面还剩下什么，一起看看吧。</p>\n<p>这里先补充一下，<code>initializeUpdateQueue</code>内部的东西，因为也有会用了，肯定会有疑问。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">fiber: Fiber</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: fiber.memoizedState,</span><br><span class=\"line\">    firstBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shared: &#123;</span><br><span class=\"line\">      pending: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      interleaved: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      lanes: NoLanes,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    effects: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  fiber.updateQueue = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"enqueueUpdate\"><a href=\"#enqueueUpdate\" class=\"headerlink\" title=\"enqueueUpdate\"></a>enqueueUpdate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function enqueueUpdate&lt;State&gt;(</span><br><span class=\"line\">  fiber: Fiber,</span><br><span class=\"line\">  update: Update&lt;State&gt;,</span><br><span class=\"line\">  lane: Lane,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  const updateQueue &#x3D; fiber.updateQueue;</span><br><span class=\"line\">  if (updateQueue &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 只在fiber 卸载的时候会发生</span><br><span class=\"line\">    &#x2F;&#x2F; Only occurs if the fiber has been unmounted.</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const sharedQueue: SharedQueue&lt;State&gt; &#x3D; (updateQueue: any).shared;</span><br><span class=\"line\">  &#x2F;&#x2F; 比较fiber lane和lane，相同时更新，具体内容可以看下面的源码。这里不加讨论</span><br><span class=\"line\">  &#x2F;&#x2F; render初始化时不执行</span><br><span class=\"line\">  if (isInterleavedUpdate(fiber, lane)) &#123;</span><br><span class=\"line\">    const interleaved &#x3D; sharedQueue.interleaved;</span><br><span class=\"line\">    if (interleaved &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; This is the first update. Create a circular list.</span><br><span class=\"line\">      update.next &#x3D; update;</span><br><span class=\"line\">      &#x2F;&#x2F; At the end of the current render, this queue&#39;s interleaved updates will</span><br><span class=\"line\">      &#x2F;&#x2F; be transfered to the pending queue.</span><br><span class=\"line\">      pushInterleavedQueue(sharedQueue);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      update.next &#x3D; interleaved.next;</span><br><span class=\"line\">      interleaved.next &#x3D; update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sharedQueue.interleaved &#x3D; update;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    const pending &#x3D; sharedQueue.pending;</span><br><span class=\"line\">    if (pending &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; This is the first update. Create a circular list.</span><br><span class=\"line\">      update.next &#x3D; update;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      update.next &#x3D; pending.next;</span><br><span class=\"line\">      pending.next &#x3D; update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sharedQueue.pending &#x3D; update;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 开发模式</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    if (</span><br><span class=\"line\">      currentlyProcessingQueue &#x3D;&#x3D;&#x3D; sharedQueue &amp;&amp;</span><br><span class=\"line\">      !didWarnUpdateInsideUpdate</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        &#39;An update (setState, replaceState, or forceUpdate) was scheduled &#39; +</span><br><span class=\"line\">          &#39;from inside an update function. Update functions should be pure, &#39; +</span><br><span class=\"line\">          &#39;with zero side-effects. Consider using componentDidUpdate or a &#39; +</span><br><span class=\"line\">          &#39;callback.&#39;,</span><br><span class=\"line\">      );</span><br><span class=\"line\">      didWarnUpdateInsideUpdate &#x3D; true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"isInterleavedUpdate\"><a href=\"#isInterleavedUpdate\" class=\"headerlink\" title=\"isInterleavedUpdate\"></a>isInterleavedUpdate</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInterleavedUpdate</span>(<span class=\"params\">fiber: Fiber, lane: Lane</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Optimize slightly by comparing to root that fiber belongs to.</span></span><br><span class=\"line\">    <span class=\"comment\">// Requires some refactoring. Not a big deal though since it's rare for</span></span><br><span class=\"line\">    <span class=\"comment\">// concurrent apps to have more than a single root.</span></span><br><span class=\"line\">    workInProgressRoot !== <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">    (fiber.mode &amp; ConcurrentMode) !== NoMode &amp;&amp;</span><br><span class=\"line\">    <span class=\"comment\">// If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),</span></span><br><span class=\"line\">    <span class=\"comment\">// then don't treat this as an interleaved update. This pattern is</span></span><br><span class=\"line\">    <span class=\"comment\">// accompanied by a warning but we haven't fully deprecated it yet. We can</span></span><br><span class=\"line\">    <span class=\"comment\">// remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.</span></span><br><span class=\"line\">    (deferRenderPhaseUpdateToNextBatch ||</span><br><span class=\"line\">      (executionContext &amp; RenderContext) === NoContext)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面提到的。函数的大概是判断是否是交错更新。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我将Fiber拆分成四块来讲</p>\n<ul>\n<li>动机（或者说初衷</li>\n<li>初始化-Fiber树的准备工作</li>\n<li>render-Fiber树的构建</li>\n<li>commit-Fiber树映射到DOM</li>\n</ul>\n<p>render-Fiber树的构建</p>\n<p>Fiber树的构建。Action！</p>\n<h2 id=\"一些废话，可以跳过\"><a href=\"#一些废话，可以跳过\" class=\"headerlink\" title=\"一些废话，可以跳过\"></a>一些废话，可以跳过</h2><p>距离上一篇文章也有2个多月的时间了。（确实搬砖比较忙没空）现在回头看，确实一脸懵逼。但是有些原理确实是刻在脑子里的，重新捡起来也很快。</p>\n<h1 id=\"前景回顾\"><a href=\"#前景回顾\" class=\"headerlink\" title=\"前景回顾\"></a>前景回顾</h1><p>我们知道一个最普通的React代码是这样的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">\"react-dom\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> text = <span class=\"string\">\"哈哈哈\"</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;text&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>\n\n<p>然后我们阅读了ReactDOM.render的源码。知道了render内部其实是调用<code>legacyRenderSubtreeIntoContainer</code>这里面其实是在做为Fiber树做初始化。</p>\n<p>然后我们<code>updateContainer</code>的最后两个函数还没有解读，继续看。</p>\n<h2 id=\"updateContainer\"><a href=\"#updateContainer\" class=\"headerlink\" title=\"updateContainer\"></a>updateContainer</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainer</span>(<span class=\"params\">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个 event 相关的入参，此处不必关注</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> eventTime = requestEventTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这是一个比较关键的入参，lane 表示优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> lane = requestUpdateLane(current);</span><br><span class=\"line\">  <span class=\"comment\">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> update = createUpdate(eventTime, lane); </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// update 的 payload 对应的是一个 React 元素</span></span><br><span class=\"line\">  update.payload = &#123;</span><br><span class=\"line\">    element: element</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span><br><span class=\"line\">  callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class=\"string\">'function. Instead received: %s.'</span>, callback);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 update 入队</span></span><br><span class=\"line\">  enqueueUpdate(current, update, lane);</span><br><span class=\"line\">  <span class=\"comment\">// 调度 fiberRoot </span></span><br><span class=\"line\">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class=\"line\">  <span class=\"comment\">// 返回当前节点（fiberRoot）的优先级</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lane;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"源码攻读\"><a href=\"#源码攻读\" class=\"headerlink\" title=\"源码攻读\"></a>源码攻读</h1><p>还剩下两个函数<code>enqueueUpdate</code>和<code>scheduleUpdateOnFiber</code></p>\n<p>这两个兄弟弄完不知道后面还剩下什么，一起看看吧。</p>\n<p>这里先补充一下，<code>initializeUpdateQueue</code>内部的东西，因为也有会用了，肯定会有疑问。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">fiber: Fiber</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: fiber.memoizedState,</span><br><span class=\"line\">    firstBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastBaseUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shared: &#123;</span><br><span class=\"line\">      pending: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      interleaved: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      lanes: NoLanes,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    effects: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  fiber.updateQueue = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"enqueueUpdate\"><a href=\"#enqueueUpdate\" class=\"headerlink\" title=\"enqueueUpdate\"></a>enqueueUpdate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function enqueueUpdate&lt;State&gt;(</span><br><span class=\"line\">  fiber: Fiber,</span><br><span class=\"line\">  update: Update&lt;State&gt;,</span><br><span class=\"line\">  lane: Lane,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  const updateQueue &#x3D; fiber.updateQueue;</span><br><span class=\"line\">  if (updateQueue &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 只在fiber 卸载的时候会发生</span><br><span class=\"line\">    &#x2F;&#x2F; Only occurs if the fiber has been unmounted.</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const sharedQueue: SharedQueue&lt;State&gt; &#x3D; (updateQueue: any).shared;</span><br><span class=\"line\">  &#x2F;&#x2F; 比较fiber lane和lane，相同时更新，具体内容可以看下面的源码。这里不加讨论</span><br><span class=\"line\">  &#x2F;&#x2F; render初始化时不执行</span><br><span class=\"line\">  if (isInterleavedUpdate(fiber, lane)) &#123;</span><br><span class=\"line\">    const interleaved &#x3D; sharedQueue.interleaved;</span><br><span class=\"line\">    if (interleaved &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; This is the first update. Create a circular list.</span><br><span class=\"line\">      update.next &#x3D; update;</span><br><span class=\"line\">      &#x2F;&#x2F; At the end of the current render, this queue&#39;s interleaved updates will</span><br><span class=\"line\">      &#x2F;&#x2F; be transfered to the pending queue.</span><br><span class=\"line\">      pushInterleavedQueue(sharedQueue);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      update.next &#x3D; interleaved.next;</span><br><span class=\"line\">      interleaved.next &#x3D; update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sharedQueue.interleaved &#x3D; update;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    const pending &#x3D; sharedQueue.pending;</span><br><span class=\"line\">    if (pending &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; This is the first update. Create a circular list.</span><br><span class=\"line\">      update.next &#x3D; update;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      update.next &#x3D; pending.next;</span><br><span class=\"line\">      pending.next &#x3D; update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sharedQueue.pending &#x3D; update;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 开发模式</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    if (</span><br><span class=\"line\">      currentlyProcessingQueue &#x3D;&#x3D;&#x3D; sharedQueue &amp;&amp;</span><br><span class=\"line\">      !didWarnUpdateInsideUpdate</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        &#39;An update (setState, replaceState, or forceUpdate) was scheduled &#39; +</span><br><span class=\"line\">          &#39;from inside an update function. Update functions should be pure, &#39; +</span><br><span class=\"line\">          &#39;with zero side-effects. Consider using componentDidUpdate or a &#39; +</span><br><span class=\"line\">          &#39;callback.&#39;,</span><br><span class=\"line\">      );</span><br><span class=\"line\">      didWarnUpdateInsideUpdate &#x3D; true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"isInterleavedUpdate\"><a href=\"#isInterleavedUpdate\" class=\"headerlink\" title=\"isInterleavedUpdate\"></a>isInterleavedUpdate</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInterleavedUpdate</span>(<span class=\"params\">fiber: Fiber, lane: Lane</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Optimize slightly by comparing to root that fiber belongs to.</span></span><br><span class=\"line\">    <span class=\"comment\">// Requires some refactoring. Not a big deal though since it's rare for</span></span><br><span class=\"line\">    <span class=\"comment\">// concurrent apps to have more than a single root.</span></span><br><span class=\"line\">    workInProgressRoot !== <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">    (fiber.mode &amp; ConcurrentMode) !== NoMode &amp;&amp;</span><br><span class=\"line\">    <span class=\"comment\">// If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),</span></span><br><span class=\"line\">    <span class=\"comment\">// then don't treat this as an interleaved update. This pattern is</span></span><br><span class=\"line\">    <span class=\"comment\">// accompanied by a warning but we haven't fully deprecated it yet. We can</span></span><br><span class=\"line\">    <span class=\"comment\">// remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.</span></span><br><span class=\"line\">    (deferRenderPhaseUpdateToNextBatch ||</span><br><span class=\"line\">      (executionContext &amp; RenderContext) === NoContext)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面提到的。函数的大概是判断是否是交错更新。</p>\n"},{"title":"【重识前端】一次搞定JavaScript的执行机制","date":"2020-08-10T13:36:40.000Z","cover":"/image/cover/web.jpeg","_content":"\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n事件循环这个事情，其实在我们的工作中或多或少都会碰到，可能我们只是没有去认认真真的理解他，了解他而已。今天我们一起把事件循环吃透。\n\n## 单线程的JS\n\n其实，事件循环就是对于单线程的JS应运而生的。\n\n- 单线程？什么是线程，诶，我好像听过进程诶，他们两兄弟啥区别？\n- 为什么js一定要单线程啊，我听说CPU不是有很多核吗？为什么不多线程？\n\n### 线程和进程的爱恨纠葛\n\n这里我推荐阮一峰老师的一篇文章 \n\n[点我学习](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)\n\n### 为什么JS是单线程？\n\n> 这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。\n\n## 浏览器中的消息队列和事件循环\n\n这里暂时只说浏览器中的循环事件循环，有关node的话可能有些细微的差别，不过底层的原理都是差不多的。\n\n### 注意\n\n这里主要是从一个设计者的角度来模拟，从零构建浏览器中的时间循环。为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。\n\n### 开始\n\n#### 事先约定好的执行顺序\n\n假如我有以下几个任务\n\n```js\nvar num1 = 1+2; // 任务 1\nvar num2 = 20/5; // 任务 2\nvar num3 = 7*8; // 任务 3\nconsole.log(num1, num2, num3)； // 任务 4\n```\n\n\n\n如果让我来设计，我就会有一个主线程，然后把他们按顺序排进去，然后顺序执行。\n\n\n\n```js\nfunction mainThread(){\n  var num1 = 1+2; // 任务 1\n  var num2 = 20/5; // 任务 2\n  var num3 = 7*8; // 任务 3\n  console.log(num1, num2, num3)； // 任务 4\n}\n```\n\n😯，我们已经设计了最简单的线程啦。\n\n#### 线程运行中，处理突发事件\n\n很多时候，所有的任务不是之前就统一安排好的，比如⌨️的输入，🖱的点击等等。\n\n如果想要在线程运行中可以很好的处理这些事件。就需要\n\n ====>事件循环。这里我们用while来实现简单的事件循环\n\n```js\nfunction awaitt() {\n  return new Promise(resolve => {\n    document.addEventListener('keydown', resolve);\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    const result = await awaitt();\n    console.log(result);\n  }\n}\n\nmainThread();\n```\n\n这样改版之后有了以下几点改进：\n\n- 引入了循环机制\n- 引入事件，然后整个线程在运行的过程中，活了起来，不再是死的，运行完就滚蛋了的那种，有了交互了\n\n（🤫最简单的实现。。。别吐槽代码，都是最简单的实现和最简单的场景，助于理解而已。。。）\n\n#### 处理其他线程的任务\n\n上面的版本用了事件循环的方式来获取内部的事件，但是对于外部突发情况的事件是无法解决的。所以，我们需要升级~\n\n那么怎么设计好一个线程模型呢？我们换个角度想想思路马上就出来了。\n\n这些外部的任务，都是有先后顺序的，哪怕是都是突发情况。他们也是有先后顺序。\n\n所以一个比较通用的模式就是\n\n======> 消息队列\n\n> 消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。\n\n我们要完成以下几个操作：\n\n1. 添加一个消息队列；\n2. IO 线程中产生的新任务添加进消息队列尾部；\n3. 渲染主线程会循环地从消息队列头部中读取任务，执行任务。\n\n\n\n```js\nconst arrTask = []\n\nfunction addTask(fn) {\n  arrTask.push(fn)\n}\n\nfunction otherThread() {\n  addTask(() => {console.log('other')})\n}\n\nfunction awaitt() {\n  return new Promise(resolve => {\n      if(arrTask.length) {\n        const task = arrTask.shift()\n        task()\n        resolve()\n      }\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    \tawait awaitt();\n  }\n}\n\n\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\n\nmainThread();\notherThread()\n```\n\n\n\n我们用一个数组来模拟一个队列。\n\n既基础了内部的任务，也处理了外部突发的任务\n\n有任务进来， 就会执行任务。\n\n\n\n#### 退出主线程\n\n当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。\n\n\n\n```js\nconst arrTask = []\nlet over = false\n\nfunction addTask(fn) {\n  arrTask.push(fn)\n}\n\nfunction otherThread() {\n  addTask(() => {console.log('other')})\n}\n\nfunction awaitt() {\n  return new Promise(resolve => {\n      if(arrTask.length) {\n        const task = arrTask.shift()\n        task()\n        if(!arrTask.length){\n          over = true\n        }\n        resolve()\n      }\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    if(over){\n      break;\n    }\n    \tawait awaitt();\n  }\n}\n\n\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\n\nmainThread();\notherThread()\n```\n\n\n\n### 单线程的缺点\n\n通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。\n\n#### 如何处理高优先级的任务\n\n场景：\n\n假如，我现在有一大串的任务在主线程上执行。\n\n我的dom节点变化的时候，我需要发送请求或者提示一个`alert`之类的业务逻辑要执行。\n\n现在可行的有两种方案：\n\n- dom节点变化的话，我就停下现在正在运行的主线程上的任务，然后调用我需要执行的业务逻辑。这样确实具有实效性，但是！这样会使得当前任务的效率极度降低，比如我的dom节点变化200次，那岂不是当前的任务特别久了吗？\n- 第二个方法就可以解决上述的问题：一旦dom节点有变化，哪怕是200000次变化，我都是将业务逻辑push到队列的尾部，这样就不会影响当前任务进行以及效率了。但是！这样的话我的实效性就莫得了。就莫得了。\n\n总结一下：其实就是实效性和任务效率的权衡问题罢了。\n\n江江江~\n\n微任务就应运而生啦。\n\n加入我们把任务队列里面的每个任务都称作宏任务的话，每个宏任务里面都会包含一个微任务队列。每个宏任务结束之后，都回去清理一遍微任务队列里面的队列，这样的话既保护了实效性，也保护了任务的效率。\n\n\n\n#### 如何处理调用时间过长的问题\n\n我们都知道js是单线程的。如果现在在执行一个任务的情况下。其他任务就是要等待的。那么就会出现某个任务计算的周期特别长，导致别人都在等待。\n\n👌，我们来验证一下\n\n```js\nwhile(true){}\nalter(123)\n```\n\n下面的`alter`永远都不会执行了。因为`while`在工作，`alter`在等他把资源让出来。\n\n假如说，我现在有一个动画要进行，但是运行完一帧之后，有一个极其复杂的计算，导致了我的动画不流畅，那么用户可能就会非常的烦。这不是我们希望看到的。\n\n所以js有一个回调机制，到了特定的时间点了，回调一下，把动画的下一帧执行一下，然后继续当前的复杂计算。\n\n### 总结\n\n- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。\n- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。\n- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。\n- 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。\n- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务\n\n基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。\n\n## 浏览器是怎么实现setTimeout\n\n要想知道浏览器是怎么实现的，我们先回顾一下，我们之前设计的那个事件循环系统：\n\n有xx任务了，ok，我`push`到任务队列。以此循环。\n\n所以我们写在`setTimeout`里面的函数执行其实也是一个任务，也是需要push到任务队列去的。\n\n但是，我们的这个是其实是一个异步的函数，不能直接将整个函数push到队列中，否则的话我们的实效性就很有可能出错了，比如我希望他在24小时之后`alter`告诉我已经到了第二天了。他如果是直接push到任务队列，没有到第二天就会告诉我第二天到了，这不是让用户匪夷所思嘛。\n\n所以肯定不是直接`push`的。那又是怎么弄得嘞？\n\n你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？\n\n在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中\n\n我们把之前的事件循环模拟改一下\n\n```js\nconst mainTask = [\n  fn1,\n  fn2,\n  fn3,\n  ……\n]\n\nconst setTimeoutTask = []\n\nfunction addSetTimeoutTask(fn, timeout){\n  setTimeoutTask.push({\n    fn: fn,\n    id: Math.random(),\n    useTime: timeout + ((new Date()).getTime()\n  })\n}\n\nconst runSetTimeoutTask (){\n  const runList = []\n  setTimeoutTask.forEach(item => {\n    // 已经过了时间，或者刚刚好到时间的话就取出来。待会一起执行了\n    if(item.useTime <= ((new Date()).getTime()) {\n      runList.push(item.fn) \n    }\n  })\n  if(runList.length) {\n    const fn = runList.shift()\n    fn()\n  }\n}\n\nasync function mainThread() {\n  while(true){\n    const task = arrTask.shift()\n    \n    // 每次执行完一个任务，都回去查找一下延迟队列里面有没有到点的函数\n    if(setTimeoutTask.length) {\n       runSetTimeoutTask()\n    }\n  }\n}\n\nmainThread();\n```\n\n所以这里我们会看到一个问题，那就是其实你到点了可能要不会立刻执行，必须等到之前的任务执行完了才轮到延迟队列的查询和执行。\n\n我们代码中有一个彩蛋----> ID\n\n这个ID有什么用？\n\n就是用于`clearTimeout`\n\n直接传入ID，然后循环找到他，就可以直接从队列里面删掉就好了。\n\n这里就不需要贴代码了吧？\n\n### 冷知识\n\n- **如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒**\n- **未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**\n  - 除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。\n- **延时执行时间有最大值**\n  - 除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。\n- **使用 setTimeout 设置的回调函数中的 this 不符合直觉**\n  - 这里可以看我之前的文章，有对this进行攻破\n\n### 总结\n\n- 首先，为了支持定时器的实现，浏览器增加了延时队列。\n- 其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。\n\n## 宏任务和微任务\n\n其实通过之前的学习，我们对事件循环已经了解的差不多了，这里主要是更详细了解一下他们。\n\n### 宏任务\n\n宏任务有哪些？\n\n除了微任务的都是宏任务。。。\n\n那么微任务有哪些？\n\n`Process.nextTick`、`Promise.then catch finally`(注意我不是说 Promise)、`MutationObserver`。\n\n\n\n在之前的学习我们知道在宏任务结束之后，会去执行他自己当前的微任务队列。在这个微任务队列执行完成之后再去执行下一个宏任务。\n\n### 微任务\n\n异步函数有两种方式：\n\n**第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数**。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。\n\n**第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的**。\n\n\n\n- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。\n- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。\n- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。\n\n\n\n## 期末考试\n\n```js\nconsole.log('script start')\n\nasync function async1() {\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2 end')\n}\nasync1()\n\nsetTimeout(function() {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise(resolve => {\n  console.log('Promise')\n  resolve()\n})\n  .then(function() {\n    console.log('promise1')\n  })\n  .then(function() {\n    console.log('promise2')\n  })\n\nconsole.log('script end')\n```\n\n大家可以自己在浏览器里面试试吧。","source":"_posts/【重识前端】一次搞定事件循环.md","raw":"---\ntitle: 【重识前端】一次搞定JavaScript的执行机制\ndate: 2020-08-10 21:36:40\ntags: [JavaScript]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n事件循环这个事情，其实在我们的工作中或多或少都会碰到，可能我们只是没有去认认真真的理解他，了解他而已。今天我们一起把事件循环吃透。\n\n## 单线程的JS\n\n其实，事件循环就是对于单线程的JS应运而生的。\n\n- 单线程？什么是线程，诶，我好像听过进程诶，他们两兄弟啥区别？\n- 为什么js一定要单线程啊，我听说CPU不是有很多核吗？为什么不多线程？\n\n### 线程和进程的爱恨纠葛\n\n这里我推荐阮一峰老师的一篇文章 \n\n[点我学习](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)\n\n### 为什么JS是单线程？\n\n> 这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。\n\n## 浏览器中的消息队列和事件循环\n\n这里暂时只说浏览器中的循环事件循环，有关node的话可能有些细微的差别，不过底层的原理都是差不多的。\n\n### 注意\n\n这里主要是从一个设计者的角度来模拟，从零构建浏览器中的时间循环。为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。\n\n### 开始\n\n#### 事先约定好的执行顺序\n\n假如我有以下几个任务\n\n```js\nvar num1 = 1+2; // 任务 1\nvar num2 = 20/5; // 任务 2\nvar num3 = 7*8; // 任务 3\nconsole.log(num1, num2, num3)； // 任务 4\n```\n\n\n\n如果让我来设计，我就会有一个主线程，然后把他们按顺序排进去，然后顺序执行。\n\n\n\n```js\nfunction mainThread(){\n  var num1 = 1+2; // 任务 1\n  var num2 = 20/5; // 任务 2\n  var num3 = 7*8; // 任务 3\n  console.log(num1, num2, num3)； // 任务 4\n}\n```\n\n😯，我们已经设计了最简单的线程啦。\n\n#### 线程运行中，处理突发事件\n\n很多时候，所有的任务不是之前就统一安排好的，比如⌨️的输入，🖱的点击等等。\n\n如果想要在线程运行中可以很好的处理这些事件。就需要\n\n ====>事件循环。这里我们用while来实现简单的事件循环\n\n```js\nfunction awaitt() {\n  return new Promise(resolve => {\n    document.addEventListener('keydown', resolve);\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    const result = await awaitt();\n    console.log(result);\n  }\n}\n\nmainThread();\n```\n\n这样改版之后有了以下几点改进：\n\n- 引入了循环机制\n- 引入事件，然后整个线程在运行的过程中，活了起来，不再是死的，运行完就滚蛋了的那种，有了交互了\n\n（🤫最简单的实现。。。别吐槽代码，都是最简单的实现和最简单的场景，助于理解而已。。。）\n\n#### 处理其他线程的任务\n\n上面的版本用了事件循环的方式来获取内部的事件，但是对于外部突发情况的事件是无法解决的。所以，我们需要升级~\n\n那么怎么设计好一个线程模型呢？我们换个角度想想思路马上就出来了。\n\n这些外部的任务，都是有先后顺序的，哪怕是都是突发情况。他们也是有先后顺序。\n\n所以一个比较通用的模式就是\n\n======> 消息队列\n\n> 消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。\n\n我们要完成以下几个操作：\n\n1. 添加一个消息队列；\n2. IO 线程中产生的新任务添加进消息队列尾部；\n3. 渲染主线程会循环地从消息队列头部中读取任务，执行任务。\n\n\n\n```js\nconst arrTask = []\n\nfunction addTask(fn) {\n  arrTask.push(fn)\n}\n\nfunction otherThread() {\n  addTask(() => {console.log('other')})\n}\n\nfunction awaitt() {\n  return new Promise(resolve => {\n      if(arrTask.length) {\n        const task = arrTask.shift()\n        task()\n        resolve()\n      }\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    \tawait awaitt();\n  }\n}\n\n\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\n\nmainThread();\notherThread()\n```\n\n\n\n我们用一个数组来模拟一个队列。\n\n既基础了内部的任务，也处理了外部突发的任务\n\n有任务进来， 就会执行任务。\n\n\n\n#### 退出主线程\n\n当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。\n\n\n\n```js\nconst arrTask = []\nlet over = false\n\nfunction addTask(fn) {\n  arrTask.push(fn)\n}\n\nfunction otherThread() {\n  addTask(() => {console.log('other')})\n}\n\nfunction awaitt() {\n  return new Promise(resolve => {\n      if(arrTask.length) {\n        const task = arrTask.shift()\n        task()\n        if(!arrTask.length){\n          over = true\n        }\n        resolve()\n      }\n  });\n}\n\nasync function mainThread() {\n  while(true){\n    if(over){\n      break;\n    }\n    \tawait awaitt();\n  }\n}\n\n\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\naddTask(()=>console.log('in'))\n\nmainThread();\notherThread()\n```\n\n\n\n### 单线程的缺点\n\n通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。\n\n#### 如何处理高优先级的任务\n\n场景：\n\n假如，我现在有一大串的任务在主线程上执行。\n\n我的dom节点变化的时候，我需要发送请求或者提示一个`alert`之类的业务逻辑要执行。\n\n现在可行的有两种方案：\n\n- dom节点变化的话，我就停下现在正在运行的主线程上的任务，然后调用我需要执行的业务逻辑。这样确实具有实效性，但是！这样会使得当前任务的效率极度降低，比如我的dom节点变化200次，那岂不是当前的任务特别久了吗？\n- 第二个方法就可以解决上述的问题：一旦dom节点有变化，哪怕是200000次变化，我都是将业务逻辑push到队列的尾部，这样就不会影响当前任务进行以及效率了。但是！这样的话我的实效性就莫得了。就莫得了。\n\n总结一下：其实就是实效性和任务效率的权衡问题罢了。\n\n江江江~\n\n微任务就应运而生啦。\n\n加入我们把任务队列里面的每个任务都称作宏任务的话，每个宏任务里面都会包含一个微任务队列。每个宏任务结束之后，都回去清理一遍微任务队列里面的队列，这样的话既保护了实效性，也保护了任务的效率。\n\n\n\n#### 如何处理调用时间过长的问题\n\n我们都知道js是单线程的。如果现在在执行一个任务的情况下。其他任务就是要等待的。那么就会出现某个任务计算的周期特别长，导致别人都在等待。\n\n👌，我们来验证一下\n\n```js\nwhile(true){}\nalter(123)\n```\n\n下面的`alter`永远都不会执行了。因为`while`在工作，`alter`在等他把资源让出来。\n\n假如说，我现在有一个动画要进行，但是运行完一帧之后，有一个极其复杂的计算，导致了我的动画不流畅，那么用户可能就会非常的烦。这不是我们希望看到的。\n\n所以js有一个回调机制，到了特定的时间点了，回调一下，把动画的下一帧执行一下，然后继续当前的复杂计算。\n\n### 总结\n\n- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。\n- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。\n- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。\n- 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。\n- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务\n\n基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。\n\n## 浏览器是怎么实现setTimeout\n\n要想知道浏览器是怎么实现的，我们先回顾一下，我们之前设计的那个事件循环系统：\n\n有xx任务了，ok，我`push`到任务队列。以此循环。\n\n所以我们写在`setTimeout`里面的函数执行其实也是一个任务，也是需要push到任务队列去的。\n\n但是，我们的这个是其实是一个异步的函数，不能直接将整个函数push到队列中，否则的话我们的实效性就很有可能出错了，比如我希望他在24小时之后`alter`告诉我已经到了第二天了。他如果是直接push到任务队列，没有到第二天就会告诉我第二天到了，这不是让用户匪夷所思嘛。\n\n所以肯定不是直接`push`的。那又是怎么弄得嘞？\n\n你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？\n\n在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中\n\n我们把之前的事件循环模拟改一下\n\n```js\nconst mainTask = [\n  fn1,\n  fn2,\n  fn3,\n  ……\n]\n\nconst setTimeoutTask = []\n\nfunction addSetTimeoutTask(fn, timeout){\n  setTimeoutTask.push({\n    fn: fn,\n    id: Math.random(),\n    useTime: timeout + ((new Date()).getTime()\n  })\n}\n\nconst runSetTimeoutTask (){\n  const runList = []\n  setTimeoutTask.forEach(item => {\n    // 已经过了时间，或者刚刚好到时间的话就取出来。待会一起执行了\n    if(item.useTime <= ((new Date()).getTime()) {\n      runList.push(item.fn) \n    }\n  })\n  if(runList.length) {\n    const fn = runList.shift()\n    fn()\n  }\n}\n\nasync function mainThread() {\n  while(true){\n    const task = arrTask.shift()\n    \n    // 每次执行完一个任务，都回去查找一下延迟队列里面有没有到点的函数\n    if(setTimeoutTask.length) {\n       runSetTimeoutTask()\n    }\n  }\n}\n\nmainThread();\n```\n\n所以这里我们会看到一个问题，那就是其实你到点了可能要不会立刻执行，必须等到之前的任务执行完了才轮到延迟队列的查询和执行。\n\n我们代码中有一个彩蛋----> ID\n\n这个ID有什么用？\n\n就是用于`clearTimeout`\n\n直接传入ID，然后循环找到他，就可以直接从队列里面删掉就好了。\n\n这里就不需要贴代码了吧？\n\n### 冷知识\n\n- **如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒**\n- **未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**\n  - 除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。\n- **延时执行时间有最大值**\n  - 除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。\n- **使用 setTimeout 设置的回调函数中的 this 不符合直觉**\n  - 这里可以看我之前的文章，有对this进行攻破\n\n### 总结\n\n- 首先，为了支持定时器的实现，浏览器增加了延时队列。\n- 其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。\n\n## 宏任务和微任务\n\n其实通过之前的学习，我们对事件循环已经了解的差不多了，这里主要是更详细了解一下他们。\n\n### 宏任务\n\n宏任务有哪些？\n\n除了微任务的都是宏任务。。。\n\n那么微任务有哪些？\n\n`Process.nextTick`、`Promise.then catch finally`(注意我不是说 Promise)、`MutationObserver`。\n\n\n\n在之前的学习我们知道在宏任务结束之后，会去执行他自己当前的微任务队列。在这个微任务队列执行完成之后再去执行下一个宏任务。\n\n### 微任务\n\n异步函数有两种方式：\n\n**第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数**。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。\n\n**第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的**。\n\n\n\n- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。\n- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。\n- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。\n\n\n\n## 期末考试\n\n```js\nconsole.log('script start')\n\nasync function async1() {\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2 end')\n}\nasync1()\n\nsetTimeout(function() {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise(resolve => {\n  console.log('Promise')\n  resolve()\n})\n  .then(function() {\n    console.log('promise1')\n  })\n  .then(function() {\n    console.log('promise2')\n  })\n\nconsole.log('script end')\n```\n\n大家可以自己在浏览器里面试试吧。","slug":"【重识前端】一次搞定事件循环","published":1,"updated":"2021-06-24T14:00:06.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8i001nlwrdds0t9daa","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>事件循环这个事情，其实在我们的工作中或多或少都会碰到，可能我们只是没有去认认真真的理解他，了解他而已。今天我们一起把事件循环吃透。</p>\n<h2 id=\"单线程的JS\"><a href=\"#单线程的JS\" class=\"headerlink\" title=\"单线程的JS\"></a>单线程的JS</h2><p>其实，事件循环就是对于单线程的JS应运而生的。</p>\n<ul>\n<li>单线程？什么是线程，诶，我好像听过进程诶，他们两兄弟啥区别？</li>\n<li>为什么js一定要单线程啊，我听说CPU不是有很多核吗？为什么不多线程？</li>\n</ul>\n<h3 id=\"线程和进程的爱恨纠葛\"><a href=\"#线程和进程的爱恨纠葛\" class=\"headerlink\" title=\"线程和进程的爱恨纠葛\"></a>线程和进程的爱恨纠葛</h3><p>这里我推荐阮一峰老师的一篇文章 </p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\" rel=\"noopener\">点我学习</a></p>\n<h3 id=\"为什么JS是单线程？\"><a href=\"#为什么JS是单线程？\" class=\"headerlink\" title=\"为什么JS是单线程？\"></a>为什么JS是单线程？</h3><blockquote>\n<p>这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。</p>\n</blockquote>\n<h2 id=\"浏览器中的消息队列和事件循环\"><a href=\"#浏览器中的消息队列和事件循环\" class=\"headerlink\" title=\"浏览器中的消息队列和事件循环\"></a>浏览器中的消息队列和事件循环</h2><p>这里暂时只说浏览器中的循环事件循环，有关node的话可能有些细微的差别，不过底层的原理都是差不多的。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>这里主要是从一个设计者的角度来模拟，从零构建浏览器中的时间循环。为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><h4 id=\"事先约定好的执行顺序\"><a href=\"#事先约定好的执行顺序\" class=\"headerlink\" title=\"事先约定好的执行顺序\"></a>事先约定好的执行顺序</h4><p>假如我有以下几个任务</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>+<span class=\"number\">2</span>; <span class=\"comment\">// 任务 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = <span class=\"number\">20</span>/<span class=\"number\">5</span>; <span class=\"comment\">// 任务 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num3 = <span class=\"number\">7</span>*<span class=\"number\">8</span>; <span class=\"comment\">// 任务 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num1, num2, num3)； <span class=\"comment\">// 任务 4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果让我来设计，我就会有一个主线程，然后把他们按顺序排进去，然后顺序执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>+<span class=\"number\">2</span>; <span class=\"comment\">// 任务 1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num2 = <span class=\"number\">20</span>/<span class=\"number\">5</span>; <span class=\"comment\">// 任务 2</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num3 = <span class=\"number\">7</span>*<span class=\"number\">8</span>; <span class=\"comment\">// 任务 3</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num1, num2, num3)； <span class=\"comment\">// 任务 4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>😯，我们已经设计了最简单的线程啦。</p>\n<h4 id=\"线程运行中，处理突发事件\"><a href=\"#线程运行中，处理突发事件\" class=\"headerlink\" title=\"线程运行中，处理突发事件\"></a>线程运行中，处理突发事件</h4><p>很多时候，所有的任务不是之前就统一安排好的，比如⌨️的输入，🖱的点击等等。</p>\n<p>如果想要在线程运行中可以很好的处理这些事件。就需要</p>\n<p> ====&gt;事件循环。这里我们用while来实现简单的事件循环</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'keydown'</span>, resolve);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br></pre></td></tr></table></figure>\n\n<p>这样改版之后有了以下几点改进：</p>\n<ul>\n<li>引入了循环机制</li>\n<li>引入事件，然后整个线程在运行的过程中，活了起来，不再是死的，运行完就滚蛋了的那种，有了交互了</li>\n</ul>\n<p>（🤫最简单的实现。。。别吐槽代码，都是最简单的实现和最简单的场景，助于理解而已。。。）</p>\n<h4 id=\"处理其他线程的任务\"><a href=\"#处理其他线程的任务\" class=\"headerlink\" title=\"处理其他线程的任务\"></a>处理其他线程的任务</h4><p>上面的版本用了事件循环的方式来获取内部的事件，但是对于外部突发情况的事件是无法解决的。所以，我们需要升级~</p>\n<p>那么怎么设计好一个线程模型呢？我们换个角度想想思路马上就出来了。</p>\n<p>这些外部的任务，都是有先后顺序的，哪怕是都是突发情况。他们也是有先后顺序。</p>\n<p>所以一个比较通用的模式就是</p>\n<p>======&gt; 消息队列</p>\n<blockquote>\n<p>消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>\n</blockquote>\n<p>我们要完成以下几个操作：</p>\n<ol>\n<li>添加一个消息队列；</li>\n<li>IO 线程中产生的新任务添加进消息队列尾部；</li>\n<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrTask = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTask</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  arrTask.push(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">otherThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addTask(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'other'</span>)&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arrTask.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">        task()</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br><span class=\"line\">otherThread()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们用一个数组来模拟一个队列。</p>\n<p>既基础了内部的任务，也处理了外部突发的任务</p>\n<p>有任务进来， 就会执行任务。</p>\n<h4 id=\"退出主线程\"><a href=\"#退出主线程\" class=\"headerlink\" title=\"退出主线程\"></a>退出主线程</h4><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrTask = []</span><br><span class=\"line\"><span class=\"keyword\">let</span> over = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTask</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  arrTask.push(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">otherThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addTask(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'other'</span>)&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arrTask.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">        task()</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!arrTask.length)&#123;</span><br><span class=\"line\">          over = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(over)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br><span class=\"line\">otherThread()</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"单线程的缺点\"><a href=\"#单线程的缺点\" class=\"headerlink\" title=\"单线程的缺点\"></a>单线程的缺点</h3><p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>\n<h4 id=\"如何处理高优先级的任务\"><a href=\"#如何处理高优先级的任务\" class=\"headerlink\" title=\"如何处理高优先级的任务\"></a>如何处理高优先级的任务</h4><p>场景：</p>\n<p>假如，我现在有一大串的任务在主线程上执行。</p>\n<p>我的dom节点变化的时候，我需要发送请求或者提示一个<code>alert</code>之类的业务逻辑要执行。</p>\n<p>现在可行的有两种方案：</p>\n<ul>\n<li>dom节点变化的话，我就停下现在正在运行的主线程上的任务，然后调用我需要执行的业务逻辑。这样确实具有实效性，但是！这样会使得当前任务的效率极度降低，比如我的dom节点变化200次，那岂不是当前的任务特别久了吗？</li>\n<li>第二个方法就可以解决上述的问题：一旦dom节点有变化，哪怕是200000次变化，我都是将业务逻辑push到队列的尾部，这样就不会影响当前任务进行以及效率了。但是！这样的话我的实效性就莫得了。就莫得了。</li>\n</ul>\n<p>总结一下：其实就是实效性和任务效率的权衡问题罢了。</p>\n<p>江江江~</p>\n<p>微任务就应运而生啦。</p>\n<p>加入我们把任务队列里面的每个任务都称作宏任务的话，每个宏任务里面都会包含一个微任务队列。每个宏任务结束之后，都回去清理一遍微任务队列里面的队列，这样的话既保护了实效性，也保护了任务的效率。</p>\n<h4 id=\"如何处理调用时间过长的问题\"><a href=\"#如何处理调用时间过长的问题\" class=\"headerlink\" title=\"如何处理调用时间过长的问题\"></a>如何处理调用时间过长的问题</h4><p>我们都知道js是单线程的。如果现在在执行一个任务的情况下。其他任务就是要等待的。那么就会出现某个任务计算的周期特别长，导致别人都在等待。</p>\n<p>👌，我们来验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;&#125;</span><br><span class=\"line\">alter(<span class=\"number\">123</span>)</span><br></pre></td></tr></table></figure>\n\n<p>下面的<code>alter</code>永远都不会执行了。因为<code>while</code>在工作，<code>alter</code>在等他把资源让出来。</p>\n<p>假如说，我现在有一个动画要进行，但是运行完一帧之后，有一个极其复杂的计算，导致了我的动画不流畅，那么用户可能就会非常的烦。这不是我们希望看到的。</p>\n<p>所以js有一个回调机制，到了特定的时间点了，回调一下，把动画的下一帧执行一下，然后继续当前的复杂计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>\n<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>\n<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>\n<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>\n<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</li>\n</ul>\n<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p>\n<h2 id=\"浏览器是怎么实现setTimeout\"><a href=\"#浏览器是怎么实现setTimeout\" class=\"headerlink\" title=\"浏览器是怎么实现setTimeout\"></a>浏览器是怎么实现setTimeout</h2><p>要想知道浏览器是怎么实现的，我们先回顾一下，我们之前设计的那个事件循环系统：</p>\n<p>有xx任务了，ok，我<code>push</code>到任务队列。以此循环。</p>\n<p>所以我们写在<code>setTimeout</code>里面的函数执行其实也是一个任务，也是需要push到任务队列去的。</p>\n<p>但是，我们的这个是其实是一个异步的函数，不能直接将整个函数push到队列中，否则的话我们的实效性就很有可能出错了，比如我希望他在24小时之后<code>alter</code>告诉我已经到了第二天了。他如果是直接push到任务队列，没有到第二天就会告诉我第二天到了，这不是让用户匪夷所思嘛。</p>\n<p>所以肯定不是直接<code>push</code>的。那又是怎么弄得嘞？</p>\n<p>你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>\n<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p>\n<p>我们把之前的事件循环模拟改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mainTask = [</span><br><span class=\"line\">  fn1,</span><br><span class=\"line\">  fn2,</span><br><span class=\"line\">  fn3,</span><br><span class=\"line\">  ……</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setTimeoutTask = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addSetTimeoutTask</span>(<span class=\"params\">fn, timeout</span>)</span>&#123;</span><br><span class=\"line\">  setTimeoutTask.push(&#123;</span><br><span class=\"line\">    fn: fn,</span><br><span class=\"line\">    id: <span class=\"built_in\">Math</span>.random(),</span><br><span class=\"line\">    useTime: timeout + ((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> runSetTimeoutTask ()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> runList = []</span><br><span class=\"line\">  setTimeoutTask.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 已经过了时间，或者刚刚好到时间的话就取出来。待会一起执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(item.useTime &lt;= ((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()) &#123;</span><br><span class=\"line\">      runList.push(item.fn) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(runList.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = runList.shift()</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 每次执行完一个任务，都回去查找一下延迟队列里面有没有到点的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(setTimeoutTask.length) &#123;</span><br><span class=\"line\">       runSetTimeoutTask()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br></pre></td></tr></table></figure>\n\n<p>所以这里我们会看到一个问题，那就是其实你到点了可能要不会立刻执行，必须等到之前的任务执行完了才轮到延迟队列的查询和执行。</p>\n<p>我们代码中有一个彩蛋—-&gt; ID</p>\n<p>这个ID有什么用？</p>\n<p>就是用于<code>clearTimeout</code></p>\n<p>直接传入ID，然后循环找到他，就可以直接从队列里面删掉就好了。</p>\n<p>这里就不需要贴代码了吧？</p>\n<h3 id=\"冷知识\"><a href=\"#冷知识\" class=\"headerlink\" title=\"冷知识\"></a>冷知识</h3><ul>\n<li><strong>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</strong></li>\n<li><strong>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</strong><ul>\n<li>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</li>\n</ul>\n</li>\n<li><strong>延时执行时间有最大值</strong><ul>\n<li>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</li>\n</ul>\n</li>\n<li><strong>使用 setTimeout 设置的回调函数中的 this 不符合直觉</strong><ul>\n<li>这里可以看我之前的文章，有对this进行攻破</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n</ul>\n<h2 id=\"宏任务和微任务\"><a href=\"#宏任务和微任务\" class=\"headerlink\" title=\"宏任务和微任务\"></a>宏任务和微任务</h2><p>其实通过之前的学习，我们对事件循环已经了解的差不多了，这里主要是更详细了解一下他们。</p>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务有哪些？</p>\n<p>除了微任务的都是宏任务。。。</p>\n<p>那么微任务有哪些？</p>\n<p><code>Process.nextTick</code>、<code>Promise.then catch finally</code>(注意我不是说 Promise)、<code>MutationObserver</code>。</p>\n<p>在之前的学习我们知道在宏任务结束之后，会去执行他自己当前的微任务队列。在这个微任务队列执行完成之后再去执行下一个宏任务。</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>异步函数有两种方式：</p>\n<p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>\n<p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的</strong>。</p>\n<ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul>\n<h2 id=\"期末考试\"><a href=\"#期末考试\" class=\"headerlink\" title=\"期末考试\"></a>期末考试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>大家可以自己在浏览器里面试试吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>事件循环这个事情，其实在我们的工作中或多或少都会碰到，可能我们只是没有去认认真真的理解他，了解他而已。今天我们一起把事件循环吃透。</p>\n<h2 id=\"单线程的JS\"><a href=\"#单线程的JS\" class=\"headerlink\" title=\"单线程的JS\"></a>单线程的JS</h2><p>其实，事件循环就是对于单线程的JS应运而生的。</p>\n<ul>\n<li>单线程？什么是线程，诶，我好像听过进程诶，他们两兄弟啥区别？</li>\n<li>为什么js一定要单线程啊，我听说CPU不是有很多核吗？为什么不多线程？</li>\n</ul>\n<h3 id=\"线程和进程的爱恨纠葛\"><a href=\"#线程和进程的爱恨纠葛\" class=\"headerlink\" title=\"线程和进程的爱恨纠葛\"></a>线程和进程的爱恨纠葛</h3><p>这里我推荐阮一峰老师的一篇文章 </p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\" rel=\"noopener\">点我学习</a></p>\n<h3 id=\"为什么JS是单线程？\"><a href=\"#为什么JS是单线程？\" class=\"headerlink\" title=\"为什么JS是单线程？\"></a>为什么JS是单线程？</h3><blockquote>\n<p>这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。</p>\n</blockquote>\n<h2 id=\"浏览器中的消息队列和事件循环\"><a href=\"#浏览器中的消息队列和事件循环\" class=\"headerlink\" title=\"浏览器中的消息队列和事件循环\"></a>浏览器中的消息队列和事件循环</h2><p>这里暂时只说浏览器中的循环事件循环，有关node的话可能有些细微的差别，不过底层的原理都是差不多的。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>这里主要是从一个设计者的角度来模拟，从零构建浏览器中的时间循环。为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><h4 id=\"事先约定好的执行顺序\"><a href=\"#事先约定好的执行顺序\" class=\"headerlink\" title=\"事先约定好的执行顺序\"></a>事先约定好的执行顺序</h4><p>假如我有以下几个任务</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>+<span class=\"number\">2</span>; <span class=\"comment\">// 任务 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = <span class=\"number\">20</span>/<span class=\"number\">5</span>; <span class=\"comment\">// 任务 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num3 = <span class=\"number\">7</span>*<span class=\"number\">8</span>; <span class=\"comment\">// 任务 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num1, num2, num3)； <span class=\"comment\">// 任务 4</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果让我来设计，我就会有一个主线程，然后把他们按顺序排进去，然后顺序执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>+<span class=\"number\">2</span>; <span class=\"comment\">// 任务 1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num2 = <span class=\"number\">20</span>/<span class=\"number\">5</span>; <span class=\"comment\">// 任务 2</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num3 = <span class=\"number\">7</span>*<span class=\"number\">8</span>; <span class=\"comment\">// 任务 3</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num1, num2, num3)； <span class=\"comment\">// 任务 4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>😯，我们已经设计了最简单的线程啦。</p>\n<h4 id=\"线程运行中，处理突发事件\"><a href=\"#线程运行中，处理突发事件\" class=\"headerlink\" title=\"线程运行中，处理突发事件\"></a>线程运行中，处理突发事件</h4><p>很多时候，所有的任务不是之前就统一安排好的，比如⌨️的输入，🖱的点击等等。</p>\n<p>如果想要在线程运行中可以很好的处理这些事件。就需要</p>\n<p> ====&gt;事件循环。这里我们用while来实现简单的事件循环</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'keydown'</span>, resolve);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br></pre></td></tr></table></figure>\n\n<p>这样改版之后有了以下几点改进：</p>\n<ul>\n<li>引入了循环机制</li>\n<li>引入事件，然后整个线程在运行的过程中，活了起来，不再是死的，运行完就滚蛋了的那种，有了交互了</li>\n</ul>\n<p>（🤫最简单的实现。。。别吐槽代码，都是最简单的实现和最简单的场景，助于理解而已。。。）</p>\n<h4 id=\"处理其他线程的任务\"><a href=\"#处理其他线程的任务\" class=\"headerlink\" title=\"处理其他线程的任务\"></a>处理其他线程的任务</h4><p>上面的版本用了事件循环的方式来获取内部的事件，但是对于外部突发情况的事件是无法解决的。所以，我们需要升级~</p>\n<p>那么怎么设计好一个线程模型呢？我们换个角度想想思路马上就出来了。</p>\n<p>这些外部的任务，都是有先后顺序的，哪怕是都是突发情况。他们也是有先后顺序。</p>\n<p>所以一个比较通用的模式就是</p>\n<p>======&gt; 消息队列</p>\n<blockquote>\n<p>消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>\n</blockquote>\n<p>我们要完成以下几个操作：</p>\n<ol>\n<li>添加一个消息队列；</li>\n<li>IO 线程中产生的新任务添加进消息队列尾部；</li>\n<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrTask = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTask</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  arrTask.push(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">otherThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addTask(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'other'</span>)&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arrTask.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">        task()</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br><span class=\"line\">otherThread()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们用一个数组来模拟一个队列。</p>\n<p>既基础了内部的任务，也处理了外部突发的任务</p>\n<p>有任务进来， 就会执行任务。</p>\n<h4 id=\"退出主线程\"><a href=\"#退出主线程\" class=\"headerlink\" title=\"退出主线程\"></a>退出主线程</h4><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrTask = []</span><br><span class=\"line\"><span class=\"keyword\">let</span> over = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTask</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  arrTask.push(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">otherThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addTask(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'other'</span>)&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awaitt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arrTask.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">        task()</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!arrTask.length)&#123;</span><br><span class=\"line\">          over = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(over)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">await</span> awaitt();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\">addTask(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'in'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br><span class=\"line\">otherThread()</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"单线程的缺点\"><a href=\"#单线程的缺点\" class=\"headerlink\" title=\"单线程的缺点\"></a>单线程的缺点</h3><p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>\n<h4 id=\"如何处理高优先级的任务\"><a href=\"#如何处理高优先级的任务\" class=\"headerlink\" title=\"如何处理高优先级的任务\"></a>如何处理高优先级的任务</h4><p>场景：</p>\n<p>假如，我现在有一大串的任务在主线程上执行。</p>\n<p>我的dom节点变化的时候，我需要发送请求或者提示一个<code>alert</code>之类的业务逻辑要执行。</p>\n<p>现在可行的有两种方案：</p>\n<ul>\n<li>dom节点变化的话，我就停下现在正在运行的主线程上的任务，然后调用我需要执行的业务逻辑。这样确实具有实效性，但是！这样会使得当前任务的效率极度降低，比如我的dom节点变化200次，那岂不是当前的任务特别久了吗？</li>\n<li>第二个方法就可以解决上述的问题：一旦dom节点有变化，哪怕是200000次变化，我都是将业务逻辑push到队列的尾部，这样就不会影响当前任务进行以及效率了。但是！这样的话我的实效性就莫得了。就莫得了。</li>\n</ul>\n<p>总结一下：其实就是实效性和任务效率的权衡问题罢了。</p>\n<p>江江江~</p>\n<p>微任务就应运而生啦。</p>\n<p>加入我们把任务队列里面的每个任务都称作宏任务的话，每个宏任务里面都会包含一个微任务队列。每个宏任务结束之后，都回去清理一遍微任务队列里面的队列，这样的话既保护了实效性，也保护了任务的效率。</p>\n<h4 id=\"如何处理调用时间过长的问题\"><a href=\"#如何处理调用时间过长的问题\" class=\"headerlink\" title=\"如何处理调用时间过长的问题\"></a>如何处理调用时间过长的问题</h4><p>我们都知道js是单线程的。如果现在在执行一个任务的情况下。其他任务就是要等待的。那么就会出现某个任务计算的周期特别长，导致别人都在等待。</p>\n<p>👌，我们来验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;&#125;</span><br><span class=\"line\">alter(<span class=\"number\">123</span>)</span><br></pre></td></tr></table></figure>\n\n<p>下面的<code>alter</code>永远都不会执行了。因为<code>while</code>在工作，<code>alter</code>在等他把资源让出来。</p>\n<p>假如说，我现在有一个动画要进行，但是运行完一帧之后，有一个极其复杂的计算，导致了我的动画不流畅，那么用户可能就会非常的烦。这不是我们希望看到的。</p>\n<p>所以js有一个回调机制，到了特定的时间点了，回调一下，把动画的下一帧执行一下，然后继续当前的复杂计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>\n<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>\n<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>\n<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>\n<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</li>\n</ul>\n<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p>\n<h2 id=\"浏览器是怎么实现setTimeout\"><a href=\"#浏览器是怎么实现setTimeout\" class=\"headerlink\" title=\"浏览器是怎么实现setTimeout\"></a>浏览器是怎么实现setTimeout</h2><p>要想知道浏览器是怎么实现的，我们先回顾一下，我们之前设计的那个事件循环系统：</p>\n<p>有xx任务了，ok，我<code>push</code>到任务队列。以此循环。</p>\n<p>所以我们写在<code>setTimeout</code>里面的函数执行其实也是一个任务，也是需要push到任务队列去的。</p>\n<p>但是，我们的这个是其实是一个异步的函数，不能直接将整个函数push到队列中，否则的话我们的实效性就很有可能出错了，比如我希望他在24小时之后<code>alter</code>告诉我已经到了第二天了。他如果是直接push到任务队列，没有到第二天就会告诉我第二天到了，这不是让用户匪夷所思嘛。</p>\n<p>所以肯定不是直接<code>push</code>的。那又是怎么弄得嘞？</p>\n<p>你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>\n<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p>\n<p>我们把之前的事件循环模拟改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mainTask = [</span><br><span class=\"line\">  fn1,</span><br><span class=\"line\">  fn2,</span><br><span class=\"line\">  fn3,</span><br><span class=\"line\">  ……</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setTimeoutTask = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addSetTimeoutTask</span>(<span class=\"params\">fn, timeout</span>)</span>&#123;</span><br><span class=\"line\">  setTimeoutTask.push(&#123;</span><br><span class=\"line\">    fn: fn,</span><br><span class=\"line\">    id: <span class=\"built_in\">Math</span>.random(),</span><br><span class=\"line\">    useTime: timeout + ((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> runSetTimeoutTask ()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> runList = []</span><br><span class=\"line\">  setTimeoutTask.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 已经过了时间，或者刚刚好到时间的话就取出来。待会一起执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(item.useTime &lt;= ((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()) &#123;</span><br><span class=\"line\">      runList.push(item.fn) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(runList.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = runList.shift()</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mainThread</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = arrTask.shift()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 每次执行完一个任务，都回去查找一下延迟队列里面有没有到点的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(setTimeoutTask.length) &#123;</span><br><span class=\"line\">       runSetTimeoutTask()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mainThread();</span><br></pre></td></tr></table></figure>\n\n<p>所以这里我们会看到一个问题，那就是其实你到点了可能要不会立刻执行，必须等到之前的任务执行完了才轮到延迟队列的查询和执行。</p>\n<p>我们代码中有一个彩蛋—-&gt; ID</p>\n<p>这个ID有什么用？</p>\n<p>就是用于<code>clearTimeout</code></p>\n<p>直接传入ID，然后循环找到他，就可以直接从队列里面删掉就好了。</p>\n<p>这里就不需要贴代码了吧？</p>\n<h3 id=\"冷知识\"><a href=\"#冷知识\" class=\"headerlink\" title=\"冷知识\"></a>冷知识</h3><ul>\n<li><strong>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</strong></li>\n<li><strong>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</strong><ul>\n<li>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</li>\n</ul>\n</li>\n<li><strong>延时执行时间有最大值</strong><ul>\n<li>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</li>\n</ul>\n</li>\n<li><strong>使用 setTimeout 设置的回调函数中的 this 不符合直觉</strong><ul>\n<li>这里可以看我之前的文章，有对this进行攻破</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n</ul>\n<h2 id=\"宏任务和微任务\"><a href=\"#宏任务和微任务\" class=\"headerlink\" title=\"宏任务和微任务\"></a>宏任务和微任务</h2><p>其实通过之前的学习，我们对事件循环已经了解的差不多了，这里主要是更详细了解一下他们。</p>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务有哪些？</p>\n<p>除了微任务的都是宏任务。。。</p>\n<p>那么微任务有哪些？</p>\n<p><code>Process.nextTick</code>、<code>Promise.then catch finally</code>(注意我不是说 Promise)、<code>MutationObserver</code>。</p>\n<p>在之前的学习我们知道在宏任务结束之后，会去执行他自己当前的微任务队列。在这个微任务队列执行完成之后再去执行下一个宏任务。</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>异步函数有两种方式：</p>\n<p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>\n<p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的</strong>。</p>\n<ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul>\n<h2 id=\"期末考试\"><a href=\"#期末考试\" class=\"headerlink\" title=\"期末考试\"></a>期末考试</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>大家可以自己在浏览器里面试试吧。</p>\n"},{"title":"【重识前端】原型/原型链和继承","date":"2020-07-13T15:51:21.000Z","cover":"/image/cover/web.jpeg","_content":"\n## 探究\n\n我觉得学习一个东西最重要的是搞懂三样东西\n\nWhat/How/Why\n\n### What\n\n什么是原型?什么是原型链?什么是继承?\n\n#### 原型\n\n在JavaScript中，**原型也是一个对象，通过原型可以实现对象的属性继承，**JavaScript的对象中都包含了一个\" [[Prototype]]\"内部属性，这个属性所对应的就是该对象的原型。\n\n\"[[Prototype]]\"作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了\"__proto__\"这个**非标准**（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器\"Object.getPrototype(object)\"）。\n\n用一句话来概括就是: 原型是一个属性可以被继承的对象.原型也可以有自己的原型.\n\n####\t原型链\n\n原型也可以有自己的原型, 而一个个原型通过prototype链接起来的就叫做原型链\n\n#### 继承\n\n儿子可以通过继承获得父亲的属性或者方法; \n\n### why\n\n为什么会有原型/原型链和继承?\n\n摘自JavaScript高级程序设计:\n\n> 继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: **接口继承** 和 **实现继承** .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 `实现继承` 主要是依靠原型链来实现的.\n\n### How\n\n#### 原型\n\n怎么找到原型?\n\n我们打开浏览器, 打开控制台(F12), 可以直接输入 `const obj = {}`, 我们就可以把他直接点开.发现里面有一个`__proto__` 其实我们输入的这个对象, 是一个`Object`构造函数的实例. 我们可以通过实例的`__proto__`属性找到他的原型;\n\n#### 原型链\n\n怎么找到原型链?\n\n在找之前我们先了解一个原型与构造函数与实例直接的关系.\n\n假定我们有一个构造函数 `function A(){}`, 我们称他为A\n\n我们有一个实例B, 他是这样来的: `const B = new A()`, 我们称他为B\n\nA的原型为C\n\n接下里我们写一个等式来很好的展示他们之间的关系\n\nA = prototype => C = construct => A = new => B = `__proto__` => C\n\n解释一下: A有一个属性`prototype` 指向A的原型 C, 而C的属性`construct`指向A, A通过new方法可以创建实例B, 而B有一个属性`__proto__`指向了C(A的原型)\n\n\n\nOK, 理解完上面的东西之后, 我们再加一个知识点, A的原型C, 也是C的原型的一个实例.\n\n\n\n先别懂没懂, 我们看一下实战.\n\n书接上文中的原型, 我再复制一下, 方便阅读\n\n> 我们打开浏览器, 打开控制台(F12), 可以直接输入 `const obj = {}`, 我们就可以把他直接点开.发现里面有一个`__proto__` 其实我们输入的这个对象, 是一个`Object`构造函数的实例. 我们可以通过实例的`__proto__`属性找到他的原型;\n\n我们接着点开`__proto__`,发现里面有一堆\"花里胡哨\"的东西, 我们找到了其中一个很眼熟的\"靓仔\" -> `construct`;\n\n根据之前的了解\n\n> ​\tA = prototype => C = construct => A = new => B = `__proto__` => C\n\n我们点开的这个`construct`其实那个空对象的构造函数`Object`, 那么他应该有一个`prototype`指向了他的原型.\n\n我们找找, 确实发现了有这么一个属性(`prototype`); 那么点开之后应该与最早的空对象的`__proto__`的内容一致. 根据等式可得;\n\n ##### 总结一下\n\n对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链\n\n接下来进入我们的重头戏继承\n\n### 继承\n\n其实继承又分为好多种: 原型链继承, 构造函数继承, 组合继承和寄生组合继承;\n\n#### 原型链继承\n\n\n\n```js\nfunction A(){\n\tthis.array = [\"a\", \"b\", \"c\"];\n}\n\nfunction B(){\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c,d\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,d,e\"\nconsole.log(b1.array) //\"a,b,c,d,e\"\n```\n\n我们定义了两个构造函数, A和B; 根据之前的知识, 我们让B的原型指向了构造函数A创造出来的实例(`new A()`); 然后我们用构造函数B创造了实例b1,  往 继承来的属性array 增加一个字符串\"d\"; 然后我们输出一下, 按照我们的逾期的多了一个\"e\"的情况下, 还有\"a,b,c\";\n\n接下来就有些问题了. 我们按照惯例, 通过构造函数B, 创造了b2. b2确实也有了继承来的属性\"array\", 可是这个array并不是我们想要的初始的`[\"a\",\"b\",\"c\"]`; 我们放弃探究, 继续往这个`array`里面增加一个`e`, 输出一下`b1`的属性`array`. 确实是可以增加这个`e`;\n\n\n\n可是!\n\n\n\n当我们输出`b1.array`时, 发现b1也被改了, 和之前诡异的b2多出一个`d`一样.\n\n探究发现这个由于我们用的是引用类型, 所以他们存储的是指向同一个内存的内存地址; 所以才会发生这些问题. 这也暴露了原型链继承时的一个问题.引用类型带来的毛病;\n\n其次, 我们发现我们的B的原型指向A的构造函数时不能传递参数, 这也的话有点呆板\n\n综上原型链的继承在日常中是很少用到的\n\n\n\n##### 优点\n\n​    子类可以通过原型链的查找，实现父类的属性公用与子类的实例\n\n##### 缺点\n\n- 一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类\n- 谨慎定义方法，以免定义方法也继承对象原型的方法重名\n- 无法直接给父级构造函数使用参数\n\n\n\n#### 构造函数继承\n\n```js\nfunction A(){\n\tthis.array = [\"a\", \"b\", \"c\"];\n}\n\nfunction B(){\n  A.call(this)\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,e\"\nconsole.log(b1.array) //\"a,b,c,d\"\n```\n\n我们奇迹般的发现, 构造函数的继承解决了我们之前发现的JavaScript引用问题.那函数传参的问...\n\n啪!\n\n停, 我们现在来传递一下参数!\n\n我们把上面的例子修改一下\n\n```js\nfunction A(name){\n\tthis.array = [\"a\", \"b\", \"c\"];\n  this.name = name\n}\n\nfunction B(){\n  A.call(this, 'B')\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\nconsole.log(b1.name); //\"B\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c\"\nconsole.log(b1.name); //\"B\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,e\"\nconsole.log(b1.array) //\"a,b,c,d\"\n```\n\n这样的话我们解决了原型链继承的两个问题(1.无法传参, 2.js引用问题);\n\n该不会有人认为这样就很完美了吧?不会吧!不会吧!\n\n我们冷静下来想想看, 其实这个传递参数是几乎算是写死的. 还不如直接在A里面直接写死好了, 根本就无法复用嘛; 而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。\n\n##### 优点\n\n- 解决了原型链继承的 引用类型操作问题\n- 解决了父类传递参数问题\n\n##### 缺点\n\n- 仅仅使用借用构造函数模式继承，无法摆脱够着函数。方法在构造函数中定义复用不可谈\n- 对于超类的原型定义的方法对于子类是不可使用的，子类的实例只是得到了父类的this绑定的属性 考虑到这些缺点，单独使用借用构造函数也是很少使用的\n\n\n\n#### 组合继承\n\n```js\nfunction A(name){\n  this.name = name\n  this.array = ['1', '2', '3']\n}\nA.prototype.sayName = function (){console.log(this.name)}\n\nfunction B(name, age){\n  A.call(this, name);\n  this.age = age;\n}\n\nB.prototype = new A();\nB.prototype.constructor = A; // 因为原型链继承，会把constructor指向改变，所以要重新指回自身\nB.prototype.sayAge = function (){console.log(this.age)}\n\nvar a = new B('a', 10)\na.array.push('a')\nconsole.log(a.array) // [\"1\", \"2\", \"3\", \"a\"]\na.sayName() // 'a'\na.sayAge() // 10\n\nvar b = new B('b', 20)\nb.array.push('b')\nconsole.log(b.array) // [\"1\", \"2\", \"3\", \"b\"]\nb.sayName()// 'b'\nb.sayAge() // 20\n```\n\n在这个例子中, 构造函数A有两个内置属性`name`和`array`. A的原型定义了一个方法`sayName`; 构造函数B在调用A的构造函数时传入了一个参数`name`, 然后又给B的原型上定义了一个方法`sayAge`. 这样一来, 就可以让两个B的实例分别拥有自己的属性, 当然也包括了array, 还可以拥有相同的方法.\n\n组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且(关键)，`instanceof` 和 `isPrototypeOf()`也能够用于识别基于组合继承创建的对象。\n\n##### 优点\n\n- 解决了原型链继承引用类型的实例操作导致引用改变\n- 解决了借构造函数继承方式的，父类原型子类实例可以使用\n\n##### 缺点\n\n父类的构造函数被实例换了两次 * 实例会有父类的构造函数的一些this属性、子类的构造函数（prototype）上也有一份实例的上有的属性\n\n#### 原型式继承\n\n道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n```\n\n看起来非常简单\n\n先在`object`函数内部创建一个临时的构造函数`F`, 然后将传入的这个对象`o`作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. \n\n简单来说就是`object`对传入的对象进行了浅复制.\n\n浅拷贝和深拷贝可以自行Google一下, 这算一个重要的知识点.\n\n举个🌰\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n\nvar a = {\n  name: 'a',\n  array: ['1', '2'],\n}\n\nvar qq = object(a)\nconsole.log(qq.name)\nqq.array.push('qq')\nconsole.log(qq.array)\n\nvar ww = object(a)\nconsole.log(ww.name)\nww.array.push('ww')\nconsole.log(ww.array)\nconsole.log(qq.array)\n```\n\n有没有似曾相识的感觉....原型链继承的老毛病来了...\n\n不过他也不是没有优点的.\n\n在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。\n\n> ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。有兴趣的话可以自己了解一下\n\n##### 优点\n\n再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分\n\n##### 缺点\n\n- 一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类\n- 谨慎定义方法，以免定义方法也继承对象原型的方法重名\n- 无法直接给父级构造函数使用参数\n\n#### 寄生继承\n\n寄生继承和原型式继承紧密相关, 同样也是由克罗克福德推而广 之的.寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。\n\n上代码\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n\nfunction createAnother(original){ \n  var clone=object(original); //通过调用函数创建一个新对象\n  clone.sayHi = function(){ //以某种方式来增强这个对象\n    alert(\"hi\");\n\t};\n\treturn clone;//返回这个对象\n }\n```\n\n在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，最后返回 clone 对象。\n\n```js\nvar person = {\n\tname: \"Nicholas\",\n\tfriends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = createAnother(person); \nanotherPerson.sayHi(); //\"hi\"\n```\n\n这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。\n\n在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。\n\n> 使用寄生继承, 由于不能做到函数复用而降低效率, 这点和构造函数继承很像\n\n##### 优点\n\n- 再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分\n- 可以给备份的对象添加一些属性\n\n##### 缺点\n\n类似构造函数一样，创建寄生的方法需要在clone对象上面添加一些想要的属性，这些属性是放在clone上面的一些私有的属性\n\n#### 寄生组合继承(终极方案\n\n前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。再来看一看下面组合继承的例子。\n\n```js\nfunction A(name){\n  this.name = name;\n  this.array = ['1','2','3']\n}\nA.prototype.sayName = function(){console.log(this.name)}\n\nfunction B(name, age){\n  \n  A.call(this, name) //第二次调用\n  this.age = age\n}\nB.prototype.sayAge = function(){console.log(this.age)}\n\nB.prototype = new A() // 第一次调用\nB.prototype.constructor = B\n```\n\n第一次调用A构造函数的时候, B的原型上就拥有了A的两个属性和一个方法;\n\n第二次调用A的构造函数时, 为B的实例创建了A的两个的属性和一个方法, 于是实例的两个属性和一个方法就屏蔽了原型上的实例和方法; \n\n是不是感觉有点点浪费, 不过好在我们已经找到解决方案--->寄生组合继承\n\n举一个非常简单的🌰, 并且我尽量逐字逐句的讲清楚\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n} //也可以用Object.create替代\n\nfunction B(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\n\nB.prototype.sayName = function(){ console.log(this.name);\n};\n\nfunction A(name, age){ \n  B.call(this, name); // 只调用了这一次\n\tthis.age = age; \n}\n\nfunction inheritPrototype(A, B){ \n  //让prototype可以拿到B的属性和方法...这是原型式继承\n  var prototype = object(B.prototype); \n  //由于重写了原型, 所以此时的constructor会指向Object, 所以必须指定一下constructor...那为什么会丢失呢?因为我们穿给object这个方法的是一个对象, 而对象的构造函数就是Object; 在原型那一小节我们说过了, 原型也是对象;\n  prototype.constructor = A; \n  // 继承属性之后就需要将原型给指向回去, 为了原型链的正确指向\n  A.prototype = prototype;\n}\n\ninheritPrototype(A, B);\n\nA.prototype.sayAge = function(){ \n  console.log(this.age);\n}\n```\n\n基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。实际上是**在组合继承的基础上，用超类型原型的副本代替调用超类型的构造函数给子类型指定原型**。\n\n本质上，是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。\n\n优点：只调用了一次超类型的构造函数，并且因此避免了在子类型的原型上创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用`instanceof`和`isPrototypeOf()`。普遍认为寄生组合式继承是引用类型**最理想**的继承方式。\n\n##### 优点\n\n- 在少一次实例化父类的情况下，实现了原型链继承和借用构造函数\n- 减少了原型链查找的次数（子类直接继承超类的prototype，而不是父类的实例）\n\n##### 缺点\n\n暂无\n\n\n\n#### class继承\n\n```js\nclass Parent{\n    constructor(name){\n        this.name = name;\n    }\n    getName(){\n        console.log(this.name);\n    }\n}\nclass Child extends Parent{\n    constructor(val){\n        super(val);\n    }\n}\nlet child = new Child('zhangsan');\nchild.getName();  //zhangsan\nchild instanceof Parent // true\n```\n\n**说明：**核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super。\nclass 的本质还是函数，这种表达不过是一种语法糖。\n\n这里就不展开了.","source":"_posts/【重识前端】原型原型链和继承.md","raw":"---\ntitle: 【重识前端】原型/原型链和继承\ndate: 2020-07-13 23:51:21\ntags: [原型/原型链, JavaScript, 继承]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n## 探究\n\n我觉得学习一个东西最重要的是搞懂三样东西\n\nWhat/How/Why\n\n### What\n\n什么是原型?什么是原型链?什么是继承?\n\n#### 原型\n\n在JavaScript中，**原型也是一个对象，通过原型可以实现对象的属性继承，**JavaScript的对象中都包含了一个\" [[Prototype]]\"内部属性，这个属性所对应的就是该对象的原型。\n\n\"[[Prototype]]\"作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了\"__proto__\"这个**非标准**（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器\"Object.getPrototype(object)\"）。\n\n用一句话来概括就是: 原型是一个属性可以被继承的对象.原型也可以有自己的原型.\n\n####\t原型链\n\n原型也可以有自己的原型, 而一个个原型通过prototype链接起来的就叫做原型链\n\n#### 继承\n\n儿子可以通过继承获得父亲的属性或者方法; \n\n### why\n\n为什么会有原型/原型链和继承?\n\n摘自JavaScript高级程序设计:\n\n> 继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: **接口继承** 和 **实现继承** .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 `实现继承` 主要是依靠原型链来实现的.\n\n### How\n\n#### 原型\n\n怎么找到原型?\n\n我们打开浏览器, 打开控制台(F12), 可以直接输入 `const obj = {}`, 我们就可以把他直接点开.发现里面有一个`__proto__` 其实我们输入的这个对象, 是一个`Object`构造函数的实例. 我们可以通过实例的`__proto__`属性找到他的原型;\n\n#### 原型链\n\n怎么找到原型链?\n\n在找之前我们先了解一个原型与构造函数与实例直接的关系.\n\n假定我们有一个构造函数 `function A(){}`, 我们称他为A\n\n我们有一个实例B, 他是这样来的: `const B = new A()`, 我们称他为B\n\nA的原型为C\n\n接下里我们写一个等式来很好的展示他们之间的关系\n\nA = prototype => C = construct => A = new => B = `__proto__` => C\n\n解释一下: A有一个属性`prototype` 指向A的原型 C, 而C的属性`construct`指向A, A通过new方法可以创建实例B, 而B有一个属性`__proto__`指向了C(A的原型)\n\n\n\nOK, 理解完上面的东西之后, 我们再加一个知识点, A的原型C, 也是C的原型的一个实例.\n\n\n\n先别懂没懂, 我们看一下实战.\n\n书接上文中的原型, 我再复制一下, 方便阅读\n\n> 我们打开浏览器, 打开控制台(F12), 可以直接输入 `const obj = {}`, 我们就可以把他直接点开.发现里面有一个`__proto__` 其实我们输入的这个对象, 是一个`Object`构造函数的实例. 我们可以通过实例的`__proto__`属性找到他的原型;\n\n我们接着点开`__proto__`,发现里面有一堆\"花里胡哨\"的东西, 我们找到了其中一个很眼熟的\"靓仔\" -> `construct`;\n\n根据之前的了解\n\n> ​\tA = prototype => C = construct => A = new => B = `__proto__` => C\n\n我们点开的这个`construct`其实那个空对象的构造函数`Object`, 那么他应该有一个`prototype`指向了他的原型.\n\n我们找找, 确实发现了有这么一个属性(`prototype`); 那么点开之后应该与最早的空对象的`__proto__`的内容一致. 根据等式可得;\n\n ##### 总结一下\n\n对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链\n\n接下来进入我们的重头戏继承\n\n### 继承\n\n其实继承又分为好多种: 原型链继承, 构造函数继承, 组合继承和寄生组合继承;\n\n#### 原型链继承\n\n\n\n```js\nfunction A(){\n\tthis.array = [\"a\", \"b\", \"c\"];\n}\n\nfunction B(){\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c,d\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,d,e\"\nconsole.log(b1.array) //\"a,b,c,d,e\"\n```\n\n我们定义了两个构造函数, A和B; 根据之前的知识, 我们让B的原型指向了构造函数A创造出来的实例(`new A()`); 然后我们用构造函数B创造了实例b1,  往 继承来的属性array 增加一个字符串\"d\"; 然后我们输出一下, 按照我们的逾期的多了一个\"e\"的情况下, 还有\"a,b,c\";\n\n接下来就有些问题了. 我们按照惯例, 通过构造函数B, 创造了b2. b2确实也有了继承来的属性\"array\", 可是这个array并不是我们想要的初始的`[\"a\",\"b\",\"c\"]`; 我们放弃探究, 继续往这个`array`里面增加一个`e`, 输出一下`b1`的属性`array`. 确实是可以增加这个`e`;\n\n\n\n可是!\n\n\n\n当我们输出`b1.array`时, 发现b1也被改了, 和之前诡异的b2多出一个`d`一样.\n\n探究发现这个由于我们用的是引用类型, 所以他们存储的是指向同一个内存的内存地址; 所以才会发生这些问题. 这也暴露了原型链继承时的一个问题.引用类型带来的毛病;\n\n其次, 我们发现我们的B的原型指向A的构造函数时不能传递参数, 这也的话有点呆板\n\n综上原型链的继承在日常中是很少用到的\n\n\n\n##### 优点\n\n​    子类可以通过原型链的查找，实现父类的属性公用与子类的实例\n\n##### 缺点\n\n- 一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类\n- 谨慎定义方法，以免定义方法也继承对象原型的方法重名\n- 无法直接给父级构造函数使用参数\n\n\n\n#### 构造函数继承\n\n```js\nfunction A(){\n\tthis.array = [\"a\", \"b\", \"c\"];\n}\n\nfunction B(){\n  A.call(this)\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,e\"\nconsole.log(b1.array) //\"a,b,c,d\"\n```\n\n我们奇迹般的发现, 构造函数的继承解决了我们之前发现的JavaScript引用问题.那函数传参的问...\n\n啪!\n\n停, 我们现在来传递一下参数!\n\n我们把上面的例子修改一下\n\n```js\nfunction A(name){\n\tthis.array = [\"a\", \"b\", \"c\"];\n  this.name = name\n}\n\nfunction B(){\n  A.call(this, 'B')\n}\n\n//继承了 A\nB.prototype = new A()\n\nvar b1 = new B()\nb1.array.push(\"d\"); \nconsole.log(b1.array); //\"a,b,c,d\"\nconsole.log(b1.name); //\"B\"\n\nvar b2 = new B(); \nconsole.log(b2.array); //\"a,b,c\"\nconsole.log(b1.name); //\"B\"\n\nb2.array.push(\"e\")\nconsole.log(b2.array) //\"a,b,c,e\"\nconsole.log(b1.array) //\"a,b,c,d\"\n```\n\n这样的话我们解决了原型链继承的两个问题(1.无法传参, 2.js引用问题);\n\n该不会有人认为这样就很完美了吧?不会吧!不会吧!\n\n我们冷静下来想想看, 其实这个传递参数是几乎算是写死的. 还不如直接在A里面直接写死好了, 根本就无法复用嘛; 而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。\n\n##### 优点\n\n- 解决了原型链继承的 引用类型操作问题\n- 解决了父类传递参数问题\n\n##### 缺点\n\n- 仅仅使用借用构造函数模式继承，无法摆脱够着函数。方法在构造函数中定义复用不可谈\n- 对于超类的原型定义的方法对于子类是不可使用的，子类的实例只是得到了父类的this绑定的属性 考虑到这些缺点，单独使用借用构造函数也是很少使用的\n\n\n\n#### 组合继承\n\n```js\nfunction A(name){\n  this.name = name\n  this.array = ['1', '2', '3']\n}\nA.prototype.sayName = function (){console.log(this.name)}\n\nfunction B(name, age){\n  A.call(this, name);\n  this.age = age;\n}\n\nB.prototype = new A();\nB.prototype.constructor = A; // 因为原型链继承，会把constructor指向改变，所以要重新指回自身\nB.prototype.sayAge = function (){console.log(this.age)}\n\nvar a = new B('a', 10)\na.array.push('a')\nconsole.log(a.array) // [\"1\", \"2\", \"3\", \"a\"]\na.sayName() // 'a'\na.sayAge() // 10\n\nvar b = new B('b', 20)\nb.array.push('b')\nconsole.log(b.array) // [\"1\", \"2\", \"3\", \"b\"]\nb.sayName()// 'b'\nb.sayAge() // 20\n```\n\n在这个例子中, 构造函数A有两个内置属性`name`和`array`. A的原型定义了一个方法`sayName`; 构造函数B在调用A的构造函数时传入了一个参数`name`, 然后又给B的原型上定义了一个方法`sayAge`. 这样一来, 就可以让两个B的实例分别拥有自己的属性, 当然也包括了array, 还可以拥有相同的方法.\n\n组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且(关键)，`instanceof` 和 `isPrototypeOf()`也能够用于识别基于组合继承创建的对象。\n\n##### 优点\n\n- 解决了原型链继承引用类型的实例操作导致引用改变\n- 解决了借构造函数继承方式的，父类原型子类实例可以使用\n\n##### 缺点\n\n父类的构造函数被实例换了两次 * 实例会有父类的构造函数的一些this属性、子类的构造函数（prototype）上也有一份实例的上有的属性\n\n#### 原型式继承\n\n道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n```\n\n看起来非常简单\n\n先在`object`函数内部创建一个临时的构造函数`F`, 然后将传入的这个对象`o`作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. \n\n简单来说就是`object`对传入的对象进行了浅复制.\n\n浅拷贝和深拷贝可以自行Google一下, 这算一个重要的知识点.\n\n举个🌰\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n\nvar a = {\n  name: 'a',\n  array: ['1', '2'],\n}\n\nvar qq = object(a)\nconsole.log(qq.name)\nqq.array.push('qq')\nconsole.log(qq.array)\n\nvar ww = object(a)\nconsole.log(ww.name)\nww.array.push('ww')\nconsole.log(ww.array)\nconsole.log(qq.array)\n```\n\n有没有似曾相识的感觉....原型链继承的老毛病来了...\n\n不过他也不是没有优点的.\n\n在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。\n\n> ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。有兴趣的话可以自己了解一下\n\n##### 优点\n\n再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分\n\n##### 缺点\n\n- 一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类\n- 谨慎定义方法，以免定义方法也继承对象原型的方法重名\n- 无法直接给父级构造函数使用参数\n\n#### 寄生继承\n\n寄生继承和原型式继承紧密相关, 同样也是由克罗克福德推而广 之的.寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。\n\n上代码\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n}\n\nfunction createAnother(original){ \n  var clone=object(original); //通过调用函数创建一个新对象\n  clone.sayHi = function(){ //以某种方式来增强这个对象\n    alert(\"hi\");\n\t};\n\treturn clone;//返回这个对象\n }\n```\n\n在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，最后返回 clone 对象。\n\n```js\nvar person = {\n\tname: \"Nicholas\",\n\tfriends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = createAnother(person); \nanotherPerson.sayHi(); //\"hi\"\n```\n\n这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。\n\n在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。\n\n> 使用寄生继承, 由于不能做到函数复用而降低效率, 这点和构造函数继承很像\n\n##### 优点\n\n- 再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分\n- 可以给备份的对象添加一些属性\n\n##### 缺点\n\n类似构造函数一样，创建寄生的方法需要在clone对象上面添加一些想要的属性，这些属性是放在clone上面的一些私有的属性\n\n#### 寄生组合继承(终极方案\n\n前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。再来看一看下面组合继承的例子。\n\n```js\nfunction A(name){\n  this.name = name;\n  this.array = ['1','2','3']\n}\nA.prototype.sayName = function(){console.log(this.name)}\n\nfunction B(name, age){\n  \n  A.call(this, name) //第二次调用\n  this.age = age\n}\nB.prototype.sayAge = function(){console.log(this.age)}\n\nB.prototype = new A() // 第一次调用\nB.prototype.constructor = B\n```\n\n第一次调用A构造函数的时候, B的原型上就拥有了A的两个属性和一个方法;\n\n第二次调用A的构造函数时, 为B的实例创建了A的两个的属性和一个方法, 于是实例的两个属性和一个方法就屏蔽了原型上的实例和方法; \n\n是不是感觉有点点浪费, 不过好在我们已经找到解决方案--->寄生组合继承\n\n举一个非常简单的🌰, 并且我尽量逐字逐句的讲清楚\n\n```js\nfunction object(o){\n  function F(){}\n  F.prototype = o\n  return new F\n} //也可以用Object.create替代\n\nfunction B(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\n\nB.prototype.sayName = function(){ console.log(this.name);\n};\n\nfunction A(name, age){ \n  B.call(this, name); // 只调用了这一次\n\tthis.age = age; \n}\n\nfunction inheritPrototype(A, B){ \n  //让prototype可以拿到B的属性和方法...这是原型式继承\n  var prototype = object(B.prototype); \n  //由于重写了原型, 所以此时的constructor会指向Object, 所以必须指定一下constructor...那为什么会丢失呢?因为我们穿给object这个方法的是一个对象, 而对象的构造函数就是Object; 在原型那一小节我们说过了, 原型也是对象;\n  prototype.constructor = A; \n  // 继承属性之后就需要将原型给指向回去, 为了原型链的正确指向\n  A.prototype = prototype;\n}\n\ninheritPrototype(A, B);\n\nA.prototype.sayAge = function(){ \n  console.log(this.age);\n}\n```\n\n基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。实际上是**在组合继承的基础上，用超类型原型的副本代替调用超类型的构造函数给子类型指定原型**。\n\n本质上，是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。\n\n优点：只调用了一次超类型的构造函数，并且因此避免了在子类型的原型上创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用`instanceof`和`isPrototypeOf()`。普遍认为寄生组合式继承是引用类型**最理想**的继承方式。\n\n##### 优点\n\n- 在少一次实例化父类的情况下，实现了原型链继承和借用构造函数\n- 减少了原型链查找的次数（子类直接继承超类的prototype，而不是父类的实例）\n\n##### 缺点\n\n暂无\n\n\n\n#### class继承\n\n```js\nclass Parent{\n    constructor(name){\n        this.name = name;\n    }\n    getName(){\n        console.log(this.name);\n    }\n}\nclass Child extends Parent{\n    constructor(val){\n        super(val);\n    }\n}\nlet child = new Child('zhangsan');\nchild.getName();  //zhangsan\nchild instanceof Parent // true\n```\n\n**说明：**核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super。\nclass 的本质还是函数，这种表达不过是一种语法糖。\n\n这里就不展开了.","slug":"【重识前端】原型原型链和继承","published":1,"updated":"2021-06-24T14:00:06.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8k001plwrd6bur87hd","content":"<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究\"></a>探究</h2><p>我觉得学习一个东西最重要的是搞懂三样东西</p>\n<p>What/How/Why</p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>什么是原型?什么是原型链?什么是继承?</p>\n<h4 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>在JavaScript中，<strong>原型也是一个对象，通过原型可以实现对象的属性继承，</strong>JavaScript的对象中都包含了一个” [[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。</p>\n<p>“[[Prototype]]”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了”<strong>proto</strong>“这个<strong>非标准</strong>（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器”Object.getPrototype(object)”）。</p>\n<p>用一句话来概括就是: 原型是一个属性可以被继承的对象.原型也可以有自己的原型.</p>\n<h4 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>原型也可以有自己的原型, 而一个个原型通过prototype链接起来的就叫做原型链</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>儿子可以通过继承获得父亲的属性或者方法; </p>\n<h3 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h3><p>为什么会有原型/原型链和继承?</p>\n<p>摘自JavaScript高级程序设计:</p>\n<blockquote>\n<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <strong>接口继承</strong> 和 <strong>实现继承</strong> .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>\n</blockquote>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><h4 id=\"原型-1\"><a href=\"#原型-1\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>怎么找到原型?</p>\n<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>\n<h4 id=\"原型链-1\"><a href=\"#原型链-1\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>怎么找到原型链?</p>\n<p>在找之前我们先了解一个原型与构造函数与实例直接的关系.</p>\n<p>假定我们有一个构造函数 <code>function A(){}</code>, 我们称他为A</p>\n<p>我们有一个实例B, 他是这样来的: <code>const B = new A()</code>, 我们称他为B</p>\n<p>A的原型为C</p>\n<p>接下里我们写一个等式来很好的展示他们之间的关系</p>\n<p>A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>\n<p>解释一下: A有一个属性<code>prototype</code> 指向A的原型 C, 而C的属性<code>construct</code>指向A, A通过new方法可以创建实例B, 而B有一个属性<code>__proto__</code>指向了C(A的原型)</p>\n<p>OK, 理解完上面的东西之后, 我们再加一个知识点, A的原型C, 也是C的原型的一个实例.</p>\n<p>先别懂没懂, 我们看一下实战.</p>\n<p>书接上文中的原型, 我再复制一下, 方便阅读</p>\n<blockquote>\n<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>\n</blockquote>\n<p>我们接着点开<code>__proto__</code>,发现里面有一堆”花里胡哨”的东西, 我们找到了其中一个很眼熟的”靓仔” -&gt; <code>construct</code>;</p>\n<p>根据之前的了解</p>\n<blockquote>\n<p>​    A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>\n</blockquote>\n<p>我们点开的这个<code>construct</code>其实那个空对象的构造函数<code>Object</code>, 那么他应该有一个<code>prototype</code>指向了他的原型.</p>\n<p>我们找找, 确实发现了有这么一个属性(<code>prototype</code>); 那么点开之后应该与最早的空对象的<code>__proto__</code>的内容一致. 根据等式可得;</p>\n<h5 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h5><p>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</p>\n<p>接下来进入我们的重头戏继承</p>\n<h3 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>其实继承又分为好多种: 原型链继承, 构造函数继承, 组合继承和寄生组合继承;</p>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,d,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d,e\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们定义了两个构造函数, A和B; 根据之前的知识, 我们让B的原型指向了构造函数A创造出来的实例(<code>new A()</code>); 然后我们用构造函数B创造了实例b1,  往 继承来的属性array 增加一个字符串”d”; 然后我们输出一下, 按照我们的逾期的多了一个”e”的情况下, 还有”a,b,c”;</p>\n<p>接下来就有些问题了. 我们按照惯例, 通过构造函数B, 创造了b2. b2确实也有了继承来的属性”array”, 可是这个array并不是我们想要的初始的<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>; 我们放弃探究, 继续往这个<code>array</code>里面增加一个<code>e</code>, 输出一下<code>b1</code>的属性<code>array</code>. 确实是可以增加这个<code>e</code>;</p>\n<p>可是!</p>\n<p>当我们输出<code>b1.array</code>时, 发现b1也被改了, 和之前诡异的b2多出一个<code>d</code>一样.</p>\n<p>探究发现这个由于我们用的是引用类型, 所以他们存储的是指向同一个内存的内存地址; 所以才会发生这些问题. 这也暴露了原型链继承时的一个问题.引用类型带来的毛病;</p>\n<p>其次, 我们发现我们的B的原型指向A的构造函数时不能传递参数, 这也的话有点呆板</p>\n<p>综上原型链的继承在日常中是很少用到的</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><p>​    子类可以通过原型链的查找，实现父类的属性公用与子类的实例</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>\n<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>\n<li>无法直接给父级构造函数使用参数</li>\n</ul>\n<h4 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们奇迹般的发现, 构造函数的继承解决了我们之前发现的JavaScript引用问题.那函数传参的问…</p>\n<p>啪!</p>\n<p>停, 我们现在来传递一下参数!</p>\n<p>我们把上面的例子修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, <span class=\"string\">'B'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.name); <span class=\"comment\">//\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.name); <span class=\"comment\">//\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的话我们解决了原型链继承的两个问题(1.无法传参, 2.js引用问题);</p>\n<p>该不会有人认为这样就很完美了吧?不会吧!不会吧!</p>\n<p>我们冷静下来想想看, 其实这个传递参数是几乎算是写死的. 还不如直接在A里面直接写死好了, 根本就无法复用嘛; 而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>\n<h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>解决了原型链继承的 引用类型操作问题</li>\n<li>解决了父类传递参数问题</li>\n</ul>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>仅仅使用借用构造函数模式继承，无法摆脱够着函数。方法在构造函数中定义复用不可谈</li>\n<li>对于超类的原型定义的方法对于子类是不可使用的，子类的实例只是得到了父类的this绑定的属性 考虑到这些缺点，单独使用借用构造函数也是很少使用的</li>\n</ul>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.array = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B.prototype.constructor = A; <span class=\"comment\">// 因为原型链继承，会把constructor指向改变，所以要重新指回自身</span></span><br><span class=\"line\">B.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> B(<span class=\"string\">'a'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">a.array.push(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.array) <span class=\"comment\">// [\"1\", \"2\", \"3\", \"a\"]</span></span><br><span class=\"line\">a.sayName() <span class=\"comment\">// 'a'</span></span><br><span class=\"line\">a.sayAge() <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">b.array.push(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.array) <span class=\"comment\">// [\"1\", \"2\", \"3\", \"b\"]</span></span><br><span class=\"line\">b.sayName()<span class=\"comment\">// 'b'</span></span><br><span class=\"line\">b.sayAge() <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中, 构造函数A有两个内置属性<code>name</code>和<code>array</code>. A的原型定义了一个方法<code>sayName</code>; 构造函数B在调用A的构造函数时传入了一个参数<code>name</code>, 然后又给B的原型上定义了一个方法<code>sayAge</code>. 这样一来, 就可以让两个B的实例分别拥有自己的属性, 当然也包括了array, 还可以拥有相同的方法.</p>\n<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且(关键)，<code>instanceof</code> 和 <code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>\n<h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>解决了原型链继承引用类型的实例操作导致引用改变</li>\n<li>解决了借构造函数继承方式的，父类原型子类实例可以使用</li>\n</ul>\n<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>父类的构造函数被实例换了两次 * 实例会有父类的构造函数的一些this属性、子类的构造函数（prototype）上也有一份实例的上有的属性</p>\n<h4 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h4><p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来非常简单</p>\n<p>先在<code>object</code>函数内部创建一个临时的构造函数<code>F</code>, 然后将传入的这个对象<code>o</code>作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. </p>\n<p>简单来说就是<code>object</code>对传入的对象进行了浅复制.</p>\n<p>浅拷贝和深拷贝可以自行Google一下, 这算一个重要的知识点.</p>\n<p>举个🌰</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  array: [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> qq = object(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.name)</span><br><span class=\"line\">qq.array.push(<span class=\"string\">'qq'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ww = object(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ww.name)</span><br><span class=\"line\">ww.array.push(<span class=\"string\">'ww'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ww.array)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.array)</span><br></pre></td></tr></table></figure>\n\n<p>有没有似曾相识的感觉….原型链继承的老毛病来了…</p>\n<p>不过他也不是没有优点的.</p>\n<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。</p>\n<blockquote>\n<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。有兴趣的话可以自己了解一下</p>\n</blockquote>\n<h5 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h5><p>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</p>\n<h5 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>\n<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>\n<li>无法直接给父级构造函数使用参数</li>\n</ul>\n<h4 id=\"寄生继承\"><a href=\"#寄生继承\" class=\"headerlink\" title=\"寄生继承\"></a>寄生继承</h4><p>寄生继承和原型式继承紧密相关, 同样也是由克罗克福德推而广 之的.寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。</p>\n<p>上代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone=object(original); <span class=\"comment\">//通过调用函数创建一个新对象</span></span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//以某种方式来增强这个对象</span></span><br><span class=\"line\">    alert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> clone;<span class=\"comment\">//返回这个对象</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，最后返回 clone 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">\"Nicholas\"</span>,</span><br><span class=\"line\">\tfriends: [<span class=\"string\">\"Shelby\"</span>, <span class=\"string\">\"Court\"</span>, <span class=\"string\">\"Van\"</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = createAnother(person); </span><br><span class=\"line\">anotherPerson.sayHi(); <span class=\"comment\">//\"hi\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。</p>\n<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。</p>\n<blockquote>\n<p>使用寄生继承, 由于不能做到函数复用而降低效率, 这点和构造函数继承很像</p>\n</blockquote>\n<h5 id=\"优点-4\"><a href=\"#优点-4\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</li>\n<li>可以给备份的对象添加一些属性</li>\n</ul>\n<h5 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>类似构造函数一样，创建寄生的方法需要在clone对象上面添加一些想要的属性，这些属性是放在clone上面的一些私有的属性</p>\n<h4 id=\"寄生组合继承-终极方案\"><a href=\"#寄生组合继承-终极方案\" class=\"headerlink\" title=\"寄生组合继承(终极方案\"></a>寄生组合继承(终极方案</h4><p>前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。再来看一看下面组合继承的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.array = [<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, name) <span class=\"comment\">//第二次调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A() <span class=\"comment\">// 第一次调用</span></span><br><span class=\"line\">B.prototype.constructor = B</span><br></pre></td></tr></table></figure>\n\n<p>第一次调用A构造函数的时候, B的原型上就拥有了A的两个属性和一个方法;</p>\n<p>第二次调用A的构造函数时, 为B的实例创建了A的两个的属性和一个方法, 于是实例的两个属性和一个方法就屏蔽了原型上的实例和方法; </p>\n<p>是不是感觉有点点浪费, 不过好在我们已经找到解决方案—&gt;寄生组合继承</p>\n<p>举一个非常简单的🌰, 并且我尽量逐字逐句的讲清楚</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125; <span class=\"comment\">//也可以用Object.create替代</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name, age</span>)</span>&#123; </span><br><span class=\"line\">  B.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 只调用了这一次</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">A, B</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">//让prototype可以拿到B的属性和方法...这是原型式继承</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = object(B.prototype); </span><br><span class=\"line\">  <span class=\"comment\">//由于重写了原型, 所以此时的constructor会指向Object, 所以必须指定一下constructor...那为什么会丢失呢?因为我们穿给object这个方法的是一个对象, 而对象的构造函数就是Object; 在原型那一小节我们说过了, 原型也是对象;</span></span><br><span class=\"line\">  prototype.constructor = A; </span><br><span class=\"line\">  <span class=\"comment\">// 继承属性之后就需要将原型给指向回去, 为了原型链的正确指向</span></span><br><span class=\"line\">  A.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inheritPrototype(A, B);</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。实际上是<strong>在组合继承的基础上，用超类型原型的副本代替调用超类型的构造函数给子类型指定原型</strong>。</p>\n<p>本质上，是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>\n<p>优点：只调用了一次超类型的构造函数，并且因此避免了在子类型的原型上创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code>。普遍认为寄生组合式继承是引用类型<strong>最理想</strong>的继承方式。</p>\n<h5 id=\"优点-5\"><a href=\"#优点-5\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>在少一次实例化父类的情况下，实现了原型链继承和借用构造函数</li>\n<li>减少了原型链查找的次数（子类直接继承超类的prototype，而不是父类的实例）</li>\n</ul>\n<h5 id=\"缺点-5\"><a href=\"#缺点-5\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>暂无</p>\n<h4 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zhangsan'</span>);</span><br><span class=\"line\">child.getName();  <span class=\"comment\">//zhangsan</span></span><br><span class=\"line\">child <span class=\"keyword\">instanceof</span> Parent <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：</strong>核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super。<br>class 的本质还是函数，这种表达不过是一种语法糖。</p>\n<p>这里就不展开了.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究\"></a>探究</h2><p>我觉得学习一个东西最重要的是搞懂三样东西</p>\n<p>What/How/Why</p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>什么是原型?什么是原型链?什么是继承?</p>\n<h4 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>在JavaScript中，<strong>原型也是一个对象，通过原型可以实现对象的属性继承，</strong>JavaScript的对象中都包含了一个” [[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。</p>\n<p>“[[Prototype]]”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了”<strong>proto</strong>“这个<strong>非标准</strong>（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器”Object.getPrototype(object)”）。</p>\n<p>用一句话来概括就是: 原型是一个属性可以被继承的对象.原型也可以有自己的原型.</p>\n<h4 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>原型也可以有自己的原型, 而一个个原型通过prototype链接起来的就叫做原型链</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>儿子可以通过继承获得父亲的属性或者方法; </p>\n<h3 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h3><p>为什么会有原型/原型链和继承?</p>\n<p>摘自JavaScript高级程序设计:</p>\n<blockquote>\n<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <strong>接口继承</strong> 和 <strong>实现继承</strong> .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>\n</blockquote>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><h4 id=\"原型-1\"><a href=\"#原型-1\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>怎么找到原型?</p>\n<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>\n<h4 id=\"原型链-1\"><a href=\"#原型链-1\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>怎么找到原型链?</p>\n<p>在找之前我们先了解一个原型与构造函数与实例直接的关系.</p>\n<p>假定我们有一个构造函数 <code>function A(){}</code>, 我们称他为A</p>\n<p>我们有一个实例B, 他是这样来的: <code>const B = new A()</code>, 我们称他为B</p>\n<p>A的原型为C</p>\n<p>接下里我们写一个等式来很好的展示他们之间的关系</p>\n<p>A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>\n<p>解释一下: A有一个属性<code>prototype</code> 指向A的原型 C, 而C的属性<code>construct</code>指向A, A通过new方法可以创建实例B, 而B有一个属性<code>__proto__</code>指向了C(A的原型)</p>\n<p>OK, 理解完上面的东西之后, 我们再加一个知识点, A的原型C, 也是C的原型的一个实例.</p>\n<p>先别懂没懂, 我们看一下实战.</p>\n<p>书接上文中的原型, 我再复制一下, 方便阅读</p>\n<blockquote>\n<p>我们打开浏览器, 打开控制台(F12), 可以直接输入 <code>const obj = {}</code>, 我们就可以把他直接点开.发现里面有一个<code>__proto__</code> 其实我们输入的这个对象, 是一个<code>Object</code>构造函数的实例. 我们可以通过实例的<code>__proto__</code>属性找到他的原型;</p>\n</blockquote>\n<p>我们接着点开<code>__proto__</code>,发现里面有一堆”花里胡哨”的东西, 我们找到了其中一个很眼熟的”靓仔” -&gt; <code>construct</code>;</p>\n<p>根据之前的了解</p>\n<blockquote>\n<p>​    A = prototype =&gt; C = construct =&gt; A = new =&gt; B = <code>__proto__</code> =&gt; C</p>\n</blockquote>\n<p>我们点开的这个<code>construct</code>其实那个空对象的构造函数<code>Object</code>, 那么他应该有一个<code>prototype</code>指向了他的原型.</p>\n<p>我们找找, 确实发现了有这么一个属性(<code>prototype</code>); 那么点开之后应该与最早的空对象的<code>__proto__</code>的内容一致. 根据等式可得;</p>\n<h5 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h5><p>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</p>\n<p>接下来进入我们的重头戏继承</p>\n<h3 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>其实继承又分为好多种: 原型链继承, 构造函数继承, 组合继承和寄生组合继承;</p>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,d,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d,e\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们定义了两个构造函数, A和B; 根据之前的知识, 我们让B的原型指向了构造函数A创造出来的实例(<code>new A()</code>); 然后我们用构造函数B创造了实例b1,  往 继承来的属性array 增加一个字符串”d”; 然后我们输出一下, 按照我们的逾期的多了一个”e”的情况下, 还有”a,b,c”;</p>\n<p>接下来就有些问题了. 我们按照惯例, 通过构造函数B, 创造了b2. b2确实也有了继承来的属性”array”, 可是这个array并不是我们想要的初始的<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>; 我们放弃探究, 继续往这个<code>array</code>里面增加一个<code>e</code>, 输出一下<code>b1</code>的属性<code>array</code>. 确实是可以增加这个<code>e</code>;</p>\n<p>可是!</p>\n<p>当我们输出<code>b1.array</code>时, 发现b1也被改了, 和之前诡异的b2多出一个<code>d</code>一样.</p>\n<p>探究发现这个由于我们用的是引用类型, 所以他们存储的是指向同一个内存的内存地址; 所以才会发生这些问题. 这也暴露了原型链继承时的一个问题.引用类型带来的毛病;</p>\n<p>其次, 我们发现我们的B的原型指向A的构造函数时不能传递参数, 这也的话有点呆板</p>\n<p>综上原型链的继承在日常中是很少用到的</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><p>​    子类可以通过原型链的查找，实现父类的属性公用与子类的实例</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>\n<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>\n<li>无法直接给父级构造函数使用参数</li>\n</ul>\n<h4 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d\"</span></span><br></pre></td></tr></table></figure>\n\n<p>我们奇迹般的发现, 构造函数的继承解决了我们之前发现的JavaScript引用问题.那函数传参的问…</p>\n<p>啪!</p>\n<p>停, 我们现在来传递一下参数!</p>\n<p>我们把上面的例子修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.array = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, <span class=\"string\">'B'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了 A</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b1.array.push(<span class=\"string\">\"d\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array); <span class=\"comment\">//\"a,b,c,d\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.name); <span class=\"comment\">//\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = <span class=\"keyword\">new</span> B(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array); <span class=\"comment\">//\"a,b,c\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.name); <span class=\"comment\">//\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">b2.array.push(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b2.array) <span class=\"comment\">//\"a,b,c,e\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b1.array) <span class=\"comment\">//\"a,b,c,d\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的话我们解决了原型链继承的两个问题(1.无法传参, 2.js引用问题);</p>\n<p>该不会有人认为这样就很完美了吧?不会吧!不会吧!</p>\n<p>我们冷静下来想想看, 其实这个传递参数是几乎算是写死的. 还不如直接在A里面直接写死好了, 根本就无法复用嘛; 而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>\n<h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>解决了原型链继承的 引用类型操作问题</li>\n<li>解决了父类传递参数问题</li>\n</ul>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>仅仅使用借用构造函数模式继承，无法摆脱够着函数。方法在构造函数中定义复用不可谈</li>\n<li>对于超类的原型定义的方法对于子类是不可使用的，子类的实例只是得到了父类的this绑定的属性 考虑到这些缺点，单独使用借用构造函数也是很少使用的</li>\n</ul>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.array = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B.prototype.constructor = A; <span class=\"comment\">// 因为原型链继承，会把constructor指向改变，所以要重新指回自身</span></span><br><span class=\"line\">B.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> B(<span class=\"string\">'a'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">a.array.push(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.array) <span class=\"comment\">// [\"1\", \"2\", \"3\", \"a\"]</span></span><br><span class=\"line\">a.sayName() <span class=\"comment\">// 'a'</span></span><br><span class=\"line\">a.sayAge() <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">b.array.push(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.array) <span class=\"comment\">// [\"1\", \"2\", \"3\", \"b\"]</span></span><br><span class=\"line\">b.sayName()<span class=\"comment\">// 'b'</span></span><br><span class=\"line\">b.sayAge() <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中, 构造函数A有两个内置属性<code>name</code>和<code>array</code>. A的原型定义了一个方法<code>sayName</code>; 构造函数B在调用A的构造函数时传入了一个参数<code>name</code>, 然后又给B的原型上定义了一个方法<code>sayAge</code>. 这样一来, 就可以让两个B的实例分别拥有自己的属性, 当然也包括了array, 还可以拥有相同的方法.</p>\n<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且(关键)，<code>instanceof</code> 和 <code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>\n<h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>解决了原型链继承引用类型的实例操作导致引用改变</li>\n<li>解决了借构造函数继承方式的，父类原型子类实例可以使用</li>\n</ul>\n<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>父类的构造函数被实例换了两次 * 实例会有父类的构造函数的一些this属性、子类的构造函数（prototype）上也有一份实例的上有的属性</p>\n<h4 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h4><p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来非常简单</p>\n<p>先在<code>object</code>函数内部创建一个临时的构造函数<code>F</code>, 然后将传入的这个对象<code>o</code>作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. </p>\n<p>简单来说就是<code>object</code>对传入的对象进行了浅复制.</p>\n<p>浅拷贝和深拷贝可以自行Google一下, 这算一个重要的知识点.</p>\n<p>举个🌰</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  array: [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> qq = object(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.name)</span><br><span class=\"line\">qq.array.push(<span class=\"string\">'qq'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ww = object(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ww.name)</span><br><span class=\"line\">ww.array.push(<span class=\"string\">'ww'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ww.array)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(qq.array)</span><br></pre></td></tr></table></figure>\n\n<p>有没有似曾相识的感觉….原型链继承的老毛病来了…</p>\n<p>不过他也不是没有优点的.</p>\n<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。</p>\n<blockquote>\n<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。有兴趣的话可以自己了解一下</p>\n</blockquote>\n<h5 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h5><p>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</p>\n<h5 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li>\n<li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li>\n<li>无法直接给父级构造函数使用参数</li>\n</ul>\n<h4 id=\"寄生继承\"><a href=\"#寄生继承\" class=\"headerlink\" title=\"寄生继承\"></a>寄生继承</h4><p>寄生继承和原型式继承紧密相关, 同样也是由克罗克福德推而广 之的.寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。</p>\n<p>上代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone=object(original); <span class=\"comment\">//通过调用函数创建一个新对象</span></span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//以某种方式来增强这个对象</span></span><br><span class=\"line\">    alert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> clone;<span class=\"comment\">//返回这个对象</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，最后返回 clone 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">\"Nicholas\"</span>,</span><br><span class=\"line\">\tfriends: [<span class=\"string\">\"Shelby\"</span>, <span class=\"string\">\"Court\"</span>, <span class=\"string\">\"Van\"</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = createAnother(person); </span><br><span class=\"line\">anotherPerson.sayHi(); <span class=\"comment\">//\"hi\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。</p>\n<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。</p>\n<blockquote>\n<p>使用寄生继承, 由于不能做到函数复用而降低效率, 这点和构造函数继承很像</p>\n</blockquote>\n<h5 id=\"优点-4\"><a href=\"#优点-4\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分</li>\n<li>可以给备份的对象添加一些属性</li>\n</ul>\n<h5 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>类似构造函数一样，创建寄生的方法需要在clone对象上面添加一些想要的属性，这些属性是放在clone上面的一些私有的属性</p>\n<h4 id=\"寄生组合继承-终极方案\"><a href=\"#寄生组合继承-终极方案\" class=\"headerlink\" title=\"寄生组合继承(终极方案\"></a>寄生组合继承(终极方案</h4><p>前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。再来看一看下面组合继承的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.array = [<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  A.call(<span class=\"keyword\">this</span>, name) <span class=\"comment\">//第二次调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A() <span class=\"comment\">// 第一次调用</span></span><br><span class=\"line\">B.prototype.constructor = B</span><br></pre></td></tr></table></figure>\n\n<p>第一次调用A构造函数的时候, B的原型上就拥有了A的两个属性和一个方法;</p>\n<p>第二次调用A的构造函数时, 为B的实例创建了A的两个的属性和一个方法, 于是实例的两个属性和一个方法就屏蔽了原型上的实例和方法; </p>\n<p>是不是感觉有点点浪费, 不过好在我们已经找到解决方案—&gt;寄生组合继承</p>\n<p>举一个非常简单的🌰, 并且我尽量逐字逐句的讲清楚</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125; <span class=\"comment\">//也可以用Object.create替代</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name, age</span>)</span>&#123; </span><br><span class=\"line\">  B.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 只调用了这一次</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">A, B</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">//让prototype可以拿到B的属性和方法...这是原型式继承</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = object(B.prototype); </span><br><span class=\"line\">  <span class=\"comment\">//由于重写了原型, 所以此时的constructor会指向Object, 所以必须指定一下constructor...那为什么会丢失呢?因为我们穿给object这个方法的是一个对象, 而对象的构造函数就是Object; 在原型那一小节我们说过了, 原型也是对象;</span></span><br><span class=\"line\">  prototype.constructor = A; </span><br><span class=\"line\">  <span class=\"comment\">// 继承属性之后就需要将原型给指向回去, 为了原型链的正确指向</span></span><br><span class=\"line\">  A.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inheritPrototype(A, B);</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。实际上是<strong>在组合继承的基础上，用超类型原型的副本代替调用超类型的构造函数给子类型指定原型</strong>。</p>\n<p>本质上，是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>\n<p>优点：只调用了一次超类型的构造函数，并且因此避免了在子类型的原型上创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code>。普遍认为寄生组合式继承是引用类型<strong>最理想</strong>的继承方式。</p>\n<h5 id=\"优点-5\"><a href=\"#优点-5\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>在少一次实例化父类的情况下，实现了原型链继承和借用构造函数</li>\n<li>减少了原型链查找的次数（子类直接继承超类的prototype，而不是父类的实例）</li>\n</ul>\n<h5 id=\"缺点-5\"><a href=\"#缺点-5\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>暂无</p>\n<h4 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zhangsan'</span>);</span><br><span class=\"line\">child.getName();  <span class=\"comment\">//zhangsan</span></span><br><span class=\"line\">child <span class=\"keyword\">instanceof</span> Parent <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：</strong>核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super。<br>class 的本质还是函数，这种表达不过是一种语法糖。</p>\n<p>这里就不展开了.</p>\n"},{"title":"【重识前端】全面攻破this","date":"2020-07-16T14:02:55.000Z","cover":"/image/cover/web.jpeg","_content":"\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n其实说起this，这个几乎是前端面试必考题，也是前端最多“脑经急转弯”的地方，也是让无数前端人烦恼的地方。今天我们就彻底的深入this，全面的攻破它！\n\n## 绑定规则\n\n我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。\n\n你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。\n\nthis的绑定规则总共有以下5种：\n\n1. 默认绑定（最令人头疼的）\n   1. 严格模式\n   2. 非严格模式\n2. 隐式绑定\n3. 显式绑定\n   1. bind\n   2. call\n   3. apply\n4. new绑定\n\n### 默认绑定\n\n默认绑定顾名思义，就是没人要的“孤儿”就会应用默认绑定。\n\n思考🤔一下👇的代码会输出什么？\n\n```js\nvar a = 'out'\nfunction fnc() {\n  var a = 'in'\n  console.log(this.a)\n}\nfnc();\n```\n\n**答案是：'out'**\n\n我们可以看到当调用 `fnc()` 时，`this.a` 被解析成了全局变量 `a`。为什么?因为在本 例中，函数调用时应用了 `this` 的默认绑定，因此 `this` 指向全局对象。\n\n那我们怎么知道他是应用了默认绑定呢？\n\n我们发现 `fnc` 他只是孤零零的被调用，没有任何的修饰*（调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。）*，所以它就相当于是没有人要的`孩子`，只能去`福利院`---默认绑定。\n\n这样说可能还不太明白默认绑定究竟是怎么一回事。等到后面的规则介绍的多了，你就会发现没有应用其他规则的“孤儿”只能来福利院 ---默认绑定的怀抱\n\n#### 严格模式\n\n在严格下，默认绑定不是绑定到`window`，而是`undefined`。\n\n```js\nvar a = 'out'\nfunction fnc() {\n\t\"use strict\";\n\n  var a = 'in'\n  console.log(this.a)\n}\nfnc();\n```\n\n**答案是：报错**\n\n为什么？因为我们想在`undefined`里面找`a`，那肯定是报错的\n\n### 隐式绑定\n\n隐式绑定，顾名思义就是悄悄的绑定，或者说公认的，但是没有明说的绑定。就好比一个男人和一个女人手牵手走在一起，他们基本上可以认定就是在情侣，但是还是有可能会是“偷情”（映射到隐式绑定的隐式丢失，等会会说到。）\n\n思考🤔一下👇的代码会输出什么？\n\n```js\nvar a = 'out'\nfunction fnc() {\n  console.log(this.a)\n}\nvar obj = {\n  a: 'in',\n  fnc: fnc\n}\nobj.fnc();\n```\n\n**答案是：'in'**\n\n我们可以注意到，`fnc` 是在什么情况下被调用的？是`obj` 调用的，说明这个`fnc`已经有主了，护花使者是`obj`，所以`fnc`说的话肯定是向着`obj`的，胳膊肘不会往外拐。\n\n其实这里面有一个小的点需要注意，那就是如果是多个对象引用的调用，那这个时候的执行上下文又是谁的呢？\n\n其实我们用常理就可以解释这个问题，A叫B去吃饭，但是B想叫C一起去，结果A和B起了冲突，你作为这个C你会向着谁？那肯定是B，因为有C叫你去，你们才会出现在这场聚会。所以这个问题不难回答。我们直接看一个例子🌰\n\n```js\nvar name = 'aa'\nfunction fnc() {\n  console.log(this.name)\n}\nvar bb = {\n  name: 'bb',\n  fnc: fnc\n}\nvar cc = {\n  name: 'cc',\n  bb: bb\n}\ncc.bb.fnc();\n```\n\n**答案是：bb**\n\n为什么？因为能让`fnc`被调用的是`bb`，没有`bb`，`fnc`根本没有机会登场。\n\n#### 隐式丢失\n\n前面说过，虽然很多东西表上面看起来都很正常，但是也有可能有一些其他状况的出现。比如隐式绑定里面的隐式丢失。\n\n我们把之前的例子修改一下\n\n```js\nvar name = 'aa'\nfunction fnc() {\n  console.log(this.name)\n}\nvar bb = {\n  name: 'bb',\n  fnc: fnc\n}\nvar cc = {\n  name: 'cc',\n  bb: bb\n}\nvar aa = cc.bb.fnc;\naa()\n```\n\n**答案是：aa**\n\n为什么？这个其实也很好理解，这个`fnc`并没有被`bb`调用，真正调用的地方是在`window`里面声明的一个变量`aa`。所以`bb`丢失了`fnc`的信任，`fnc`无处可去，只能去孤儿院。\n\n还是刚刚吃饭的例子，我们修改一下场景就很好理解了。\n\nA叫B去吃饭，B把C的联系方式不小心弄丢了，结果被一个陌生人D捡去了，刚刚好D也要参加聚会，就打电话叫了D一起参加聚会。但是C不认识D，叫他去的不是熟人B，所以谁也信不过。最终只能应用默认规则--默认绑定了。\n\n\n\n还有一种情况是非常常见的，也是隐式丢失，那就是回调函数。\n\n看下面的例子：\n\n```js\nvar name = 'window'\nfunction fnc() {\n  console.log(this.name)\n}\nfunction ffnncc(fn) {\n  fn()\n}\nvar obj = {\n  name: 'obj',\n  fnc: fnc,\n}\nffnncc(obj.fnc)\n```\n\n**答案是：widnow**\n\n为什么？这和之前的那个例子一样，表面上看起来好像是`obj`调用的，但是其实是`obj`把调用`fnc`的方法转交给了别人，由`fnc`不认识的来调用了。\n\n再来看一个面试题经常考的题目：\n\n```js\nvar name = 'window'\nfunction fnc() {\n  console.log(this.name)\n}\nvar obj = {\n  name: 'obj',\n  fnc: fnc,\n}\nsetTimeout(obj.fnc, 100)\n```\n\n**答案是：widnow**\n\n我相信不用解释你也找到为什么了吧？`fnc`的联系方式被`obj`转交给别人了！\n\n哈哈哈哈，有没有感觉this其实也不过如此，so easy！\n\n> 思考题：那么react中的函数调用为什么要用箭头函数或者为什么要在constructor里面bind一下。\n\n### 显式绑定\n\n我们刚刚看到的是隐式绑定，是偷偷摸摸的那种。接下来我们就介绍一下显式绑定，光明正大的那种。\n\n那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么\n\n做呢?\n\nJavaScript 中的“所有”函数都有一些有用的特性(这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型)，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。\n\n看下面的例子：\n\n```js\nvar a = 'window'\nfunction foo() { \n\tconsole.log( this.a );\n}\nvar obj = { \n\ta:'obj'\n};\nfoo.call( obj );\nfoo()\n```\n\n**答案的先后顺序是：obj，window**\n\n通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。\n\n可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n    fn();\n}\nHi.call(person, person.sayHi); \n```\n\n**答案是：Hello, Wiliam**\n\n其实我们不难发现，这个`fn`不是直接被调用的，所以造成了隐式丢失。我们的`call`绑定的`person`其实绑定在了`Hi`上面了，不信的话我们改一下你就会发现了。\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n  \tconsole.log(this.name)\n    fn();\n}\nHi.call(person, person.sayHi); \n```\n\n输出了什么？\n\n**YvetteLau**\n\n**Hello, Wiliam**\n\n那么咋办呢？别怕显示绑定的变异版，硬绑定可以解决这个问题。\n\n#### 硬绑定\n\n硬绑定其实就是在最后一层给他进行显示绑定。\n\n请看代码：\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n  \tconsole.log(this.name)\n    fn.call(person);\n}\nHi(person.sayHi); \n```\n\n输出了什么？\n\n**YvetteLau**\n\n**Hello, Wiliam**\n\n虽然我们调用`Hi`的时候，在`call`之前`this`还是指向了`window`，但是我们用`call`给他绑定上了`person`。无论之后如何调用函数 `fn`，它 总会手动在 `person` 上调用 `fn`。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。\n\n```js\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// 硬绑定的bar不可能再修改它的this\nbar.call( window ); // 2\n```\n\n典型应用场景是创建一个包裹函数，负责接收参数并返回值。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    return foo.apply( obj, arguments );\n};\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n创建一个可以重复使用的辅助函数。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    }\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nES5内置了`Function.prototype.bind`，bind会返回一个硬绑定的新函数，用法如下。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nAPI调用的“上下文”\n\nJS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和`bind(..)`一样，确保回调函数使用指定的this。这些函数实际上通过`call(..)`和`apply(..)`实现了显式绑定。\n\n```js\nfunction foo(el) {\n\tconsole.log( el, this.id );\n}\n\nvar obj = {\n    id: \"awesome\"\n}\n\nvar myArray = [1, 2, 3]\n// 调用foo(..)时把this绑定到obj\nmyArray.forEach( foo, obj );\n// 1 awesome 2 awesome 3 awesome\n```\n\n### new 绑定\n\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n1. 创建(或者说构造)一个全新的对象。\n2. 这个新对象会被执行[[原型]]连接。\n3. 这个新对象会绑定到函数调用的this。\n4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n思考下面的代码:\n\n```js\nvar a = 4\nfunction foo(a) { \n  this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a );  // 2\n```\n\n使用`new`来调用`foo(..)`时，会构造一个新对象并把它（`bar`）绑定到`foo(..)`调用中的this。\n\n### 绑定优先级\n\n看完规则，我们肯定想知道如果这些规则撞在一起，我们又该听谁的呢？\n\n毫无疑问，默认绑定的优先级是四条规则中最低的，因为是没人应用任何规则才会去应用默认绑定。所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下:\n\n\n\n```js\nfunction foo() { \n\tconsole.log( this.a );\n}\nvar obj1 = { \n\ta: 2,\n\tfoo: foo \n};\nvar obj2 = { \n\ta: 3,\n\tfoo: foo \n};\nobj1.foo(); // 2 \nobj2.foo(); // 3\nobj1.foo.call( obj2 ); // 3 \nobj2.foo.call( obj1 ); // 2\n```\n\n可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低:\n\n```js\nfunction foo(something) { \t\n\tthis.a = something;\n}\nvar obj1 = { \n\tfoo: foo\n};\nvar obj2 = {};\nobj1.foo( 2 );\nconsole.log( obj1.a ); // 2\nobj1.foo.call( obj2, 3 ); \nconsole.log( obj2.a ); // 3\nvar bar = new obj1.foo( 4 ); \nconsole.log( obj1.a ); // 2 \nconsole.log( bar.a ); // 4\n```\n\n可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢?\n\n> new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。\n>\n> 这是因为函数内部有两个不同的方法：`[[Call]]`和`[[Constructor]]`。 当使用普通函数调用时，`[[Call]]`会被执行。当使用构造函数调用时，`[[Constructor]]`会被执行。`call`、`apply`、`bind`和箭头函数内部没有`[[Constructor]]`方法。\n\n```js\n\nfunction foo(something) { \n\tthis.a = something;\n}\nvar obj1 = {};\nvar bar = foo.bind( obj1 ); \nbar( 2 );\nconsole.log( obj1.a ); // 2\nvar baz = new bar(3); \nconsole.log( obj1.a ); // 2 \nconsole.log( baz.a ); // 3\n```\n\n我们可以看到new把bind的硬绑定给顶掉了\n\n所以new  > 硬绑定\n\n#### 总结\n\n> new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定\n\n### 绑定例外\n\n#### 被忽略的this\n\n把`null`或者`undefined`作为`this`的绑定对象传入`call`、`apply`或者`bind`，这些值在调用时会被忽略，实际应用的是默认规则。\n\n下面两种情况下会传入`null`\n\n- 使用`apply(..)`来“展开”一个数组，并当作参数传入一个函数\n- `bind(..)`可以对参数进行柯里化（预先设置一些参数）\n\n```js\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 把数组”展开“成参数\nfoo.apply( null, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2，b:3 \n```\n\n总是传入`null`来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。\n\n> 更安全的this\n\n安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。\n\nJS中创建一个空对象最简单的方法是**`Object.create(null)`**，这个和`{}`很像，但是并不会创建`Object.prototype`这个委托，所以比`{}`更空。\n\n```js\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 我们的空对象\nvar ø = Object.create( null );\n\n// 把数组”展开“成参数\nfoo.apply( ø, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2，b:3 \n```\n\n#### 间接引用\n\n间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在**赋值**时发生。\n\n```js\n// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4};\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n```\n\n####  软绑定\n\n- 硬绑定可以把this强制绑定到指定的对象（`new`除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用**硬绑定之后就无法使用隐式绑定或者显式绑定来修改this**。\n- **如果给默认绑定指定一个全局对象和undefined以外的值**，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。\n\n```js\n// 默认绑定规则，优先级排最后\n// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this\nif(!Function.prototype.softBind) {\n    Function.prototype.softBind = function(obj) {\n        var fn = this;\n        // 捕获所有curried参数\n        var curried = [].slice.call( arguments, 1 ); \n        var bound = function() {\n            return fn.apply(\n            \t(!this || this === (window || global)) ? \n                \tobj : this,\n                curried.concat.apply( curried, arguments )\n            );\n        };\n        bound.prototype = Object.create( fn.prototype );\n        return bound;\n    };\n}\n```\n\n使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。\n\n```js\nfunction foo() {\n    console.log(\"name:\" + this.name);\n}\n\nvar obj = { name: \"obj\" },\n    obj2 = { name: \"obj2\" },\n    obj3 = { name: \"obj3\" };\n\n// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj\nvar fooOBJ = foo.softBind( obj );\nfooOBJ(); // name: obj \n\n// 隐式绑定规则\nobj2.foo = foo.softBind( obj );\nobj2.foo(); // name: obj2 <---- 看！！！\n\n// 显式绑定规则\nfooOBJ.call( obj3 ); // name: obj3 <---- 看！！！\n\n// 绑定丢失，应用软绑定\nsetTimeout( obj2.foo, 10 ); // name: obj\n```\n\n### 箭头函数\n\nES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（**词法作用域**）来决定this。\n\n- `foo()`内部创建的箭头函数会捕获调用时`foo()`的this。由于`foo()`的this绑定到`obj1`，`bar`(引用箭头函数)的this也会绑定到`obj1`，**箭头函数的绑定无法被修改**(`new`也不行)。\n\n```js\nfunction foo() {\n    // 返回一个箭头函数\n    return (a) => {\n        // this继承自foo()\n        console.log( this.a );\n    };\n}\n\nvar obj1 = {\n    a: 2\n};\n\nvar obj2 = {\n    a: 3\n}\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2，不是3！\n```\n\n\n\n箭头函数最常用于回调函数中，例如事件处理器或者定时器：\n\n\n\n```js\n\nfunction foo() { \n  setTimeout(() => {\n    // 这里的 this 在此法上继承自 foo()\n    console.log( this.a ); },100);\n  }\nvar obj = { \n\ta:2\n};\nfoo.call( obj ); // 2\n\n```\n\n\n\nES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。\n\n\n\n```js\nfunction foo() {\n    var self = this; // lexical capture of this\n    setTimeout( function() {\n        console.log( self.a ); // self只是继承了foo()函数的this绑定\n    }, 100 );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call(obj); // 2\n```\n\n## 实现call和apply\n\n### 了解call和apply\n\n为什么会有call和apply？ call和apply两个方法的作用基本相同，它们都是为了改变某个函数**执行时的上下文**（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部**this 的指向**。\n\n\n\n举个栗子：\n\n```\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor();//red\nsayColor.call(this);//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)\nsayColor.call(window);//red，把函数体sayColor内部的this，绑到window（全局作用域）\nsayColor.call(o);//blue复制代码\n```\n\n\n\n> **解释：**上面的栗子，很明显函数sayColor是在全局作用域（环境/window）中调用的，而全局作用域中有一个color属性，值为\"red\"，sayColor.call(this)这一行代码就是表示**把函数体sayColor内部的this，绑到当前环境（作用域）**，而sayColor.call(window)这一行代码就是表示**把函数体sayColor内部的this，绑到window（全局作用域）**，之所以这两行的输出都是\"red\"就是因为他当前作用域的this就是window（this === window）； 最后，sayColor.call(o)这一行代码就表示**把函数体sayColor内部的this，绑到o这个对象的执行环境（上下文）中来**，也就是说sayColor内部的this——>**o**\n\n### call和apply的区别\n\n`call()` 和 `apply()`的区别在于，`call()`方法接受的是**若干个参数的列表**，而`apply()`方法接受的是**一个包含多个参数的数组**\n\n举个例子：\n\n```js\nvar func = function(arg1, arg2) {\n     ...\n};\n\nfunc.call(this, arg1, arg2); // 使用 call，参数列表\nfunc.apply(this, [arg1, arg2]) // 使用 apply，参数数组\n```\n\n### 应用场景\n\n其实这些应用场景都有新的方法可以快速解决， 我只是想告诉大家一些小的知识点， 而且这些东西虽然有新的方法代替，但是面试的时候很可能会被问到。\n\n#### 合并两个数组\n\n\n\n```js\nvar a = ['a', 'aa'];\nvar b = ['b', 'bb'];\n\nArray.prototype.push.apply(a, b);\nconsole.log(a) // ['a', 'aa', 'b', 'bb']\n```\n\n其实现在有`concat`来代替了。或者其他奇淫技巧。但是，都不是我们的重点。\n\n> 当第二个数组(如示例中的 b )太大时不要使用这个方法来合并数组，因为**一个函数能够接受的参数个数是有限制**的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。\n\n那么要如何解决呢？\n\n我们可以把数组进行切割。然后分批次的调用。\n\n\n\n```js\nfunction myConcat(arr1, arr2, max = 32768) {\n  for(var i = 0; i < arr2.length; i += max) {\n    Array.prototype.push.apply(\n    \tarr1,\n      arr2.slice(i, i + max) // 小的知识点，第二个参数大于数组长度就一直取到数组的末尾\n    )\n  }\n}\n\nvar a = [-2, -1];\nvar b = [];\nfor(var i = 0; i < 999999; i ++) {\n  b.push(i)\n}\n\nArray.prototype.push.apply(a, b) // Uncaught RangeError: Maximum call stack size exceeded\n\n\nmyConcat(a, b)\n```\n\n#### 验证是否是数组\n\n#### \n\n```js\nvar arr = [];\nObject.prototype.toString.call(arr); // [object Array]\n//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）复制代码\n```\n\n\n\n#### 同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？\n\n> 这是因为toString()为Object的原型方法，而Array ，function等引用类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的**重写**之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串.....），而不会去调用Object上原型toString方法，所以采用arr.toString()不能得到其对象类型，只能将arr转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。\n\n#### 类数组对象（Array-like Object）使用数组方法\n\n```js\nvar domNodes = document.getElementsByTagName(\"*\");\ndomNodes.unshift(\"h1\");\n// TypeError: domNodes.unshift is not a function\n\nvar domNodeArrays = Array.prototype.slice.call(domNodes);\ndomNodeArrays.unshift(\"h1\"); // 505 不同环境下数据不同\n// (505) [\"h1\", html.gr__hujiang_com, head, meta, ...] \n```\n\n类数组对象有下面两个特性\n\n- 1、具有：指向对象元素的数字索引下标和 `length` 属性\n- 2、不具有：比如 `push` 、`shift`、 `forEach` 以及 `indexOf`等数组对象具有的方法\n\n要说明的是，类数组对象是一个**对象**。JS中存在一种名为**类数组**的对象结构，比如 `arguments` 对象，还有DOM API 返回的 `NodeList` 对象都属于类数组对象，类数组对象不能使用 `push/pop/shift/unshift` 等数组方法，通过 `Array.prototype.slice.call` 转换成真正的数组，就可以使用 `Array`下所有方法。\n\n**类数组对象转数组**的其他方法：\n\n```js\n// 上面代码等同于\nvar arr = [].slice.call(arguments)；\n\nES6:\nlet arr = Array.from(arguments);\nlet arr = [...arguments];\n```\n\n`Array.from()` 可以将两类对象转为真正的数组：**类数组**对象和**可遍历**（iterable）对象（包括ES6新增的数据结构 Set 和 Map）。\n\n### 实现call\n\n这里会使用隐式绑定来实现。\n\n先丢出我们要测试的例子：\n\n```js\nvar a = 1;\nfunction f () {\n  console.log(this.a)\n}\nvar b = {\n  a: 2\n}\nf(); // 1\nf.call(b) // 2\n```\n\nOK, 我们现在就来实现以下自定义的call。应用隐式绑定的话就可以直接绑定上了。\n\n```js\n\nvar a = 1;\nfunction f () {\n  console.log(this.a)\n}\n\nFunction.prototype.myCall = function (context) {\n  context.fn = f;\n  context.fn();\n  delete context.fn;\n}\n\nvar b = {\n  a: 2\n}\nf(); // 1\nf.myCall(b) // 2\n```\n\n很潇洒的完成了。但是好像不能接受参数诶，接受参数又要考虑边界情况，比如`undefined`，`null`之类的。而且！！而且！！而且`call`不传的话是默认应用`window`的；\n\n所以他有我们也要有！冲！\n\n```js\nFunction.prototype.myCall = function(context) {\n  // 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo\n  // 不传第一个参数，默认是window,\n  var context = context || window;\n  // 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数\n  context.fn = this;//这里的context.fn就相当于上文的bar函数\n  // 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表\n  var args = [...arguments].slice(1);\n  // 执行函数（相当于上文的bar(...args)）\n  var result = context.fn(...args);\n  // 删除函数\n  delete context.fn;\n  return result;\n};\n\n```\n\n###  实现apply\n\n因为他们两兄弟就参数不一样所以就不解释了，直接看代码吧。\n\n```js\nFunction.prototype.myApply = function(context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      // 判断第二个参数是否存在，也就是context后面有没有一个数组\n      // 如果存在，则需要展开第二个参数\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn;\n      return result;\n}\n\n```\n\n\n\n## 实现bind\n\n#### 了解bind\n\n> `bind() 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n>\n> 语法：`fun.bind(thisArg[, arg1[, arg2[, ...]]])`\n>\n> MDN\n\n#### bind和apply，call两兄弟的区别\n\n`bind` 方法与 `call / apply` 最大的不同就是前者返回一个绑定上下文的**函数**，而后两者是**直接执行**了函数。\n\n上代码！\n\n```js\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    return {\n\t\tvalue: this.value,\n\t\tname: name,\n\t\tage: age\n    }\n};\n\nbar.call(foo, \"Jack\", 20); // 直接执行了函数\n// {value: 1, name: \"Jack\", age: 20}\n\nvar bindFoo1 = bar.bind(foo, \"Jack\", 20); // 返回一个函数\nbindFoo1();\n// {value: 1, name: \"Jack\", age: 20}\n\nvar bindFoo2 = bar.bind(foo, \"Jack\"); // 返回一个函数\nbindFoo2(20);\n// {value: 1, name: \"Jack\", age: 20}\n```\n\n通过上述代码可以看出`bind` 有如下特性：\n\n- 1、可以指定`this`\n- 2、返回一个函数\n- 3、可以传入参数\n- 4、柯里化\n\n#### 实现bind\n\n直接开干！\n\n```js\nFunction.prototype.myBind = function (context) {\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  return function () { \n    return that.apply(context)\n  }\n}\n\n// 测试用例\nvar value = 2;\nvar foo = {\n    value: 1\n};\n\nfunction bar() {\n\treturn this.value;\n}\n\nvar bindFoo = bar.myBind(foo);\n\nconsole.log(bindFoo()); // 1\n```\n\nOk,接下来我们处理一下参数和柯里化吧。\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  return function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    return that.apply(context, args.concat(nowArgs))\n  }\n}\n// 测试用例\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    return {\n\t\tvalue: this.value,\n\t\tname: name,\n\t\tage: age\n    }\n};\n\nvar bindFoo = bar.myBind(foo, \"Jack\");\nbindFoo(20);\n// {value: 1, name: \"Jack\", age: 20}\n\n```\n\n到现在已经完成大部分了，但是还有一个难点，`bind` 有以下一个特性\n\n> 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n\n举例说明：正规的bind\n\n```js\nvar value = 2;\nvar foo = {\n    value: 1\n};\nfunction bar(name, age) {\n    this.habit = 'shopping';\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\nbar.prototype.friend = 'kevin';\n\nvar bindFoo = bar.bind(foo, 'Jack');\nvar obj = new bindFoo(20);\n// undefined\n// Jack\n// 20\n\nobj.habit;\n// shopping\n\nobj.friend;\n// kevin\n```\n\n上面例子中，运行结果`this.value` 输出为 `undefined`，这不是全局`value` 也不是`foo`对象中的`value`，这说明 `bind` 的 `this` 对象失效了，`new` 的实现中生成一个新的对象，这个时候的 `this`指向的是 `obj`。\n\n所以我们返回的时候需要判断一下他是不是作为了构造函数返回，如果是就返回当前的this，如果不是就绑定当前输入的`context`\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fnc ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fnc.prototype = this.prototype\n  return fnc\n}\n```\n\n但是其实这样会有一个问题，我如果实例修改了原型，那么接下来的继承就会出现问题。\n\n这个时候我们需要拷贝一下我们原型上面的参数。会用到\n\n> 道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。\n>\n> ```js\n> function object(o){\n>   function F(){}\n>   F.prototype = o\n>   return new F\n> }\n> ```\n>\n> 看起来非常简单\n>\n> 先在`object`函数内部创建一个临时的构造函数`F`, 然后将传入的这个对象`o`作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. \n>\n> 简单来说就是`object`对传入的对象进行了浅复制.\n\n这句话在我的《原型原型链和继承》里面有具体的介绍。想看的话可以点击头像查找文章。\n\n这边可以直接使用ES5的 `Object.create()`方法生成一个新对象\n\n```js\nfBound.prototype = Object.create(this.prototype);\n```\n\n不过 `bind` 和 `Object.create()`都是ES5方法，部分IE浏览器（IE < 9）并不支持，Polyfill中不能用 `Object.create()`实现 `bind`，不过原理是一样的。\n\nok。那我们就修改一下\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fNOP = function () {};\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fNOP ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fNOP.prototype = this.prototype\n  fnc.prototype = new FNOP()\n  return fnc\n}\n```\n\n到这里其实已经差不多了，突然想起来还有一个问题是调用 `bind` 的不是函数，这时候需要抛出异常。\n\n```js\nif (typeof this !== \"function\") {\n  throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n}\n```\n\n所以\n\n#### 顶配\n\n```js\nFunction.prototype.myBind = function (context) {\n  if (typeof this !== \"function\") {\n  \tthrow new Error(\"Function.prototype.bind - what is trying to \tbe bound is not callable\");\n\t}\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fNOP = function () {};\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fNOP ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fNOP.prototype = this.prototype\n  fnc.prototype = new FNOP()\n  return fnc\n}\n```\n\n\n\n\n\n## 实现new\n\n#### 了解new\n\n> **new 运算符**创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）\n\n我们先试试现在有的new，他有什么功能，然后我们总结之后，在开始实现。\n\n看个🌰：\n\n```js\nfunction NEW (a) {\n  this.a = a;\n}\nNEW.prototype.sayA = function () {\n  console.log(this.a+'b')\n}\nvar A = new NEW(1);\nA.sayA()\nA.a\n\n```\n\n我们可以看到A是NEW的一个实例。继承了构造函数（NEW）的属性和原型上的属性（sayA）。\n\n> **`new`** 关键字会进行如下的操作：\n>\n> 1. 创建一个空的简单JavaScript对象（即{}）；\n> 2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n> 3. 将步骤1新创建的对象作为`this`的上下文 ；\n> 4. 如果该函数没有返回对象，则返回`this`。\n>\n> MDN\n\n\n\n#### 实现一个new\n\n说干就干：\n\n```js\n// new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。\nfunction create () {\n  // 1.\n  var obj = new Object();\n  \n  // 获取构造函数\n  // 因为arguments是一个类数组对象，没有unshift方法，所以用了call，我们没有new这关键字，只能模拟，所以的一个参数我们认为他需要传递一个构造函数。\n  var Con = [].unshift.call(arguments)\n  \n  // 2.\n  obj.__proto__ = Con.prototype \n  \n  // 3、 绑定this。因为之前arguments已经被我们删除了第一个元素，所以剩下的就是我们所需要的参数了。\n  Con.apply(obj, arguments)\n  \n  // 4. 简陋版\n  return obj\n  \n}\n```\n\n构造函数返回值有如下三种情况：\n\n- 1、返回一个对象\n- 2、没有 `return`，即返回 `undefined`\n- 3、返回`undefined` 以外的基本类型\n\n```js\nfunction create() {\n\t// 1、获得构造函数，同时删除 arguments 中第一个参数\n    Con = [].shift.call(arguments);\n\t// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性\n    var obj = Object.create(Con.prototype);\n\t// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n\t// 4、优先返回构造函数返回的对象\n\treturn ret instanceof Object ? ret : obj;\n};\n```\n\n","source":"_posts/【重识前端】全面攻破this.md","raw":"---\ntitle: 【重识前端】全面攻破this\ndate: 2020-07-16 22:02:55\ntags: [this, JavaScript]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n其实说起this，这个几乎是前端面试必考题，也是前端最多“脑经急转弯”的地方，也是让无数前端人烦恼的地方。今天我们就彻底的深入this，全面的攻破它！\n\n## 绑定规则\n\n我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。\n\n你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。\n\nthis的绑定规则总共有以下5种：\n\n1. 默认绑定（最令人头疼的）\n   1. 严格模式\n   2. 非严格模式\n2. 隐式绑定\n3. 显式绑定\n   1. bind\n   2. call\n   3. apply\n4. new绑定\n\n### 默认绑定\n\n默认绑定顾名思义，就是没人要的“孤儿”就会应用默认绑定。\n\n思考🤔一下👇的代码会输出什么？\n\n```js\nvar a = 'out'\nfunction fnc() {\n  var a = 'in'\n  console.log(this.a)\n}\nfnc();\n```\n\n**答案是：'out'**\n\n我们可以看到当调用 `fnc()` 时，`this.a` 被解析成了全局变量 `a`。为什么?因为在本 例中，函数调用时应用了 `this` 的默认绑定，因此 `this` 指向全局对象。\n\n那我们怎么知道他是应用了默认绑定呢？\n\n我们发现 `fnc` 他只是孤零零的被调用，没有任何的修饰*（调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。）*，所以它就相当于是没有人要的`孩子`，只能去`福利院`---默认绑定。\n\n这样说可能还不太明白默认绑定究竟是怎么一回事。等到后面的规则介绍的多了，你就会发现没有应用其他规则的“孤儿”只能来福利院 ---默认绑定的怀抱\n\n#### 严格模式\n\n在严格下，默认绑定不是绑定到`window`，而是`undefined`。\n\n```js\nvar a = 'out'\nfunction fnc() {\n\t\"use strict\";\n\n  var a = 'in'\n  console.log(this.a)\n}\nfnc();\n```\n\n**答案是：报错**\n\n为什么？因为我们想在`undefined`里面找`a`，那肯定是报错的\n\n### 隐式绑定\n\n隐式绑定，顾名思义就是悄悄的绑定，或者说公认的，但是没有明说的绑定。就好比一个男人和一个女人手牵手走在一起，他们基本上可以认定就是在情侣，但是还是有可能会是“偷情”（映射到隐式绑定的隐式丢失，等会会说到。）\n\n思考🤔一下👇的代码会输出什么？\n\n```js\nvar a = 'out'\nfunction fnc() {\n  console.log(this.a)\n}\nvar obj = {\n  a: 'in',\n  fnc: fnc\n}\nobj.fnc();\n```\n\n**答案是：'in'**\n\n我们可以注意到，`fnc` 是在什么情况下被调用的？是`obj` 调用的，说明这个`fnc`已经有主了，护花使者是`obj`，所以`fnc`说的话肯定是向着`obj`的，胳膊肘不会往外拐。\n\n其实这里面有一个小的点需要注意，那就是如果是多个对象引用的调用，那这个时候的执行上下文又是谁的呢？\n\n其实我们用常理就可以解释这个问题，A叫B去吃饭，但是B想叫C一起去，结果A和B起了冲突，你作为这个C你会向着谁？那肯定是B，因为有C叫你去，你们才会出现在这场聚会。所以这个问题不难回答。我们直接看一个例子🌰\n\n```js\nvar name = 'aa'\nfunction fnc() {\n  console.log(this.name)\n}\nvar bb = {\n  name: 'bb',\n  fnc: fnc\n}\nvar cc = {\n  name: 'cc',\n  bb: bb\n}\ncc.bb.fnc();\n```\n\n**答案是：bb**\n\n为什么？因为能让`fnc`被调用的是`bb`，没有`bb`，`fnc`根本没有机会登场。\n\n#### 隐式丢失\n\n前面说过，虽然很多东西表上面看起来都很正常，但是也有可能有一些其他状况的出现。比如隐式绑定里面的隐式丢失。\n\n我们把之前的例子修改一下\n\n```js\nvar name = 'aa'\nfunction fnc() {\n  console.log(this.name)\n}\nvar bb = {\n  name: 'bb',\n  fnc: fnc\n}\nvar cc = {\n  name: 'cc',\n  bb: bb\n}\nvar aa = cc.bb.fnc;\naa()\n```\n\n**答案是：aa**\n\n为什么？这个其实也很好理解，这个`fnc`并没有被`bb`调用，真正调用的地方是在`window`里面声明的一个变量`aa`。所以`bb`丢失了`fnc`的信任，`fnc`无处可去，只能去孤儿院。\n\n还是刚刚吃饭的例子，我们修改一下场景就很好理解了。\n\nA叫B去吃饭，B把C的联系方式不小心弄丢了，结果被一个陌生人D捡去了，刚刚好D也要参加聚会，就打电话叫了D一起参加聚会。但是C不认识D，叫他去的不是熟人B，所以谁也信不过。最终只能应用默认规则--默认绑定了。\n\n\n\n还有一种情况是非常常见的，也是隐式丢失，那就是回调函数。\n\n看下面的例子：\n\n```js\nvar name = 'window'\nfunction fnc() {\n  console.log(this.name)\n}\nfunction ffnncc(fn) {\n  fn()\n}\nvar obj = {\n  name: 'obj',\n  fnc: fnc,\n}\nffnncc(obj.fnc)\n```\n\n**答案是：widnow**\n\n为什么？这和之前的那个例子一样，表面上看起来好像是`obj`调用的，但是其实是`obj`把调用`fnc`的方法转交给了别人，由`fnc`不认识的来调用了。\n\n再来看一个面试题经常考的题目：\n\n```js\nvar name = 'window'\nfunction fnc() {\n  console.log(this.name)\n}\nvar obj = {\n  name: 'obj',\n  fnc: fnc,\n}\nsetTimeout(obj.fnc, 100)\n```\n\n**答案是：widnow**\n\n我相信不用解释你也找到为什么了吧？`fnc`的联系方式被`obj`转交给别人了！\n\n哈哈哈哈，有没有感觉this其实也不过如此，so easy！\n\n> 思考题：那么react中的函数调用为什么要用箭头函数或者为什么要在constructor里面bind一下。\n\n### 显式绑定\n\n我们刚刚看到的是隐式绑定，是偷偷摸摸的那种。接下来我们就介绍一下显式绑定，光明正大的那种。\n\n那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么\n\n做呢?\n\nJavaScript 中的“所有”函数都有一些有用的特性(这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型)，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。\n\n看下面的例子：\n\n```js\nvar a = 'window'\nfunction foo() { \n\tconsole.log( this.a );\n}\nvar obj = { \n\ta:'obj'\n};\nfoo.call( obj );\nfoo()\n```\n\n**答案的先后顺序是：obj，window**\n\n通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。\n\n可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n    fn();\n}\nHi.call(person, person.sayHi); \n```\n\n**答案是：Hello, Wiliam**\n\n其实我们不难发现，这个`fn`不是直接被调用的，所以造成了隐式丢失。我们的`call`绑定的`person`其实绑定在了`Hi`上面了，不信的话我们改一下你就会发现了。\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n  \tconsole.log(this.name)\n    fn();\n}\nHi.call(person, person.sayHi); \n```\n\n输出了什么？\n\n**YvetteLau**\n\n**Hello, Wiliam**\n\n那么咋办呢？别怕显示绑定的变异版，硬绑定可以解决这个问题。\n\n#### 硬绑定\n\n硬绑定其实就是在最后一层给他进行显示绑定。\n\n请看代码：\n\n```js\nfunction sayHi(){\n    console.log('Hello,', this.name);\n}\nvar person = {\n    name: 'YvetteLau',\n    sayHi: sayHi\n}\nvar name = 'Wiliam';\nvar Hi = function(fn) {\n  \tconsole.log(this.name)\n    fn.call(person);\n}\nHi(person.sayHi); \n```\n\n输出了什么？\n\n**YvetteLau**\n\n**Hello, Wiliam**\n\n虽然我们调用`Hi`的时候，在`call`之前`this`还是指向了`window`，但是我们用`call`给他绑定上了`person`。无论之后如何调用函数 `fn`，它 总会手动在 `person` 上调用 `fn`。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。\n\n```js\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// 硬绑定的bar不可能再修改它的this\nbar.call( window ); // 2\n```\n\n典型应用场景是创建一个包裹函数，负责接收参数并返回值。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    return foo.apply( obj, arguments );\n};\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n创建一个可以重复使用的辅助函数。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    }\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nES5内置了`Function.prototype.bind`，bind会返回一个硬绑定的新函数，用法如下。\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nAPI调用的“上下文”\n\nJS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和`bind(..)`一样，确保回调函数使用指定的this。这些函数实际上通过`call(..)`和`apply(..)`实现了显式绑定。\n\n```js\nfunction foo(el) {\n\tconsole.log( el, this.id );\n}\n\nvar obj = {\n    id: \"awesome\"\n}\n\nvar myArray = [1, 2, 3]\n// 调用foo(..)时把this绑定到obj\nmyArray.forEach( foo, obj );\n// 1 awesome 2 awesome 3 awesome\n```\n\n### new 绑定\n\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n1. 创建(或者说构造)一个全新的对象。\n2. 这个新对象会被执行[[原型]]连接。\n3. 这个新对象会绑定到函数调用的this。\n4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n思考下面的代码:\n\n```js\nvar a = 4\nfunction foo(a) { \n  this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a );  // 2\n```\n\n使用`new`来调用`foo(..)`时，会构造一个新对象并把它（`bar`）绑定到`foo(..)`调用中的this。\n\n### 绑定优先级\n\n看完规则，我们肯定想知道如果这些规则撞在一起，我们又该听谁的呢？\n\n毫无疑问，默认绑定的优先级是四条规则中最低的，因为是没人应用任何规则才会去应用默认绑定。所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下:\n\n\n\n```js\nfunction foo() { \n\tconsole.log( this.a );\n}\nvar obj1 = { \n\ta: 2,\n\tfoo: foo \n};\nvar obj2 = { \n\ta: 3,\n\tfoo: foo \n};\nobj1.foo(); // 2 \nobj2.foo(); // 3\nobj1.foo.call( obj2 ); // 3 \nobj2.foo.call( obj1 ); // 2\n```\n\n可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低:\n\n```js\nfunction foo(something) { \t\n\tthis.a = something;\n}\nvar obj1 = { \n\tfoo: foo\n};\nvar obj2 = {};\nobj1.foo( 2 );\nconsole.log( obj1.a ); // 2\nobj1.foo.call( obj2, 3 ); \nconsole.log( obj2.a ); // 3\nvar bar = new obj1.foo( 4 ); \nconsole.log( obj1.a ); // 2 \nconsole.log( bar.a ); // 4\n```\n\n可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢?\n\n> new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。\n>\n> 这是因为函数内部有两个不同的方法：`[[Call]]`和`[[Constructor]]`。 当使用普通函数调用时，`[[Call]]`会被执行。当使用构造函数调用时，`[[Constructor]]`会被执行。`call`、`apply`、`bind`和箭头函数内部没有`[[Constructor]]`方法。\n\n```js\n\nfunction foo(something) { \n\tthis.a = something;\n}\nvar obj1 = {};\nvar bar = foo.bind( obj1 ); \nbar( 2 );\nconsole.log( obj1.a ); // 2\nvar baz = new bar(3); \nconsole.log( obj1.a ); // 2 \nconsole.log( baz.a ); // 3\n```\n\n我们可以看到new把bind的硬绑定给顶掉了\n\n所以new  > 硬绑定\n\n#### 总结\n\n> new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定\n\n### 绑定例外\n\n#### 被忽略的this\n\n把`null`或者`undefined`作为`this`的绑定对象传入`call`、`apply`或者`bind`，这些值在调用时会被忽略，实际应用的是默认规则。\n\n下面两种情况下会传入`null`\n\n- 使用`apply(..)`来“展开”一个数组，并当作参数传入一个函数\n- `bind(..)`可以对参数进行柯里化（预先设置一些参数）\n\n```js\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 把数组”展开“成参数\nfoo.apply( null, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2，b:3 \n```\n\n总是传入`null`来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。\n\n> 更安全的this\n\n安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。\n\nJS中创建一个空对象最简单的方法是**`Object.create(null)`**，这个和`{}`很像，但是并不会创建`Object.prototype`这个委托，所以比`{}`更空。\n\n```js\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 我们的空对象\nvar ø = Object.create( null );\n\n// 把数组”展开“成参数\nfoo.apply( ø, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2，b:3 \n```\n\n#### 间接引用\n\n间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在**赋值**时发生。\n\n```js\n// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4};\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n```\n\n####  软绑定\n\n- 硬绑定可以把this强制绑定到指定的对象（`new`除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用**硬绑定之后就无法使用隐式绑定或者显式绑定来修改this**。\n- **如果给默认绑定指定一个全局对象和undefined以外的值**，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。\n\n```js\n// 默认绑定规则，优先级排最后\n// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this\nif(!Function.prototype.softBind) {\n    Function.prototype.softBind = function(obj) {\n        var fn = this;\n        // 捕获所有curried参数\n        var curried = [].slice.call( arguments, 1 ); \n        var bound = function() {\n            return fn.apply(\n            \t(!this || this === (window || global)) ? \n                \tobj : this,\n                curried.concat.apply( curried, arguments )\n            );\n        };\n        bound.prototype = Object.create( fn.prototype );\n        return bound;\n    };\n}\n```\n\n使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。\n\n```js\nfunction foo() {\n    console.log(\"name:\" + this.name);\n}\n\nvar obj = { name: \"obj\" },\n    obj2 = { name: \"obj2\" },\n    obj3 = { name: \"obj3\" };\n\n// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj\nvar fooOBJ = foo.softBind( obj );\nfooOBJ(); // name: obj \n\n// 隐式绑定规则\nobj2.foo = foo.softBind( obj );\nobj2.foo(); // name: obj2 <---- 看！！！\n\n// 显式绑定规则\nfooOBJ.call( obj3 ); // name: obj3 <---- 看！！！\n\n// 绑定丢失，应用软绑定\nsetTimeout( obj2.foo, 10 ); // name: obj\n```\n\n### 箭头函数\n\nES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（**词法作用域**）来决定this。\n\n- `foo()`内部创建的箭头函数会捕获调用时`foo()`的this。由于`foo()`的this绑定到`obj1`，`bar`(引用箭头函数)的this也会绑定到`obj1`，**箭头函数的绑定无法被修改**(`new`也不行)。\n\n```js\nfunction foo() {\n    // 返回一个箭头函数\n    return (a) => {\n        // this继承自foo()\n        console.log( this.a );\n    };\n}\n\nvar obj1 = {\n    a: 2\n};\n\nvar obj2 = {\n    a: 3\n}\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2，不是3！\n```\n\n\n\n箭头函数最常用于回调函数中，例如事件处理器或者定时器：\n\n\n\n```js\n\nfunction foo() { \n  setTimeout(() => {\n    // 这里的 this 在此法上继承自 foo()\n    console.log( this.a ); },100);\n  }\nvar obj = { \n\ta:2\n};\nfoo.call( obj ); // 2\n\n```\n\n\n\nES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。\n\n\n\n```js\nfunction foo() {\n    var self = this; // lexical capture of this\n    setTimeout( function() {\n        console.log( self.a ); // self只是继承了foo()函数的this绑定\n    }, 100 );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call(obj); // 2\n```\n\n## 实现call和apply\n\n### 了解call和apply\n\n为什么会有call和apply？ call和apply两个方法的作用基本相同，它们都是为了改变某个函数**执行时的上下文**（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部**this 的指向**。\n\n\n\n举个栗子：\n\n```\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor();//red\nsayColor.call(this);//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)\nsayColor.call(window);//red，把函数体sayColor内部的this，绑到window（全局作用域）\nsayColor.call(o);//blue复制代码\n```\n\n\n\n> **解释：**上面的栗子，很明显函数sayColor是在全局作用域（环境/window）中调用的，而全局作用域中有一个color属性，值为\"red\"，sayColor.call(this)这一行代码就是表示**把函数体sayColor内部的this，绑到当前环境（作用域）**，而sayColor.call(window)这一行代码就是表示**把函数体sayColor内部的this，绑到window（全局作用域）**，之所以这两行的输出都是\"red\"就是因为他当前作用域的this就是window（this === window）； 最后，sayColor.call(o)这一行代码就表示**把函数体sayColor内部的this，绑到o这个对象的执行环境（上下文）中来**，也就是说sayColor内部的this——>**o**\n\n### call和apply的区别\n\n`call()` 和 `apply()`的区别在于，`call()`方法接受的是**若干个参数的列表**，而`apply()`方法接受的是**一个包含多个参数的数组**\n\n举个例子：\n\n```js\nvar func = function(arg1, arg2) {\n     ...\n};\n\nfunc.call(this, arg1, arg2); // 使用 call，参数列表\nfunc.apply(this, [arg1, arg2]) // 使用 apply，参数数组\n```\n\n### 应用场景\n\n其实这些应用场景都有新的方法可以快速解决， 我只是想告诉大家一些小的知识点， 而且这些东西虽然有新的方法代替，但是面试的时候很可能会被问到。\n\n#### 合并两个数组\n\n\n\n```js\nvar a = ['a', 'aa'];\nvar b = ['b', 'bb'];\n\nArray.prototype.push.apply(a, b);\nconsole.log(a) // ['a', 'aa', 'b', 'bb']\n```\n\n其实现在有`concat`来代替了。或者其他奇淫技巧。但是，都不是我们的重点。\n\n> 当第二个数组(如示例中的 b )太大时不要使用这个方法来合并数组，因为**一个函数能够接受的参数个数是有限制**的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。\n\n那么要如何解决呢？\n\n我们可以把数组进行切割。然后分批次的调用。\n\n\n\n```js\nfunction myConcat(arr1, arr2, max = 32768) {\n  for(var i = 0; i < arr2.length; i += max) {\n    Array.prototype.push.apply(\n    \tarr1,\n      arr2.slice(i, i + max) // 小的知识点，第二个参数大于数组长度就一直取到数组的末尾\n    )\n  }\n}\n\nvar a = [-2, -1];\nvar b = [];\nfor(var i = 0; i < 999999; i ++) {\n  b.push(i)\n}\n\nArray.prototype.push.apply(a, b) // Uncaught RangeError: Maximum call stack size exceeded\n\n\nmyConcat(a, b)\n```\n\n#### 验证是否是数组\n\n#### \n\n```js\nvar arr = [];\nObject.prototype.toString.call(arr); // [object Array]\n//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）复制代码\n```\n\n\n\n#### 同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？\n\n> 这是因为toString()为Object的原型方法，而Array ，function等引用类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的**重写**之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串.....），而不会去调用Object上原型toString方法，所以采用arr.toString()不能得到其对象类型，只能将arr转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。\n\n#### 类数组对象（Array-like Object）使用数组方法\n\n```js\nvar domNodes = document.getElementsByTagName(\"*\");\ndomNodes.unshift(\"h1\");\n// TypeError: domNodes.unshift is not a function\n\nvar domNodeArrays = Array.prototype.slice.call(domNodes);\ndomNodeArrays.unshift(\"h1\"); // 505 不同环境下数据不同\n// (505) [\"h1\", html.gr__hujiang_com, head, meta, ...] \n```\n\n类数组对象有下面两个特性\n\n- 1、具有：指向对象元素的数字索引下标和 `length` 属性\n- 2、不具有：比如 `push` 、`shift`、 `forEach` 以及 `indexOf`等数组对象具有的方法\n\n要说明的是，类数组对象是一个**对象**。JS中存在一种名为**类数组**的对象结构，比如 `arguments` 对象，还有DOM API 返回的 `NodeList` 对象都属于类数组对象，类数组对象不能使用 `push/pop/shift/unshift` 等数组方法，通过 `Array.prototype.slice.call` 转换成真正的数组，就可以使用 `Array`下所有方法。\n\n**类数组对象转数组**的其他方法：\n\n```js\n// 上面代码等同于\nvar arr = [].slice.call(arguments)；\n\nES6:\nlet arr = Array.from(arguments);\nlet arr = [...arguments];\n```\n\n`Array.from()` 可以将两类对象转为真正的数组：**类数组**对象和**可遍历**（iterable）对象（包括ES6新增的数据结构 Set 和 Map）。\n\n### 实现call\n\n这里会使用隐式绑定来实现。\n\n先丢出我们要测试的例子：\n\n```js\nvar a = 1;\nfunction f () {\n  console.log(this.a)\n}\nvar b = {\n  a: 2\n}\nf(); // 1\nf.call(b) // 2\n```\n\nOK, 我们现在就来实现以下自定义的call。应用隐式绑定的话就可以直接绑定上了。\n\n```js\n\nvar a = 1;\nfunction f () {\n  console.log(this.a)\n}\n\nFunction.prototype.myCall = function (context) {\n  context.fn = f;\n  context.fn();\n  delete context.fn;\n}\n\nvar b = {\n  a: 2\n}\nf(); // 1\nf.myCall(b) // 2\n```\n\n很潇洒的完成了。但是好像不能接受参数诶，接受参数又要考虑边界情况，比如`undefined`，`null`之类的。而且！！而且！！而且`call`不传的话是默认应用`window`的；\n\n所以他有我们也要有！冲！\n\n```js\nFunction.prototype.myCall = function(context) {\n  // 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo\n  // 不传第一个参数，默认是window,\n  var context = context || window;\n  // 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数\n  context.fn = this;//这里的context.fn就相当于上文的bar函数\n  // 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表\n  var args = [...arguments].slice(1);\n  // 执行函数（相当于上文的bar(...args)）\n  var result = context.fn(...args);\n  // 删除函数\n  delete context.fn;\n  return result;\n};\n\n```\n\n###  实现apply\n\n因为他们两兄弟就参数不一样所以就不解释了，直接看代码吧。\n\n```js\nFunction.prototype.myApply = function(context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      // 判断第二个参数是否存在，也就是context后面有没有一个数组\n      // 如果存在，则需要展开第二个参数\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn;\n      return result;\n}\n\n```\n\n\n\n## 实现bind\n\n#### 了解bind\n\n> `bind() 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n>\n> 语法：`fun.bind(thisArg[, arg1[, arg2[, ...]]])`\n>\n> MDN\n\n#### bind和apply，call两兄弟的区别\n\n`bind` 方法与 `call / apply` 最大的不同就是前者返回一个绑定上下文的**函数**，而后两者是**直接执行**了函数。\n\n上代码！\n\n```js\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    return {\n\t\tvalue: this.value,\n\t\tname: name,\n\t\tage: age\n    }\n};\n\nbar.call(foo, \"Jack\", 20); // 直接执行了函数\n// {value: 1, name: \"Jack\", age: 20}\n\nvar bindFoo1 = bar.bind(foo, \"Jack\", 20); // 返回一个函数\nbindFoo1();\n// {value: 1, name: \"Jack\", age: 20}\n\nvar bindFoo2 = bar.bind(foo, \"Jack\"); // 返回一个函数\nbindFoo2(20);\n// {value: 1, name: \"Jack\", age: 20}\n```\n\n通过上述代码可以看出`bind` 有如下特性：\n\n- 1、可以指定`this`\n- 2、返回一个函数\n- 3、可以传入参数\n- 4、柯里化\n\n#### 实现bind\n\n直接开干！\n\n```js\nFunction.prototype.myBind = function (context) {\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  return function () { \n    return that.apply(context)\n  }\n}\n\n// 测试用例\nvar value = 2;\nvar foo = {\n    value: 1\n};\n\nfunction bar() {\n\treturn this.value;\n}\n\nvar bindFoo = bar.myBind(foo);\n\nconsole.log(bindFoo()); // 1\n```\n\nOk,接下来我们处理一下参数和柯里化吧。\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  return function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    return that.apply(context, args.concat(nowArgs))\n  }\n}\n// 测试用例\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    return {\n\t\tvalue: this.value,\n\t\tname: name,\n\t\tage: age\n    }\n};\n\nvar bindFoo = bar.myBind(foo, \"Jack\");\nbindFoo(20);\n// {value: 1, name: \"Jack\", age: 20}\n\n```\n\n到现在已经完成大部分了，但是还有一个难点，`bind` 有以下一个特性\n\n> 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n\n举例说明：正规的bind\n\n```js\nvar value = 2;\nvar foo = {\n    value: 1\n};\nfunction bar(name, age) {\n    this.habit = 'shopping';\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\nbar.prototype.friend = 'kevin';\n\nvar bindFoo = bar.bind(foo, 'Jack');\nvar obj = new bindFoo(20);\n// undefined\n// Jack\n// 20\n\nobj.habit;\n// shopping\n\nobj.friend;\n// kevin\n```\n\n上面例子中，运行结果`this.value` 输出为 `undefined`，这不是全局`value` 也不是`foo`对象中的`value`，这说明 `bind` 的 `this` 对象失效了，`new` 的实现中生成一个新的对象，这个时候的 `this`指向的是 `obj`。\n\n所以我们返回的时候需要判断一下他是不是作为了构造函数返回，如果是就返回当前的this，如果不是就绑定当前输入的`context`\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fnc ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fnc.prototype = this.prototype\n  return fnc\n}\n```\n\n但是其实这样会有一个问题，我如果实例修改了原型，那么接下来的继承就会出现问题。\n\n这个时候我们需要拷贝一下我们原型上面的参数。会用到\n\n> 道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。\n>\n> ```js\n> function object(o){\n>   function F(){}\n>   F.prototype = o\n>   return new F\n> }\n> ```\n>\n> 看起来非常简单\n>\n> 先在`object`函数内部创建一个临时的构造函数`F`, 然后将传入的这个对象`o`作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. \n>\n> 简单来说就是`object`对传入的对象进行了浅复制.\n\n这句话在我的《原型原型链和继承》里面有具体的介绍。想看的话可以点击头像查找文章。\n\n这边可以直接使用ES5的 `Object.create()`方法生成一个新对象\n\n```js\nfBound.prototype = Object.create(this.prototype);\n```\n\n不过 `bind` 和 `Object.create()`都是ES5方法，部分IE浏览器（IE < 9）并不支持，Polyfill中不能用 `Object.create()`实现 `bind`，不过原理是一样的。\n\nok。那我们就修改一下\n\n```js\nFunction.prototype.myBind = function (context) {\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fNOP = function () {};\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fNOP ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fNOP.prototype = this.prototype\n  fnc.prototype = new FNOP()\n  return fnc\n}\n```\n\n到这里其实已经差不多了，突然想起来还有一个问题是调用 `bind` 的不是函数，这时候需要抛出异常。\n\n```js\nif (typeof this !== \"function\") {\n  throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n}\n```\n\n所以\n\n#### 顶配\n\n```js\nFunction.prototype.myBind = function (context) {\n  if (typeof this !== \"function\") {\n  \tthrow new Error(\"Function.prototype.bind - what is trying to \tbe bound is not callable\");\n\t}\n  // 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到\n  var args = Array.prototype.slice.call(arguments, 1)\n  var that = this; // 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失\n  var fNOP = function () {};\n  var fnc = function () { \n    // 和上面一样拷贝参数\n    var nowArgs = Array.prototype.slice.call(arguments)\n    //当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。\n//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n    return that.apply(\n      this instanceof fNOP ? this : context, \n      args.concat(nowArgs)\n    )\n  }\n  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。\n  fNOP.prototype = this.prototype\n  fnc.prototype = new FNOP()\n  return fnc\n}\n```\n\n\n\n\n\n## 实现new\n\n#### 了解new\n\n> **new 运算符**创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）\n\n我们先试试现在有的new，他有什么功能，然后我们总结之后，在开始实现。\n\n看个🌰：\n\n```js\nfunction NEW (a) {\n  this.a = a;\n}\nNEW.prototype.sayA = function () {\n  console.log(this.a+'b')\n}\nvar A = new NEW(1);\nA.sayA()\nA.a\n\n```\n\n我们可以看到A是NEW的一个实例。继承了构造函数（NEW）的属性和原型上的属性（sayA）。\n\n> **`new`** 关键字会进行如下的操作：\n>\n> 1. 创建一个空的简单JavaScript对象（即{}）；\n> 2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n> 3. 将步骤1新创建的对象作为`this`的上下文 ；\n> 4. 如果该函数没有返回对象，则返回`this`。\n>\n> MDN\n\n\n\n#### 实现一个new\n\n说干就干：\n\n```js\n// new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。\nfunction create () {\n  // 1.\n  var obj = new Object();\n  \n  // 获取构造函数\n  // 因为arguments是一个类数组对象，没有unshift方法，所以用了call，我们没有new这关键字，只能模拟，所以的一个参数我们认为他需要传递一个构造函数。\n  var Con = [].unshift.call(arguments)\n  \n  // 2.\n  obj.__proto__ = Con.prototype \n  \n  // 3、 绑定this。因为之前arguments已经被我们删除了第一个元素，所以剩下的就是我们所需要的参数了。\n  Con.apply(obj, arguments)\n  \n  // 4. 简陋版\n  return obj\n  \n}\n```\n\n构造函数返回值有如下三种情况：\n\n- 1、返回一个对象\n- 2、没有 `return`，即返回 `undefined`\n- 3、返回`undefined` 以外的基本类型\n\n```js\nfunction create() {\n\t// 1、获得构造函数，同时删除 arguments 中第一个参数\n    Con = [].shift.call(arguments);\n\t// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性\n    var obj = Object.create(Con.prototype);\n\t// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n\t// 4、优先返回构造函数返回的对象\n\treturn ret instanceof Object ? ret : obj;\n};\n```\n\n","slug":"【重识前端】全面攻破this","published":1,"updated":"2021-06-24T14:00:06.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8l001rlwrd3343aisg","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说起this，这个几乎是前端面试必考题，也是前端最多“脑经急转弯”的地方，也是让无数前端人烦恼的地方。今天我们就彻底的深入this，全面的攻破它！</p>\n<h2 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h2><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。</p>\n<p>你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<p>this的绑定规则总共有以下5种：</p>\n<ol>\n<li>默认绑定（最令人头疼的）<ol>\n<li>严格模式</li>\n<li>非严格模式</li>\n</ol>\n</li>\n<li>隐式绑定</li>\n<li>显式绑定<ol>\n<li>bind</li>\n<li>call</li>\n<li>apply</li>\n</ol>\n</li>\n<li>new绑定</li>\n</ol>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>默认绑定顾名思义，就是没人要的“孤儿”就会应用默认绑定。</p>\n<p>思考🤔一下👇的代码会输出什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'in'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：’out’</strong></p>\n<p>我们可以看到当调用 <code>fnc()</code> 时，<code>this.a</code> 被解析成了全局变量 <code>a</code>。为什么?因为在本 例中，函数调用时应用了 <code>this</code> 的默认绑定，因此 <code>this</code> 指向全局对象。</p>\n<p>那我们怎么知道他是应用了默认绑定呢？</p>\n<p>我们发现 <code>fnc</code> 他只是孤零零的被调用，没有任何的修饰<em>（调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。）</em>，所以它就相当于是没有人要的<code>孩子</code>，只能去<code>福利院</code>—默认绑定。</p>\n<p>这样说可能还不太明白默认绑定究竟是怎么一回事。等到后面的规则介绍的多了，你就会发现没有应用其他规则的“孤儿”只能来福利院 —默认绑定的怀抱</p>\n<h4 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h4><p>在严格下，默认绑定不是绑定到<code>window</code>，而是<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'in'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：报错</strong></p>\n<p>为什么？因为我们想在<code>undefined</code>里面找<code>a</code>，那肯定是报错的</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>隐式绑定，顾名思义就是悄悄的绑定，或者说公认的，但是没有明说的绑定。就好比一个男人和一个女人手牵手走在一起，他们基本上可以认定就是在情侣，但是还是有可能会是“偷情”（映射到隐式绑定的隐式丢失，等会会说到。）</p>\n<p>思考🤔一下👇的代码会输出什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">'in'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：’in’</strong></p>\n<p>我们可以注意到，<code>fnc</code> 是在什么情况下被调用的？是<code>obj</code> 调用的，说明这个<code>fnc</code>已经有主了，护花使者是<code>obj</code>，所以<code>fnc</code>说的话肯定是向着<code>obj</code>的，胳膊肘不会往外拐。</p>\n<p>其实这里面有一个小的点需要注意，那就是如果是多个对象引用的调用，那这个时候的执行上下文又是谁的呢？</p>\n<p>其实我们用常理就可以解释这个问题，A叫B去吃饭，但是B想叫C一起去，结果A和B起了冲突，你作为这个C你会向着谁？那肯定是B，因为有C叫你去，你们才会出现在这场聚会。所以这个问题不难回答。我们直接看一个例子🌰</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'aa'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bb = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'bb'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cc = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cc'</span>,</span><br><span class=\"line\">  bb: bb</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cc.bb.fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：bb</strong></p>\n<p>为什么？因为能让<code>fnc</code>被调用的是<code>bb</code>，没有<code>bb</code>，<code>fnc</code>根本没有机会登场。</p>\n<h4 id=\"隐式丢失\"><a href=\"#隐式丢失\" class=\"headerlink\" title=\"隐式丢失\"></a>隐式丢失</h4><p>前面说过，虽然很多东西表上面看起来都很正常，但是也有可能有一些其他状况的出现。比如隐式绑定里面的隐式丢失。</p>\n<p>我们把之前的例子修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'aa'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bb = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'bb'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cc = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cc'</span>,</span><br><span class=\"line\">  bb: bb</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = cc.bb.fnc;</span><br><span class=\"line\">aa()</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：aa</strong></p>\n<p>为什么？这个其实也很好理解，这个<code>fnc</code>并没有被<code>bb</code>调用，真正调用的地方是在<code>window</code>里面声明的一个变量<code>aa</code>。所以<code>bb</code>丢失了<code>fnc</code>的信任，<code>fnc</code>无处可去，只能去孤儿院。</p>\n<p>还是刚刚吃饭的例子，我们修改一下场景就很好理解了。</p>\n<p>A叫B去吃饭，B把C的联系方式不小心弄丢了，结果被一个陌生人D捡去了，刚刚好D也要参加聚会，就打电话叫了D一起参加聚会。但是C不认识D，叫他去的不是熟人B，所以谁也信不过。最终只能应用默认规则–默认绑定了。</p>\n<p>还有一种情况是非常常见的，也是隐式丢失，那就是回调函数。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ffnncc</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  fnc: fnc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ffnncc(obj.fnc)</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：widnow</strong></p>\n<p>为什么？这和之前的那个例子一样，表面上看起来好像是<code>obj</code>调用的，但是其实是<code>obj</code>把调用<code>fnc</code>的方法转交给了别人，由<code>fnc</code>不认识的来调用了。</p>\n<p>再来看一个面试题经常考的题目：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  fnc: fnc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(obj.fnc, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：widnow</strong></p>\n<p>我相信不用解释你也找到为什么了吧？<code>fnc</code>的联系方式被<code>obj</code>转交给别人了！</p>\n<p>哈哈哈哈，有没有感觉this其实也不过如此，so easy！</p>\n<blockquote>\n<p>思考题：那么react中的函数调用为什么要用箭头函数或者为什么要在constructor里面bind一下。</p>\n</blockquote>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>我们刚刚看到的是隐式绑定，是偷偷摸摸的那种。接下来我们就介绍一下显式绑定，光明正大的那种。</p>\n<p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么</p>\n<p>做呢?</p>\n<p>JavaScript 中的“所有”函数都有一些有用的特性(这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型)，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">\ta:<span class=\"string\">'obj'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj );</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案的先后顺序是：obj，window</strong></p>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p>\n<p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：Hello, Wiliam</strong></p>\n<p>其实我们不难发现，这个<code>fn</code>不是直接被调用的，所以造成了隐式丢失。我们的<code>call</code>绑定的<code>person</code>其实绑定在了<code>Hi</code>上面了，不信的话我们改一下你就会发现了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p>输出了什么？</p>\n<p><strong>YvetteLau</strong></p>\n<p><strong>Hello, Wiliam</strong></p>\n<p>那么咋办呢？别怕显示绑定的变异版，硬绑定可以解决这个问题。</p>\n<h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>硬绑定其实就是在最后一层给他进行显示绑定。</p>\n<p>请看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    fn.call(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi(person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p>输出了什么？</p>\n<p><strong>YvetteLau</strong></p>\n<p><strong>Hello, Wiliam</strong></p>\n<p>虽然我们调用<code>Hi</code>的时候，在<code>call</code>之前<code>this</code>还是指向了<code>window</code>，但是我们用<code>call</code>给他绑定上了<code>person</code>。无论之后如何调用函数 <code>fn</code>，它 总会手动在 <code>person</code> 上调用 <code>fn</code>。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的bar不可能再修改它的this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>典型应用场景是创建一个包裹函数，负责接收参数并返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个可以重复使用的辅助函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的辅助绑定函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind( foo, obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>ES5内置了<code>Function.prototype.bind</code>，bind会返回一个硬绑定的新函数，用法如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>API调用的“上下文”</p>\n<p>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和<code>bind(..)</code>一样，确保回调函数使用指定的this。这些函数实际上通过<code>call(..)</code>和<code>apply(..)</code>实现了显式绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( el, <span class=\"keyword\">this</span>.id );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    id: <span class=\"string\">\"awesome\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">// 调用foo(..)时把this绑定到obj</span></span><br><span class=\"line\">myArray.forEach( foo, obj );</span><br><span class=\"line\"><span class=\"comment\">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h3><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>思考下面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a );  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>new</code>来调用<code>foo(..)</code>时，会构造一个新对象并把它（<code>bar</code>）绑定到<code>foo(..)</code>调用中的this。</p>\n<h3 id=\"绑定优先级\"><a href=\"#绑定优先级\" class=\"headerlink\" title=\"绑定优先级\"></a>绑定优先级</h3><p>看完规则，我们肯定想知道如果这些规则撞在一起，我们又该听谁的呢？</p>\n<p>毫无疑问，默认绑定的优先级是四条规则中最低的，因为是没人应用任何规则才会去应用默认绑定。所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">\ta: <span class=\"number\">2</span>,</span><br><span class=\"line\">\tfoo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">\ta: <span class=\"number\">3</span>,</span><br><span class=\"line\">\tfoo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.foo(); <span class=\"comment\">// 2 </span></span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">obj1.foo.call( obj2 ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">obj2.foo.call( obj1 ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123; \t</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a = something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">obj1.foo( <span class=\"number\">2</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">obj1.foo.call( obj2, <span class=\"number\">3</span> ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj2.a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> obj1.foo( <span class=\"number\">4</span> ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢?</p>\n<blockquote>\n<p>new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。</p>\n<p>这是因为函数内部有两个不同的方法：<code>[[Call]]</code>和<code>[[Constructor]]</code>。 当使用普通函数调用时，<code>[[Call]]</code>会被执行。当使用构造函数调用时，<code>[[Constructor]]</code>会被执行。<code>call</code>、<code>apply</code>、<code>bind</code>和箭头函数内部没有<code>[[Constructor]]</code>方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a = something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj1 ); </span><br><span class=\"line\">bar( <span class=\"number\">2</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( baz.a ); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到new把bind的硬绑定给顶掉了</p>\n<p>所以new  &gt; 硬绑定</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>\n</blockquote>\n<h3 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h3><h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p>\n<p>下面两种情况下会传入<code>null</code></p>\n<ul>\n<li>使用<code>apply(..)</code>来“展开”一个数组，并当作参数传入一个函数</li>\n<li><code>bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"，b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组”展开“成参数</span></span><br><span class=\"line\">foo.apply( <span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2，b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用bind(..)进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2，b:3</span></span><br></pre></td></tr></table></figure>\n\n<p>总是传入<code>null</code>来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。</p>\n<blockquote>\n<p>更安全的this</p>\n</blockquote>\n<p>安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。</p>\n<p>JS中创建一个空对象最简单的方法是<strong><code>Object.create(null)</code></strong>，这个和<code>{}</code>很像，但是并不会创建<code>Object.prototype</code>这个委托，所以比<code>{}</code>更空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"，b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们的空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create( <span class=\"literal\">null</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组”展开“成参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2，b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用bind(..)进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2，b:3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在<strong>赋值</strong>时发生。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><ul>\n<li>硬绑定可以把this强制绑定到指定的对象（<code>new</code>除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用<strong>硬绑定之后就无法使用隐式绑定或者显式绑定来修改this</strong>。</li>\n<li><strong>如果给默认绑定指定一个全局对象和undefined以外的值</strong>，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认绑定规则，优先级排最后</span></span><br><span class=\"line\"><span class=\"comment\">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有curried参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = [].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> ); </span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">            \t(!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ? </span><br><span class=\"line\">                \tobj : <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"name:\"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj\"</span> &#125;,</span><br><span class=\"line\">    obj2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj2\"</span> &#125;,</span><br><span class=\"line\">    obj3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj3\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fooOBJ = foo.softBind( obj );</span><br><span class=\"line\">fooOBJ(); <span class=\"comment\">// name: obj </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐式绑定规则</span></span><br><span class=\"line\">obj2.foo = foo.softBind( obj );</span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// name: obj2 &lt;---- 看！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显式绑定规则</span></span><br><span class=\"line\">fooOBJ.call( obj3 ); <span class=\"comment\">// name: obj3 &lt;---- 看！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定丢失，应用软绑定</span></span><br><span class=\"line\">setTimeout( obj2.foo, <span class=\"number\">10</span> ); <span class=\"comment\">// name: obj</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（<strong>词法作用域</strong>）来决定this。</p>\n<ul>\n<li><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于<code>foo()</code>的this绑定到<code>obj1</code>，<code>bar</code>(引用箭头函数)的this也会绑定到<code>obj1</code>，<strong>箭头函数的绑定无法被修改</strong>(<code>new</code>也不行)。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this继承自foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2，不是3！</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 this 在此法上继承自 foo()</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a ); &#125;,<span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">\ta:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// lexical capture of this</span></span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( self.a ); <span class=\"comment\">// self只是继承了foo()函数的this绑定</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现call和apply\"><a href=\"#实现call和apply\" class=\"headerlink\" title=\"实现call和apply\"></a>实现call和apply</h2><h3 id=\"了解call和apply\"><a href=\"#了解call和apply\" class=\"headerlink\" title=\"了解call和apply\"></a>了解call和apply</h3><p>为什么会有call和apply？ call和apply两个方法的作用基本相同，它们都是为了改变某个函数<strong>执行时的上下文</strong>（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部<strong>this 的指向</strong>。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.color &#x3D; &quot;red&quot;;</span><br><span class=\"line\">var o &#x3D; &#123;color: &quot;blue&quot;&#125;;</span><br><span class=\"line\">function sayColor()&#123;</span><br><span class=\"line\">\talert(this.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor();&#x2F;&#x2F;red</span><br><span class=\"line\">sayColor.call(this);&#x2F;&#x2F;red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)</span><br><span class=\"line\">sayColor.call(window);&#x2F;&#x2F;red，把函数体sayColor内部的this，绑到window（全局作用域）</span><br><span class=\"line\">sayColor.call(o);&#x2F;&#x2F;blue复制代码</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>解释：</strong>上面的栗子，很明显函数sayColor是在全局作用域（环境/window）中调用的，而全局作用域中有一个color属性，值为”red”，sayColor.call(this)这一行代码就是表示<strong>把函数体sayColor内部的this，绑到当前环境（作用域）</strong>，而sayColor.call(window)这一行代码就是表示<strong>把函数体sayColor内部的this，绑到window（全局作用域）</strong>，之所以这两行的输出都是”red”就是因为他当前作用域的this就是window（this === window）； 最后，sayColor.call(o)这一行代码就表示<strong>把函数体sayColor内部的this，绑到o这个对象的执行环境（上下文）中来</strong>，也就是说sayColor内部的this——&gt;<strong>o</strong></p>\n</blockquote>\n<h3 id=\"call和apply的区别\"><a href=\"#call和apply的区别\" class=\"headerlink\" title=\"call和apply的区别\"></a>call和apply的区别</h3><p><code>call()</code> 和 <code>apply()</code>的区别在于，<code>call()</code>方法接受的是<strong>若干个参数的列表</strong>，而<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(<span class=\"keyword\">this</span>, arg1, arg2); <span class=\"comment\">// 使用 call，参数列表</span></span><br><span class=\"line\">func.apply(<span class=\"keyword\">this</span>, [arg1, arg2]) <span class=\"comment\">// 使用 apply，参数数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>其实这些应用场景都有新的方法可以快速解决， 我只是想告诉大家一些小的知识点， 而且这些东西虽然有新的方法代替，但是面试的时候很可能会被问到。</p>\n<h4 id=\"合并两个数组\"><a href=\"#合并两个数组\" class=\"headerlink\" title=\"合并两个数组\"></a>合并两个数组</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'a'</span>, <span class=\"string\">'aa'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'b'</span>, <span class=\"string\">'bb'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(a, b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// ['a', 'aa', 'b', 'bb']</span></span><br></pre></td></tr></table></figure>\n\n<p>其实现在有<code>concat</code>来代替了。或者其他奇淫技巧。但是，都不是我们的重点。</p>\n<blockquote>\n<p>当第二个数组(如示例中的 b )太大时不要使用这个方法来合并数组，因为<strong>一个函数能够接受的参数个数是有限制</strong>的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。</p>\n</blockquote>\n<p>那么要如何解决呢？</p>\n<p>我们可以把数组进行切割。然后分批次的调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myConcat</span>(<span class=\"params\">arr1, arr2, max = <span class=\"number\">32768</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr2.length; i += max) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.push.apply(</span><br><span class=\"line\">    \tarr1,</span><br><span class=\"line\">      arr2.slice(i, i + max) <span class=\"comment\">// 小的知识点，第二个参数大于数组长度就一直取到数组的末尾</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">-2</span>, <span class=\"number\">-1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">999999</span>; i ++) &#123;</span><br><span class=\"line\">  b.push(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(a, b) <span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myConcat(a, b)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"验证是否是数组\"><a href=\"#验证是否是数组\" class=\"headerlink\" title=\"验证是否是数组\"></a>验证是否是数组</h4><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(arr); <span class=\"comment\">// [object Array]</span></span><br><span class=\"line\"><span class=\"comment\">//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）复制代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"同样是检测对象类型，arr-toString-的结果和Object-prototype-toString-call-arr-的结果不一样，这是为什么？\"><a href=\"#同样是检测对象类型，arr-toString-的结果和Object-prototype-toString-call-arr-的结果不一样，这是为什么？\" class=\"headerlink\" title=\"同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？\"></a>同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？</h4><blockquote>\n<p>这是因为toString()为Object的原型方法，而Array ，function等引用类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的<strong>重写</strong>之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法，所以采用arr.toString()不能得到其对象类型，只能将arr转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p>\n</blockquote>\n<h4 id=\"类数组对象（Array-like-Object）使用数组方法\"><a href=\"#类数组对象（Array-like-Object）使用数组方法\" class=\"headerlink\" title=\"类数组对象（Array-like Object）使用数组方法\"></a>类数组对象（Array-like Object）使用数组方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> domNodes = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">domNodes.unshift(<span class=\"string\">\"h1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// TypeError: domNodes.unshift is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> domNodeArrays = <span class=\"built_in\">Array</span>.prototype.slice.call(domNodes);</span><br><span class=\"line\">domNodeArrays.unshift(<span class=\"string\">\"h1\"</span>); <span class=\"comment\">// 505 不同环境下数据不同</span></span><br><span class=\"line\"><span class=\"comment\">// (505) [\"h1\", html.gr__hujiang_com, head, meta, ...]</span></span><br></pre></td></tr></table></figure>\n\n<p>类数组对象有下面两个特性</p>\n<ul>\n<li>1、具有：指向对象元素的数字索引下标和 <code>length</code> 属性</li>\n<li>2、不具有：比如 <code>push</code> 、<code>shift</code>、 <code>forEach</code> 以及 <code>indexOf</code>等数组对象具有的方法</li>\n</ul>\n<p>要说明的是，类数组对象是一个<strong>对象</strong>。JS中存在一种名为<strong>类数组</strong>的对象结构，比如 <code>arguments</code> 对象，还有DOM API 返回的 <code>NodeList</code> 对象都属于类数组对象，类数组对象不能使用 <code>push/pop/shift/unshift</code> 等数组方法，通过 <code>Array.prototype.slice.call</code> 转换成真正的数组，就可以使用 <code>Array</code>下所有方法。</p>\n<p><strong>类数组对象转数组</strong>的其他方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上面代码等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [].slice.call(<span class=\"built_in\">arguments</span>)；</span><br><span class=\"line\"></span><br><span class=\"line\">ES6:</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...arguments];</span><br></pre></td></tr></table></figure>\n\n<p><code>Array.from()</code> 可以将两类对象转为真正的数组：<strong>类数组</strong>对象和<strong>可遍历</strong>（iterable）对象（包括ES6新增的数据结构 Set 和 Map）。</p>\n<h3 id=\"实现call\"><a href=\"#实现call\" class=\"headerlink\" title=\"实现call\"></a>实现call</h3><p>这里会使用隐式绑定来实现。</p>\n<p>先丢出我们要测试的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.call(b) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>OK, 我们现在就来实现以下自定义的call。应用隐式绑定的话就可以直接绑定上了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  context.fn = f;</span><br><span class=\"line\">  context.fn();</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.myCall(b) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>很潇洒的完成了。但是好像不能接受参数诶，接受参数又要考虑边界情况，比如<code>undefined</code>，<code>null</code>之类的。而且！！而且！！而且<code>call</code>不传的话是默认应用<code>window</code>的；</p>\n<p>所以他有我们也要有！冲！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myCall = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo</span></span><br><span class=\"line\">  <span class=\"comment\">// 不传第一个参数，默认是window,</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> context = context || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数</span></span><br><span class=\"line\">  context.fn = <span class=\"keyword\">this</span>;<span class=\"comment\">//这里的context.fn就相当于上文的bar函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [...arguments].slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 执行函数（相当于上文的bar(...args)）</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = context.fn(...args);</span><br><span class=\"line\">  <span class=\"comment\">// 删除函数</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现apply\"><a href=\"#实现apply\" class=\"headerlink\" title=\"实现apply\"></a>实现apply</h3><p>因为他们两兄弟就参数不一样所以就不解释了，直接看代码吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myApply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> context = context || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">      context.fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">      <span class=\"comment\">// 判断第二个参数是否存在，也就是context后面有没有一个数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果存在，则需要展开第二个参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        result = context.fn(...arguments[<span class=\"number\">1</span>]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = context.fn();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实现bind\"><a href=\"#实现bind\" class=\"headerlink\" title=\"实现bind\"></a>实现bind</h2><h4 id=\"了解bind\"><a href=\"#了解bind\" class=\"headerlink\" title=\"了解bind\"></a>了解bind</h4><blockquote>\n<p><code>bind() 方法创建一个新的函数，在</code>bind()<code>被调用时，这个新函数的</code>this<code>被指定为</code>bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>\n<p>语法：<code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<p>MDN</p>\n</blockquote>\n<h4 id=\"bind和apply，call两兄弟的区别\"><a href=\"#bind和apply，call两兄弟的区别\" class=\"headerlink\" title=\"bind和apply，call两兄弟的区别\"></a>bind和apply，call两兄弟的区别</h4><p><code>bind</code> 方法与 <code>call / apply</code> 最大的不同就是前者返回一个绑定上下文的<strong>函数</strong>，而后两者是<strong>直接执行</strong>了函数。</p>\n<p>上代码！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tvalue: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">\t\tname: name,</span><br><span class=\"line\">\t\tage: age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.call(foo, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 直接执行了函数</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo1 = bar.bind(foo, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">bindFoo1();</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo2 = bar.bind(foo, <span class=\"string\">\"Jack\"</span>); <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">bindFoo2(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上述代码可以看出<code>bind</code> 有如下特性：</p>\n<ul>\n<li>1、可以指定<code>this</code></li>\n<li>2、返回一个函数</li>\n<li>3、可以传入参数</li>\n<li>4、柯里化</li>\n</ul>\n<h4 id=\"实现bind-1\"><a href=\"#实现bind-1\" class=\"headerlink\" title=\"实现bind\"></a>实现bind</h4><p>直接开干！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(context)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.myBind(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bindFoo()); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>Ok,接下来我们处理一下参数和柯里化吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(context, args.concat(nowArgs))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tvalue: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">\t\tname: name,</span><br><span class=\"line\">\t\tage: age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.myBind(foo, <span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">bindFoo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>到现在已经完成大部分了，但是还有一个难点，<code>bind</code> 有以下一个特性</p>\n<blockquote>\n<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>\n</blockquote>\n<p>举例说明：正规的bind</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.habit = <span class=\"string\">'shopping'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.prototype.friend = <span class=\"string\">'kevin'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.bind(foo, <span class=\"string\">'Jack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> bindFoo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.habit;</span><br><span class=\"line\"><span class=\"comment\">// shopping</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.friend;</span><br><span class=\"line\"><span class=\"comment\">// kevin</span></span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，运行结果<code>this.value</code> 输出为 <code>undefined</code>，这不是全局<code>value</code> 也不是<code>foo</code>对象中的<code>value</code>，这说明 <code>bind</code> 的 <code>this</code> 对象失效了，<code>new</code> 的实现中生成一个新的对象，这个时候的 <code>this</code>指向的是 <code>obj</code>。</p>\n<p>所以我们返回的时候需要判断一下他是不是作为了构造函数返回，如果是就返回当前的this，如果不是就绑定当前输入的<code>context</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fnc ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是其实这样会有一个问题，我如果实例修改了原型，那么接下来的继承就会出现问题。</p>\n<p>这个时候我们需要拷贝一下我们原型上面的参数。会用到</p>\n<blockquote>\n<p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来非常简单</p>\n<p>先在<code>object</code>函数内部创建一个临时的构造函数<code>F</code>, 然后将传入的这个对象<code>o</code>作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. </p>\n<p>简单来说就是<code>object</code>对传入的对象进行了浅复制.</p>\n</blockquote>\n<p>这句话在我的《原型原型链和继承》里面有具体的介绍。想看的话可以点击头像查找文章。</p>\n<p>这边可以直接使用ES5的 <code>Object.create()</code>方法生成一个新对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fBound.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.prototype);</span><br></pre></td></tr></table></figure>\n\n<p>不过 <code>bind</code> 和 <code>Object.create()</code>都是ES5方法，部分IE浏览器（IE &lt; 9）并不支持，Polyfill中不能用 <code>Object.create()</code>实现 <code>bind</code>，不过原理是一样的。</p>\n<p>ok。那我们就修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fNOP ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fNOP.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">new</span> FNOP()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里其实已经差不多了，突然想起来还有一个问题是调用 <code>bind</code> 的不是函数，这时候需要抛出异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Function.prototype.bind - what is trying to be bound is not callable\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以</p>\n<h4 id=\"顶配\"><a href=\"#顶配\" class=\"headerlink\" title=\"顶配\"></a>顶配</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Function.prototype.bind - what is trying to \tbe bound is not callable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fNOP ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fNOP.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">new</span> FNOP()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"实现new\"><a href=\"#实现new\" class=\"headerlink\" title=\"实现new\"></a>实现new</h2><h4 id=\"了解new\"><a href=\"#了解new\" class=\"headerlink\" title=\"了解new\"></a>了解new</h4><blockquote>\n<p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）</p>\n</blockquote>\n<p>我们先试试现在有的new，他有什么功能，然后我们总结之后，在开始实现。</p>\n<p>看个🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NEW</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">NEW.prototype.sayA = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a+<span class=\"string\">'b'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"keyword\">new</span> NEW(<span class=\"number\">1</span>);</span><br><span class=\"line\">A.sayA()</span><br><span class=\"line\">A.a</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到A是NEW的一个实例。继承了构造函数（NEW）的属性和原型上的属性（sayA）。</p>\n<blockquote>\n<p><strong><code>new</code></strong> 关键字会进行如下的操作：</p>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回<code>this</code>。</li>\n</ol>\n<p>MDN</p>\n</blockquote>\n<h4 id=\"实现一个new\"><a href=\"#实现一个new\" class=\"headerlink\" title=\"实现一个new\"></a>实现一个new</h4><p>说干就干：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 获取构造函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为arguments是一个类数组对象，没有unshift方法，所以用了call，我们没有new这关键字，只能模拟，所以的一个参数我们认为他需要传递一个构造函数。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Con = [].unshift.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 2.</span></span><br><span class=\"line\">  obj.__proto__ = Con.prototype </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 3、 绑定this。因为之前arguments已经被我们删除了第一个元素，所以剩下的就是我们所需要的参数了。</span></span><br><span class=\"line\">  Con.apply(obj, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 4. 简陋版</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数返回值有如下三种情况：</p>\n<ul>\n<li>1、返回一个对象</li>\n<li>2、没有 <code>return</code>，即返回 <code>undefined</code></li>\n<li>3、返回<code>undefined</code> 以外的基本类型</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class=\"line\">    Con = [].shift.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(Con.prototype);</span><br><span class=\"line\">\t<span class=\"comment\">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = Con.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 4、优先返回构造函数返回的对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> ? ret : obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说起this，这个几乎是前端面试必考题，也是前端最多“脑经急转弯”的地方，也是让无数前端人烦恼的地方。今天我们就彻底的深入this，全面的攻破它！</p>\n<h2 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h2><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。</p>\n<p>你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>\n<p>this的绑定规则总共有以下5种：</p>\n<ol>\n<li>默认绑定（最令人头疼的）<ol>\n<li>严格模式</li>\n<li>非严格模式</li>\n</ol>\n</li>\n<li>隐式绑定</li>\n<li>显式绑定<ol>\n<li>bind</li>\n<li>call</li>\n<li>apply</li>\n</ol>\n</li>\n<li>new绑定</li>\n</ol>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>默认绑定顾名思义，就是没人要的“孤儿”就会应用默认绑定。</p>\n<p>思考🤔一下👇的代码会输出什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'in'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：’out’</strong></p>\n<p>我们可以看到当调用 <code>fnc()</code> 时，<code>this.a</code> 被解析成了全局变量 <code>a</code>。为什么?因为在本 例中，函数调用时应用了 <code>this</code> 的默认绑定，因此 <code>this</code> 指向全局对象。</p>\n<p>那我们怎么知道他是应用了默认绑定呢？</p>\n<p>我们发现 <code>fnc</code> 他只是孤零零的被调用，没有任何的修饰<em>（调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。）</em>，所以它就相当于是没有人要的<code>孩子</code>，只能去<code>福利院</code>—默认绑定。</p>\n<p>这样说可能还不太明白默认绑定究竟是怎么一回事。等到后面的规则介绍的多了，你就会发现没有应用其他规则的“孤儿”只能来福利院 —默认绑定的怀抱</p>\n<h4 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h4><p>在严格下，默认绑定不是绑定到<code>window</code>，而是<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'in'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：报错</strong></p>\n<p>为什么？因为我们想在<code>undefined</code>里面找<code>a</code>，那肯定是报错的</p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>隐式绑定，顾名思义就是悄悄的绑定，或者说公认的，但是没有明说的绑定。就好比一个男人和一个女人手牵手走在一起，他们基本上可以认定就是在情侣，但是还是有可能会是“偷情”（映射到隐式绑定的隐式丢失，等会会说到。）</p>\n<p>思考🤔一下👇的代码会输出什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'out'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">'in'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：’in’</strong></p>\n<p>我们可以注意到，<code>fnc</code> 是在什么情况下被调用的？是<code>obj</code> 调用的，说明这个<code>fnc</code>已经有主了，护花使者是<code>obj</code>，所以<code>fnc</code>说的话肯定是向着<code>obj</code>的，胳膊肘不会往外拐。</p>\n<p>其实这里面有一个小的点需要注意，那就是如果是多个对象引用的调用，那这个时候的执行上下文又是谁的呢？</p>\n<p>其实我们用常理就可以解释这个问题，A叫B去吃饭，但是B想叫C一起去，结果A和B起了冲突，你作为这个C你会向着谁？那肯定是B，因为有C叫你去，你们才会出现在这场聚会。所以这个问题不难回答。我们直接看一个例子🌰</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'aa'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bb = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'bb'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cc = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cc'</span>,</span><br><span class=\"line\">  bb: bb</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cc.bb.fnc();</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：bb</strong></p>\n<p>为什么？因为能让<code>fnc</code>被调用的是<code>bb</code>，没有<code>bb</code>，<code>fnc</code>根本没有机会登场。</p>\n<h4 id=\"隐式丢失\"><a href=\"#隐式丢失\" class=\"headerlink\" title=\"隐式丢失\"></a>隐式丢失</h4><p>前面说过，虽然很多东西表上面看起来都很正常，但是也有可能有一些其他状况的出现。比如隐式绑定里面的隐式丢失。</p>\n<p>我们把之前的例子修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'aa'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bb = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'bb'</span>,</span><br><span class=\"line\">  fnc: fnc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cc = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cc'</span>,</span><br><span class=\"line\">  bb: bb</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = cc.bb.fnc;</span><br><span class=\"line\">aa()</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：aa</strong></p>\n<p>为什么？这个其实也很好理解，这个<code>fnc</code>并没有被<code>bb</code>调用，真正调用的地方是在<code>window</code>里面声明的一个变量<code>aa</code>。所以<code>bb</code>丢失了<code>fnc</code>的信任，<code>fnc</code>无处可去，只能去孤儿院。</p>\n<p>还是刚刚吃饭的例子，我们修改一下场景就很好理解了。</p>\n<p>A叫B去吃饭，B把C的联系方式不小心弄丢了，结果被一个陌生人D捡去了，刚刚好D也要参加聚会，就打电话叫了D一起参加聚会。但是C不认识D，叫他去的不是熟人B，所以谁也信不过。最终只能应用默认规则–默认绑定了。</p>\n<p>还有一种情况是非常常见的，也是隐式丢失，那就是回调函数。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ffnncc</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  fnc: fnc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ffnncc(obj.fnc)</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：widnow</strong></p>\n<p>为什么？这和之前的那个例子一样，表面上看起来好像是<code>obj</code>调用的，但是其实是<code>obj</code>把调用<code>fnc</code>的方法转交给了别人，由<code>fnc</code>不认识的来调用了。</p>\n<p>再来看一个面试题经常考的题目：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  fnc: fnc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(obj.fnc, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：widnow</strong></p>\n<p>我相信不用解释你也找到为什么了吧？<code>fnc</code>的联系方式被<code>obj</code>转交给别人了！</p>\n<p>哈哈哈哈，有没有感觉this其实也不过如此，so easy！</p>\n<blockquote>\n<p>思考题：那么react中的函数调用为什么要用箭头函数或者为什么要在constructor里面bind一下。</p>\n</blockquote>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>我们刚刚看到的是隐式绑定，是偷偷摸摸的那种。接下来我们就介绍一下显式绑定，光明正大的那种。</p>\n<p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么</p>\n<p>做呢?</p>\n<p>JavaScript 中的“所有”函数都有一些有用的特性(这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型)，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">\ta:<span class=\"string\">'obj'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj );</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案的先后顺序是：obj，window</strong></p>\n<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p>\n<p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p><strong>答案是：Hello, Wiliam</strong></p>\n<p>其实我们不难发现，这个<code>fn</code>不是直接被调用的，所以造成了隐式丢失。我们的<code>call</code>绑定的<code>person</code>其实绑定在了<code>Hi</code>上面了，不信的话我们改一下你就会发现了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p>输出了什么？</p>\n<p><strong>YvetteLau</strong></p>\n<p><strong>Hello, Wiliam</strong></p>\n<p>那么咋办呢？别怕显示绑定的变异版，硬绑定可以解决这个问题。</p>\n<h4 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h4><p>硬绑定其实就是在最后一层给他进行显示绑定。</p>\n<p>请看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,'</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'YvetteLau'</span>,</span><br><span class=\"line\">    sayHi: sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Wiliam'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Hi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    fn.call(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Hi(person.sayHi);</span><br></pre></td></tr></table></figure>\n\n<p>输出了什么？</p>\n<p><strong>YvetteLau</strong></p>\n<p><strong>Hello, Wiliam</strong></p>\n<p>虽然我们调用<code>Hi</code>的时候，在<code>call</code>之前<code>this</code>还是指向了<code>window</code>，但是我们用<code>call</code>给他绑定上了<code>person</code>。无论之后如何调用函数 <code>fn</code>，它 总会手动在 <code>person</code> 上调用 <code>fn</code>。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call( obj );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">setTimeout( bar, <span class=\"number\">100</span> ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的bar不可能再修改它的this</span></span><br><span class=\"line\">bar.call( <span class=\"built_in\">window</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>典型应用场景是创建一个包裹函数，负责接收参数并返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个可以重复使用的辅助函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的辅助绑定函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind( foo, obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>ES5内置了<code>Function.prototype.bind</code>，bind会返回一个硬绑定的新函数，用法如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>API调用的“上下文”</p>\n<p>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和<code>bind(..)</code>一样，确保回调函数使用指定的this。这些函数实际上通过<code>call(..)</code>和<code>apply(..)</code>实现了显式绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( el, <span class=\"keyword\">this</span>.id );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    id: <span class=\"string\">\"awesome\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">// 调用foo(..)时把this绑定到obj</span></span><br><span class=\"line\">myArray.forEach( foo, obj );</span><br><span class=\"line\"><span class=\"comment\">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h3><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>\n<ol>\n<li>创建(或者说构造)一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>思考下面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a );  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>new</code>来调用<code>foo(..)</code>时，会构造一个新对象并把它（<code>bar</code>）绑定到<code>foo(..)</code>调用中的this。</p>\n<h3 id=\"绑定优先级\"><a href=\"#绑定优先级\" class=\"headerlink\" title=\"绑定优先级\"></a>绑定优先级</h3><p>看完规则，我们肯定想知道如果这些规则撞在一起，我们又该听谁的呢？</p>\n<p>毫无疑问，默认绑定的优先级是四条规则中最低的，因为是没人应用任何规则才会去应用默认绑定。所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">\ta: <span class=\"number\">2</span>,</span><br><span class=\"line\">\tfoo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">\ta: <span class=\"number\">3</span>,</span><br><span class=\"line\">\tfoo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj1.foo(); <span class=\"comment\">// 2 </span></span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">obj1.foo.call( obj2 ); <span class=\"comment\">// 3 </span></span><br><span class=\"line\">obj2.foo.call( obj1 ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123; \t</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a = something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">obj1.foo( <span class=\"number\">2</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">obj1.foo.call( obj2, <span class=\"number\">3</span> ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj2.a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> obj1.foo( <span class=\"number\">4</span> ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢?</p>\n<blockquote>\n<p>new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。</p>\n<p>这是因为函数内部有两个不同的方法：<code>[[Call]]</code>和<code>[[Constructor]]</code>。 当使用普通函数调用时，<code>[[Call]]</code>会被执行。当使用构造函数调用时，<code>[[Constructor]]</code>会被执行。<code>call</code>、<code>apply</code>、<code>bind</code>和箭头函数内部没有<code>[[Constructor]]</code>方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a = something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj1 ); </span><br><span class=\"line\">bar( <span class=\"number\">2</span> );</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj1.a ); <span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( baz.a ); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到new把bind的硬绑定给顶掉了</p>\n<p>所以new  &gt; 硬绑定</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>\n</blockquote>\n<h3 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h3><h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p>\n<p>下面两种情况下会传入<code>null</code></p>\n<ul>\n<li>使用<code>apply(..)</code>来“展开”一个数组，并当作参数传入一个函数</li>\n<li><code>bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"，b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组”展开“成参数</span></span><br><span class=\"line\">foo.apply( <span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2，b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用bind(..)进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2，b:3</span></span><br></pre></td></tr></table></figure>\n\n<p>总是传入<code>null</code>来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。</p>\n<blockquote>\n<p>更安全的this</p>\n</blockquote>\n<p>安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。</p>\n<p>JS中创建一个空对象最简单的方法是<strong><code>Object.create(null)</code></strong>，这个和<code>{}</code>很像，但是并不会创建<code>Object.prototype</code>这个委托，所以比<code>{}</code>更空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"，b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们的空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create( <span class=\"literal\">null</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组”展开“成参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2，b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用bind(..)进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2，b:3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"间接引用\"><a href=\"#间接引用\" class=\"headerlink\" title=\"间接引用\"></a>间接引用</h4><p>间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在<strong>赋值</strong>时发生。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><ul>\n<li>硬绑定可以把this强制绑定到指定的对象（<code>new</code>除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用<strong>硬绑定之后就无法使用隐式绑定或者显式绑定来修改this</strong>。</li>\n<li><strong>如果给默认绑定指定一个全局对象和undefined以外的值</strong>，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认绑定规则，优先级排最后</span></span><br><span class=\"line\"><span class=\"comment\">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有curried参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = [].slice.call( <span class=\"built_in\">arguments</span>, <span class=\"number\">1</span> ); </span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">            \t(!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ? </span><br><span class=\"line\">                \tobj : <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                curried.concat.apply( curried, <span class=\"built_in\">arguments</span> )</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create( fn.prototype );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"name:\"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj\"</span> &#125;,</span><br><span class=\"line\">    obj2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj2\"</span> &#125;,</span><br><span class=\"line\">    obj3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj3\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fooOBJ = foo.softBind( obj );</span><br><span class=\"line\">fooOBJ(); <span class=\"comment\">// name: obj </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐式绑定规则</span></span><br><span class=\"line\">obj2.foo = foo.softBind( obj );</span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// name: obj2 &lt;---- 看！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显式绑定规则</span></span><br><span class=\"line\">fooOBJ.call( obj3 ); <span class=\"comment\">// name: obj3 &lt;---- 看！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定丢失，应用软绑定</span></span><br><span class=\"line\">setTimeout( obj2.foo, <span class=\"number\">10</span> ); <span class=\"comment\">// name: obj</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（<strong>词法作用域</strong>）来决定this。</p>\n<ul>\n<li><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于<code>foo()</code>的this绑定到<code>obj1</code>，<code>bar</code>(引用箭头函数)的this也会绑定到<code>obj1</code>，<strong>箭头函数的绑定无法被修改</strong>(<code>new</code>也不行)。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this继承自foo()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2，不是3！</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 this 在此法上继承自 foo()</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a ); &#125;,<span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">\ta:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// lexical capture of this</span></span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( self.a ); <span class=\"comment\">// self只是继承了foo()函数的this绑定</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现call和apply\"><a href=\"#实现call和apply\" class=\"headerlink\" title=\"实现call和apply\"></a>实现call和apply</h2><h3 id=\"了解call和apply\"><a href=\"#了解call和apply\" class=\"headerlink\" title=\"了解call和apply\"></a>了解call和apply</h3><p>为什么会有call和apply？ call和apply两个方法的作用基本相同，它们都是为了改变某个函数<strong>执行时的上下文</strong>（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部<strong>this 的指向</strong>。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.color &#x3D; &quot;red&quot;;</span><br><span class=\"line\">var o &#x3D; &#123;color: &quot;blue&quot;&#125;;</span><br><span class=\"line\">function sayColor()&#123;</span><br><span class=\"line\">\talert(this.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor();&#x2F;&#x2F;red</span><br><span class=\"line\">sayColor.call(this);&#x2F;&#x2F;red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)</span><br><span class=\"line\">sayColor.call(window);&#x2F;&#x2F;red，把函数体sayColor内部的this，绑到window（全局作用域）</span><br><span class=\"line\">sayColor.call(o);&#x2F;&#x2F;blue复制代码</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p><strong>解释：</strong>上面的栗子，很明显函数sayColor是在全局作用域（环境/window）中调用的，而全局作用域中有一个color属性，值为”red”，sayColor.call(this)这一行代码就是表示<strong>把函数体sayColor内部的this，绑到当前环境（作用域）</strong>，而sayColor.call(window)这一行代码就是表示<strong>把函数体sayColor内部的this，绑到window（全局作用域）</strong>，之所以这两行的输出都是”red”就是因为他当前作用域的this就是window（this === window）； 最后，sayColor.call(o)这一行代码就表示<strong>把函数体sayColor内部的this，绑到o这个对象的执行环境（上下文）中来</strong>，也就是说sayColor内部的this——&gt;<strong>o</strong></p>\n</blockquote>\n<h3 id=\"call和apply的区别\"><a href=\"#call和apply的区别\" class=\"headerlink\" title=\"call和apply的区别\"></a>call和apply的区别</h3><p><code>call()</code> 和 <code>apply()</code>的区别在于，<code>call()</code>方法接受的是<strong>若干个参数的列表</strong>，而<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(<span class=\"keyword\">this</span>, arg1, arg2); <span class=\"comment\">// 使用 call，参数列表</span></span><br><span class=\"line\">func.apply(<span class=\"keyword\">this</span>, [arg1, arg2]) <span class=\"comment\">// 使用 apply，参数数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>其实这些应用场景都有新的方法可以快速解决， 我只是想告诉大家一些小的知识点， 而且这些东西虽然有新的方法代替，但是面试的时候很可能会被问到。</p>\n<h4 id=\"合并两个数组\"><a href=\"#合并两个数组\" class=\"headerlink\" title=\"合并两个数组\"></a>合并两个数组</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'a'</span>, <span class=\"string\">'aa'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'b'</span>, <span class=\"string\">'bb'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(a, b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// ['a', 'aa', 'b', 'bb']</span></span><br></pre></td></tr></table></figure>\n\n<p>其实现在有<code>concat</code>来代替了。或者其他奇淫技巧。但是，都不是我们的重点。</p>\n<blockquote>\n<p>当第二个数组(如示例中的 b )太大时不要使用这个方法来合并数组，因为<strong>一个函数能够接受的参数个数是有限制</strong>的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。</p>\n</blockquote>\n<p>那么要如何解决呢？</p>\n<p>我们可以把数组进行切割。然后分批次的调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myConcat</span>(<span class=\"params\">arr1, arr2, max = <span class=\"number\">32768</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr2.length; i += max) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.push.apply(</span><br><span class=\"line\">    \tarr1,</span><br><span class=\"line\">      arr2.slice(i, i + max) <span class=\"comment\">// 小的知识点，第二个参数大于数组长度就一直取到数组的末尾</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">-2</span>, <span class=\"number\">-1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">999999</span>; i ++) &#123;</span><br><span class=\"line\">  b.push(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(a, b) <span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myConcat(a, b)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"验证是否是数组\"><a href=\"#验证是否是数组\" class=\"headerlink\" title=\"验证是否是数组\"></a>验证是否是数组</h4><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(arr); <span class=\"comment\">// [object Array]</span></span><br><span class=\"line\"><span class=\"comment\">//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）复制代码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"同样是检测对象类型，arr-toString-的结果和Object-prototype-toString-call-arr-的结果不一样，这是为什么？\"><a href=\"#同样是检测对象类型，arr-toString-的结果和Object-prototype-toString-call-arr-的结果不一样，这是为什么？\" class=\"headerlink\" title=\"同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？\"></a>同样是检测对象类型，arr.toString()的结果和Object.prototype.toString.call(arr)的结果不一样，这是为什么？</h4><blockquote>\n<p>这是因为toString()为Object的原型方法，而Array ，function等引用类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的<strong>重写</strong>之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法，所以采用arr.toString()不能得到其对象类型，只能将arr转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p>\n</blockquote>\n<h4 id=\"类数组对象（Array-like-Object）使用数组方法\"><a href=\"#类数组对象（Array-like-Object）使用数组方法\" class=\"headerlink\" title=\"类数组对象（Array-like Object）使用数组方法\"></a>类数组对象（Array-like Object）使用数组方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> domNodes = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">domNodes.unshift(<span class=\"string\">\"h1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// TypeError: domNodes.unshift is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> domNodeArrays = <span class=\"built_in\">Array</span>.prototype.slice.call(domNodes);</span><br><span class=\"line\">domNodeArrays.unshift(<span class=\"string\">\"h1\"</span>); <span class=\"comment\">// 505 不同环境下数据不同</span></span><br><span class=\"line\"><span class=\"comment\">// (505) [\"h1\", html.gr__hujiang_com, head, meta, ...]</span></span><br></pre></td></tr></table></figure>\n\n<p>类数组对象有下面两个特性</p>\n<ul>\n<li>1、具有：指向对象元素的数字索引下标和 <code>length</code> 属性</li>\n<li>2、不具有：比如 <code>push</code> 、<code>shift</code>、 <code>forEach</code> 以及 <code>indexOf</code>等数组对象具有的方法</li>\n</ul>\n<p>要说明的是，类数组对象是一个<strong>对象</strong>。JS中存在一种名为<strong>类数组</strong>的对象结构，比如 <code>arguments</code> 对象，还有DOM API 返回的 <code>NodeList</code> 对象都属于类数组对象，类数组对象不能使用 <code>push/pop/shift/unshift</code> 等数组方法，通过 <code>Array.prototype.slice.call</code> 转换成真正的数组，就可以使用 <code>Array</code>下所有方法。</p>\n<p><strong>类数组对象转数组</strong>的其他方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上面代码等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [].slice.call(<span class=\"built_in\">arguments</span>)；</span><br><span class=\"line\"></span><br><span class=\"line\">ES6:</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...arguments];</span><br></pre></td></tr></table></figure>\n\n<p><code>Array.from()</code> 可以将两类对象转为真正的数组：<strong>类数组</strong>对象和<strong>可遍历</strong>（iterable）对象（包括ES6新增的数据结构 Set 和 Map）。</p>\n<h3 id=\"实现call\"><a href=\"#实现call\" class=\"headerlink\" title=\"实现call\"></a>实现call</h3><p>这里会使用隐式绑定来实现。</p>\n<p>先丢出我们要测试的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.call(b) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>OK, 我们现在就来实现以下自定义的call。应用隐式绑定的话就可以直接绑定上了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  context.fn = f;</span><br><span class=\"line\">  context.fn();</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.myCall(b) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>很潇洒的完成了。但是好像不能接受参数诶，接受参数又要考虑边界情况，比如<code>undefined</code>，<code>null</code>之类的。而且！！而且！！而且<code>call</code>不传的话是默认应用<code>window</code>的；</p>\n<p>所以他有我们也要有！冲！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myCall = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo</span></span><br><span class=\"line\">  <span class=\"comment\">// 不传第一个参数，默认是window,</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> context = context || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数</span></span><br><span class=\"line\">  context.fn = <span class=\"keyword\">this</span>;<span class=\"comment\">//这里的context.fn就相当于上文的bar函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [...arguments].slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 执行函数（相当于上文的bar(...args)）</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = context.fn(...args);</span><br><span class=\"line\">  <span class=\"comment\">// 删除函数</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现apply\"><a href=\"#实现apply\" class=\"headerlink\" title=\"实现apply\"></a>实现apply</h3><p>因为他们两兄弟就参数不一样所以就不解释了，直接看代码吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myApply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> context = context || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">      context.fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">      <span class=\"comment\">// 判断第二个参数是否存在，也就是context后面有没有一个数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果存在，则需要展开第二个参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        result = context.fn(...arguments[<span class=\"number\">1</span>]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = context.fn();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> context.fn;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实现bind\"><a href=\"#实现bind\" class=\"headerlink\" title=\"实现bind\"></a>实现bind</h2><h4 id=\"了解bind\"><a href=\"#了解bind\" class=\"headerlink\" title=\"了解bind\"></a>了解bind</h4><blockquote>\n<p><code>bind() 方法创建一个新的函数，在</code>bind()<code>被调用时，这个新函数的</code>this<code>被指定为</code>bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>\n<p>语法：<code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<p>MDN</p>\n</blockquote>\n<h4 id=\"bind和apply，call两兄弟的区别\"><a href=\"#bind和apply，call两兄弟的区别\" class=\"headerlink\" title=\"bind和apply，call两兄弟的区别\"></a>bind和apply，call两兄弟的区别</h4><p><code>bind</code> 方法与 <code>call / apply</code> 最大的不同就是前者返回一个绑定上下文的<strong>函数</strong>，而后两者是<strong>直接执行</strong>了函数。</p>\n<p>上代码！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tvalue: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">\t\tname: name,</span><br><span class=\"line\">\t\tage: age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.call(foo, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 直接执行了函数</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo1 = bar.bind(foo, <span class=\"string\">\"Jack\"</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">bindFoo1();</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo2 = bar.bind(foo, <span class=\"string\">\"Jack\"</span>); <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">bindFoo2(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上述代码可以看出<code>bind</code> 有如下特性：</p>\n<ul>\n<li>1、可以指定<code>this</code></li>\n<li>2、返回一个函数</li>\n<li>3、可以传入参数</li>\n<li>4、柯里化</li>\n</ul>\n<h4 id=\"实现bind-1\"><a href=\"#实现bind-1\" class=\"headerlink\" title=\"实现bind\"></a>实现bind</h4><p>直接开干！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(context)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.myBind(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bindFoo()); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>Ok,接下来我们处理一下参数和柯里化吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(context, args.concat(nowArgs))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试用例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tvalue: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">\t\tname: name,</span><br><span class=\"line\">\t\tage: age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.myBind(foo, <span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">bindFoo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, name: \"Jack\", age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>到现在已经完成大部分了，但是还有一个难点，<code>bind</code> 有以下一个特性</p>\n<blockquote>\n<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>\n</blockquote>\n<p>举例说明：正规的bind</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.habit = <span class=\"string\">'shopping'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.prototype.friend = <span class=\"string\">'kevin'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.bind(foo, <span class=\"string\">'Jack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> bindFoo(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.habit;</span><br><span class=\"line\"><span class=\"comment\">// shopping</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.friend;</span><br><span class=\"line\"><span class=\"comment\">// kevin</span></span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，运行结果<code>this.value</code> 输出为 <code>undefined</code>，这不是全局<code>value</code> 也不是<code>foo</code>对象中的<code>value</code>，这说明 <code>bind</code> 的 <code>this</code> 对象失效了，<code>new</code> 的实现中生成一个新的对象，这个时候的 <code>this</code>指向的是 <code>obj</code>。</p>\n<p>所以我们返回的时候需要判断一下他是不是作为了构造函数返回，如果是就返回当前的this，如果不是就绑定当前输入的<code>context</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fnc ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是其实这样会有一个问题，我如果实例修改了原型，那么接下来的继承就会出现问题。</p>\n<p>这个时候我们需要拷贝一下我们原型上面的参数。会用到</p>\n<blockquote>\n<p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10 中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来非常简单</p>\n<p>先在<code>object</code>函数内部创建一个临时的构造函数<code>F</code>, 然后将传入的这个对象<code>o</code>作为这个临时构造函数的原型, 最后返回这个临时构造函数的实例. </p>\n<p>简单来说就是<code>object</code>对传入的对象进行了浅复制.</p>\n</blockquote>\n<p>这句话在我的《原型原型链和继承》里面有具体的介绍。想看的话可以点击头像查找文章。</p>\n<p>这边可以直接使用ES5的 <code>Object.create()</code>方法生成一个新对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fBound.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.prototype);</span><br></pre></td></tr></table></figure>\n\n<p>不过 <code>bind</code> 和 <code>Object.create()</code>都是ES5方法，部分IE浏览器（IE &lt; 9）并不支持，Polyfill中不能用 <code>Object.create()</code>实现 <code>bind</code>，不过原理是一样的。</p>\n<p>ok。那我们就修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fNOP ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fNOP.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">new</span> FNOP()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里其实已经差不多了，突然想起来还有一个问题是调用 <code>bind</code> 的不是函数，这时候需要抛出异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Function.prototype.bind - what is trying to be bound is not callable\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以</p>\n<h4 id=\"顶配\"><a href=\"#顶配\" class=\"headerlink\" title=\"顶配\"></a>顶配</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.myBind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Function.prototype.bind - what is trying to \tbe bound is not callable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 因为参数是类数组没有slice方法，通过call绑定this之后使用slice拷贝数组，除了第一个需要绑定的this 之外，下面会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 这里利用的闭包保存了此时此刻的this，否则后面调用的话会隐式丢失</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fnc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 和上面一样拷贝参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">//当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。</span></span><br><span class=\"line\"><span class=\"comment\">//当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fNOP ? <span class=\"keyword\">this</span> : context, </span><br><span class=\"line\">      args.concat(nowArgs)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。</span></span><br><span class=\"line\">  fNOP.prototype = <span class=\"keyword\">this</span>.prototype</span><br><span class=\"line\">  fnc.prototype = <span class=\"keyword\">new</span> FNOP()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"实现new\"><a href=\"#实现new\" class=\"headerlink\" title=\"实现new\"></a>实现new</h2><h4 id=\"了解new\"><a href=\"#了解new\" class=\"headerlink\" title=\"了解new\"></a>了解new</h4><blockquote>\n<p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）</p>\n</blockquote>\n<p>我们先试试现在有的new，他有什么功能，然后我们总结之后，在开始实现。</p>\n<p>看个🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NEW</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">NEW.prototype.sayA = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a+<span class=\"string\">'b'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"keyword\">new</span> NEW(<span class=\"number\">1</span>);</span><br><span class=\"line\">A.sayA()</span><br><span class=\"line\">A.a</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到A是NEW的一个实例。继承了构造函数（NEW）的属性和原型上的属性（sayA）。</p>\n<blockquote>\n<p><strong><code>new</code></strong> 关键字会进行如下的操作：</p>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回<code>this</code>。</li>\n</ol>\n<p>MDN</p>\n</blockquote>\n<h4 id=\"实现一个new\"><a href=\"#实现一个new\" class=\"headerlink\" title=\"实现一个new\"></a>实现一个new</h4><p>说干就干：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 获取构造函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为arguments是一个类数组对象，没有unshift方法，所以用了call，我们没有new这关键字，只能模拟，所以的一个参数我们认为他需要传递一个构造函数。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Con = [].unshift.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 2.</span></span><br><span class=\"line\">  obj.__proto__ = Con.prototype </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 3、 绑定this。因为之前arguments已经被我们删除了第一个元素，所以剩下的就是我们所需要的参数了。</span></span><br><span class=\"line\">  Con.apply(obj, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 4. 简陋版</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数返回值有如下三种情况：</p>\n<ul>\n<li>1、返回一个对象</li>\n<li>2、没有 <code>return</code>，即返回 <code>undefined</code></li>\n<li>3、返回<code>undefined</code> 以外的基本类型</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class=\"line\">    Con = [].shift.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(Con.prototype);</span><br><span class=\"line\">\t<span class=\"comment\">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = Con.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 4、优先返回构造函数返回的对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> ? ret : obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【重识前端】什么是BFC、IFC、GFC 和 FFC","date":"2020-08-12T10:03:34.000Z","cover":"/image/cover/web.jpeg","_content":"\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n其实在面试的过程中很有可能会被问到“介绍一下BFC”\n\n那今天就一口气把BFC、IFC、GFC 和 FFC这四兄弟给吃透\n\n吃透透\n\n重点介绍一下BFC，他的三兄弟这里只做介绍，感兴趣的可以上网多查查资料然后回来教教我😂\n\n## 开始\n\n### what\n\n其实在说BFC和他的三兄弟之前，我们先了解一下，什么是FC？\n\n打断一下。说FC之前我希望先说一下BOX\n\n#### BOX\n\n一个页面是由很多元素组成的，而这些元素都是一个接一个盒子。那有人就说了，那`border-radius: 50%`捏？\n\nOk, 直接看下图吧：\n\n![demo1-1](/image/BFC/1.png)\n\n再来看一个更直观的图。打开Google的首页，然后在控制台输入\n\n```js\n[].forEach.call(document.querySelectorAll('*'), function(a){a.style.outline = \"1px solid red\";})\n```\n\n![demo2](/image/BFC/2.png)\n\n所以，其实页面都是由一个又一个的盒子组合而成的。\n\n明确了这个，我们再来说说FC是个什么东西。\n\n#### FC（Formatting Context）\n\n它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它**决定了其子元素将如何定位**，以及**和其他元素的关系和相互作用**。\n\n常见的`Formatting Context` 有：`Block Formatting Context`（BFC | 块级格式化上下文） 和 `Inline Formatting Context`（IFC |行内格式化上下文）。\n\n#### BFC\n\n> MDN: **块格式化上下文（Block Formatting Context，BFC）** 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n\n\n### why\n\n那么FC四兄弟他们的作用是什么？可不可以不要他们？\n\n其实，我们换个角度想想就会舒服很多。比如我们开车上路，如果没有🚦，那么路况可能会变得很糟，不同的路口的🚦的红灯绿灯时间都是经过精心设计的，比如车多的方向，红灯时间就少一些，绿灯多一些。大家都是为了让路况变得更好。\n\n反观FC四兄弟，他们也是为了让不同情况下的CSS可以更有秩序的显示。\n\n\n\n### how\n\n那么我要怎么样才可以制造一个BFC？\n\n- 根元素（`<html>）`\n- 浮动元素（元素的 [`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float) 不是 `none`）\n- 绝对定位元素（元素的 [`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 为 `absolute` 或 `fixed`）\n- 行内块元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `inline-block`）\n- 表格单元格（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-cell`，HTML表格单元格默认为该值）\n- 表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）\n- 匿名表格单元格元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table、``table-row`、 `table-row-group、``table-header-group、``table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）\n- [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible` 的块元素\n- [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flow-root` 的元素\n- [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 值为 `layout`、`content `或 paint 的元素\n- 弹性元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `flex` 或 `inline-flex `元素的直接子元素）\n- 网格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `grid` 或 `inline-grid` 元素的直接子元素）\n- 多列容器（元素的 [`column-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count) 或 [`column-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width) 不为 `auto，包括 ``column-count` 为 `1`）\n- `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（[标准变更](https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51)，[Chrome bug](https://bugs.chromium.org/p/chromium/issues/detail?id=709362)）。\n\n\n\n### BFC可以做些什么？\n\n#### 让浮动内容和周围的内容等高\n\n\n\n🌰：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}      \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n可以看到，那个float把底下的div盖住了。\n\n我们随便弄一个BFC的特性中的一条：[`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible` 的块元素。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n    overflow: auto;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}          \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n那就设置成`auto`吧~\n\n有没有很神奇的发现！！！\n\n再告诉大家一个黑科技：表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）。这个是没有副作用的哦。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n    display: table-caption;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}          \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n给 `<div>` `display: flow-root` 属性后，`<div>` 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。\n\n关于值 `flow-root `的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的`<html>`元素） 的东西时，就能发现这个名字的意义了——即创建一个上下文，里面将进行 flow layout。\n\n#### 外边距塌陷\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.blue{\n  height: 50px;\n  margin: 50px 0;\n} \n.red-inner {\n  height: 50px;\n  margin: 50px 0;\n}\n\n.blue {\n  background: blue;\n}\n\n.red-outer {\n  overflow: hidden;\n  background: red;\n}        \n</style>\n</head>\n<body>\n<div class=\"blue\"></div>\n<div class=\"red-outer\">\n  <div class=\"red-inner\">red inner</div>\n</div>\n</body>\n</html>\n\n```\n\n意外的发现，我们两个margin都是50px，理论上应该是100px啊，可是看起来怎么只有50px的样子。。。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}       \n</style>\n</head>\n<body>\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n\n</body>\n</html>\n\n\n```\n\n这时候，两个盒子边距就变成了 200px\n\n### BFC的约束条件\n\n- 内部的Box会在垂直方向上一个接一个的放置\n- 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）\n- 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\n- BFC的区域不会与float的元素区域重叠\n- 计算BFC的高度时，浮动子元素也参与计算\n- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n\n\n\n## 补充\n\n### **IFC**\n\n> IFC(Inline Formatting Contexts)直译为\"内联格式化上下文\"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)\n> IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。\n> 那么IFC一般有什么用呢？\n> 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。\n> 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n###  GFC\n\n> **GFC**\n> GFC(GridLayout Formatting Contexts)直译为\"网格布局格式化上下文\"，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 \n> 那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。\n\n### FFC\n\n> **FFC**\n> FFC(Flex Formatting Contexts)直译为\"自适应格式化上下文\"，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。\n> Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。\n> 伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。\n\n\n\n","source":"_posts/【重识前端】什么是BFC、IFC、GFC 和 FFC.md","raw":"---\ntitle: 【重识前端】什么是BFC、IFC、GFC 和 FFC\ndate: 2020-08-12 18:03:34\ntags: [CSS]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n其实在面试的过程中很有可能会被问到“介绍一下BFC”\n\n那今天就一口气把BFC、IFC、GFC 和 FFC这四兄弟给吃透\n\n吃透透\n\n重点介绍一下BFC，他的三兄弟这里只做介绍，感兴趣的可以上网多查查资料然后回来教教我😂\n\n## 开始\n\n### what\n\n其实在说BFC和他的三兄弟之前，我们先了解一下，什么是FC？\n\n打断一下。说FC之前我希望先说一下BOX\n\n#### BOX\n\n一个页面是由很多元素组成的，而这些元素都是一个接一个盒子。那有人就说了，那`border-radius: 50%`捏？\n\nOk, 直接看下图吧：\n\n![demo1-1](/image/BFC/1.png)\n\n再来看一个更直观的图。打开Google的首页，然后在控制台输入\n\n```js\n[].forEach.call(document.querySelectorAll('*'), function(a){a.style.outline = \"1px solid red\";})\n```\n\n![demo2](/image/BFC/2.png)\n\n所以，其实页面都是由一个又一个的盒子组合而成的。\n\n明确了这个，我们再来说说FC是个什么东西。\n\n#### FC（Formatting Context）\n\n它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它**决定了其子元素将如何定位**，以及**和其他元素的关系和相互作用**。\n\n常见的`Formatting Context` 有：`Block Formatting Context`（BFC | 块级格式化上下文） 和 `Inline Formatting Context`（IFC |行内格式化上下文）。\n\n#### BFC\n\n> MDN: **块格式化上下文（Block Formatting Context，BFC）** 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n\n\n### why\n\n那么FC四兄弟他们的作用是什么？可不可以不要他们？\n\n其实，我们换个角度想想就会舒服很多。比如我们开车上路，如果没有🚦，那么路况可能会变得很糟，不同的路口的🚦的红灯绿灯时间都是经过精心设计的，比如车多的方向，红灯时间就少一些，绿灯多一些。大家都是为了让路况变得更好。\n\n反观FC四兄弟，他们也是为了让不同情况下的CSS可以更有秩序的显示。\n\n\n\n### how\n\n那么我要怎么样才可以制造一个BFC？\n\n- 根元素（`<html>）`\n- 浮动元素（元素的 [`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float) 不是 `none`）\n- 绝对定位元素（元素的 [`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 为 `absolute` 或 `fixed`）\n- 行内块元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `inline-block`）\n- 表格单元格（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-cell`，HTML表格单元格默认为该值）\n- 表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）\n- 匿名表格单元格元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table、``table-row`、 `table-row-group、``table-header-group、``table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）\n- [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible` 的块元素\n- [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flow-root` 的元素\n- [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 值为 `layout`、`content `或 paint 的元素\n- 弹性元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `flex` 或 `inline-flex `元素的直接子元素）\n- 网格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `grid` 或 `inline-grid` 元素的直接子元素）\n- 多列容器（元素的 [`column-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count) 或 [`column-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width) 不为 `auto，包括 ``column-count` 为 `1`）\n- `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（[标准变更](https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51)，[Chrome bug](https://bugs.chromium.org/p/chromium/issues/detail?id=709362)）。\n\n\n\n### BFC可以做些什么？\n\n#### 让浮动内容和周围的内容等高\n\n\n\n🌰：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}      \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n可以看到，那个float把底下的div盖住了。\n\n我们随便弄一个BFC的特性中的一条：[`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible` 的块元素。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n    overflow: auto;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}          \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n那就设置成`auto`吧~\n\n有没有很神奇的发现！！！\n\n再告诉大家一个黑科技：表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）。这个是没有副作用的哦。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.box {\n    background-color: rgb(224, 206, 247);\n    border: 5px solid rebeccapurple;\n    display: table-caption;\n}\n\n.float {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border:1px solid black;\n    padding: 10px;\n}          \n</style>\n</head>\n<body>\n\n<div class=\"box\">\n    <div class=\"float\">I am a floated box!</div>\n    <p>I am content inside the container.</p>\n</div>\n\n<p>This is some text outside the div element.</p>\n\n</body>\n</html>\n\n```\n\n给 `<div>` `display: flow-root` 属性后，`<div>` 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。\n\n关于值 `flow-root `的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的`<html>`元素） 的东西时，就能发现这个名字的意义了——即创建一个上下文，里面将进行 flow layout。\n\n#### 外边距塌陷\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.blue{\n  height: 50px;\n  margin: 50px 0;\n} \n.red-inner {\n  height: 50px;\n  margin: 50px 0;\n}\n\n.blue {\n  background: blue;\n}\n\n.red-outer {\n  overflow: hidden;\n  background: red;\n}        \n</style>\n</head>\n<body>\n<div class=\"blue\"></div>\n<div class=\"red-outer\">\n  <div class=\"red-inner\">red inner</div>\n</div>\n</body>\n</html>\n\n```\n\n意外的发现，我们两个margin都是50px，理论上应该是100px啊，可是看起来怎么只有50px的样子。。。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}       \n</style>\n</head>\n<body>\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n\n</body>\n</html>\n\n\n```\n\n这时候，两个盒子边距就变成了 200px\n\n### BFC的约束条件\n\n- 内部的Box会在垂直方向上一个接一个的放置\n- 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）\n- 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\n- BFC的区域不会与float的元素区域重叠\n- 计算BFC的高度时，浮动子元素也参与计算\n- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n\n\n\n## 补充\n\n### **IFC**\n\n> IFC(Inline Formatting Contexts)直译为\"内联格式化上下文\"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)\n> IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。\n> 那么IFC一般有什么用呢？\n> 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。\n> 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n###  GFC\n\n> **GFC**\n> GFC(GridLayout Formatting Contexts)直译为\"网格布局格式化上下文\"，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 \n> 那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。\n\n### FFC\n\n> **FFC**\n> FFC(Flex Formatting Contexts)直译为\"自适应格式化上下文\"，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。\n> Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。\n> 伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。\n\n\n\n","slug":"【重识前端】什么是BFC、IFC、GFC 和 FFC","published":1,"updated":"2021-06-24T14:00:06.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8n001ulwrd5dv7hesr","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实在面试的过程中很有可能会被问到“介绍一下BFC”</p>\n<p>那今天就一口气把BFC、IFC、GFC 和 FFC这四兄弟给吃透</p>\n<p>吃透透</p>\n<p>重点介绍一下BFC，他的三兄弟这里只做介绍，感兴趣的可以上网多查查资料然后回来教教我😂</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h3><p>其实在说BFC和他的三兄弟之前，我们先了解一下，什么是FC？</p>\n<p>打断一下。说FC之前我希望先说一下BOX</p>\n<h4 id=\"BOX\"><a href=\"#BOX\" class=\"headerlink\" title=\"BOX\"></a>BOX</h4><p>一个页面是由很多元素组成的，而这些元素都是一个接一个盒子。那有人就说了，那<code>border-radius: 50%</code>捏？</p>\n<p>Ok, 直接看下图吧：</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/BFC/1.png\"  alt=\"demo1-1\"></p>\n<p>再来看一个更直观的图。打开Google的首页，然后在控制台输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;a.style.outline = <span class=\"string\">\"1px solid red\"</span>;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/BFC/2.png\"  alt=\"demo2\"></p>\n<p>所以，其实页面都是由一个又一个的盒子组合而成的。</p>\n<p>明确了这个，我们再来说说FC是个什么东西。</p>\n<h4 id=\"FC（Formatting-Context）\"><a href=\"#FC（Formatting-Context）\" class=\"headerlink\" title=\"FC（Formatting Context）\"></a>FC（Formatting Context）</h4><p>它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它<strong>决定了其子元素将如何定位</strong>，以及<strong>和其他元素的关系和相互作用</strong>。</p>\n<p>常见的<code>Formatting Context</code> 有：<code>Block Formatting Context</code>（BFC | 块级格式化上下文） 和 <code>Inline Formatting Context</code>（IFC |行内格式化上下文）。</p>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><blockquote>\n<p>MDN: <strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>\n</blockquote>\n<h3 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h3><p>那么FC四兄弟他们的作用是什么？可不可以不要他们？</p>\n<p>其实，我们换个角度想想就会舒服很多。比如我们开车上路，如果没有🚦，那么路况可能会变得很糟，不同的路口的🚦的红灯绿灯时间都是经过精心设计的，比如车多的方向，红灯时间就少一些，绿灯多一些。大家都是为了让路况变得更好。</p>\n<p>反观FC四兄弟，他们也是为了让不同情况下的CSS可以更有秩序的显示。</p>\n<h3 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h3><p>那么我要怎么样才可以制造一个BFC？</p>\n<ul>\n<li>根元素（<code>&lt;html&gt;）</code></li>\n<li>浮动元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/float\" target=\"_blank\" rel=\"noopener\"><code>float</code></a> 不是 <code>none</code>）</li>\n<li>绝对定位元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>\n<li>行内块元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>inline-block</code>）</li>\n<li>表格单元格（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>\n<li>表格标题（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>\n<li>匿名表格单元格元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\"><code>overflow</code></a> 值不为 <code>visible</code> 的块元素</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain\" target=\"_blank\" rel=\"noopener\"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code>或 paint 的元素</li>\n<li>弹性元素（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>\n<li>网格元素（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>\n<li>多列容器（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count\" target=\"_blank\" rel=\"noopener\"><code>column-count</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width\" target=\"_blank\" rel=\"noopener\"><code>column-width</code></a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li>\n<li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href=\"https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51\" target=\"_blank\" rel=\"noopener\">标准变更</a>，<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=709362\" target=\"_blank\" rel=\"noopener\">Chrome bug</a>）。</li>\n</ul>\n<h3 id=\"BFC可以做些什么？\"><a href=\"#BFC可以做些什么？\" class=\"headerlink\" title=\"BFC可以做些什么？\"></a>BFC可以做些什么？</h3><h4 id=\"让浮动内容和周围的内容等高\"><a href=\"#让浮动内容和周围的内容等高\" class=\"headerlink\" title=\"让浮动内容和周围的内容等高\"></a>让浮动内容和周围的内容等高</h4><p>🌰：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;      </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，那个float把底下的div盖住了。</p>\n<p>我们随便弄一个BFC的特性中的一条：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\"><code>overflow</code></a> 值不为 <code>visible</code> 的块元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">    overflow: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那就设置成<code>auto</code>吧~</p>\n<p>有没有很神奇的发现！！！</p>\n<p>再告诉大家一个黑科技：表格标题（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）。这个是没有副作用的哦。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">    display: table-caption;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>给 <code>&lt;div&gt;</code> <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</p>\n<p>关于值 <code>flow-root</code>的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的<code>&lt;html&gt;</code>元素） 的东西时，就能发现这个名字的意义了——即创建一个上下文，里面将进行 flow layout。</p>\n<h4 id=\"外边距塌陷\"><a href=\"#外边距塌陷\" class=\"headerlink\" title=\"外边距塌陷\"></a>外边距塌陷</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.blue</span>&#123;</span></span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">  margin: 50px 0;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.red-inner</span> &#123;</span></span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">  margin: 50px 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.blue</span> &#123;</span></span><br><span class=\"line\">  background: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.red-outer</span> &#123;</span></span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-inner\"</span>&gt;</span>red inner<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>意外的发现，我们两个margin都是50px，理论上应该是100px啊，可是看起来怎么只有50px的样子。。。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候，两个盒子边距就变成了 200px</p>\n<h3 id=\"BFC的约束条件\"><a href=\"#BFC的约束条件\" class=\"headerlink\" title=\"BFC的约束条件\"></a>BFC的约束条件</h3><ul>\n<li>内部的Box会在垂直方向上一个接一个的放置</li>\n<li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）</li>\n<li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a><strong>IFC</strong></h3><blockquote>\n<p>IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)<br>IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。<br>那么IFC一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。<br>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>\n</blockquote>\n<h3 id=\"GFC\"><a href=\"#GFC\" class=\"headerlink\" title=\"GFC\"></a>GFC</h3><blockquote>\n<p><strong>GFC</strong><br>GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。<br>那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>\n</blockquote>\n<h3 id=\"FFC\"><a href=\"#FFC\" class=\"headerlink\" title=\"FFC\"></a>FFC</h3><blockquote>\n<p><strong>FFC</strong><br>FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。<br>Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。<br>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实在面试的过程中很有可能会被问到“介绍一下BFC”</p>\n<p>那今天就一口气把BFC、IFC、GFC 和 FFC这四兄弟给吃透</p>\n<p>吃透透</p>\n<p>重点介绍一下BFC，他的三兄弟这里只做介绍，感兴趣的可以上网多查查资料然后回来教教我😂</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h3><p>其实在说BFC和他的三兄弟之前，我们先了解一下，什么是FC？</p>\n<p>打断一下。说FC之前我希望先说一下BOX</p>\n<h4 id=\"BOX\"><a href=\"#BOX\" class=\"headerlink\" title=\"BOX\"></a>BOX</h4><p>一个页面是由很多元素组成的，而这些元素都是一个接一个盒子。那有人就说了，那<code>border-radius: 50%</code>捏？</p>\n<p>Ok, 直接看下图吧：</p>\n<p><img src=\"/image/BFC/1.png\" alt=\"demo1-1\"></p>\n<p>再来看一个更直观的图。打开Google的首页，然后在控制台输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;a.style.outline = <span class=\"string\">\"1px solid red\"</span>;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/image/BFC/2.png\" alt=\"demo2\"></p>\n<p>所以，其实页面都是由一个又一个的盒子组合而成的。</p>\n<p>明确了这个，我们再来说说FC是个什么东西。</p>\n<h4 id=\"FC（Formatting-Context）\"><a href=\"#FC（Formatting-Context）\" class=\"headerlink\" title=\"FC（Formatting Context）\"></a>FC（Formatting Context）</h4><p>它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它<strong>决定了其子元素将如何定位</strong>，以及<strong>和其他元素的关系和相互作用</strong>。</p>\n<p>常见的<code>Formatting Context</code> 有：<code>Block Formatting Context</code>（BFC | 块级格式化上下文） 和 <code>Inline Formatting Context</code>（IFC |行内格式化上下文）。</p>\n<h4 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h4><blockquote>\n<p>MDN: <strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>\n</blockquote>\n<h3 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h3><p>那么FC四兄弟他们的作用是什么？可不可以不要他们？</p>\n<p>其实，我们换个角度想想就会舒服很多。比如我们开车上路，如果没有🚦，那么路况可能会变得很糟，不同的路口的🚦的红灯绿灯时间都是经过精心设计的，比如车多的方向，红灯时间就少一些，绿灯多一些。大家都是为了让路况变得更好。</p>\n<p>反观FC四兄弟，他们也是为了让不同情况下的CSS可以更有秩序的显示。</p>\n<h3 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h3><p>那么我要怎么样才可以制造一个BFC？</p>\n<ul>\n<li>根元素（<code>&lt;html&gt;）</code></li>\n<li>浮动元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/float\" target=\"_blank\" rel=\"noopener\"><code>float</code></a> 不是 <code>none</code>）</li>\n<li>绝对定位元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>\n<li>行内块元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>inline-block</code>）</li>\n<li>表格单元格（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>\n<li>表格标题（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>\n<li>匿名表格单元格元素（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\"><code>overflow</code></a> 值不为 <code>visible</code> 的块元素</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain\" target=\"_blank\" rel=\"noopener\"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code>或 paint 的元素</li>\n<li>弹性元素（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>\n<li>网格元素（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>\n<li>多列容器（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count\" target=\"_blank\" rel=\"noopener\"><code>column-count</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width\" target=\"_blank\" rel=\"noopener\"><code>column-width</code></a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li>\n<li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href=\"https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51\" target=\"_blank\" rel=\"noopener\">标准变更</a>，<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=709362\" target=\"_blank\" rel=\"noopener\">Chrome bug</a>）。</li>\n</ul>\n<h3 id=\"BFC可以做些什么？\"><a href=\"#BFC可以做些什么？\" class=\"headerlink\" title=\"BFC可以做些什么？\"></a>BFC可以做些什么？</h3><h4 id=\"让浮动内容和周围的内容等高\"><a href=\"#让浮动内容和周围的内容等高\" class=\"headerlink\" title=\"让浮动内容和周围的内容等高\"></a>让浮动内容和周围的内容等高</h4><p>🌰：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;      </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，那个float把底下的div盖住了。</p>\n<p>我们随便弄一个BFC的特性中的一条：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\"><code>overflow</code></a> 值不为 <code>visible</code> 的块元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">    overflow: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那就设置成<code>auto</code>吧~</p>\n<p>有没有很神奇的发现！！！</p>\n<p>再告诉大家一个黑科技：表格标题（元素的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）。这个是没有副作用的哦。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.box</span> &#123;</span></span><br><span class=\"line\">    background-color: rgb(224, 206, 247);</span><br><span class=\"line\">    border: 5px solid rebeccapurple;</span><br><span class=\"line\">    display: table-caption;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.float</span> &#123;</span></span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 150px;</span><br><span class=\"line\">    background-color: white;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">black</span>;</span></span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>I am a floated box!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I am content inside the container.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is some text outside the div element.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>给 <code>&lt;div&gt;</code> <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</p>\n<p>关于值 <code>flow-root</code>的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的<code>&lt;html&gt;</code>元素） 的东西时，就能发现这个名字的意义了——即创建一个上下文，里面将进行 flow layout。</p>\n<h4 id=\"外边距塌陷\"><a href=\"#外边距塌陷\" class=\"headerlink\" title=\"外边距塌陷\"></a>外边距塌陷</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.blue</span>&#123;</span></span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">  margin: 50px 0;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.red-inner</span> &#123;</span></span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">  margin: 50px 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.blue</span> &#123;</span></span><br><span class=\"line\">  background: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.red-outer</span> &#123;</span></span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-inner\"</span>&gt;</span>red inner<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>意外的发现，我们两个margin都是50px，理论上应该是100px啊，可是看起来怎么只有50px的样子。。。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候，两个盒子边距就变成了 200px</p>\n<h3 id=\"BFC的约束条件\"><a href=\"#BFC的约束条件\" class=\"headerlink\" title=\"BFC的约束条件\"></a>BFC的约束条件</h3><ul>\n<li>内部的Box会在垂直方向上一个接一个的放置</li>\n<li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）</li>\n<li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a><strong>IFC</strong></h3><blockquote>\n<p>IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)<br>IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。<br>那么IFC一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。<br>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>\n</blockquote>\n<h3 id=\"GFC\"><a href=\"#GFC\" class=\"headerlink\" title=\"GFC\"></a>GFC</h3><blockquote>\n<p><strong>GFC</strong><br>GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。<br>那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>\n</blockquote>\n<h3 id=\"FFC\"><a href=\"#FFC\" class=\"headerlink\" title=\"FFC\"></a>FFC</h3><blockquote>\n<p><strong>FFC</strong><br>FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。<br>Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。<br>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>\n</blockquote>\n"},{"title":"【重识前端】闭包与模块","date":"2020-07-15T10:18:21.000Z","cover":"/image/cover/web.jpeg","_content":"\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门 道。\n\n> JavaScript中闭包无处不在，你只需要能够识别并拥抱它。\n>\n> 最后你恍然大悟:原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。理 解闭包就好像 Neo3 第一次见到矩阵 4 一样。\n\n## 定义\n\n当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\tbar(); \n}\nfoo();\n```\n\n这样可能还不够直观，我们再修改一下。\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\treturn bar; \n}\nvar baz = foo();\nbaz(); // 2 —— 朋友，这就是闭包的效果。\n```\n\n其实，在正常情况下，我们调用完`foo`之后，JavaScript检测到后续不会再用到他了， 所以他的内部作用域就会被回收♻️。（涉及到垃圾回收机制，后续的文章我们会说到。）\n\n闭包的神奇之处就在于他可以阻止♻️的发生。因为事实上内部作用域已然存在，那么又有谁在使用呢？哦~是我们的`bar`在使用。\n\n拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。\n\nbar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n所以我说说我自己的理解：\n\n闭包是一个运行时的概念，如果只是声明或者定义。即使他符合闭包的要求那他也不能成为一个真正的闭包。为什么？因为内存地址并没有开始分配，闭包只是分配之后那一块地址没有被回收而已。\n\n再回到我们最开始的函数：\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\tbar(); \n}\nfoo();\n```\n\n一个函数foo内有一个函数bar。并且函数bar用到了函数foo的变量。那么我们就可以称这个引用过程为“闭包”。但是我们这个函数foo必须被调用，所以我们的例子地下调用了一下函数foo。\n\n再回到我们那个较为清晰的例子\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\treturn bar; \n}\nvar baz = foo();\nbaz(); // 2 —— 朋友，这就是闭包的效果。\n```\n\n这个应该是大众认知上非常经典的一个闭包了吧？但是假如说这个foo函数没有被调用，那么我认为他就不是一个闭包。\n\n## 实践\n\n### 常见的闭包\n\n前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。你已经写过的代码中一定到处都是闭包的身影。 现在让我们来搞懂这个事实。\n\n```js\nfunction wait(message) {\n\tsetTimeout( \n\t\tfunction timer() { \n\t\t\tconsole.log( message );\n\t}, 1000 ); \n}\nwait( \"Hello, closure!\" );\n```\n\n这个例子非常常见，代码很简单，就是1秒钟之后输出我们传入的参数。\n\n但是我们仔细看就能看见闭包的影子，一秒钟之后，`message`还是可以被`timer`访问到。并没有被回收♻️掉。\n\n> 这就是闭包\n\n本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!\n\n### 闭包与循环\n\n说到这里肯定有人马上就想到了最经典的面试题：请写出以下的输出内容\n\n```js\nfor (var i=1; i<=5; i++) { \n\tsetTimeout( function timer() {\n\t\tconsole.log( i ); \n  }, i*1000 );\n}\n```\n\n正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。\n\n但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。\n\n这是为什么?\n\n因为等到执行`console.log`的时候，那个时候的i已经在for的调教下变成了6了，所以他们去取只能取到6；\n\n（事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。这个涉及到时间循环，后面的文章会具体的展开来讲）\n\n通过我们刚刚的学习知道，如果我们创造了一个闭包，这样的话这个i不就不会被回收了吗？\n\nok，我们试试\n\n```js\nfor (var i=1; i<=5; i++) { \n  (function() {\n\t\tsetTimeout( function timer() { \n      console.log( i );\n    }, i*1000 );\n  })();\n}\n\n```\n\n这样能行吗?试试吧，在Chrome或者node里面试试吧，我等着你。\n\n我不卖关子了。这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。\n\n如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。\n\n它需要有自己的变量，用来在每个迭代中储存 i 的值\n\n```js\n\nfor (var i=1; i<=5; i++) { \n  (function() {\n  \tvar j = i;\n  \tsetTimeout( function timer() {\n  \t\tconsole.log( j ); \n    },j *1000 );\n   })(); \n}\n```\n\n行了!它能正常工作了!。\n\n可以对这段代码进行一些改进:\n\n```js\nfor (var i=1; i<=5; i++) { \n  (function(j) {\n  \tsetTimeout( function timer() {\n  \t\tconsole.log( j ); \n    },j *1000 );\n   })(i); \n}\n```\n\n当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量\n\n名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。\n 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的\n\n作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 问题解决啦!\n\n当然了，肯定有用块级作用域`let`的，那样其实是更完美的。\n\n```js\nfor (let i=1; i<=5; i++) { \n  \tsetTimeout( function timer() {\n  \t\tconsole.log( i ); \n    },1000 );\n}\n```\n\n### 闭包与模块\n\n很早之前，我们引用的js文件内部的变量其实都是挂载在window上面的，久而久之变量名很可能会重复=>覆盖=>BUG=>难以追寻的BUG\n\n所以很需要模块的这个概念来解决。\n\n模块的发展我分为三块：上古时代，近现代，现代\n\n#### 上古时代的模块\n\n闭包最强大的功能=>《模块》\n\n看个例子\n\n```js\nfunction a(){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n  }\n}\n\nvar f = a(); \nf.getQ(); // 1\nf.getW(); // [1, 2]\n```\n\n我们仔细的剖析一下这段代码， `a`是一个函数，我们用a创建了一个模块实例。注意一下：如果不执行 `getQ` 或者 `getW` 这个闭包就无法创建，因为在函数a内部的getQ和getW都只是对变量q和变了w的引用声明；没有实实在在的调用就没有创建作用域，也没有开辟内存空间。\n\n引用一句《你不知道的JavaScript-上》中的一句话：\n\n> 如果不执行 外部函数，内部作用域和闭包都无法被创建。\n\n其次，a() 返回一个用对象字面量语法 { key: value, ... } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。\n\n这个对象类型的返回值最终被赋值给外部的变量 f，然后就可以通过它来访问 API 中的 属性方法，比如 f.getW()。\n\n> 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属 性)。\n\n其实我们这样每次调用一次`a函数`相当于创建了一个新的模块实例。\n\n假如，此时我们希望只要一个实例，那咋办呢？\n\n天降猛男----IIFE（立即执行函数）\n\n=》\n\n```js\nvar f = (function a(){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n  }\n})(); \n\nf.getQ(); // 1\nf.getW(); // [1, 2]\n```\n\n这个模块只属于f一个人，要修改只能找f帮忙了。\n\n既然模块也是一个函数，那是不是也可以传参呀？\n\n是的，稍作修改就好了。\n\n```js\nfunction a(id){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  \n  function getId(){\n    console.log(id)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n    getId: getId,\n  }\n}\n\nvar f = a(99); \nf.getQ(); // 1\nf.getW(); // [1, 2]\nf.getId(); // 99\n```\n\n那我想修改模块内部的东西咋办捏？\n\n安排！\n\n```js\nfunction a(id){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  \n  function getId(){\n    console.log(id)\n  }\n  \n  function change(){\n    q = q + 1\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n    getId: getId,\n    change: change,\n  }\n}\n\nvar f = a(99); \nf.getQ(); // 1\nf.getW(); // [1, 2]\nf.getId(); // 99\nf.change(); // 99\nf.getQ(); // 2\n```\n\n通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。\n\n#### 近现代的模块\n\n##### AMD（很少用到了）\n\nAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范\n\n由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出\n\nrequireJS主要解决两个问题\n\n1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 \n2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 \n看一个使用requireJS的例子\n\n```js\n/* \n\n*  a.js \n\n*  创建一个名为“a”的模块\n\n*/\n\n\n\ndefine('a', function(require, exports, module) {   \n\n  exports.getTime = function() {   \n\n    return new Date();   \n\n  }  \n\n});\n\n\n\n/* \n\n*  b.js \n\n*  创建一个名为“b”的模块，同时使用依赖require、exports和名为“a”的模块：\n\n*/\n\ndefine('b', ['require', 'exports', 'a'], function(require, exports, a) {   exports.test = function() {\n\n    return {   \n\n      now: a.getTime()    \n\n    };   \n\n  }  \n\n});\n\n\n\n/* main.js */\n\nrequire(['b'], function(b) {   \n\n  console.log(b.test());  \n\n});\n```\n\n**语法**\n\nrequireJS定义了一个函数 define，它是全局变量，用来定义模块\n\ndefine(id?, dependencies?, factory);\n\n1. id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n2. dependencies：是一个当前模块依赖的模块名称数组\n3. factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 \n   在页面上使用require函数加载模块\n\nrequire([dependencies], function(){}); \nrequire()函数接受两个参数\n\n1. 第一个参数是一个数组，表示所依赖的模块\n2. 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\nrequire()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n\n##### CMD（很少用到了）\n\nCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 \n**语法** \nSea.js 推崇一个模块一个文件，遵循统一的写法 \ndefine(id?, deps?, factory) \n因为CMD推崇\n\n1. 一个文件一个模块，所以经常就用文件名作为模块id\n2. CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\nfactory是一个函数，有三个参数，function(require, exports, module)\n\n1. require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)\n2. exports 是一个对象，用来向外提供模块接口\n3. module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n\n看个例子：\n\n```js\n/* \n\n*  a.js \n\n*  一个文件就是一个模块\n\n*/\n\ndefine(function(require, exports, module) {   \n\n  exports.getTime = function() {   \n\n    return new Date();   \n\n  }  \n\n});\n\n\n\n/* main.js */\n\ndefine(function(require, exports, module) {  \n\n  /* 按需加载a.js */ \n\n  var a = require('./a');    \n\n  console.log(a.getTime());  \n\n});\n```\n\n##### AMD和CMD的区别\n\n最明显的区别就是在模块定义时对依赖的处理不同\n\n**1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块** \n**2、CMD推崇就近依赖，只有在用到某个模块的时候再去require** \n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同\n\n很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略\n\n为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行\n\nCMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的\n\n这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因\n\n\n\n#### 现代的模块\n\n##### CommonJS\n\nCommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。\n\n```js\n// a.js\nmodule.exports = {\n    a: 1\n}\n// or \nexports.a = 1\n\n// b.js\nvar module = require('./a.js')\nmodule.a // -> log 1\n```\n\n因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析\n\n先说 `require` 吧\n\n```js\nvar module = require('./a.js')\nmodule.a \n// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，\n// 重要的是 module 这里，module 是 Node 独有的一个变量\nmodule.exports = {\n    a: 1\n}\n// module 基本实现\nvar module = {\n  id: 'xxxx', // 我总得知道怎么去找到他吧\n  exports: {} // exports 就是个空对象\n}\n// 这个是为什么 exports 和 module.exports 用法相似的原因\nvar exports = module.exports \nvar load = function (module) {\n    // 导出的东西\n    var a = 1\n    module.exports = a\n    return module.exports\n};\n// 然后当我 require 的时候去找到独特的\n// id，然后将要使用的东西用立即执行函数包装下，over\n```\n\n另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。\n\n##### ES Module\n\nES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别\n\n- CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案\n- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响\n- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化\n- ES Module 会编译成 `require/exports` 来执行的\n\n```js\n// 引入模块 API\nimport XXX from './a.js'\nimport { XXX } from './a.js'\n// 导出模块 API\nexport function a() {}\nexport default function() {}\n```\n\n## 总结\n\n当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。\n\n\n\n> 索引：https://juejin.im/post/5a422b036fb9a045211ef789\n\n\n\n\n\n","source":"_posts/【重识前端】闭包与模块.md","raw":"---\ntitle: 【重识前端】闭包与模块\ndate: 2020-07-15 18:18:21\ntags: [闭包, JavaScript, 模块]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门 道。\n\n> JavaScript中闭包无处不在，你只需要能够识别并拥抱它。\n>\n> 最后你恍然大悟:原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。理 解闭包就好像 Neo3 第一次见到矩阵 4 一样。\n\n## 定义\n\n当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\tbar(); \n}\nfoo();\n```\n\n这样可能还不够直观，我们再修改一下。\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\treturn bar; \n}\nvar baz = foo();\nbaz(); // 2 —— 朋友，这就是闭包的效果。\n```\n\n其实，在正常情况下，我们调用完`foo`之后，JavaScript检测到后续不会再用到他了， 所以他的内部作用域就会被回收♻️。（涉及到垃圾回收机制，后续的文章我们会说到。）\n\n闭包的神奇之处就在于他可以阻止♻️的发生。因为事实上内部作用域已然存在，那么又有谁在使用呢？哦~是我们的`bar`在使用。\n\n拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。\n\nbar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n所以我说说我自己的理解：\n\n闭包是一个运行时的概念，如果只是声明或者定义。即使他符合闭包的要求那他也不能成为一个真正的闭包。为什么？因为内存地址并没有开始分配，闭包只是分配之后那一块地址没有被回收而已。\n\n再回到我们最开始的函数：\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\tbar(); \n}\nfoo();\n```\n\n一个函数foo内有一个函数bar。并且函数bar用到了函数foo的变量。那么我们就可以称这个引用过程为“闭包”。但是我们这个函数foo必须被调用，所以我们的例子地下调用了一下函数foo。\n\n再回到我们那个较为清晰的例子\n\n```js\nfunction foo() { \n  var a = 2;\n\tfunction bar() { \n    console.log( a ); // 2\n\t}\n\treturn bar; \n}\nvar baz = foo();\nbaz(); // 2 —— 朋友，这就是闭包的效果。\n```\n\n这个应该是大众认知上非常经典的一个闭包了吧？但是假如说这个foo函数没有被调用，那么我认为他就不是一个闭包。\n\n## 实践\n\n### 常见的闭包\n\n前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。你已经写过的代码中一定到处都是闭包的身影。 现在让我们来搞懂这个事实。\n\n```js\nfunction wait(message) {\n\tsetTimeout( \n\t\tfunction timer() { \n\t\t\tconsole.log( message );\n\t}, 1000 ); \n}\nwait( \"Hello, closure!\" );\n```\n\n这个例子非常常见，代码很简单，就是1秒钟之后输出我们传入的参数。\n\n但是我们仔细看就能看见闭包的影子，一秒钟之后，`message`还是可以被`timer`访问到。并没有被回收♻️掉。\n\n> 这就是闭包\n\n本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!\n\n### 闭包与循环\n\n说到这里肯定有人马上就想到了最经典的面试题：请写出以下的输出内容\n\n```js\nfor (var i=1; i<=5; i++) { \n\tsetTimeout( function timer() {\n\t\tconsole.log( i ); \n  }, i*1000 );\n}\n```\n\n正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。\n\n但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。\n\n这是为什么?\n\n因为等到执行`console.log`的时候，那个时候的i已经在for的调教下变成了6了，所以他们去取只能取到6；\n\n（事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。这个涉及到时间循环，后面的文章会具体的展开来讲）\n\n通过我们刚刚的学习知道，如果我们创造了一个闭包，这样的话这个i不就不会被回收了吗？\n\nok，我们试试\n\n```js\nfor (var i=1; i<=5; i++) { \n  (function() {\n\t\tsetTimeout( function timer() { \n      console.log( i );\n    }, i*1000 );\n  })();\n}\n\n```\n\n这样能行吗?试试吧，在Chrome或者node里面试试吧，我等着你。\n\n我不卖关子了。这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。\n\n如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。\n\n它需要有自己的变量，用来在每个迭代中储存 i 的值\n\n```js\n\nfor (var i=1; i<=5; i++) { \n  (function() {\n  \tvar j = i;\n  \tsetTimeout( function timer() {\n  \t\tconsole.log( j ); \n    },j *1000 );\n   })(); \n}\n```\n\n行了!它能正常工作了!。\n\n可以对这段代码进行一些改进:\n\n```js\nfor (var i=1; i<=5; i++) { \n  (function(j) {\n  \tsetTimeout( function timer() {\n  \t\tconsole.log( j ); \n    },j *1000 );\n   })(i); \n}\n```\n\n当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量\n\n名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。\n 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的\n\n作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 问题解决啦!\n\n当然了，肯定有用块级作用域`let`的，那样其实是更完美的。\n\n```js\nfor (let i=1; i<=5; i++) { \n  \tsetTimeout( function timer() {\n  \t\tconsole.log( i ); \n    },1000 );\n}\n```\n\n### 闭包与模块\n\n很早之前，我们引用的js文件内部的变量其实都是挂载在window上面的，久而久之变量名很可能会重复=>覆盖=>BUG=>难以追寻的BUG\n\n所以很需要模块的这个概念来解决。\n\n模块的发展我分为三块：上古时代，近现代，现代\n\n#### 上古时代的模块\n\n闭包最强大的功能=>《模块》\n\n看个例子\n\n```js\nfunction a(){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n  }\n}\n\nvar f = a(); \nf.getQ(); // 1\nf.getW(); // [1, 2]\n```\n\n我们仔细的剖析一下这段代码， `a`是一个函数，我们用a创建了一个模块实例。注意一下：如果不执行 `getQ` 或者 `getW` 这个闭包就无法创建，因为在函数a内部的getQ和getW都只是对变量q和变了w的引用声明；没有实实在在的调用就没有创建作用域，也没有开辟内存空间。\n\n引用一句《你不知道的JavaScript-上》中的一句话：\n\n> 如果不执行 外部函数，内部作用域和闭包都无法被创建。\n\n其次，a() 返回一个用对象字面量语法 { key: value, ... } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。\n\n这个对象类型的返回值最终被赋值给外部的变量 f，然后就可以通过它来访问 API 中的 属性方法，比如 f.getW()。\n\n> 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属 性)。\n\n其实我们这样每次调用一次`a函数`相当于创建了一个新的模块实例。\n\n假如，此时我们希望只要一个实例，那咋办呢？\n\n天降猛男----IIFE（立即执行函数）\n\n=》\n\n```js\nvar f = (function a(){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n  }\n})(); \n\nf.getQ(); // 1\nf.getW(); // [1, 2]\n```\n\n这个模块只属于f一个人，要修改只能找f帮忙了。\n\n既然模块也是一个函数，那是不是也可以传参呀？\n\n是的，稍作修改就好了。\n\n```js\nfunction a(id){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  \n  function getId(){\n    console.log(id)\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n    getId: getId,\n  }\n}\n\nvar f = a(99); \nf.getQ(); // 1\nf.getW(); // [1, 2]\nf.getId(); // 99\n```\n\n那我想修改模块内部的东西咋办捏？\n\n安排！\n\n```js\nfunction a(id){\n  var q = 1;\n  var w = [1, 2];\n  \n  function getQ(){\n    console.log(q)\n  }\n  \n  function getW(){\n    console.log(w)\n  }\n  \n  function getId(){\n    console.log(id)\n  }\n  \n  function change(){\n    q = q + 1\n  }\n  return {\n    getQ: getQ,\n    getW: getW,\n    getId: getId,\n    change: change,\n  }\n}\n\nvar f = a(99); \nf.getQ(); // 1\nf.getW(); // [1, 2]\nf.getId(); // 99\nf.change(); // 99\nf.getQ(); // 2\n```\n\n通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。\n\n#### 近现代的模块\n\n##### AMD（很少用到了）\n\nAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范\n\n由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出\n\nrequireJS主要解决两个问题\n\n1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 \n2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 \n看一个使用requireJS的例子\n\n```js\n/* \n\n*  a.js \n\n*  创建一个名为“a”的模块\n\n*/\n\n\n\ndefine('a', function(require, exports, module) {   \n\n  exports.getTime = function() {   \n\n    return new Date();   \n\n  }  \n\n});\n\n\n\n/* \n\n*  b.js \n\n*  创建一个名为“b”的模块，同时使用依赖require、exports和名为“a”的模块：\n\n*/\n\ndefine('b', ['require', 'exports', 'a'], function(require, exports, a) {   exports.test = function() {\n\n    return {   \n\n      now: a.getTime()    \n\n    };   \n\n  }  \n\n});\n\n\n\n/* main.js */\n\nrequire(['b'], function(b) {   \n\n  console.log(b.test());  \n\n});\n```\n\n**语法**\n\nrequireJS定义了一个函数 define，它是全局变量，用来定义模块\n\ndefine(id?, dependencies?, factory);\n\n1. id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n2. dependencies：是一个当前模块依赖的模块名称数组\n3. factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 \n   在页面上使用require函数加载模块\n\nrequire([dependencies], function(){}); \nrequire()函数接受两个参数\n\n1. 第一个参数是一个数组，表示所依赖的模块\n2. 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\nrequire()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n\n##### CMD（很少用到了）\n\nCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 \n**语法** \nSea.js 推崇一个模块一个文件，遵循统一的写法 \ndefine(id?, deps?, factory) \n因为CMD推崇\n\n1. 一个文件一个模块，所以经常就用文件名作为模块id\n2. CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写\n\nfactory是一个函数，有三个参数，function(require, exports, module)\n\n1. require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)\n2. exports 是一个对象，用来向外提供模块接口\n3. module 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n\n看个例子：\n\n```js\n/* \n\n*  a.js \n\n*  一个文件就是一个模块\n\n*/\n\ndefine(function(require, exports, module) {   \n\n  exports.getTime = function() {   \n\n    return new Date();   \n\n  }  \n\n});\n\n\n\n/* main.js */\n\ndefine(function(require, exports, module) {  \n\n  /* 按需加载a.js */ \n\n  var a = require('./a');    \n\n  console.log(a.getTime());  \n\n});\n```\n\n##### AMD和CMD的区别\n\n最明显的区别就是在模块定义时对依赖的处理不同\n\n**1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块** \n**2、CMD推崇就近依赖，只有在用到某个模块的时候再去require** \n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同\n\n很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略\n\n为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行\n\nCMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的\n\n这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因\n\n\n\n#### 现代的模块\n\n##### CommonJS\n\nCommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。\n\n```js\n// a.js\nmodule.exports = {\n    a: 1\n}\n// or \nexports.a = 1\n\n// b.js\nvar module = require('./a.js')\nmodule.a // -> log 1\n```\n\n因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析\n\n先说 `require` 吧\n\n```js\nvar module = require('./a.js')\nmodule.a \n// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，\n// 重要的是 module 这里，module 是 Node 独有的一个变量\nmodule.exports = {\n    a: 1\n}\n// module 基本实现\nvar module = {\n  id: 'xxxx', // 我总得知道怎么去找到他吧\n  exports: {} // exports 就是个空对象\n}\n// 这个是为什么 exports 和 module.exports 用法相似的原因\nvar exports = module.exports \nvar load = function (module) {\n    // 导出的东西\n    var a = 1\n    module.exports = a\n    return module.exports\n};\n// 然后当我 require 的时候去找到独特的\n// id，然后将要使用的东西用立即执行函数包装下，over\n```\n\n另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。\n\n##### ES Module\n\nES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别\n\n- CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案\n- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响\n- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化\n- ES Module 会编译成 `require/exports` 来执行的\n\n```js\n// 引入模块 API\nimport XXX from './a.js'\nimport { XXX } from './a.js'\n// 导出模块 API\nexport function a() {}\nexport default function() {}\n```\n\n## 总结\n\n当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。\n\n\n\n> 索引：https://juejin.im/post/5a422b036fb9a045211ef789\n\n\n\n\n\n","slug":"【重识前端】闭包与模块","published":1,"updated":"2021-06-24T14:00:06.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8p001wlwrdh7m9appx","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门 道。</p>\n<blockquote>\n<p>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</p>\n<p>最后你恍然大悟:原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。理 解闭包就好像 Neo3 第一次见到矩阵 4 一样。</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbar(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<p>这样可能还不够直观，我们再修改一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>\n\n<p>其实，在正常情况下，我们调用完<code>foo</code>之后，JavaScript检测到后续不会再用到他了， 所以他的内部作用域就会被回收♻️。（涉及到垃圾回收机制，后续的文章我们会说到。）</p>\n<p>闭包的神奇之处就在于他可以阻止♻️的发生。因为事实上内部作用域已然存在，那么又有谁在使用呢？哦~是我们的<code>bar</code>在使用。</p>\n<p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。</p>\n<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>\n<p>所以我说说我自己的理解：</p>\n<p>闭包是一个运行时的概念，如果只是声明或者定义。即使他符合闭包的要求那他也不能成为一个真正的闭包。为什么？因为内存地址并没有开始分配，闭包只是分配之后那一块地址没有被回收而已。</p>\n<p>再回到我们最开始的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbar(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<p>一个函数foo内有一个函数bar。并且函数bar用到了函数foo的变量。那么我们就可以称这个引用过程为“闭包”。但是我们这个函数foo必须被调用，所以我们的例子地下调用了一下函数foo。</p>\n<p>再回到我们那个较为清晰的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>\n\n<p>这个应该是大众认知上非常经典的一个闭包了吧？但是假如说这个foo函数没有被调用，那么我认为他就不是一个闭包。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"常见的闭包\"><a href=\"#常见的闭包\" class=\"headerlink\" title=\"常见的闭包\"></a>常见的闭包</h3><p>前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。你已经写过的代码中一定到处都是闭包的身影。 现在让我们来搞懂这个事实。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">\tsetTimeout( </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( message );</span><br><span class=\"line\">\t&#125;, <span class=\"number\">1000</span> ); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait( <span class=\"string\">\"Hello, closure!\"</span> );</span><br></pre></td></tr></table></figure>\n\n<p>这个例子非常常见，代码很简单，就是1秒钟之后输出我们传入的参数。</p>\n<p>但是我们仔细看就能看见闭包的影子，一秒钟之后，<code>message</code>还是可以被<code>timer</code>访问到。并没有被回收♻️掉。</p>\n<blockquote>\n<p>这就是闭包</p>\n</blockquote>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!</p>\n<h3 id=\"闭包与循环\"><a href=\"#闭包与循环\" class=\"headerlink\" title=\"闭包与循环\"></a>闭包与循环</h3><p>说到这里肯定有人马上就想到了最经典的面试题：请写出以下的输出内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( i ); </span><br><span class=\"line\">  &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。</p>\n<p>但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p>\n<p>这是为什么?</p>\n<p>因为等到执行<code>console.log</code>的时候，那个时候的i已经在for的调教下变成了6了，所以他们去取只能取到6；</p>\n<p>（事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。这个涉及到时间循环，后面的文章会具体的展开来讲）</p>\n<p>通过我们刚刚的学习知道，如果我们创造了一个闭包，这样的话这个i不就不会被回收了吗？</p>\n<p>ok，我们试试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样能行吗?试试吧，在Chrome或者node里面试试吧，我等着你。</p>\n<p>我不卖关子了。这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。</p>\n<p>如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。</p>\n<p>它需要有自己的变量，用来在每个迭代中储存 i 的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( j ); </span><br><span class=\"line\">    &#125;,j *<span class=\"number\">1000</span> );</span><br><span class=\"line\">   &#125;)(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>行了!它能正常工作了!。</p>\n<p>可以对这段代码进行一些改进:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( j ); </span><br><span class=\"line\">    &#125;,j *<span class=\"number\">1000</span> );</span><br><span class=\"line\">   &#125;)(i); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量</p>\n<p>名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。<br> 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的</p>\n<p>作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 问题解决啦!</p>\n<p>当然了，肯定有用块级作用域<code>let</code>的，那样其实是更完美的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( i ); </span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包与模块\"><a href=\"#闭包与模块\" class=\"headerlink\" title=\"闭包与模块\"></a>闭包与模块</h3><p>很早之前，我们引用的js文件内部的变量其实都是挂载在window上面的，久而久之变量名很可能会重复=&gt;覆盖=&gt;BUG=&gt;难以追寻的BUG</p>\n<p>所以很需要模块的这个概念来解决。</p>\n<p>模块的发展我分为三块：上古时代，近现代，现代</p>\n<h4 id=\"上古时代的模块\"><a href=\"#上古时代的模块\" class=\"headerlink\" title=\"上古时代的模块\"></a>上古时代的模块</h4><p>闭包最强大的功能=&gt;《模块》</p>\n<p>看个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>我们仔细的剖析一下这段代码， <code>a</code>是一个函数，我们用a创建了一个模块实例。注意一下：如果不执行 <code>getQ</code> 或者 <code>getW</code> 这个闭包就无法创建，因为在函数a内部的getQ和getW都只是对变量q和变了w的引用声明；没有实实在在的调用就没有创建作用域，也没有开辟内存空间。</p>\n<p>引用一句《你不知道的JavaScript-上》中的一句话：</p>\n<blockquote>\n<p>如果不执行 外部函数，内部作用域和闭包都无法被创建。</p>\n</blockquote>\n<p>其次，a() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</p>\n<p>这个对象类型的返回值最终被赋值给外部的变量 f，然后就可以通过它来访问 API 中的 属性方法，比如 f.getW()。</p>\n<blockquote>\n<p>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属 性)。</p>\n</blockquote>\n<p>其实我们这样每次调用一次<code>a函数</code>相当于创建了一个新的模块实例。</p>\n<p>假如，此时我们希望只要一个实例，那咋办呢？</p>\n<p>天降猛男—-IIFE（立即执行函数）</p>\n<p>=》</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(); </span><br><span class=\"line\"></span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>这个模块只属于f一个人，要修改只能找f帮忙了。</p>\n<p>既然模块也是一个函数，那是不是也可以传参呀？</p>\n<p>是的，稍作修改就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getId</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">    getId: getId,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(<span class=\"number\">99</span>); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">f.getId(); <span class=\"comment\">// 99</span></span><br></pre></td></tr></table></figure>\n\n<p>那我想修改模块内部的东西咋办捏？</p>\n<p>安排！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getId</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">change</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    q = q + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">    getId: getId,</span><br><span class=\"line\">    change: change,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(<span class=\"number\">99</span>); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">f.getId(); <span class=\"comment\">// 99</span></span><br><span class=\"line\">f.change(); <span class=\"comment\">// 99</span></span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。</p>\n<h4 id=\"近现代的模块\"><a href=\"#近现代的模块\" class=\"headerlink\" title=\"近现代的模块\"></a>近现代的模块</h4><h5 id=\"AMD（很少用到了）\"><a href=\"#AMD（很少用到了）\" class=\"headerlink\" title=\"AMD（很少用到了）\"></a>AMD（很少用到了）</h5><p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范</p>\n<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>\n<p>requireJS主要解决两个问题</p>\n<p>1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器<br>2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长<br>看一个使用requireJS的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  a.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  创建一个名为“a”的模块</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  exports.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  b.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  创建一个名为“b”的模块，同时使用依赖require、exports和名为“a”的模块：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">'b'</span>, [<span class=\"string\">'require'</span>, <span class=\"string\">'exports'</span>, <span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, a</span>) </span>&#123;   exports.test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">      now: a.getTime()    </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* main.js */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b.test());  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>语法</strong></p>\n<p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p>\n<p>define(id?, dependencies?, factory);</p>\n<ol>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值<br>在页面上使用require函数加载模块</li>\n</ol>\n<p>require([dependencies], function(){});<br>require()函数接受两个参数</p>\n<ol>\n<li>第一个参数是一个数组，表示所依赖的模块</li>\n<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n</ol>\n<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>\n<h5 id=\"CMD（很少用到了）\"><a href=\"#CMD（很少用到了）\" class=\"headerlink\" title=\"CMD（很少用到了）\"></a>CMD（很少用到了）</h5><p>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同<br><strong>语法</strong><br>Sea.js 推崇一个模块一个文件，遵循统一的写法<br>define(id?, deps?, factory)<br>因为CMD推崇</p>\n<ol>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n</ol>\n<p>factory是一个函数，有三个参数，function(require, exports, module)</p>\n<ol>\n<li>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)</li>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ol>\n<p>看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  a.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  一个文件就是一个模块</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  exports.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* main.js */</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 按需加载a.js */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a.getTime());  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"AMD和CMD的区别\"><a href=\"#AMD和CMD的区别\" class=\"headerlink\" title=\"AMD和CMD的区别\"></a>AMD和CMD的区别</h5><p>最明显的区别就是在模块定义时对依赖的处理不同</p>\n<p><strong>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</strong><br><strong>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require</strong><br>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>\n<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>\n<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</p>\n<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</p>\n<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>\n<h4 id=\"现代的模块\"><a href=\"#现代的模块\" class=\"headerlink\" title=\"现代的模块\"></a>现代的模块</h4><h5 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h5><p>CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// or </span></span><br><span class=\"line\">exports.a = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.a <span class=\"comment\">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>\n\n<p>因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析</p>\n<p>先说 <code>require</code> 吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.a </span><br><span class=\"line\"><span class=\"comment\">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class=\"line\"><span class=\"comment\">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// module 基本实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'xxxx'</span>, <span class=\"comment\">// 我总得知道怎么去找到他吧</span></span><br><span class=\"line\">  exports: &#123;&#125; <span class=\"comment\">// exports 就是个空对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> exports = <span class=\"built_in\">module</span>.exports </span><br><span class=\"line\"><span class=\"keyword\">var</span> load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 导出的东西</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 然后当我 require 的时候去找到独特的</span></span><br><span class=\"line\"><span class=\"comment\">// id，然后将要使用的东西用立即执行函数包装下，over</span></span><br></pre></td></tr></table></figure>\n\n<p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code> 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效。</p>\n<h5 id=\"ES-Module\"><a href=\"#ES-Module\" class=\"headerlink\" title=\"ES Module\"></a>ES Module</h5><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p>\n<ul>\n<li>CommonJS 支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li>\n<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>\n<li>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>\n<li>ES Module 会编译成 <code>require/exports</code> 来执行的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块 API</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> XXX <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; XXX &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 导出模块 API</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。</p>\n<blockquote>\n<p>索引：<a href=\"https://juejin.im/post/5a422b036fb9a045211ef789\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a422b036fb9a045211ef789</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门 道。</p>\n<blockquote>\n<p>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</p>\n<p>最后你恍然大悟:原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。理 解闭包就好像 Neo3 第一次见到矩阵 4 一样。</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbar(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<p>这样可能还不够直观，我们再修改一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>\n\n<p>其实，在正常情况下，我们调用完<code>foo</code>之后，JavaScript检测到后续不会再用到他了， 所以他的内部作用域就会被回收♻️。（涉及到垃圾回收机制，后续的文章我们会说到。）</p>\n<p>闭包的神奇之处就在于他可以阻止♻️的发生。因为事实上内部作用域已然存在，那么又有谁在使用呢？哦~是我们的<code>bar</code>在使用。</p>\n<p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。</p>\n<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>\n<p>所以我说说我自己的理解：</p>\n<p>闭包是一个运行时的概念，如果只是声明或者定义。即使他符合闭包的要求那他也不能成为一个真正的闭包。为什么？因为内存地址并没有开始分配，闭包只是分配之后那一块地址没有被回收而已。</p>\n<p>再回到我们最开始的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbar(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<p>一个函数foo内有一个函数bar。并且函数bar用到了函数foo的变量。那么我们就可以称这个引用过程为“闭包”。但是我们这个函数foo必须被调用，所以我们的例子地下调用了一下函数foo。</p>\n<p>再回到我们那个较为清晰的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>\n\n<p>这个应该是大众认知上非常经典的一个闭包了吧？但是假如说这个foo函数没有被调用，那么我认为他就不是一个闭包。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"常见的闭包\"><a href=\"#常见的闭包\" class=\"headerlink\" title=\"常见的闭包\"></a>常见的闭包</h3><p>前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。你已经写过的代码中一定到处都是闭包的身影。 现在让我们来搞懂这个事实。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">\tsetTimeout( </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( message );</span><br><span class=\"line\">\t&#125;, <span class=\"number\">1000</span> ); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait( <span class=\"string\">\"Hello, closure!\"</span> );</span><br></pre></td></tr></table></figure>\n\n<p>这个例子非常常见，代码很简单，就是1秒钟之后输出我们传入的参数。</p>\n<p>但是我们仔细看就能看见闭包的影子，一秒钟之后，<code>message</code>还是可以被<code>timer</code>访问到。并没有被回收♻️掉。</p>\n<blockquote>\n<p>这就是闭包</p>\n</blockquote>\n<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!</p>\n<h3 id=\"闭包与循环\"><a href=\"#闭包与循环\" class=\"headerlink\" title=\"闭包与循环\"></a>闭包与循环</h3><p>说到这里肯定有人马上就想到了最经典的面试题：请写出以下的输出内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( i ); </span><br><span class=\"line\">  &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。</p>\n<p>但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p>\n<p>这是为什么?</p>\n<p>因为等到执行<code>console.log</code>的时候，那个时候的i已经在for的调教下变成了6了，所以他们去取只能取到6；</p>\n<p>（事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。这个涉及到时间循环，后面的文章会具体的展开来讲）</p>\n<p>通过我们刚刚的学习知道，如果我们创造了一个闭包，这样的话这个i不就不会被回收了吗？</p>\n<p>ok，我们试试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">    &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样能行吗?试试吧，在Chrome或者node里面试试吧，我等着你。</p>\n<p>我不卖关子了。这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。</p>\n<p>如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。</p>\n<p>它需要有自己的变量，用来在每个迭代中储存 i 的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( j ); </span><br><span class=\"line\">    &#125;,j *<span class=\"number\">1000</span> );</span><br><span class=\"line\">   &#125;)(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>行了!它能正常工作了!。</p>\n<p>可以对这段代码进行一些改进:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( j ); </span><br><span class=\"line\">    &#125;,j *<span class=\"number\">1000</span> );</span><br><span class=\"line\">   &#125;)(i); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量</p>\n<p>名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。<br> 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的</p>\n<p>作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 问题解决啦!</p>\n<p>当然了，肯定有用块级作用域<code>let</code>的，那样其实是更完美的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123; </span><br><span class=\"line\">  \tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"built_in\">console</span>.log( i ); </span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包与模块\"><a href=\"#闭包与模块\" class=\"headerlink\" title=\"闭包与模块\"></a>闭包与模块</h3><p>很早之前，我们引用的js文件内部的变量其实都是挂载在window上面的，久而久之变量名很可能会重复=&gt;覆盖=&gt;BUG=&gt;难以追寻的BUG</p>\n<p>所以很需要模块的这个概念来解决。</p>\n<p>模块的发展我分为三块：上古时代，近现代，现代</p>\n<h4 id=\"上古时代的模块\"><a href=\"#上古时代的模块\" class=\"headerlink\" title=\"上古时代的模块\"></a>上古时代的模块</h4><p>闭包最强大的功能=&gt;《模块》</p>\n<p>看个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>我们仔细的剖析一下这段代码， <code>a</code>是一个函数，我们用a创建了一个模块实例。注意一下：如果不执行 <code>getQ</code> 或者 <code>getW</code> 这个闭包就无法创建，因为在函数a内部的getQ和getW都只是对变量q和变了w的引用声明；没有实实在在的调用就没有创建作用域，也没有开辟内存空间。</p>\n<p>引用一句《你不知道的JavaScript-上》中的一句话：</p>\n<blockquote>\n<p>如果不执行 外部函数，内部作用域和闭包都无法被创建。</p>\n</blockquote>\n<p>其次，a() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</p>\n<p>这个对象类型的返回值最终被赋值给外部的变量 f，然后就可以通过它来访问 API 中的 属性方法，比如 f.getW()。</p>\n<blockquote>\n<p>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属 性)。</p>\n</blockquote>\n<p>其实我们这样每次调用一次<code>a函数</code>相当于创建了一个新的模块实例。</p>\n<p>假如，此时我们希望只要一个实例，那咋办呢？</p>\n<p>天降猛男—-IIFE（立即执行函数）</p>\n<p>=》</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(); </span><br><span class=\"line\"></span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>这个模块只属于f一个人，要修改只能找f帮忙了。</p>\n<p>既然模块也是一个函数，那是不是也可以传参呀？</p>\n<p>是的，稍作修改就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getId</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">    getId: getId,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(<span class=\"number\">99</span>); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">f.getId(); <span class=\"comment\">// 99</span></span><br></pre></td></tr></table></figure>\n\n<p>那我想修改模块内部的东西咋办捏？</p>\n<p>安排！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getW</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(w)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getId</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">change</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    q = q + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getQ: getQ,</span><br><span class=\"line\">    getW: getW,</span><br><span class=\"line\">    getId: getId,</span><br><span class=\"line\">    change: change,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = a(<span class=\"number\">99</span>); </span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f.getW(); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">f.getId(); <span class=\"comment\">// 99</span></span><br><span class=\"line\">f.change(); <span class=\"comment\">// 99</span></span><br><span class=\"line\">f.getQ(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。</p>\n<h4 id=\"近现代的模块\"><a href=\"#近现代的模块\" class=\"headerlink\" title=\"近现代的模块\"></a>近现代的模块</h4><h5 id=\"AMD（很少用到了）\"><a href=\"#AMD（很少用到了）\" class=\"headerlink\" title=\"AMD（很少用到了）\"></a>AMD（很少用到了）</h5><p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范</p>\n<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>\n<p>requireJS主要解决两个问题</p>\n<p>1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器<br>2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长<br>看一个使用requireJS的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  a.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  创建一个名为“a”的模块</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  exports.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  b.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  创建一个名为“b”的模块，同时使用依赖require、exports和名为“a”的模块：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">'b'</span>, [<span class=\"string\">'require'</span>, <span class=\"string\">'exports'</span>, <span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, a</span>) </span>&#123;   exports.test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">      now: a.getTime()    </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* main.js */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b.test());  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>语法</strong></p>\n<p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p>\n<p>define(id?, dependencies?, factory);</p>\n<ol>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值<br>在页面上使用require函数加载模块</li>\n</ol>\n<p>require([dependencies], function(){});<br>require()函数接受两个参数</p>\n<ol>\n<li>第一个参数是一个数组，表示所依赖的模块</li>\n<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n</ol>\n<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>\n<h5 id=\"CMD（很少用到了）\"><a href=\"#CMD（很少用到了）\" class=\"headerlink\" title=\"CMD（很少用到了）\"></a>CMD（很少用到了）</h5><p>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同<br><strong>语法</strong><br>Sea.js 推崇一个模块一个文件，遵循统一的写法<br>define(id?, deps?, factory)<br>因为CMD推崇</p>\n<ol>\n<li>一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>\n</ol>\n<p>factory是一个函数，有三个参数，function(require, exports, module)</p>\n<ol>\n<li>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)</li>\n<li>exports 是一个对象，用来向外提供模块接口</li>\n<li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>\n</ol>\n<p>看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  a.js </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*  一个文件就是一个模块</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">  exports.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();   </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* main.js */</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 按需加载a.js */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a.getTime());  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"AMD和CMD的区别\"><a href=\"#AMD和CMD的区别\" class=\"headerlink\" title=\"AMD和CMD的区别\"></a>AMD和CMD的区别</h5><p>最明显的区别就是在模块定义时对依赖的处理不同</p>\n<p><strong>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</strong><br><strong>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require</strong><br>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>\n<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>\n<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</p>\n<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</p>\n<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>\n<h4 id=\"现代的模块\"><a href=\"#现代的模块\" class=\"headerlink\" title=\"现代的模块\"></a>现代的模块</h4><h5 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h5><p>CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// or </span></span><br><span class=\"line\">exports.a = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.a <span class=\"comment\">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>\n\n<p>因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析</p>\n<p>先说 <code>require</code> 吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.a </span><br><span class=\"line\"><span class=\"comment\">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class=\"line\"><span class=\"comment\">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// module 基本实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'xxxx'</span>, <span class=\"comment\">// 我总得知道怎么去找到他吧</span></span><br><span class=\"line\">  exports: &#123;&#125; <span class=\"comment\">// exports 就是个空对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> exports = <span class=\"built_in\">module</span>.exports </span><br><span class=\"line\"><span class=\"keyword\">var</span> load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 导出的东西</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 然后当我 require 的时候去找到独特的</span></span><br><span class=\"line\"><span class=\"comment\">// id，然后将要使用的东西用立即执行函数包装下，over</span></span><br></pre></td></tr></table></figure>\n\n<p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code> 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效。</p>\n<h5 id=\"ES-Module\"><a href=\"#ES-Module\" class=\"headerlink\" title=\"ES Module\"></a>ES Module</h5><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p>\n<ul>\n<li>CommonJS 支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li>\n<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>\n<li>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>\n<li>ES Module 会编译成 <code>require/exports</code> 来执行的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块 API</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> XXX <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; XXX &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 导出模块 API</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。</p>\n<blockquote>\n<p>索引：<a href=\"https://juejin.im/post/5a422b036fb9a045211ef789\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a422b036fb9a045211ef789</a></p>\n</blockquote>\n"},{"title":"【重识前端】地址栏中输入网址后发生了什么","date":"2020-10-09T02:08:31.000Z","cover":"/image/cover/web.jpeg","_content":"\n# 前言\n\n不说太多废话了，这个题目其实基本上是现在面试的高频考点了，现在我也想自己认认真真的捋一遍，到时候面试也可以流利的回答。\n\n# 开始\n\nlet's go\n\n## URL解析\n\n其实有人一开始会有疑惑，至少我一开始也有疑惑，不是应该先DNS解析吗？\n\n其实不是的，现在的浏览器他会优先解析你是不是一个合法的URL，为什么呢？比如我们在Chrome输入中文“Derrick是帅哥吗”，这样的不是一个正常的合法的URL，就会优先调用你默认的搜索引擎开始搜索。\n\n当然了，合法的URL包括了协议和网络地址，最常用的协议是\n\n- HTTP（超文本传输协议）\n- FTP（文件传输协议）\n\n网络地址也可以是ip地址，以及端口号，没有端口默认是80端口\n\n## DNS域名解析\n\n这一步其实简单来说就是\"baidu.com\"这个域名，解析成一个整个的地址。\n\n比如我们的家庭住址都有一个门牌号，xx小区xx栋xx号\n\n这样的一串标识符就可以精准的找到我们的家庭住址，而每一个ip地址就是这样的一个门牌号，比如`baidu.com`这个不是一个门牌号，这个可以理解为百度的家，你告诉浏览器你要去百度的家，这个时候就会开始进行DNS解析他会解析成百度的门牌号，然后找到百度的家。\n\n### 缓存\n\n这里面又会涉及到缓存的概念，什么意思呢？\n\n就是之前我查过百度的家了，已经记录下来百度的家的门牌号了，就不需要重新的进行解析了，直接读取就好了，节约时间。\n\n\n\n这里面涉及的知识太多了，不在这次的讨论范围内。所以只简单的说一下。\n\n![demo1](/image/地址栏/dns.png)\n\n\n\n上图其实很好的解答了DNS的整个解析过程。\n\n1. 从浏览器获取缓存结果。\n2. 如果浏览器没有缓存就从本地系统的缓存中读取，比如host文件等等，像我们平常上GitHub如果慢的话我们都会修改host文件，给他配一个快一点的ip之类的等等。\n3. 然后是图里面没有提到的路由器缓存，一般的路由器也会有自己的缓存。\n4. 路由器也找不到只能开始解析了。本地域名服务器会向根域名服务器发送一个请求， 如果根域名服务器也不存在该域名时， 本地域名会向com顶级域名服务器发送一个请求， 依次类推下去。 直到最后找到目标网址所对应的 IP， 并将其缓存到本地， 以供下次使用。\n\n\n\n### DNS重定向\n\n这里顺便说一下DNS的重定向吧\n\n> DNS每次返回的ip地址可能会不一样，因为世界上不是只有一个机器可以处理\"baidu.com\"的这个请求，有很多机器可以处理，DNS只需要返回可以处理的机器的ip地址就可以了。例如可以根据每台机器的负载量， 该机器离用户地理位置的距离等等， 这种过程就是DNS负载均衡， 又叫做DNS重定向。\n\n很简单，几个例子，比如我在故宫的北门，打开地图要查询故宫肯定会让我从北门进去。而如果我在故宫的南门，要导航到故宫就会让我从南门进去。\n\n### DNS污染\n\nDNS 污染（DNS cache pollution）， 又称域名服务器缓存投毒（DNS cache poisoning）， 是指一些刻意制造或无意中制造出来的域名服务器数据包， 把域名指往**不正确的IP地址**。\n\n某些网络运营商为了某些目的， 对DNS进行了某些操作， 导致上网的用户无法通过域名取得正确的IP地址。 某些国家或地区出于某些目的为了防止某网站被访问， 而且其又掌握部分国际DNS根目录服务器或镜像， 也会利用此方法进行屏蔽。 （Google、 Facebook等）\n\n至于如果防止DNS污染， 这里只说一个方法就是修改hosts文件， 其他的自行搜索吧。\n\n\n\n## TCP建立连接\n\n其实我们解析之后，找到真正的服务器，我们就需要获取他的资源，最简单的就是获取他的HTML文件，来渲染对吧？怎么获取呢，我们需要TCP连接来获取。\n\n这里涉及到三次握手，和四次挥手以及UDP的一些细一点的知识点。\n\n说TCP之前我想把一些里面可能用到的东西先说说清楚，方便查找。\n\n> 位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)\n\n### 三次握手\n\n![demo2](/image/地址栏/woshou.png)\n\n\n\n三次握手基本上就是👆的图片了，里面的位码在之前也有解释。\n\n这里重点说一下为什么是三次握手🤝，而不是两次或者四次。\n\nA在街上看见了隔了100米的B，（正常情况下如果面对面交流是没有问题的，但是街上很吵，各种车鸣声，店铺广告声之类的。）所以A想和B进行对话，（别问题为什么不打电话，节约钱！）\n\nA喊了B一声，不知道B听不听得见，所以只能在远处等B的回应。\n\nB听见了，也回应了A，但是他不知道A能不能听见所以也要等A回应。\n\n然后A给出了回应，之后A和B就快乐的交流起来。\n\nok，我们再概括一下。\n\n对应到三次握手就是A -> client；B->server\n\n1. 第一次🤝（A喊B）是为了确认一下B能不能听见，也就是客户端要确认服务端的接受功能正不正常\n2. 第二次🤝（B喊A）是告诉A，我能听见，现在我现在知道你能不能听见，也就是服务端告诉客户端我接受功能正常，现在我想知道你接收功能正不正常。\n3. 第三次🤝（A喊B）是为了告诉B我听见了，也就是客户端让服务端知道客户端的接收功能正常，并且可以开始传输。\n\n为什么要三次握手，因为只有这三次可以完美的确认双方的接收和发送功能正常。\n\n为什么不是两次握手？按照上面的说法，B直接开始发送数据，可是他根本不知道A能不能接收啊，发出去岂不是浪费了，对吧？万一A不能接收呢？所以只能等待A的回应\n\n为什么不是四次握手？因为三次就已经完成了他们互相想知道的信息不需要继续浪费资源了，赶紧开始通信吧！\n\n### 四次挥手\n\n四次挥手其实后面才会讲到，但是因为知识点是一起的，所以就放在一起讲了\n\n老规矩，看图和上面的位码意思，就不多解释了。\n\n![demo3](/image/地址栏/huishou.png)\n\n\n\n这里重点解释一下为什么是四次挥手👋\n\n看图我们可以很明显的看到其实就多了一次服务端告诉客户端要终止的消息。\n\n还是举刚刚A和B的例子吧。\n\nA觉得和B聊的差不多了，想结束对话，因为天色很晚了要回家吃饭🍚了。\n\n所以A告诉B，我想走了，不想聊了。\n\nB收到后告诉A，好的，我知道了，但是你等我一下，我撒泡尿，撒完一起走。\n\nB撒完尿之后，告诉A我撒完尿了。\n\nA收到两句话（1.B听到👂A想回家的消息，2.B撒完尿之后的一句话）后，告诉B，我走了。\n\nB听到后也回家了。\n\nok，我们再概括一下。\n\n对应到三次握手就是A -> client；B->server\n\n1. 第一次👋 A告诉B我想回家吃饭了。也就是客户端告诉服务端，想断开连接了。\n2. 第二次👋B告诉A我收到你的消息了，不过我尿拉完就一起回家吧。也就是服务端告诉客户端我收到你的消息了，但是我这里还有一个文件没有传输完，搞定了就关闭链接。\n3. 第三次👋B告诉A我撒完尿了。也就是服务端告诉客户端我文件传输完了，可以关闭链接了。\n4. 第四次👋A告诉B你的两句话都听到了（1.B听到了A想回家的消息，2.B撒完尿了）。也就是客户端告诉服务端我关闭链接了，你也别发了。\n\n双方结束链接。\n\n相比于三次握手，多出来的那一次回收就是服务端需要有一个关闭传输的这么一个过程，这个过程可能需要时间，所以客户端需要等待传输。\n\n### UDP\n\n这里虽然不在范围内，但是我想讲都讲了，顺便吧UDP一起说吧！\n\nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n\n它有以下几个特点：\n\n#### 1.面向无连接\n\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n\n具体来说就是：\n\n- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n#### 2.有单播，多播，广播的功能\n\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n\n#### 3.UDP是面向报文的\n\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n\n#### 4.不可靠性\n\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n\nUDP只想把数据发出去，具体有没有成功他不关心\n\n#### 5.头部开销小，传输数据报文时是很高效的。\n\nUDP 头部包含了以下几个数据：\n\n- 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n- 整个数据报文的长度\n- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误\n\n因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的\n\n#### 6.总结\n\n\n\n|              | UDP                                        | TCP                                    |\n| ------------ | ------------------------------------------ | -------------------------------------- |\n| 是否连接     | 无连接                                     | 面向连接                               |\n| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |\n| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |\n| 传输方式     | 面向报文                                   | 面向字节流                             |\n| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |\n| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |\n\n## SSL/TLS加密\n\n在HTTP请求之前，如果有加密的（就是HTTPS），需要先确认一下双方是否是自己想要找的那个人。\n\n怎么知道那个他是不是自己要找的人呢？有两种方法：对称加密和非对称加密\n\n### 对称加密\n\n对称加密其实就是A和B都有一个解密的规则，双方都心知肚明。这样就可以解密。\n\n对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。\n\n### 非对称加密\n\n那么什么是非对称加密呢？\n\n非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人--银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。\n\n### 总结\n\n所以基本上都是先用非对称加密传输对称加密的秘钥。\n\n## HTTP请求\n\nHTTP请求得到资源文件，如果有gzip压缩的话还需要解压，然后是一些HTTP小的零碎知识点。\n\n### HTTP报文\n\nHTTP 报文是由 请求报文+响应报文 共同组成\n\n- 请求报文：\n  - 定义：所有经过传输协议，客户端传递给服务器的内容，都被成为请求报文\n  - 包含：\n    - 起始行\n    - 请求头（请求首部）\n    - 请求主体\n- 响应报文：\n  - 定义：所有经过传输协议，服务器返回给客户端的内容，都被成为响应报文\n  - 包含：\n    - HTTP状态码\n    - 响应头\n    - 响应主体\n\n\n\n### HTTP状态码\n\n1~5开头，三位数字\n\n- 1 开头的代表处理中，一般见不到\n- 2开头：都是成功\n  - 200：OK：成功\n  - 201：CREATED：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码\n  - 204：NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知\n- 3开头：代表成功，只不过中间需要中转一下\n  - 301：Moved Permanently：永久重定向（永久转移）\n  - 302：Moved Temporarily：临时转移，很早以前基本上用302来做，但是现在主要用307来处理这个事情，\n  - 307的意思就是临时重定向Temporary Redirect =>主要用于：服务器的负载均衡等\n  - 304：Not Modified：设置HTTP的协商缓存\n- 4开头：都是失败\n  - 400：Bad Request：传递给服务器的参数错误\n  - 401：Unauthorized：无权限访问\n  - 404：Not Found：请求地址错误\n- 5开头：都是失败\n  - 500：Internal Server Error：未知服务器错误\n  - 503：Service Unavailable：服务器超负荷\n\n\n\n### HTTP请求方式\n\n其实正常会说到什么`POST`, `GET`之类的，但是我这里想说一下cors里面的东西。\n\n还是本着既然学到这里顺路搞搞清楚\n\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n\n#### 简单请求\n\n只要同时满足以下两大条件，就属于简单请求。\n\n> （1) 请求方法是以下三种方法之一：\n>\n> - HEAD\n> - GET\n> - POST\n>\n> （2）HTTP的头信息不超出以下几种字段：\n>\n> - Accept\n> - Accept-Language\n> - Content-Language\n> - Last-Event-ID\n> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n\n\n\n\n\n#### 非简单请求\n\n凡是不同时满足上面两个条件，就属于非简单请求。\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n也就是我们常说的跨域，这个问题可以交由后端的同学设置白名单或者运维的同学设置。\n\n如果是前端的同学做这种跨域的问题的话不太方便\n\n比如\n\n- **JSONP**\n\n- #### **document.domain + iframe跨域**\n\n- ####  **location.hash + iframe跨域**\n\n- ####  **window.name + iframe跨域**\n\n- #### **postMessage跨域**\n\n但是基本上我们常用的就是`JSONP`\n\n具体这些方法和场景有机会的话具体说一下。\n\n## 断开TCP连接\n\n也就是之前的四次挥手，可以看一下上面的说的四次挥手\n\n## 浏览器渲染页面\n\n文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。\n\n如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。\n\nCSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n\n在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。\n\n\n\n# 总结\n\n1. URL解析\n2. DNS解析\n3. 建立连接\n4. 如果有加密的话要先解密\n5. 然后http请求获取资源\n6. 断开连接\n7. 得到资源之后如果有gzip压缩要先解压\n8. 然后先构建DOM树，CSS树。下载JS文件，然后下载图片。然后生成Render树，最后确定布局，GPU绘制。\n\n# 索引\n\n> https://www.ruanyifeng.com/blog/2016/04/cors.html\n>\n> 前端面试之道（掘金小册\n>\n> https://juejin.im/post/6844904162166063118#heading-30","source":"_posts/【重识前端】地址栏中输入网址后.md","raw":"---\ntitle: 【重识前端】地址栏中输入网址后发生了什么\ndate: 2020-10-09 10:08:31\ntags: [浏览器]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n# 前言\n\n不说太多废话了，这个题目其实基本上是现在面试的高频考点了，现在我也想自己认认真真的捋一遍，到时候面试也可以流利的回答。\n\n# 开始\n\nlet's go\n\n## URL解析\n\n其实有人一开始会有疑惑，至少我一开始也有疑惑，不是应该先DNS解析吗？\n\n其实不是的，现在的浏览器他会优先解析你是不是一个合法的URL，为什么呢？比如我们在Chrome输入中文“Derrick是帅哥吗”，这样的不是一个正常的合法的URL，就会优先调用你默认的搜索引擎开始搜索。\n\n当然了，合法的URL包括了协议和网络地址，最常用的协议是\n\n- HTTP（超文本传输协议）\n- FTP（文件传输协议）\n\n网络地址也可以是ip地址，以及端口号，没有端口默认是80端口\n\n## DNS域名解析\n\n这一步其实简单来说就是\"baidu.com\"这个域名，解析成一个整个的地址。\n\n比如我们的家庭住址都有一个门牌号，xx小区xx栋xx号\n\n这样的一串标识符就可以精准的找到我们的家庭住址，而每一个ip地址就是这样的一个门牌号，比如`baidu.com`这个不是一个门牌号，这个可以理解为百度的家，你告诉浏览器你要去百度的家，这个时候就会开始进行DNS解析他会解析成百度的门牌号，然后找到百度的家。\n\n### 缓存\n\n这里面又会涉及到缓存的概念，什么意思呢？\n\n就是之前我查过百度的家了，已经记录下来百度的家的门牌号了，就不需要重新的进行解析了，直接读取就好了，节约时间。\n\n\n\n这里面涉及的知识太多了，不在这次的讨论范围内。所以只简单的说一下。\n\n![demo1](/image/地址栏/dns.png)\n\n\n\n上图其实很好的解答了DNS的整个解析过程。\n\n1. 从浏览器获取缓存结果。\n2. 如果浏览器没有缓存就从本地系统的缓存中读取，比如host文件等等，像我们平常上GitHub如果慢的话我们都会修改host文件，给他配一个快一点的ip之类的等等。\n3. 然后是图里面没有提到的路由器缓存，一般的路由器也会有自己的缓存。\n4. 路由器也找不到只能开始解析了。本地域名服务器会向根域名服务器发送一个请求， 如果根域名服务器也不存在该域名时， 本地域名会向com顶级域名服务器发送一个请求， 依次类推下去。 直到最后找到目标网址所对应的 IP， 并将其缓存到本地， 以供下次使用。\n\n\n\n### DNS重定向\n\n这里顺便说一下DNS的重定向吧\n\n> DNS每次返回的ip地址可能会不一样，因为世界上不是只有一个机器可以处理\"baidu.com\"的这个请求，有很多机器可以处理，DNS只需要返回可以处理的机器的ip地址就可以了。例如可以根据每台机器的负载量， 该机器离用户地理位置的距离等等， 这种过程就是DNS负载均衡， 又叫做DNS重定向。\n\n很简单，几个例子，比如我在故宫的北门，打开地图要查询故宫肯定会让我从北门进去。而如果我在故宫的南门，要导航到故宫就会让我从南门进去。\n\n### DNS污染\n\nDNS 污染（DNS cache pollution）， 又称域名服务器缓存投毒（DNS cache poisoning）， 是指一些刻意制造或无意中制造出来的域名服务器数据包， 把域名指往**不正确的IP地址**。\n\n某些网络运营商为了某些目的， 对DNS进行了某些操作， 导致上网的用户无法通过域名取得正确的IP地址。 某些国家或地区出于某些目的为了防止某网站被访问， 而且其又掌握部分国际DNS根目录服务器或镜像， 也会利用此方法进行屏蔽。 （Google、 Facebook等）\n\n至于如果防止DNS污染， 这里只说一个方法就是修改hosts文件， 其他的自行搜索吧。\n\n\n\n## TCP建立连接\n\n其实我们解析之后，找到真正的服务器，我们就需要获取他的资源，最简单的就是获取他的HTML文件，来渲染对吧？怎么获取呢，我们需要TCP连接来获取。\n\n这里涉及到三次握手，和四次挥手以及UDP的一些细一点的知识点。\n\n说TCP之前我想把一些里面可能用到的东西先说说清楚，方便查找。\n\n> 位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)\n\n### 三次握手\n\n![demo2](/image/地址栏/woshou.png)\n\n\n\n三次握手基本上就是👆的图片了，里面的位码在之前也有解释。\n\n这里重点说一下为什么是三次握手🤝，而不是两次或者四次。\n\nA在街上看见了隔了100米的B，（正常情况下如果面对面交流是没有问题的，但是街上很吵，各种车鸣声，店铺广告声之类的。）所以A想和B进行对话，（别问题为什么不打电话，节约钱！）\n\nA喊了B一声，不知道B听不听得见，所以只能在远处等B的回应。\n\nB听见了，也回应了A，但是他不知道A能不能听见所以也要等A回应。\n\n然后A给出了回应，之后A和B就快乐的交流起来。\n\nok，我们再概括一下。\n\n对应到三次握手就是A -> client；B->server\n\n1. 第一次🤝（A喊B）是为了确认一下B能不能听见，也就是客户端要确认服务端的接受功能正不正常\n2. 第二次🤝（B喊A）是告诉A，我能听见，现在我现在知道你能不能听见，也就是服务端告诉客户端我接受功能正常，现在我想知道你接收功能正不正常。\n3. 第三次🤝（A喊B）是为了告诉B我听见了，也就是客户端让服务端知道客户端的接收功能正常，并且可以开始传输。\n\n为什么要三次握手，因为只有这三次可以完美的确认双方的接收和发送功能正常。\n\n为什么不是两次握手？按照上面的说法，B直接开始发送数据，可是他根本不知道A能不能接收啊，发出去岂不是浪费了，对吧？万一A不能接收呢？所以只能等待A的回应\n\n为什么不是四次握手？因为三次就已经完成了他们互相想知道的信息不需要继续浪费资源了，赶紧开始通信吧！\n\n### 四次挥手\n\n四次挥手其实后面才会讲到，但是因为知识点是一起的，所以就放在一起讲了\n\n老规矩，看图和上面的位码意思，就不多解释了。\n\n![demo3](/image/地址栏/huishou.png)\n\n\n\n这里重点解释一下为什么是四次挥手👋\n\n看图我们可以很明显的看到其实就多了一次服务端告诉客户端要终止的消息。\n\n还是举刚刚A和B的例子吧。\n\nA觉得和B聊的差不多了，想结束对话，因为天色很晚了要回家吃饭🍚了。\n\n所以A告诉B，我想走了，不想聊了。\n\nB收到后告诉A，好的，我知道了，但是你等我一下，我撒泡尿，撒完一起走。\n\nB撒完尿之后，告诉A我撒完尿了。\n\nA收到两句话（1.B听到👂A想回家的消息，2.B撒完尿之后的一句话）后，告诉B，我走了。\n\nB听到后也回家了。\n\nok，我们再概括一下。\n\n对应到三次握手就是A -> client；B->server\n\n1. 第一次👋 A告诉B我想回家吃饭了。也就是客户端告诉服务端，想断开连接了。\n2. 第二次👋B告诉A我收到你的消息了，不过我尿拉完就一起回家吧。也就是服务端告诉客户端我收到你的消息了，但是我这里还有一个文件没有传输完，搞定了就关闭链接。\n3. 第三次👋B告诉A我撒完尿了。也就是服务端告诉客户端我文件传输完了，可以关闭链接了。\n4. 第四次👋A告诉B你的两句话都听到了（1.B听到了A想回家的消息，2.B撒完尿了）。也就是客户端告诉服务端我关闭链接了，你也别发了。\n\n双方结束链接。\n\n相比于三次握手，多出来的那一次回收就是服务端需要有一个关闭传输的这么一个过程，这个过程可能需要时间，所以客户端需要等待传输。\n\n### UDP\n\n这里虽然不在范围内，但是我想讲都讲了，顺便吧UDP一起说吧！\n\nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n\n它有以下几个特点：\n\n#### 1.面向无连接\n\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n\n具体来说就是：\n\n- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n#### 2.有单播，多播，广播的功能\n\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n\n#### 3.UDP是面向报文的\n\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n\n#### 4.不可靠性\n\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n\nUDP只想把数据发出去，具体有没有成功他不关心\n\n#### 5.头部开销小，传输数据报文时是很高效的。\n\nUDP 头部包含了以下几个数据：\n\n- 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n- 整个数据报文的长度\n- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误\n\n因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的\n\n#### 6.总结\n\n\n\n|              | UDP                                        | TCP                                    |\n| ------------ | ------------------------------------------ | -------------------------------------- |\n| 是否连接     | 无连接                                     | 面向连接                               |\n| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |\n| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |\n| 传输方式     | 面向报文                                   | 面向字节流                             |\n| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |\n| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |\n\n## SSL/TLS加密\n\n在HTTP请求之前，如果有加密的（就是HTTPS），需要先确认一下双方是否是自己想要找的那个人。\n\n怎么知道那个他是不是自己要找的人呢？有两种方法：对称加密和非对称加密\n\n### 对称加密\n\n对称加密其实就是A和B都有一个解密的规则，双方都心知肚明。这样就可以解密。\n\n对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。\n\n### 非对称加密\n\n那么什么是非对称加密呢？\n\n非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人--银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。\n\n### 总结\n\n所以基本上都是先用非对称加密传输对称加密的秘钥。\n\n## HTTP请求\n\nHTTP请求得到资源文件，如果有gzip压缩的话还需要解压，然后是一些HTTP小的零碎知识点。\n\n### HTTP报文\n\nHTTP 报文是由 请求报文+响应报文 共同组成\n\n- 请求报文：\n  - 定义：所有经过传输协议，客户端传递给服务器的内容，都被成为请求报文\n  - 包含：\n    - 起始行\n    - 请求头（请求首部）\n    - 请求主体\n- 响应报文：\n  - 定义：所有经过传输协议，服务器返回给客户端的内容，都被成为响应报文\n  - 包含：\n    - HTTP状态码\n    - 响应头\n    - 响应主体\n\n\n\n### HTTP状态码\n\n1~5开头，三位数字\n\n- 1 开头的代表处理中，一般见不到\n- 2开头：都是成功\n  - 200：OK：成功\n  - 201：CREATED：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码\n  - 204：NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知\n- 3开头：代表成功，只不过中间需要中转一下\n  - 301：Moved Permanently：永久重定向（永久转移）\n  - 302：Moved Temporarily：临时转移，很早以前基本上用302来做，但是现在主要用307来处理这个事情，\n  - 307的意思就是临时重定向Temporary Redirect =>主要用于：服务器的负载均衡等\n  - 304：Not Modified：设置HTTP的协商缓存\n- 4开头：都是失败\n  - 400：Bad Request：传递给服务器的参数错误\n  - 401：Unauthorized：无权限访问\n  - 404：Not Found：请求地址错误\n- 5开头：都是失败\n  - 500：Internal Server Error：未知服务器错误\n  - 503：Service Unavailable：服务器超负荷\n\n\n\n### HTTP请求方式\n\n其实正常会说到什么`POST`, `GET`之类的，但是我这里想说一下cors里面的东西。\n\n还是本着既然学到这里顺路搞搞清楚\n\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n\n#### 简单请求\n\n只要同时满足以下两大条件，就属于简单请求。\n\n> （1) 请求方法是以下三种方法之一：\n>\n> - HEAD\n> - GET\n> - POST\n>\n> （2）HTTP的头信息不超出以下几种字段：\n>\n> - Accept\n> - Accept-Language\n> - Content-Language\n> - Last-Event-ID\n> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n\n\n\n\n\n#### 非简单请求\n\n凡是不同时满足上面两个条件，就属于非简单请求。\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n也就是我们常说的跨域，这个问题可以交由后端的同学设置白名单或者运维的同学设置。\n\n如果是前端的同学做这种跨域的问题的话不太方便\n\n比如\n\n- **JSONP**\n\n- #### **document.domain + iframe跨域**\n\n- ####  **location.hash + iframe跨域**\n\n- ####  **window.name + iframe跨域**\n\n- #### **postMessage跨域**\n\n但是基本上我们常用的就是`JSONP`\n\n具体这些方法和场景有机会的话具体说一下。\n\n## 断开TCP连接\n\n也就是之前的四次挥手，可以看一下上面的说的四次挥手\n\n## 浏览器渲染页面\n\n文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。\n\n如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。\n\nCSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n\n在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。\n\n\n\n# 总结\n\n1. URL解析\n2. DNS解析\n3. 建立连接\n4. 如果有加密的话要先解密\n5. 然后http请求获取资源\n6. 断开连接\n7. 得到资源之后如果有gzip压缩要先解压\n8. 然后先构建DOM树，CSS树。下载JS文件，然后下载图片。然后生成Render树，最后确定布局，GPU绘制。\n\n# 索引\n\n> https://www.ruanyifeng.com/blog/2016/04/cors.html\n>\n> 前端面试之道（掘金小册\n>\n> https://juejin.im/post/6844904162166063118#heading-30","slug":"【重识前端】地址栏中输入网址后","published":1,"updated":"2021-06-24T14:00:06.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8r0021lwrd3eocghnu","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>不说太多废话了，这个题目其实基本上是现在面试的高频考点了，现在我也想自己认认真真的捋一遍，到时候面试也可以流利的回答。</p>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>let’s go</p>\n<h2 id=\"URL解析\"><a href=\"#URL解析\" class=\"headerlink\" title=\"URL解析\"></a>URL解析</h2><p>其实有人一开始会有疑惑，至少我一开始也有疑惑，不是应该先DNS解析吗？</p>\n<p>其实不是的，现在的浏览器他会优先解析你是不是一个合法的URL，为什么呢？比如我们在Chrome输入中文“Derrick是帅哥吗”，这样的不是一个正常的合法的URL，就会优先调用你默认的搜索引擎开始搜索。</p>\n<p>当然了，合法的URL包括了协议和网络地址，最常用的协议是</p>\n<ul>\n<li>HTTP（超文本传输协议）</li>\n<li>FTP（文件传输协议）</li>\n</ul>\n<p>网络地址也可以是ip地址，以及端口号，没有端口默认是80端口</p>\n<h2 id=\"DNS域名解析\"><a href=\"#DNS域名解析\" class=\"headerlink\" title=\"DNS域名解析\"></a>DNS域名解析</h2><p>这一步其实简单来说就是”baidu.com”这个域名，解析成一个整个的地址。</p>\n<p>比如我们的家庭住址都有一个门牌号，xx小区xx栋xx号</p>\n<p>这样的一串标识符就可以精准的找到我们的家庭住址，而每一个ip地址就是这样的一个门牌号，比如<code>baidu.com</code>这个不是一个门牌号，这个可以理解为百度的家，你告诉浏览器你要去百度的家，这个时候就会开始进行DNS解析他会解析成百度的门牌号，然后找到百度的家。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>这里面又会涉及到缓存的概念，什么意思呢？</p>\n<p>就是之前我查过百度的家了，已经记录下来百度的家的门牌号了，就不需要重新的进行解析了，直接读取就好了，节约时间。</p>\n<p>这里面涉及的知识太多了，不在这次的讨论范围内。所以只简单的说一下。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/dns.png\"  alt=\"demo1\"></p>\n<p>上图其实很好的解答了DNS的整个解析过程。</p>\n<ol>\n<li>从浏览器获取缓存结果。</li>\n<li>如果浏览器没有缓存就从本地系统的缓存中读取，比如host文件等等，像我们平常上GitHub如果慢的话我们都会修改host文件，给他配一个快一点的ip之类的等等。</li>\n<li>然后是图里面没有提到的路由器缓存，一般的路由器也会有自己的缓存。</li>\n<li>路由器也找不到只能开始解析了。本地域名服务器会向根域名服务器发送一个请求， 如果根域名服务器也不存在该域名时， 本地域名会向com顶级域名服务器发送一个请求， 依次类推下去。 直到最后找到目标网址所对应的 IP， 并将其缓存到本地， 以供下次使用。</li>\n</ol>\n<h3 id=\"DNS重定向\"><a href=\"#DNS重定向\" class=\"headerlink\" title=\"DNS重定向\"></a>DNS重定向</h3><p>这里顺便说一下DNS的重定向吧</p>\n<blockquote>\n<p>DNS每次返回的ip地址可能会不一样，因为世界上不是只有一个机器可以处理”baidu.com”的这个请求，有很多机器可以处理，DNS只需要返回可以处理的机器的ip地址就可以了。例如可以根据每台机器的负载量， 该机器离用户地理位置的距离等等， 这种过程就是DNS负载均衡， 又叫做DNS重定向。</p>\n</blockquote>\n<p>很简单，几个例子，比如我在故宫的北门，打开地图要查询故宫肯定会让我从北门进去。而如果我在故宫的南门，要导航到故宫就会让我从南门进去。</p>\n<h3 id=\"DNS污染\"><a href=\"#DNS污染\" class=\"headerlink\" title=\"DNS污染\"></a>DNS污染</h3><p>DNS 污染（DNS cache pollution）， 又称域名服务器缓存投毒（DNS cache poisoning）， 是指一些刻意制造或无意中制造出来的域名服务器数据包， 把域名指往<strong>不正确的IP地址</strong>。</p>\n<p>某些网络运营商为了某些目的， 对DNS进行了某些操作， 导致上网的用户无法通过域名取得正确的IP地址。 某些国家或地区出于某些目的为了防止某网站被访问， 而且其又掌握部分国际DNS根目录服务器或镜像， 也会利用此方法进行屏蔽。 （Google、 Facebook等）</p>\n<p>至于如果防止DNS污染， 这里只说一个方法就是修改hosts文件， 其他的自行搜索吧。</p>\n<h2 id=\"TCP建立连接\"><a href=\"#TCP建立连接\" class=\"headerlink\" title=\"TCP建立连接\"></a>TCP建立连接</h2><p>其实我们解析之后，找到真正的服务器，我们就需要获取他的资源，最简单的就是获取他的HTML文件，来渲染对吧？怎么获取呢，我们需要TCP连接来获取。</p>\n<p>这里涉及到三次握手，和四次挥手以及UDP的一些细一点的知识点。</p>\n<p>说TCP之前我想把一些里面可能用到的东西先说说清楚，方便查找。</p>\n<blockquote>\n<p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</p>\n</blockquote>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/woshou.png\"  alt=\"demo2\"></p>\n<p>三次握手基本上就是👆的图片了，里面的位码在之前也有解释。</p>\n<p>这里重点说一下为什么是三次握手🤝，而不是两次或者四次。</p>\n<p>A在街上看见了隔了100米的B，（正常情况下如果面对面交流是没有问题的，但是街上很吵，各种车鸣声，店铺广告声之类的。）所以A想和B进行对话，（别问题为什么不打电话，节约钱！）</p>\n<p>A喊了B一声，不知道B听不听得见，所以只能在远处等B的回应。</p>\n<p>B听见了，也回应了A，但是他不知道A能不能听见所以也要等A回应。</p>\n<p>然后A给出了回应，之后A和B就快乐的交流起来。</p>\n<p>ok，我们再概括一下。</p>\n<p>对应到三次握手就是A -&gt; client；B-&gt;server</p>\n<ol>\n<li>第一次🤝（A喊B）是为了确认一下B能不能听见，也就是客户端要确认服务端的接受功能正不正常</li>\n<li>第二次🤝（B喊A）是告诉A，我能听见，现在我现在知道你能不能听见，也就是服务端告诉客户端我接受功能正常，现在我想知道你接收功能正不正常。</li>\n<li>第三次🤝（A喊B）是为了告诉B我听见了，也就是客户端让服务端知道客户端的接收功能正常，并且可以开始传输。</li>\n</ol>\n<p>为什么要三次握手，因为只有这三次可以完美的确认双方的接收和发送功能正常。</p>\n<p>为什么不是两次握手？按照上面的说法，B直接开始发送数据，可是他根本不知道A能不能接收啊，发出去岂不是浪费了，对吧？万一A不能接收呢？所以只能等待A的回应</p>\n<p>为什么不是四次握手？因为三次就已经完成了他们互相想知道的信息不需要继续浪费资源了，赶紧开始通信吧！</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>四次挥手其实后面才会讲到，但是因为知识点是一起的，所以就放在一起讲了</p>\n<p>老规矩，看图和上面的位码意思，就不多解释了。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/huishou.png\"  alt=\"demo3\"></p>\n<p>这里重点解释一下为什么是四次挥手👋</p>\n<p>看图我们可以很明显的看到其实就多了一次服务端告诉客户端要终止的消息。</p>\n<p>还是举刚刚A和B的例子吧。</p>\n<p>A觉得和B聊的差不多了，想结束对话，因为天色很晚了要回家吃饭🍚了。</p>\n<p>所以A告诉B，我想走了，不想聊了。</p>\n<p>B收到后告诉A，好的，我知道了，但是你等我一下，我撒泡尿，撒完一起走。</p>\n<p>B撒完尿之后，告诉A我撒完尿了。</p>\n<p>A收到两句话（1.B听到👂A想回家的消息，2.B撒完尿之后的一句话）后，告诉B，我走了。</p>\n<p>B听到后也回家了。</p>\n<p>ok，我们再概括一下。</p>\n<p>对应到三次握手就是A -&gt; client；B-&gt;server</p>\n<ol>\n<li>第一次👋 A告诉B我想回家吃饭了。也就是客户端告诉服务端，想断开连接了。</li>\n<li>第二次👋B告诉A我收到你的消息了，不过我尿拉完就一起回家吧。也就是服务端告诉客户端我收到你的消息了，但是我这里还有一个文件没有传输完，搞定了就关闭链接。</li>\n<li>第三次👋B告诉A我撒完尿了。也就是服务端告诉客户端我文件传输完了，可以关闭链接了。</li>\n<li>第四次👋A告诉B你的两句话都听到了（1.B听到了A想回家的消息，2.B撒完尿了）。也就是客户端告诉服务端我关闭链接了，你也别发了。</li>\n</ol>\n<p>双方结束链接。</p>\n<p>相比于三次握手，多出来的那一次回收就是服务端需要有一个关闭传输的这么一个过程，这个过程可能需要时间，所以客户端需要等待传输。</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><p>这里虽然不在范围内，但是我想讲都讲了，顺便吧UDP一起说吧！</p>\n<p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>\n<p>它有以下几个特点：</p>\n<h4 id=\"1-面向无连接\"><a href=\"#1-面向无连接\" class=\"headerlink\" title=\"1.面向无连接\"></a>1.面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>\n<p>具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n<h4 id=\"2-有单播，多播，广播的功能\"><a href=\"#2-有单播，多播，广播的功能\" class=\"headerlink\" title=\"2.有单播，多播，广播的功能\"></a>2.有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>\n<h4 id=\"3-UDP是面向报文的\"><a href=\"#3-UDP是面向报文的\" class=\"headerlink\" title=\"3.UDP是面向报文的\"></a>3.UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>\n<h4 id=\"4-不可靠性\"><a href=\"#4-不可靠性\" class=\"headerlink\" title=\"4.不可靠性\"></a>4.不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>\n<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>\n<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<p>UDP只想把数据发出去，具体有没有成功他不关心</p>\n<h4 id=\"5-头部开销小，传输数据报文时是很高效的。\"><a href=\"#5-头部开销小，传输数据报文时是很高效的。\" class=\"headerlink\" title=\"5.头部开销小，传输数据报文时是很高效的。\"></a>5.头部开销小，传输数据报文时是很高效的。</h4><p>UDP 头部包含了以下几个数据：</p>\n<ul>\n<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>\n<li>整个数据报文的长度</li>\n<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>\n</ul>\n<p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p>\n<h4 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>适用于实时应用（IP电话、视频会议、直播等）</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<h2 id=\"SSL-TLS加密\"><a href=\"#SSL-TLS加密\" class=\"headerlink\" title=\"SSL/TLS加密\"></a>SSL/TLS加密</h2><p>在HTTP请求之前，如果有加密的（就是HTTPS），需要先确认一下双方是否是自己想要找的那个人。</p>\n<p>怎么知道那个他是不是自己要找的人呢？有两种方法：对称加密和非对称加密</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>对称加密其实就是A和B都有一个解密的规则，双方都心知肚明。这样就可以解密。</p>\n<p>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>那么什么是非对称加密呢？</p>\n<p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所以基本上都是先用非对称加密传输对称加密的秘钥。</p>\n<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><p>HTTP请求得到资源文件，如果有gzip压缩的话还需要解压，然后是一些HTTP小的零碎知识点。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP 报文是由 请求报文+响应报文 共同组成</p>\n<ul>\n<li>请求报文：<ul>\n<li>定义：所有经过传输协议，客户端传递给服务器的内容，都被成为请求报文</li>\n<li>包含：<ul>\n<li>起始行</li>\n<li>请求头（请求首部）</li>\n<li>请求主体</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应报文：<ul>\n<li>定义：所有经过传输协议，服务器返回给客户端的内容，都被成为响应报文</li>\n<li>包含：<ul>\n<li>HTTP状态码</li>\n<li>响应头</li>\n<li>响应主体</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>1~5开头，三位数字</p>\n<ul>\n<li>1 开头的代表处理中，一般见不到</li>\n<li>2开头：都是成功<ul>\n<li>200：OK：成功</li>\n<li>201：CREATED：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码</li>\n<li>204：NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知</li>\n</ul>\n</li>\n<li>3开头：代表成功，只不过中间需要中转一下<ul>\n<li>301：Moved Permanently：永久重定向（永久转移）</li>\n<li>302：Moved Temporarily：临时转移，很早以前基本上用302来做，但是现在主要用307来处理这个事情，</li>\n<li>307的意思就是临时重定向Temporary Redirect =&gt;主要用于：服务器的负载均衡等</li>\n<li>304：Not Modified：设置HTTP的协商缓存</li>\n</ul>\n</li>\n<li>4开头：都是失败<ul>\n<li>400：Bad Request：传递给服务器的参数错误</li>\n<li>401：Unauthorized：无权限访问</li>\n<li>404：Not Found：请求地址错误</li>\n</ul>\n</li>\n<li>5开头：都是失败<ul>\n<li>500：Internal Server Error：未知服务器错误</li>\n<li>503：Service Unavailable：服务器超负荷</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP请求方式\"><a href=\"#HTTP请求方式\" class=\"headerlink\" title=\"HTTP请求方式\"></a>HTTP请求方式</h3><p>其实正常会说到什么<code>POST</code>, <code>GET</code>之类的，但是我这里想说一下cors里面的东西。</p>\n<p>还是本着既然学到这里顺路搞搞清楚</p>\n<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。</p>\n<blockquote>\n<p>（1) 请求方法是以下三种方法之一：</p>\n<ul>\n<li>HEAD</li>\n<li>GET</li>\n<li>POST</li>\n</ul>\n<p>（2）HTTP的头信息不超出以下几种字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>\n</ul>\n</blockquote>\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>凡是不同时满足上面两个条件，就属于非简单请求。</p>\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>\n<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>\n<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<p>也就是我们常说的跨域，这个问题可以交由后端的同学设置白名单或者运维的同学设置。</p>\n<p>如果是前端的同学做这种跨域的问题的话不太方便</p>\n<p>比如</p>\n<ul>\n<li><p><strong>JSONP</strong></p>\n</li>\n<li><h4 id=\"document-domain-iframe跨域\"><a href=\"#document-domain-iframe跨域\" class=\"headerlink\" title=\"document.domain + iframe跨域\"></a><strong>document.domain + iframe跨域</strong></h4></li>\n<li><h4 id=\"location-hash-iframe跨域\"><a href=\"#location-hash-iframe跨域\" class=\"headerlink\" title=\"location.hash + iframe跨域\"></a><strong>location.hash + iframe跨域</strong></h4></li>\n<li><h4 id=\"window-name-iframe跨域\"><a href=\"#window-name-iframe跨域\" class=\"headerlink\" title=\"window.name + iframe跨域\"></a><strong>window.name + iframe跨域</strong></h4></li>\n<li><h4 id=\"postMessage跨域\"><a href=\"#postMessage跨域\" class=\"headerlink\" title=\"postMessage跨域\"></a><strong>postMessage跨域</strong></h4></li>\n</ul>\n<p>但是基本上我们常用的就是<code>JSONP</code></p>\n<p>具体这些方法和场景有机会的话具体说一下。</p>\n<h2 id=\"断开TCP连接\"><a href=\"#断开TCP连接\" class=\"headerlink\" title=\"断开TCP连接\"></a>断开TCP连接</h2><p>也就是之前的四次挥手，可以看一下上面的说的四次挥手</p>\n<h2 id=\"浏览器渲染页面\"><a href=\"#浏览器渲染页面\" class=\"headerlink\" title=\"浏览器渲染页面\"></a>浏览器渲染页面</h2><p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p>\n<p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。</p>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。</p>\n<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>URL解析</li>\n<li>DNS解析</li>\n<li>建立连接</li>\n<li>如果有加密的话要先解密</li>\n<li>然后http请求获取资源</li>\n<li>断开连接</li>\n<li>得到资源之后如果有gzip压缩要先解压</li>\n<li>然后先构建DOM树，CSS树。下载JS文件，然后下载图片。然后生成Render树，最后确定布局，GPU绘制。</li>\n</ol>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><blockquote>\n<p><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>\n<p>前端面试之道（掘金小册</p>\n<p><a href=\"https://juejin.im/post/6844904162166063118#heading-30\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904162166063118#heading-30</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>不说太多废话了，这个题目其实基本上是现在面试的高频考点了，现在我也想自己认认真真的捋一遍，到时候面试也可以流利的回答。</p>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>let’s go</p>\n<h2 id=\"URL解析\"><a href=\"#URL解析\" class=\"headerlink\" title=\"URL解析\"></a>URL解析</h2><p>其实有人一开始会有疑惑，至少我一开始也有疑惑，不是应该先DNS解析吗？</p>\n<p>其实不是的，现在的浏览器他会优先解析你是不是一个合法的URL，为什么呢？比如我们在Chrome输入中文“Derrick是帅哥吗”，这样的不是一个正常的合法的URL，就会优先调用你默认的搜索引擎开始搜索。</p>\n<p>当然了，合法的URL包括了协议和网络地址，最常用的协议是</p>\n<ul>\n<li>HTTP（超文本传输协议）</li>\n<li>FTP（文件传输协议）</li>\n</ul>\n<p>网络地址也可以是ip地址，以及端口号，没有端口默认是80端口</p>\n<h2 id=\"DNS域名解析\"><a href=\"#DNS域名解析\" class=\"headerlink\" title=\"DNS域名解析\"></a>DNS域名解析</h2><p>这一步其实简单来说就是”baidu.com”这个域名，解析成一个整个的地址。</p>\n<p>比如我们的家庭住址都有一个门牌号，xx小区xx栋xx号</p>\n<p>这样的一串标识符就可以精准的找到我们的家庭住址，而每一个ip地址就是这样的一个门牌号，比如<code>baidu.com</code>这个不是一个门牌号，这个可以理解为百度的家，你告诉浏览器你要去百度的家，这个时候就会开始进行DNS解析他会解析成百度的门牌号，然后找到百度的家。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>这里面又会涉及到缓存的概念，什么意思呢？</p>\n<p>就是之前我查过百度的家了，已经记录下来百度的家的门牌号了，就不需要重新的进行解析了，直接读取就好了，节约时间。</p>\n<p>这里面涉及的知识太多了，不在这次的讨论范围内。所以只简单的说一下。</p>\n<p><img src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/dns.png\" alt=\"demo1\"></p>\n<p>上图其实很好的解答了DNS的整个解析过程。</p>\n<ol>\n<li>从浏览器获取缓存结果。</li>\n<li>如果浏览器没有缓存就从本地系统的缓存中读取，比如host文件等等，像我们平常上GitHub如果慢的话我们都会修改host文件，给他配一个快一点的ip之类的等等。</li>\n<li>然后是图里面没有提到的路由器缓存，一般的路由器也会有自己的缓存。</li>\n<li>路由器也找不到只能开始解析了。本地域名服务器会向根域名服务器发送一个请求， 如果根域名服务器也不存在该域名时， 本地域名会向com顶级域名服务器发送一个请求， 依次类推下去。 直到最后找到目标网址所对应的 IP， 并将其缓存到本地， 以供下次使用。</li>\n</ol>\n<h3 id=\"DNS重定向\"><a href=\"#DNS重定向\" class=\"headerlink\" title=\"DNS重定向\"></a>DNS重定向</h3><p>这里顺便说一下DNS的重定向吧</p>\n<blockquote>\n<p>DNS每次返回的ip地址可能会不一样，因为世界上不是只有一个机器可以处理”baidu.com”的这个请求，有很多机器可以处理，DNS只需要返回可以处理的机器的ip地址就可以了。例如可以根据每台机器的负载量， 该机器离用户地理位置的距离等等， 这种过程就是DNS负载均衡， 又叫做DNS重定向。</p>\n</blockquote>\n<p>很简单，几个例子，比如我在故宫的北门，打开地图要查询故宫肯定会让我从北门进去。而如果我在故宫的南门，要导航到故宫就会让我从南门进去。</p>\n<h3 id=\"DNS污染\"><a href=\"#DNS污染\" class=\"headerlink\" title=\"DNS污染\"></a>DNS污染</h3><p>DNS 污染（DNS cache pollution）， 又称域名服务器缓存投毒（DNS cache poisoning）， 是指一些刻意制造或无意中制造出来的域名服务器数据包， 把域名指往<strong>不正确的IP地址</strong>。</p>\n<p>某些网络运营商为了某些目的， 对DNS进行了某些操作， 导致上网的用户无法通过域名取得正确的IP地址。 某些国家或地区出于某些目的为了防止某网站被访问， 而且其又掌握部分国际DNS根目录服务器或镜像， 也会利用此方法进行屏蔽。 （Google、 Facebook等）</p>\n<p>至于如果防止DNS污染， 这里只说一个方法就是修改hosts文件， 其他的自行搜索吧。</p>\n<h2 id=\"TCP建立连接\"><a href=\"#TCP建立连接\" class=\"headerlink\" title=\"TCP建立连接\"></a>TCP建立连接</h2><p>其实我们解析之后，找到真正的服务器，我们就需要获取他的资源，最简单的就是获取他的HTML文件，来渲染对吧？怎么获取呢，我们需要TCP连接来获取。</p>\n<p>这里涉及到三次握手，和四次挥手以及UDP的一些细一点的知识点。</p>\n<p>说TCP之前我想把一些里面可能用到的东西先说说清楚，方便查找。</p>\n<blockquote>\n<p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</p>\n</blockquote>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p><img src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/woshou.png\" alt=\"demo2\"></p>\n<p>三次握手基本上就是👆的图片了，里面的位码在之前也有解释。</p>\n<p>这里重点说一下为什么是三次握手🤝，而不是两次或者四次。</p>\n<p>A在街上看见了隔了100米的B，（正常情况下如果面对面交流是没有问题的，但是街上很吵，各种车鸣声，店铺广告声之类的。）所以A想和B进行对话，（别问题为什么不打电话，节约钱！）</p>\n<p>A喊了B一声，不知道B听不听得见，所以只能在远处等B的回应。</p>\n<p>B听见了，也回应了A，但是他不知道A能不能听见所以也要等A回应。</p>\n<p>然后A给出了回应，之后A和B就快乐的交流起来。</p>\n<p>ok，我们再概括一下。</p>\n<p>对应到三次握手就是A -&gt; client；B-&gt;server</p>\n<ol>\n<li>第一次🤝（A喊B）是为了确认一下B能不能听见，也就是客户端要确认服务端的接受功能正不正常</li>\n<li>第二次🤝（B喊A）是告诉A，我能听见，现在我现在知道你能不能听见，也就是服务端告诉客户端我接受功能正常，现在我想知道你接收功能正不正常。</li>\n<li>第三次🤝（A喊B）是为了告诉B我听见了，也就是客户端让服务端知道客户端的接收功能正常，并且可以开始传输。</li>\n</ol>\n<p>为什么要三次握手，因为只有这三次可以完美的确认双方的接收和发送功能正常。</p>\n<p>为什么不是两次握手？按照上面的说法，B直接开始发送数据，可是他根本不知道A能不能接收啊，发出去岂不是浪费了，对吧？万一A不能接收呢？所以只能等待A的回应</p>\n<p>为什么不是四次握手？因为三次就已经完成了他们互相想知道的信息不需要继续浪费资源了，赶紧开始通信吧！</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>四次挥手其实后面才会讲到，但是因为知识点是一起的，所以就放在一起讲了</p>\n<p>老规矩，看图和上面的位码意思，就不多解释了。</p>\n<p><img src=\"/image/%E5%9C%B0%E5%9D%80%E6%A0%8F/huishou.png\" alt=\"demo3\"></p>\n<p>这里重点解释一下为什么是四次挥手👋</p>\n<p>看图我们可以很明显的看到其实就多了一次服务端告诉客户端要终止的消息。</p>\n<p>还是举刚刚A和B的例子吧。</p>\n<p>A觉得和B聊的差不多了，想结束对话，因为天色很晚了要回家吃饭🍚了。</p>\n<p>所以A告诉B，我想走了，不想聊了。</p>\n<p>B收到后告诉A，好的，我知道了，但是你等我一下，我撒泡尿，撒完一起走。</p>\n<p>B撒完尿之后，告诉A我撒完尿了。</p>\n<p>A收到两句话（1.B听到👂A想回家的消息，2.B撒完尿之后的一句话）后，告诉B，我走了。</p>\n<p>B听到后也回家了。</p>\n<p>ok，我们再概括一下。</p>\n<p>对应到三次握手就是A -&gt; client；B-&gt;server</p>\n<ol>\n<li>第一次👋 A告诉B我想回家吃饭了。也就是客户端告诉服务端，想断开连接了。</li>\n<li>第二次👋B告诉A我收到你的消息了，不过我尿拉完就一起回家吧。也就是服务端告诉客户端我收到你的消息了，但是我这里还有一个文件没有传输完，搞定了就关闭链接。</li>\n<li>第三次👋B告诉A我撒完尿了。也就是服务端告诉客户端我文件传输完了，可以关闭链接了。</li>\n<li>第四次👋A告诉B你的两句话都听到了（1.B听到了A想回家的消息，2.B撒完尿了）。也就是客户端告诉服务端我关闭链接了，你也别发了。</li>\n</ol>\n<p>双方结束链接。</p>\n<p>相比于三次握手，多出来的那一次回收就是服务端需要有一个关闭传输的这么一个过程，这个过程可能需要时间，所以客户端需要等待传输。</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><p>这里虽然不在范围内，但是我想讲都讲了，顺便吧UDP一起说吧！</p>\n<p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>\n<p>它有以下几个特点：</p>\n<h4 id=\"1-面向无连接\"><a href=\"#1-面向无连接\" class=\"headerlink\" title=\"1.面向无连接\"></a>1.面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>\n<p>具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n<h4 id=\"2-有单播，多播，广播的功能\"><a href=\"#2-有单播，多播，广播的功能\" class=\"headerlink\" title=\"2.有单播，多播，广播的功能\"></a>2.有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>\n<h4 id=\"3-UDP是面向报文的\"><a href=\"#3-UDP是面向报文的\" class=\"headerlink\" title=\"3.UDP是面向报文的\"></a>3.UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>\n<h4 id=\"4-不可靠性\"><a href=\"#4-不可靠性\" class=\"headerlink\" title=\"4.不可靠性\"></a>4.不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>\n<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>\n<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<p>UDP只想把数据发出去，具体有没有成功他不关心</p>\n<h4 id=\"5-头部开销小，传输数据报文时是很高效的。\"><a href=\"#5-头部开销小，传输数据报文时是很高效的。\" class=\"headerlink\" title=\"5.头部开销小，传输数据报文时是很高效的。\"></a>5.头部开销小，传输数据报文时是很高效的。</h4><p>UDP 头部包含了以下几个数据：</p>\n<ul>\n<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>\n<li>整个数据报文的长度</li>\n<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>\n</ul>\n<p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p>\n<h4 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>适用于实时应用（IP电话、视频会议、直播等）</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<h2 id=\"SSL-TLS加密\"><a href=\"#SSL-TLS加密\" class=\"headerlink\" title=\"SSL/TLS加密\"></a>SSL/TLS加密</h2><p>在HTTP请求之前，如果有加密的（就是HTTPS），需要先确认一下双方是否是自己想要找的那个人。</p>\n<p>怎么知道那个他是不是自己要找的人呢？有两种方法：对称加密和非对称加密</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>对称加密其实就是A和B都有一个解密的规则，双方都心知肚明。这样就可以解密。</p>\n<p>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>那么什么是非对称加密呢？</p>\n<p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所以基本上都是先用非对称加密传输对称加密的秘钥。</p>\n<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><p>HTTP请求得到资源文件，如果有gzip压缩的话还需要解压，然后是一些HTTP小的零碎知识点。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP 报文是由 请求报文+响应报文 共同组成</p>\n<ul>\n<li>请求报文：<ul>\n<li>定义：所有经过传输协议，客户端传递给服务器的内容，都被成为请求报文</li>\n<li>包含：<ul>\n<li>起始行</li>\n<li>请求头（请求首部）</li>\n<li>请求主体</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应报文：<ul>\n<li>定义：所有经过传输协议，服务器返回给客户端的内容，都被成为响应报文</li>\n<li>包含：<ul>\n<li>HTTP状态码</li>\n<li>响应头</li>\n<li>响应主体</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>1~5开头，三位数字</p>\n<ul>\n<li>1 开头的代表处理中，一般见不到</li>\n<li>2开头：都是成功<ul>\n<li>200：OK：成功</li>\n<li>201：CREATED：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码</li>\n<li>204：NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知</li>\n</ul>\n</li>\n<li>3开头：代表成功，只不过中间需要中转一下<ul>\n<li>301：Moved Permanently：永久重定向（永久转移）</li>\n<li>302：Moved Temporarily：临时转移，很早以前基本上用302来做，但是现在主要用307来处理这个事情，</li>\n<li>307的意思就是临时重定向Temporary Redirect =&gt;主要用于：服务器的负载均衡等</li>\n<li>304：Not Modified：设置HTTP的协商缓存</li>\n</ul>\n</li>\n<li>4开头：都是失败<ul>\n<li>400：Bad Request：传递给服务器的参数错误</li>\n<li>401：Unauthorized：无权限访问</li>\n<li>404：Not Found：请求地址错误</li>\n</ul>\n</li>\n<li>5开头：都是失败<ul>\n<li>500：Internal Server Error：未知服务器错误</li>\n<li>503：Service Unavailable：服务器超负荷</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP请求方式\"><a href=\"#HTTP请求方式\" class=\"headerlink\" title=\"HTTP请求方式\"></a>HTTP请求方式</h3><p>其实正常会说到什么<code>POST</code>, <code>GET</code>之类的，但是我这里想说一下cors里面的东西。</p>\n<p>还是本着既然学到这里顺路搞搞清楚</p>\n<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。</p>\n<blockquote>\n<p>（1) 请求方法是以下三种方法之一：</p>\n<ul>\n<li>HEAD</li>\n<li>GET</li>\n<li>POST</li>\n</ul>\n<p>（2）HTTP的头信息不超出以下几种字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>\n</ul>\n</blockquote>\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>凡是不同时满足上面两个条件，就属于非简单请求。</p>\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>\n<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>\n<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<p>也就是我们常说的跨域，这个问题可以交由后端的同学设置白名单或者运维的同学设置。</p>\n<p>如果是前端的同学做这种跨域的问题的话不太方便</p>\n<p>比如</p>\n<ul>\n<li><p><strong>JSONP</strong></p>\n</li>\n<li><h4 id=\"document-domain-iframe跨域\"><a href=\"#document-domain-iframe跨域\" class=\"headerlink\" title=\"document.domain + iframe跨域\"></a><strong>document.domain + iframe跨域</strong></h4></li>\n<li><h4 id=\"location-hash-iframe跨域\"><a href=\"#location-hash-iframe跨域\" class=\"headerlink\" title=\"location.hash + iframe跨域\"></a><strong>location.hash + iframe跨域</strong></h4></li>\n<li><h4 id=\"window-name-iframe跨域\"><a href=\"#window-name-iframe跨域\" class=\"headerlink\" title=\"window.name + iframe跨域\"></a><strong>window.name + iframe跨域</strong></h4></li>\n<li><h4 id=\"postMessage跨域\"><a href=\"#postMessage跨域\" class=\"headerlink\" title=\"postMessage跨域\"></a><strong>postMessage跨域</strong></h4></li>\n</ul>\n<p>但是基本上我们常用的就是<code>JSONP</code></p>\n<p>具体这些方法和场景有机会的话具体说一下。</p>\n<h2 id=\"断开TCP连接\"><a href=\"#断开TCP连接\" class=\"headerlink\" title=\"断开TCP连接\"></a>断开TCP连接</h2><p>也就是之前的四次挥手，可以看一下上面的说的四次挥手</p>\n<h2 id=\"浏览器渲染页面\"><a href=\"#浏览器渲染页面\" class=\"headerlink\" title=\"浏览器渲染页面\"></a>浏览器渲染页面</h2><p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p>\n<p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。</p>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。</p>\n<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>URL解析</li>\n<li>DNS解析</li>\n<li>建立连接</li>\n<li>如果有加密的话要先解密</li>\n<li>然后http请求获取资源</li>\n<li>断开连接</li>\n<li>得到资源之后如果有gzip压缩要先解压</li>\n<li>然后先构建DOM树，CSS树。下载JS文件，然后下载图片。然后生成Render树，最后确定布局，GPU绘制。</li>\n</ol>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><blockquote>\n<p><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>\n<p>前端面试之道（掘金小册</p>\n<p><a href=\"https://juejin.im/post/6844904162166063118#heading-30\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904162166063118#heading-30</a></p>\n</blockquote>\n"},{"title":"【重识前端】深入内存世界","date":"2020-08-25T15:05:00.000Z","cover":"/image/cover/web.jpeg","_content":"\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n用于记录本人的学习过程，希望可以帮助到大家~🤠\n\nJavaScript有自动垃圾回收机制，可能因为这个自动让我们前端开发人员忽略了对他的认识（包括我自己），但是阿里的面试官可不会和你嘻嘻哈哈。\n\n“垃圾回收的机制是什么？什么时候会去触发”\n\n我一脸懵逼....啥...这个不是他自己运行的吗...🤕\n\n还是老规矩，黄金圈法则：\n\n### 为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\n\n计算机在启动一个程序的时候，会为他分配一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。我们知道电脑的内存其实是有限的，比如常见的8G、16G等等，甚至还有一些什么虚拟内存就讨论了。我们关注点在于内存是一个种稀缺资源，对于不用的东西我们不要#占着茅坑不拉屎#。\n\n**所以垃圾回收的作用就是释放一下不再使用的内存空间。**\n\n### 内存的结构\n\nJavaScript中，分为两种内存空间\n\n- 堆内存->存储引用类型\n- 栈内存->存储基本类型\n\n> 基本类型又叫原始类型；因为本人已经说习惯了基本类型，所以以下都叫做基本类型哈。\n\n\n\n## 引用类型、基本类型与堆栈的爱恨纠葛\n\n### 变量存放\n\n#### 基本类型\n\n截止北京时间2020年8月25日；\n\n在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)中显示的基本类型（原始类型）有以下7种\n\n- [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean)\n- [Null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null)\n- [Undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/undefined)\n- [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number)\n- [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt)\n- [String](https://developer.mozilla.org/zh-CN/docs/Glossary/字符串)\n- [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol) \n\n基本类型是存储在栈内存里面的。栈内存里面还存着指向堆内存的内存地址。\n\n> PS：闭包中，基本类型也是存放在堆内存中的哦，要注意一下。\n\n#### 引用类型\n\n除了基本类型的数据结构就是引用类型，包括什么数组（Array）、函数（Function）、对象（Object）之类的都是引用类型。\n\n引用类型和闭包的变量都是存储在堆内存中的。而指针或者说内存地址是存在栈内存的。\n\n> 当查询引用类型的变量时， 先从**栈中读取内存地址**， 然后再通过地址**找到堆中的值**。对于这种，我们把它叫做按引用访问。\n\n干说有点难理解。身为马良的我给大家画一幅画，帮助理解。\n\n```js\nvar a = 123;\nvar b = true;\nvar c = null;\nvar d = '123';\nvar e = undefined;\nvar f = Symbol();\nvar g = 123n;\nvar h = new Date();\n// 字太丑了。。。代码可以看这里\n```\n\n![1](/image/深入内存世界/1.jpeg)\n\n\n\n### 堆内存和栈内存的总结\n\n| **栈内存**                   | 堆内存                       |\n| ---------------------------- | ---------------------------- |\n| 存储基础数据类型以及内存地址 | 存储引用数据类型以及闭包变量 |\n| 按值访问                     | 按引用（内存地址）访问       |\n| 存储的值大小固定             | 存储的值大小不定，可动态调整 |\n| 由系统自动分配内存空间       | 由代码进行指定分配           |\n| 空间小，运行效率高           | 空间大，运行效率相对较低     |\n\n\n\n## 深拷贝、浅拷贝、赋值铁人三项的不解渊源\n\n### 赋值\n\n赋值分两种情况：\n\n1. 创建新值\n\n   ```js\n   var a = 123;\n   var b = [1, 2, 3];\n   ```\n\n   这种就是赋新值的情况。\n\n2. 赋值已有的变量的值\n\n   在上面的例子基础上修改一下。\n\n   ```js\n   var a = 123;\n   var b = [1, 2, 3];\n   var A = a;\n   var B = b;\n   ```\n\n   这种情况就是赋值已有变量。\n\n👌，接下来来看一个例子，还是把👆的🌰修改一下\n\n```js\nvar a = 123;\nvar b = [1, 2, 3];\nvar A = a;\nvar B = b;\n\nA = 1234;\nconsole.log(a);\nconsole.log(A);\nB.push(4);\nconsole.log(b);\nconsole.log(B);\n```\n\n\n\n带🔥自己打开控制台，参与进来！看完之后然后再看看和自己的理解是不是一样，如果是一样的话，说明你很👍，不是的话就一起来看看👇的解释吧。\n\n我们观察之后发现，我们只修改了`B`但是，我们英俊的`b`也被修改了。\n\n？？？（脑补黑人问号脸）\n\n其实我们在开发过程中肯定是不希望这种情况的发生的，我们修改的只是`B`，不希望修改`b`的，不然我们肯定会写`b.push(4)`。\n\n这时就需要用到铁人三项的另外两个项目：浅拷贝和深拷贝。\n\n### 浅拷贝和深拷贝\n\n刚刚说到引用类型其实是放在堆内存中的，而栈内存里面只存指向堆内存的地址。（有点拗口....🧘‍♂️）\n\n浅拷贝浅拷贝，顾名思义。就是浅一点的拷贝，有多浅呢？\n\n一层那么浅。\n\n也就是说除了第一层的东西，第一层之外更深的层级就不是拷贝了，叫拿别人的地址。\n\n口说无凭，我弄个demo给大家🔥see see。\n\n![2](/image/深入内存世界/2.png)\n\n可以很清晰，清晰的不能再清晰的看到，浅拷贝出来的对象里面的属性`b`其实还是指向之前的对象，之前说过，再深的他就不拷贝了，验证的话就交给大家了，毕竟我们是一个动手节目组！\n\n那么浅拷贝有哪些方法呢？\n\n1. Object.assign()\n2. es6的扩展运算符`{...xxx}`\n3. Array.prototype.slice()\n\n### 深拷贝\n\n看看我那个完美的图就已经知道了，深拷贝就是完美的弄一个一模一样的出来。\n\n帅哥帅哥，深拷贝有啥办法捏？\n\n1. JSON.parse(JSON.stringify(object))\n   1. 会忽略 `undefined`\n   2.  会忽略 `symbol`\n   3. 不能序列化函数\n   4. 不能解决循环引用的对象\n   5. 不能正确处理`new Date()\n   6. 不能处理正则\n2. 自己写一个递归然后疯狂浅拷贝....\n3. 终极方案：lodash的[`cloneDeep`](https://www.lodashjs.com/docs/lodash.cloneDeep)\n\n### 总结\n\n|        | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象       |\n| ------ | ------------------------ | ------------------------ | ------------------------ |\n| 赋值   | 是                       | 改变会使原数据一起改变   | 改变会使原数据一起改变   |\n| 浅拷贝 | 否                       | 改变不会使原数据一起改变 | 改变会使原数据一起改变   |\n| 深拷贝 | 否                       | 改变不会使原数据一起改变 | 改变不会使原数据一起改变 |\n\n ## 垃圾回收机制♻️\n\nJavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间或者达到某个阈值就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。\n\n### 判断方式\n\nJavaScript是怎么判断某个变量是否需要被回收的？\n\n有以下几个方法\n\n### 标记清除\n\n比如一个函数内部声明的一个变量，一旦我们的主线程离开了这个函数，那么这个函数声明的一些变量外部就无法用到，那么就会被标记为\"离开环境\"。这样在下一个垃圾回收周期来领的时候，就自动释放了这些变量占用的内存。\n\n### 引用计数\n\n另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。\n\n引用计数有一个非常严重的BUG就是，如果存在循环引用的话，系统就无法判断你这个内存到底要不要回收了。而且引用的数字永远都不会是0。举个例子\n\n```js\nvar element = document.getElementById(\"some_element\"); \nvar myObject = new Object();\nmyObject.element = element;\nelement.someObject = myObject;\n```\n\n这样的话`element`和`myObject`这对情侣就永远如胶似漆，系统无法将他们送上天堂。\n\n那咋办？要拆散他们有一个主意，就是在不用的时候给他们置为`null`\n\n```js\nmyObject.element = null; \nelement.someObject = null;\n```\n\n将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。\n\n插播一个小故事\n\n> IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。\n>\n> 随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式:触发垃圾收集的变量分配、 字面量和(或)数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。\n>\n> ----摘自JavaScript高级程序设计\n\n## V8垃圾回收策略\n\n### 什么是V8？\n\n简单介绍一下什么是V8？\n\n> **V8**是一个由[Google](https://zh.wikipedia.org/wiki/Google)开发的[开源](https://zh.wikipedia.org/wiki/开源)[JavaScript引擎](https://zh.wikipedia.org/wiki/JavaScript引擎)，用于[Google Chrome](https://zh.wikipedia.org/wiki/Google_Chrome)及[Chromium](https://zh.wikipedia.org/wiki/Chromium)中[[2\\]](https://zh.wikipedia.org/wiki/V8_(JavaScript引擎)#cite_note-comic-2)。\n>\n> ---摘自维基百科\n\n既然V8是Chrome的引擎，那么别的浏览器呢？\n\n世界上主要的浏览器有以下三种。\n\n[**V8**](https://en.wikipedia.org/wiki/V8_(JavaScript_engine))——开源，由 Google 开发，使用 C++ 编写\n\n**[SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine))**——第一个 JavaScript 引擎，该引擎过去驱动 Netscape Navigator，如今驱动 Firefox 浏览器。\n\n**[JavaScriptCore](https://en.wikipedia.org/wiki/JavaScriptCore)**——开源，苹果公司为 Safair 浏览器开发的\n\n\n\nokokok，收！回归初心。\n\n### V8的垃圾回收策略\n\n我们的伟大的Chrome，根据不同的情况有不同的对策。他把内存分成两块\n\n- 新生代\n- 老生代\n\n#### 分代内存\n\n默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。\n\n新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。\n\n\n\n#### 新生代算法\n\n首先，我们科普一下什么是新生代。\n\n新生代的内存呢，就是存活时间比较短的对象。如果存活的时间比较长的话就会《晋升》为老生代。等一下会稍微详细的说一下《晋升》这个概念。\n\n新生代采用**Scavenge GC**垃圾回收算法，在算法实现时主要采用**Cheney**算法。\n\nCheney算法呢是将内存一分为二，一块暂时把他叫做《From》，另一块暂时叫做《To》。看一下下图，就可以很清晰的知道V8是怎么分割内存的。\n\n![3](/image/深入内存世界/3.png)\n\n内存的到来先进入From，然后等到From满了之后，新生代的GC就会启动。\n\n首先释放掉一些不再使用的内存，然后将From和To两个功能进行更换，也就是说之前的From -> To  之前的  To -> From。这样的话新生代的一轮GC就此结束了。\n\n这种算法有点类似空间换时间，而新生代的对象生命一般都是比较短的，所以所以非常适合新生代。\n\n#### 晋升\n\n对象的晋升其实主要有两个要求，就好像在来P6升P7有一堆的要求一样。\n\n1. 新生代算法刚刚我们已经学习过了，就是From和To的互换功能。如果一个对象他经历了两次的新生代的更替，还没有被回收内存，说明他很强。就需要晋升为老生代，让老生代的算法来对付他。就好像在阿里的一个P6两轮361都没有被淘汰说明他很有实力，所以直接升级他为P7。\n2. 如果一个对象在To的内存占比超过了25%，在第一次更替的时候就直接将他晋升为老生代了。可以理解为一个技术大牛，像马云，一去阿里就被星探发现，直接就是P7评级，不需要经过什么复杂的面试或者什么。\n\n\n\n#### 老生代算法\n\n根据刚刚对《晋升》的了解，我们知道了在老生代里面的对象都是一些难缠的选手，比如本来就占内存比例很大，或者经历过2次的新生代GC，依旧坚挺的选手。\n\n所以，V8在老生代中主要采用了**Mark-Sweep**和**Mark-Compact**相结合的方式进行垃圾回收。\n\n在介绍老生代算法之前，先科普一下**Mark-Sweep**和**Mark-Compact**。\n\n##### **Mark-Sweep**\n\nMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。\n\n与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。\n\n也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。\n\n> 在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 [该博客](https://v8project.blogspot.com/2018/06/concurrent-marking.html) 详细阅读。\n\n\n\n##### **Mark-Compact**\n\n在清除完对象后，这些对象在内存内部就不是连续的。这样内存地址就无法很好地利用起来，因为他们需要连续的内存，有的大的对象就无法塞入刚刚释放的小内存当中。\n\n而Mark-Compact就是用于解决内存碎片的问题，他主要干的活就是移动这些对象，让他们变成紧凑起来。\n\n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\n\n##### 总结\n\n在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。\n\n由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。\n\n\n\n## JavaScript内存泄漏\n\n### 什么是内存泄漏\n\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n\n**不再用到的内存，没有及时释放，就叫做内存泄漏**（memory leak）。\n\n### 常见的内存泄漏\n\n1. 定时器未及时清除\n\n2. 意外的全局变量\n\n   ```js\n   function foo(arg) {\n       bar = \"this is a hidden global variable\";  // 意外挂在在 window 全局变量，导致内存泄漏\n   }\n   ```\n\n   这里是想说一下高程（JavaScript高级程序设计第三版）里面的一个非常经典的demo。\n\n3. 闭包的滥用\n\n### WeakMap与WeakSet\n\n其实这两个在这篇文章里面的意义相同，只需要介绍一个就行。\n\n我们知道Map是简单的key-value。而且key可以为任意类型，比如引用类型，如果我们的key是引用类型那么他所占据的内存就无法被释放了。\n\n又有同学问题了，我有毛病啊，我非要引用类型吗？我string和number他不香吗？\n\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。\n\n```javascript\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n```\n\n上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。\n\n也就是说，上面的 DOM 节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\n\n总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。\n\n更多的知识就不讨论了，这里是内存世界！不是什么WeakMap专场哦。\n\n怎么验证？emmmmm....这里我copy一下阮一峰老师的内容。\n\n### 阮老师的demo\n\n首先，打开 Node 命令行。\n\n```bash\n$ node --expose-gc\n```\n\n上面代码中，`--expose-gc`参数表示允许手动执行垃圾回收机制。\n\n然后，执行下面的代码。\n\n```javascript\n// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n> global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapUsed 为 4M 左右\n> process.memoryUsage();\n{ rss: 21106688,\n  heapTotal: 7376896,\n  heapUsed: 4153936,\n  external: 9059 }\n\n> let wm = new WeakMap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n> let key = new Array(5 * 1024 * 1024);\nundefined\n\n// 设置 WeakMap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，WeakMap 的键名引用了第二次\n// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1\n> wm.set(key, 1);\nWeakMap {}\n\n> global.gc();\nundefined\n\n// 这时内存占用 heapUsed 增加到 45M 了\n> process.memoryUsage();\n{ rss: 67538944,\n  heapTotal: 7376896,\n  heapUsed: 45782816,\n  external: 8945 }\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 WeakMap 实例的键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc();\nundefined\n\n// 内存占用 heapUsed 变回 4M 左右，\n// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收\n> process.memoryUsage();\n{ rss: 20639744,\n  heapTotal: 8425472,\n  heapUsed: 3979792,\n  external: 8956 }\n```\n\n上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。\n\n## 看完几件事\n\n如果你觉得对你有帮助，就帮我点个赞吧，也算是对我的肯定。谢谢，如果有错误的地方欢迎大家指出来。一起讨论学习。我是Derrick，一名正在去阿里路上的前端开发工程师。\n\n## reference\n\n> [https://muyiy.cn/blog/1/1.3.html#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84](https://muyiy.cn/blog/1/1.3.html#栈数据结构)\n>\n> http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\n>\n> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\n>\n> https://juejin.im/post/6844903615300108302\n>\n> https://juejin.im/post/6844903591510016007\n>\n> JavaScript高级程序设计（第三版）\n\n","source":"_posts/【重识前端】深入内存世界.md","raw":"---\ntitle: 【重识前端】深入内存世界\ndate: 2020-08-25 23:05:00\ntags: [JavaScript]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n## 前言\n\n用于记录本人的学习过程，希望可以帮助到大家~🤠\n\nJavaScript有自动垃圾回收机制，可能因为这个自动让我们前端开发人员忽略了对他的认识（包括我自己），但是阿里的面试官可不会和你嘻嘻哈哈。\n\n“垃圾回收的机制是什么？什么时候会去触发”\n\n我一脸懵逼....啥...这个不是他自己运行的吗...🤕\n\n还是老规矩，黄金圈法则：\n\n### 为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\n\n计算机在启动一个程序的时候，会为他分配一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。我们知道电脑的内存其实是有限的，比如常见的8G、16G等等，甚至还有一些什么虚拟内存就讨论了。我们关注点在于内存是一个种稀缺资源，对于不用的东西我们不要#占着茅坑不拉屎#。\n\n**所以垃圾回收的作用就是释放一下不再使用的内存空间。**\n\n### 内存的结构\n\nJavaScript中，分为两种内存空间\n\n- 堆内存->存储引用类型\n- 栈内存->存储基本类型\n\n> 基本类型又叫原始类型；因为本人已经说习惯了基本类型，所以以下都叫做基本类型哈。\n\n\n\n## 引用类型、基本类型与堆栈的爱恨纠葛\n\n### 变量存放\n\n#### 基本类型\n\n截止北京时间2020年8月25日；\n\n在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)中显示的基本类型（原始类型）有以下7种\n\n- [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean)\n- [Null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null)\n- [Undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/undefined)\n- [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number)\n- [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt)\n- [String](https://developer.mozilla.org/zh-CN/docs/Glossary/字符串)\n- [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol) \n\n基本类型是存储在栈内存里面的。栈内存里面还存着指向堆内存的内存地址。\n\n> PS：闭包中，基本类型也是存放在堆内存中的哦，要注意一下。\n\n#### 引用类型\n\n除了基本类型的数据结构就是引用类型，包括什么数组（Array）、函数（Function）、对象（Object）之类的都是引用类型。\n\n引用类型和闭包的变量都是存储在堆内存中的。而指针或者说内存地址是存在栈内存的。\n\n> 当查询引用类型的变量时， 先从**栈中读取内存地址**， 然后再通过地址**找到堆中的值**。对于这种，我们把它叫做按引用访问。\n\n干说有点难理解。身为马良的我给大家画一幅画，帮助理解。\n\n```js\nvar a = 123;\nvar b = true;\nvar c = null;\nvar d = '123';\nvar e = undefined;\nvar f = Symbol();\nvar g = 123n;\nvar h = new Date();\n// 字太丑了。。。代码可以看这里\n```\n\n![1](/image/深入内存世界/1.jpeg)\n\n\n\n### 堆内存和栈内存的总结\n\n| **栈内存**                   | 堆内存                       |\n| ---------------------------- | ---------------------------- |\n| 存储基础数据类型以及内存地址 | 存储引用数据类型以及闭包变量 |\n| 按值访问                     | 按引用（内存地址）访问       |\n| 存储的值大小固定             | 存储的值大小不定，可动态调整 |\n| 由系统自动分配内存空间       | 由代码进行指定分配           |\n| 空间小，运行效率高           | 空间大，运行效率相对较低     |\n\n\n\n## 深拷贝、浅拷贝、赋值铁人三项的不解渊源\n\n### 赋值\n\n赋值分两种情况：\n\n1. 创建新值\n\n   ```js\n   var a = 123;\n   var b = [1, 2, 3];\n   ```\n\n   这种就是赋新值的情况。\n\n2. 赋值已有的变量的值\n\n   在上面的例子基础上修改一下。\n\n   ```js\n   var a = 123;\n   var b = [1, 2, 3];\n   var A = a;\n   var B = b;\n   ```\n\n   这种情况就是赋值已有变量。\n\n👌，接下来来看一个例子，还是把👆的🌰修改一下\n\n```js\nvar a = 123;\nvar b = [1, 2, 3];\nvar A = a;\nvar B = b;\n\nA = 1234;\nconsole.log(a);\nconsole.log(A);\nB.push(4);\nconsole.log(b);\nconsole.log(B);\n```\n\n\n\n带🔥自己打开控制台，参与进来！看完之后然后再看看和自己的理解是不是一样，如果是一样的话，说明你很👍，不是的话就一起来看看👇的解释吧。\n\n我们观察之后发现，我们只修改了`B`但是，我们英俊的`b`也被修改了。\n\n？？？（脑补黑人问号脸）\n\n其实我们在开发过程中肯定是不希望这种情况的发生的，我们修改的只是`B`，不希望修改`b`的，不然我们肯定会写`b.push(4)`。\n\n这时就需要用到铁人三项的另外两个项目：浅拷贝和深拷贝。\n\n### 浅拷贝和深拷贝\n\n刚刚说到引用类型其实是放在堆内存中的，而栈内存里面只存指向堆内存的地址。（有点拗口....🧘‍♂️）\n\n浅拷贝浅拷贝，顾名思义。就是浅一点的拷贝，有多浅呢？\n\n一层那么浅。\n\n也就是说除了第一层的东西，第一层之外更深的层级就不是拷贝了，叫拿别人的地址。\n\n口说无凭，我弄个demo给大家🔥see see。\n\n![2](/image/深入内存世界/2.png)\n\n可以很清晰，清晰的不能再清晰的看到，浅拷贝出来的对象里面的属性`b`其实还是指向之前的对象，之前说过，再深的他就不拷贝了，验证的话就交给大家了，毕竟我们是一个动手节目组！\n\n那么浅拷贝有哪些方法呢？\n\n1. Object.assign()\n2. es6的扩展运算符`{...xxx}`\n3. Array.prototype.slice()\n\n### 深拷贝\n\n看看我那个完美的图就已经知道了，深拷贝就是完美的弄一个一模一样的出来。\n\n帅哥帅哥，深拷贝有啥办法捏？\n\n1. JSON.parse(JSON.stringify(object))\n   1. 会忽略 `undefined`\n   2.  会忽略 `symbol`\n   3. 不能序列化函数\n   4. 不能解决循环引用的对象\n   5. 不能正确处理`new Date()\n   6. 不能处理正则\n2. 自己写一个递归然后疯狂浅拷贝....\n3. 终极方案：lodash的[`cloneDeep`](https://www.lodashjs.com/docs/lodash.cloneDeep)\n\n### 总结\n\n|        | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象       |\n| ------ | ------------------------ | ------------------------ | ------------------------ |\n| 赋值   | 是                       | 改变会使原数据一起改变   | 改变会使原数据一起改变   |\n| 浅拷贝 | 否                       | 改变不会使原数据一起改变 | 改变会使原数据一起改变   |\n| 深拷贝 | 否                       | 改变不会使原数据一起改变 | 改变不会使原数据一起改变 |\n\n ## 垃圾回收机制♻️\n\nJavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间或者达到某个阈值就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。\n\n### 判断方式\n\nJavaScript是怎么判断某个变量是否需要被回收的？\n\n有以下几个方法\n\n### 标记清除\n\n比如一个函数内部声明的一个变量，一旦我们的主线程离开了这个函数，那么这个函数声明的一些变量外部就无法用到，那么就会被标记为\"离开环境\"。这样在下一个垃圾回收周期来领的时候，就自动释放了这些变量占用的内存。\n\n### 引用计数\n\n另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。\n\n引用计数有一个非常严重的BUG就是，如果存在循环引用的话，系统就无法判断你这个内存到底要不要回收了。而且引用的数字永远都不会是0。举个例子\n\n```js\nvar element = document.getElementById(\"some_element\"); \nvar myObject = new Object();\nmyObject.element = element;\nelement.someObject = myObject;\n```\n\n这样的话`element`和`myObject`这对情侣就永远如胶似漆，系统无法将他们送上天堂。\n\n那咋办？要拆散他们有一个主意，就是在不用的时候给他们置为`null`\n\n```js\nmyObject.element = null; \nelement.someObject = null;\n```\n\n将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。\n\n插播一个小故事\n\n> IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。\n>\n> 随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式:触发垃圾收集的变量分配、 字面量和(或)数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。\n>\n> ----摘自JavaScript高级程序设计\n\n## V8垃圾回收策略\n\n### 什么是V8？\n\n简单介绍一下什么是V8？\n\n> **V8**是一个由[Google](https://zh.wikipedia.org/wiki/Google)开发的[开源](https://zh.wikipedia.org/wiki/开源)[JavaScript引擎](https://zh.wikipedia.org/wiki/JavaScript引擎)，用于[Google Chrome](https://zh.wikipedia.org/wiki/Google_Chrome)及[Chromium](https://zh.wikipedia.org/wiki/Chromium)中[[2\\]](https://zh.wikipedia.org/wiki/V8_(JavaScript引擎)#cite_note-comic-2)。\n>\n> ---摘自维基百科\n\n既然V8是Chrome的引擎，那么别的浏览器呢？\n\n世界上主要的浏览器有以下三种。\n\n[**V8**](https://en.wikipedia.org/wiki/V8_(JavaScript_engine))——开源，由 Google 开发，使用 C++ 编写\n\n**[SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine))**——第一个 JavaScript 引擎，该引擎过去驱动 Netscape Navigator，如今驱动 Firefox 浏览器。\n\n**[JavaScriptCore](https://en.wikipedia.org/wiki/JavaScriptCore)**——开源，苹果公司为 Safair 浏览器开发的\n\n\n\nokokok，收！回归初心。\n\n### V8的垃圾回收策略\n\n我们的伟大的Chrome，根据不同的情况有不同的对策。他把内存分成两块\n\n- 新生代\n- 老生代\n\n#### 分代内存\n\n默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。\n\n新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。\n\n\n\n#### 新生代算法\n\n首先，我们科普一下什么是新生代。\n\n新生代的内存呢，就是存活时间比较短的对象。如果存活的时间比较长的话就会《晋升》为老生代。等一下会稍微详细的说一下《晋升》这个概念。\n\n新生代采用**Scavenge GC**垃圾回收算法，在算法实现时主要采用**Cheney**算法。\n\nCheney算法呢是将内存一分为二，一块暂时把他叫做《From》，另一块暂时叫做《To》。看一下下图，就可以很清晰的知道V8是怎么分割内存的。\n\n![3](/image/深入内存世界/3.png)\n\n内存的到来先进入From，然后等到From满了之后，新生代的GC就会启动。\n\n首先释放掉一些不再使用的内存，然后将From和To两个功能进行更换，也就是说之前的From -> To  之前的  To -> From。这样的话新生代的一轮GC就此结束了。\n\n这种算法有点类似空间换时间，而新生代的对象生命一般都是比较短的，所以所以非常适合新生代。\n\n#### 晋升\n\n对象的晋升其实主要有两个要求，就好像在来P6升P7有一堆的要求一样。\n\n1. 新生代算法刚刚我们已经学习过了，就是From和To的互换功能。如果一个对象他经历了两次的新生代的更替，还没有被回收内存，说明他很强。就需要晋升为老生代，让老生代的算法来对付他。就好像在阿里的一个P6两轮361都没有被淘汰说明他很有实力，所以直接升级他为P7。\n2. 如果一个对象在To的内存占比超过了25%，在第一次更替的时候就直接将他晋升为老生代了。可以理解为一个技术大牛，像马云，一去阿里就被星探发现，直接就是P7评级，不需要经过什么复杂的面试或者什么。\n\n\n\n#### 老生代算法\n\n根据刚刚对《晋升》的了解，我们知道了在老生代里面的对象都是一些难缠的选手，比如本来就占内存比例很大，或者经历过2次的新生代GC，依旧坚挺的选手。\n\n所以，V8在老生代中主要采用了**Mark-Sweep**和**Mark-Compact**相结合的方式进行垃圾回收。\n\n在介绍老生代算法之前，先科普一下**Mark-Sweep**和**Mark-Compact**。\n\n##### **Mark-Sweep**\n\nMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。\n\n与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。\n\n也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。\n\n> 在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 [该博客](https://v8project.blogspot.com/2018/06/concurrent-marking.html) 详细阅读。\n\n\n\n##### **Mark-Compact**\n\n在清除完对象后，这些对象在内存内部就不是连续的。这样内存地址就无法很好地利用起来，因为他们需要连续的内存，有的大的对象就无法塞入刚刚释放的小内存当中。\n\n而Mark-Compact就是用于解决内存碎片的问题，他主要干的活就是移动这些对象，让他们变成紧凑起来。\n\n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\n\n##### 总结\n\n在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。\n\n由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。\n\n\n\n## JavaScript内存泄漏\n\n### 什么是内存泄漏\n\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n\n**不再用到的内存，没有及时释放，就叫做内存泄漏**（memory leak）。\n\n### 常见的内存泄漏\n\n1. 定时器未及时清除\n\n2. 意外的全局变量\n\n   ```js\n   function foo(arg) {\n       bar = \"this is a hidden global variable\";  // 意外挂在在 window 全局变量，导致内存泄漏\n   }\n   ```\n\n   这里是想说一下高程（JavaScript高级程序设计第三版）里面的一个非常经典的demo。\n\n3. 闭包的滥用\n\n### WeakMap与WeakSet\n\n其实这两个在这篇文章里面的意义相同，只需要介绍一个就行。\n\n我们知道Map是简单的key-value。而且key可以为任意类型，比如引用类型，如果我们的key是引用类型那么他所占据的内存就无法被释放了。\n\n又有同学问题了，我有毛病啊，我非要引用类型吗？我string和number他不香吗？\n\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。\n\n```javascript\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n```\n\n上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。\n\n也就是说，上面的 DOM 节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\n\n总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。\n\n更多的知识就不讨论了，这里是内存世界！不是什么WeakMap专场哦。\n\n怎么验证？emmmmm....这里我copy一下阮一峰老师的内容。\n\n### 阮老师的demo\n\n首先，打开 Node 命令行。\n\n```bash\n$ node --expose-gc\n```\n\n上面代码中，`--expose-gc`参数表示允许手动执行垃圾回收机制。\n\n然后，执行下面的代码。\n\n```javascript\n// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n> global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapUsed 为 4M 左右\n> process.memoryUsage();\n{ rss: 21106688,\n  heapTotal: 7376896,\n  heapUsed: 4153936,\n  external: 9059 }\n\n> let wm = new WeakMap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n> let key = new Array(5 * 1024 * 1024);\nundefined\n\n// 设置 WeakMap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，WeakMap 的键名引用了第二次\n// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1\n> wm.set(key, 1);\nWeakMap {}\n\n> global.gc();\nundefined\n\n// 这时内存占用 heapUsed 增加到 45M 了\n> process.memoryUsage();\n{ rss: 67538944,\n  heapTotal: 7376896,\n  heapUsed: 45782816,\n  external: 8945 }\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 WeakMap 实例的键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc();\nundefined\n\n// 内存占用 heapUsed 变回 4M 左右，\n// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收\n> process.memoryUsage();\n{ rss: 20639744,\n  heapTotal: 8425472,\n  heapUsed: 3979792,\n  external: 8956 }\n```\n\n上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。\n\n## 看完几件事\n\n如果你觉得对你有帮助，就帮我点个赞吧，也算是对我的肯定。谢谢，如果有错误的地方欢迎大家指出来。一起讨论学习。我是Derrick，一名正在去阿里路上的前端开发工程师。\n\n## reference\n\n> [https://muyiy.cn/blog/1/1.3.html#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84](https://muyiy.cn/blog/1/1.3.html#栈数据结构)\n>\n> http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\n>\n> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\n>\n> https://juejin.im/post/6844903615300108302\n>\n> https://juejin.im/post/6844903591510016007\n>\n> JavaScript高级程序设计（第三版）\n\n","slug":"【重识前端】深入内存世界","published":1,"updated":"2021-06-24T14:00:06.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8s0024lwrdh8gvdkxa","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用于记录本人的学习过程，希望可以帮助到大家~🤠</p>\n<p>JavaScript有自动垃圾回收机制，可能因为这个自动让我们前端开发人员忽略了对他的认识（包括我自己），但是阿里的面试官可不会和你嘻嘻哈哈。</p>\n<p>“垃圾回收的机制是什么？什么时候会去触发”</p>\n<p>我一脸懵逼….啥…这个不是他自己运行的吗…🤕</p>\n<p>还是老规矩，黄金圈法则：</p>\n<h3 id=\"为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\"><a href=\"#为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\" class=\"headerlink\" title=\"为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\"></a>为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？</h3><p>计算机在启动一个程序的时候，会为他分配一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。我们知道电脑的内存其实是有限的，比如常见的8G、16G等等，甚至还有一些什么虚拟内存就讨论了。我们关注点在于内存是一个种稀缺资源，对于不用的东西我们不要#占着茅坑不拉屎#。</p>\n<p><strong>所以垃圾回收的作用就是释放一下不再使用的内存空间。</strong></p>\n<h3 id=\"内存的结构\"><a href=\"#内存的结构\" class=\"headerlink\" title=\"内存的结构\"></a>内存的结构</h3><p>JavaScript中，分为两种内存空间</p>\n<ul>\n<li>堆内存-&gt;存储引用类型</li>\n<li>栈内存-&gt;存储基本类型</li>\n</ul>\n<blockquote>\n<p>基本类型又叫原始类型；因为本人已经说习惯了基本类型，所以以下都叫做基本类型哈。</p>\n</blockquote>\n<h2 id=\"引用类型、基本类型与堆栈的爱恨纠葛\"><a href=\"#引用类型、基本类型与堆栈的爱恨纠葛\" class=\"headerlink\" title=\"引用类型、基本类型与堆栈的爱恨纠葛\"></a>引用类型、基本类型与堆栈的爱恨纠葛</h2><h3 id=\"变量存放\"><a href=\"#变量存放\" class=\"headerlink\" title=\"变量存放\"></a>变量存放</h3><h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><p>截止北京时间2020年8月25日；</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\" target=\"_blank\" rel=\"noopener\">MDN</a>中显示的基本类型（原始类型）有以下7种</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean\" target=\"_blank\" rel=\"noopener\">Boolean</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Null\" target=\"_blank\" rel=\"noopener\">Null</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/undefined\" target=\"_blank\" rel=\"noopener\">Undefined</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Number\" target=\"_blank\" rel=\"noopener\">Number</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt\" target=\"_blank\" rel=\"noopener\">BigInt</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/字符串\" target=\"_blank\" rel=\"noopener\">String</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol\" target=\"_blank\" rel=\"noopener\">Symbol</a> </li>\n</ul>\n<p>基本类型是存储在栈内存里面的。栈内存里面还存着指向堆内存的内存地址。</p>\n<blockquote>\n<p>PS：闭包中，基本类型也是存放在堆内存中的哦，要注意一下。</p>\n</blockquote>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>除了基本类型的数据结构就是引用类型，包括什么数组（Array）、函数（Function）、对象（Object）之类的都是引用类型。</p>\n<p>引用类型和闭包的变量都是存储在堆内存中的。而指针或者说内存地址是存在栈内存的。</p>\n<blockquote>\n<p>当查询引用类型的变量时， 先从<strong>栈中读取内存地址</strong>， 然后再通过地址<strong>找到堆中的值</strong>。对于这种，我们把它叫做按引用访问。</p>\n</blockquote>\n<p>干说有点难理解。身为马良的我给大家画一幅画，帮助理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">'123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"number\">123n</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"comment\">// 字太丑了。。。代码可以看这里</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/1.jpeg\"  alt=\"1\"></p>\n<h3 id=\"堆内存和栈内存的总结\"><a href=\"#堆内存和栈内存的总结\" class=\"headerlink\" title=\"堆内存和栈内存的总结\"></a>堆内存和栈内存的总结</h3><table>\n<thead>\n<tr>\n<th><strong>栈内存</strong></th>\n<th>堆内存</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储基础数据类型以及内存地址</td>\n<td>存储引用数据类型以及闭包变量</td>\n</tr>\n<tr>\n<td>按值访问</td>\n<td>按引用（内存地址）访问</td>\n</tr>\n<tr>\n<td>存储的值大小固定</td>\n<td>存储的值大小不定，可动态调整</td>\n</tr>\n<tr>\n<td>由系统自动分配内存空间</td>\n<td>由代码进行指定分配</td>\n</tr>\n<tr>\n<td>空间小，运行效率高</td>\n<td>空间大，运行效率相对较低</td>\n</tr>\n</tbody></table>\n<h2 id=\"深拷贝、浅拷贝、赋值铁人三项的不解渊源\"><a href=\"#深拷贝、浅拷贝、赋值铁人三项的不解渊源\" class=\"headerlink\" title=\"深拷贝、浅拷贝、赋值铁人三项的不解渊源\"></a>深拷贝、浅拷贝、赋值铁人三项的不解渊源</h2><h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>赋值分两种情况：</p>\n<ol>\n<li><p>创建新值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这种就是赋新值的情况。</p>\n</li>\n<li><p>赋值已有的变量的值</p>\n<p>在上面的例子基础上修改一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> B = b;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况就是赋值已有变量。</p>\n</li>\n</ol>\n<p>👌，接下来来看一个例子，还是把👆的🌰修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> B = b;</span><br><span class=\"line\"></span><br><span class=\"line\">A = <span class=\"number\">1234</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(A);</span><br><span class=\"line\">B.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(B);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>带🔥自己打开控制台，参与进来！看完之后然后再看看和自己的理解是不是一样，如果是一样的话，说明你很👍，不是的话就一起来看看👇的解释吧。</p>\n<p>我们观察之后发现，我们只修改了<code>B</code>但是，我们英俊的<code>b</code>也被修改了。</p>\n<p>？？？（脑补黑人问号脸）</p>\n<p>其实我们在开发过程中肯定是不希望这种情况的发生的，我们修改的只是<code>B</code>，不希望修改<code>b</code>的，不然我们肯定会写<code>b.push(4)</code>。</p>\n<p>这时就需要用到铁人三项的另外两个项目：浅拷贝和深拷贝。</p>\n<h3 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h3><p>刚刚说到引用类型其实是放在堆内存中的，而栈内存里面只存指向堆内存的地址。（有点拗口….🧘‍♂️）</p>\n<p>浅拷贝浅拷贝，顾名思义。就是浅一点的拷贝，有多浅呢？</p>\n<p>一层那么浅。</p>\n<p>也就是说除了第一层的东西，第一层之外更深的层级就不是拷贝了，叫拿别人的地址。</p>\n<p>口说无凭，我弄个demo给大家🔥see see。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/2.png\"  alt=\"2\"></p>\n<p>可以很清晰，清晰的不能再清晰的看到，浅拷贝出来的对象里面的属性<code>b</code>其实还是指向之前的对象，之前说过，再深的他就不拷贝了，验证的话就交给大家了，毕竟我们是一个动手节目组！</p>\n<p>那么浅拷贝有哪些方法呢？</p>\n<ol>\n<li>Object.assign()</li>\n<li>es6的扩展运算符<code>{...xxx}</code></li>\n<li>Array.prototype.slice()</li>\n</ol>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>看看我那个完美的图就已经知道了，深拷贝就是完美的弄一个一模一样的出来。</p>\n<p>帅哥帅哥，深拷贝有啥办法捏？</p>\n<ol>\n<li>JSON.parse(JSON.stringify(object))<ol>\n<li>会忽略 <code>undefined</code></li>\n<li>会忽略 <code>symbol</code></li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象</li>\n<li>不能正确处理`new Date()</li>\n<li>不能处理正则</li>\n</ol>\n</li>\n<li>自己写一个递归然后疯狂浅拷贝….</li>\n<li>终极方案：lodash的<a href=\"https://www.lodashjs.com/docs/lodash.cloneDeep\" target=\"_blank\" rel=\"noopener\"><code>cloneDeep</code></a></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>和原数据是否指向同一对象</th>\n<th>第一层数据为基本数据类型</th>\n<th>原数据中包含子对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>赋值</td>\n<td>是</td>\n<td>改变会使原数据一起改变</td>\n<td>改变会使原数据一起改变</td>\n</tr>\n<tr>\n<td>浅拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一起改变</td>\n<td>改变会使原数据一起改变</td>\n</tr>\n<tr>\n<td>深拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一起改变</td>\n<td>改变不会使原数据一起改变</td>\n</tr>\n</tbody></table>\n<h2 id=\"垃圾回收机制♻️\"><a href=\"#垃圾回收机制♻️\" class=\"headerlink\" title=\"垃圾回收机制♻️\"></a>垃圾回收机制♻️</h2><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间或者达到某个阈值就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p>\n<h3 id=\"判断方式\"><a href=\"#判断方式\" class=\"headerlink\" title=\"判断方式\"></a>判断方式</h3><p>JavaScript是怎么判断某个变量是否需要被回收的？</p>\n<p>有以下几个方法</p>\n<h3 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h3><p>比如一个函数内部声明的一个变量，一旦我们的主线程离开了这个函数，那么这个函数声明的一些变量外部就无法用到，那么就会被标记为”离开环境”。这样在下一个垃圾回收周期来领的时候，就自动释放了这些变量占用的内存。</p>\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。</p>\n<p>引用计数有一个非常严重的BUG就是，如果存在循环引用的话，系统就无法判断你这个内存到底要不要回收了。而且引用的数字永远都不会是0。举个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObject.element = element;</span><br><span class=\"line\">element.someObject = myObject;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话<code>element</code>和<code>myObject</code>这对情侣就永远如胶似漆，系统无法将他们送上天堂。</p>\n<p>那咋办？要拆散他们有一个主意，就是在不用的时候给他们置为<code>null</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.element = <span class=\"literal\">null</span>; </span><br><span class=\"line\">element.someObject = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。</p>\n<p>插播一个小故事</p>\n<blockquote>\n<p>IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。</p>\n<p>随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式:触发垃圾收集的变量分配、 字面量和(或)数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。</p>\n<p>—-摘自JavaScript高级程序设计</p>\n</blockquote>\n<h2 id=\"V8垃圾回收策略\"><a href=\"#V8垃圾回收策略\" class=\"headerlink\" title=\"V8垃圾回收策略\"></a>V8垃圾回收策略</h2><h3 id=\"什么是V8？\"><a href=\"#什么是V8？\" class=\"headerlink\" title=\"什么是V8？\"></a>什么是V8？</h3><p>简单介绍一下什么是V8？</p>\n<blockquote>\n<p><strong>V8</strong>是一个由<a href=\"https://zh.wikipedia.org/wiki/Google\" target=\"_blank\" rel=\"noopener\">Google</a>开发的<a href=\"https://zh.wikipedia.org/wiki/开源\" target=\"_blank\" rel=\"noopener\">开源</a><a href=\"https://zh.wikipedia.org/wiki/JavaScript引擎\" target=\"_blank\" rel=\"noopener\">JavaScript引擎</a>，用于<a href=\"https://zh.wikipedia.org/wiki/Google_Chrome\" target=\"_blank\" rel=\"noopener\">Google Chrome</a>及<a href=\"https://zh.wikipedia.org/wiki/Chromium\" target=\"_blank\" rel=\"noopener\">Chromium</a>中<a href=\"https://zh.wikipedia.org/wiki/V8_(JavaScript引擎)#cite_note-comic-2\" target=\"_blank\" rel=\"noopener\">[2]</a>。</p>\n<p>—摘自维基百科</p>\n</blockquote>\n<p>既然V8是Chrome的引擎，那么别的浏览器呢？</p>\n<p>世界上主要的浏览器有以下三种。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/V8_(JavaScript_engine)\" target=\"_blank\" rel=\"noopener\"><strong>V8</strong></a>——开源，由 Google 开发，使用 C++ 编写</p>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine)\" target=\"_blank\" rel=\"noopener\">SpiderMonkey</a></strong>——第一个 JavaScript 引擎，该引擎过去驱动 Netscape Navigator，如今驱动 Firefox 浏览器。</p>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/JavaScriptCore\" target=\"_blank\" rel=\"noopener\">JavaScriptCore</a></strong>——开源，苹果公司为 Safair 浏览器开发的</p>\n<p>okokok，收！回归初心。</p>\n<h3 id=\"V8的垃圾回收策略\"><a href=\"#V8的垃圾回收策略\" class=\"headerlink\" title=\"V8的垃圾回收策略\"></a>V8的垃圾回收策略</h3><p>我们的伟大的Chrome，根据不同的情况有不同的对策。他把内存分成两块</p>\n<ul>\n<li>新生代</li>\n<li>老生代</li>\n</ul>\n<h4 id=\"分代内存\"><a href=\"#分代内存\" class=\"headerlink\" title=\"分代内存\"></a>分代内存</h4><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p>\n<p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p>\n<h4 id=\"新生代算法\"><a href=\"#新生代算法\" class=\"headerlink\" title=\"新生代算法\"></a>新生代算法</h4><p>首先，我们科普一下什么是新生代。</p>\n<p>新生代的内存呢，就是存活时间比较短的对象。如果存活的时间比较长的话就会《晋升》为老生代。等一下会稍微详细的说一下《晋升》这个概念。</p>\n<p>新生代采用<strong>Scavenge GC</strong>垃圾回收算法，在算法实现时主要采用<strong>Cheney</strong>算法。</p>\n<p>Cheney算法呢是将内存一分为二，一块暂时把他叫做《From》，另一块暂时叫做《To》。看一下下图，就可以很清晰的知道V8是怎么分割内存的。</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/3.png\"  alt=\"3\"></p>\n<p>内存的到来先进入From，然后等到From满了之后，新生代的GC就会启动。</p>\n<p>首先释放掉一些不再使用的内存，然后将From和To两个功能进行更换，也就是说之前的From -&gt; To  之前的  To -&gt; From。这样的话新生代的一轮GC就此结束了。</p>\n<p>这种算法有点类似空间换时间，而新生代的对象生命一般都是比较短的，所以所以非常适合新生代。</p>\n<h4 id=\"晋升\"><a href=\"#晋升\" class=\"headerlink\" title=\"晋升\"></a>晋升</h4><p>对象的晋升其实主要有两个要求，就好像在来P6升P7有一堆的要求一样。</p>\n<ol>\n<li>新生代算法刚刚我们已经学习过了，就是From和To的互换功能。如果一个对象他经历了两次的新生代的更替，还没有被回收内存，说明他很强。就需要晋升为老生代，让老生代的算法来对付他。就好像在阿里的一个P6两轮361都没有被淘汰说明他很有实力，所以直接升级他为P7。</li>\n<li>如果一个对象在To的内存占比超过了25%，在第一次更替的时候就直接将他晋升为老生代了。可以理解为一个技术大牛，像马云，一去阿里就被星探发现，直接就是P7评级，不需要经过什么复杂的面试或者什么。</li>\n</ol>\n<h4 id=\"老生代算法\"><a href=\"#老生代算法\" class=\"headerlink\" title=\"老生代算法\"></a>老生代算法</h4><p>根据刚刚对《晋升》的了解，我们知道了在老生代里面的对象都是一些难缠的选手，比如本来就占内存比例很大，或者经历过2次的新生代GC，依旧坚挺的选手。</p>\n<p>所以，V8在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>相结合的方式进行垃圾回收。</p>\n<p>在介绍老生代算法之前，先科普一下<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>。</p>\n<h5 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a><strong>Mark-Sweep</strong></h5><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。</p>\n<p>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p>\n<p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p>\n<blockquote>\n<p>在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href=\"https://v8project.blogspot.com/2018/06/concurrent-marking.html\" target=\"_blank\" rel=\"noopener\">该博客</a> 详细阅读。</p>\n</blockquote>\n<h5 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a><strong>Mark-Compact</strong></h5><p>在清除完对象后，这些对象在内存内部就不是连续的。这样内存地址就无法很好地利用起来，因为他们需要连续的内存，有的大的对象就无法塞入刚刚释放的小内存当中。</p>\n<p>而Mark-Compact就是用于解决内存碎片的问题，他主要干的活就是移动这些对象，让他们变成紧凑起来。</p>\n<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。</p>\n<p>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p>\n<h2 id=\"JavaScript内存泄漏\"><a href=\"#JavaScript内存泄漏\" class=\"headerlink\" title=\"JavaScript内存泄漏\"></a>JavaScript内存泄漏</h2><h3 id=\"什么是内存泄漏\"><a href=\"#什么是内存泄漏\" class=\"headerlink\" title=\"什么是内存泄漏\"></a>什么是内存泄漏</h3><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p><strong>不再用到的内存，没有及时释放，就叫做内存泄漏</strong>（memory leak）。</p>\n<h3 id=\"常见的内存泄漏\"><a href=\"#常见的内存泄漏\" class=\"headerlink\" title=\"常见的内存泄漏\"></a>常见的内存泄漏</h3><ol>\n<li><p>定时器未及时清除</p>\n</li>\n<li><p>意外的全局变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    bar = <span class=\"string\">\"this is a hidden global variable\"</span>;  <span class=\"comment\">// 意外挂在在 window 全局变量，导致内存泄漏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是想说一下高程（JavaScript高级程序设计第三版）里面的一个非常经典的demo。</p>\n</li>\n<li><p>闭包的滥用</p>\n</li>\n</ol>\n<h3 id=\"WeakMap与WeakSet\"><a href=\"#WeakMap与WeakSet\" class=\"headerlink\" title=\"WeakMap与WeakSet\"></a>WeakMap与WeakSet</h3><p>其实这两个在这篇文章里面的意义相同，只需要介绍一个就行。</p>\n<p>我们知道Map是简单的key-value。而且key可以为任意类型，比如引用类型，如果我们的key是引用类型那么他所占据的内存就无法被释放了。</p>\n<p>又有同学问题了，我有毛病啊，我非要引用类型吗？我string和number他不香吗？</p>\n<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">wm.set(element, <span class=\"string\">'some information'</span>);</span><br><span class=\"line\">wm.get(element) <span class=\"comment\">// \"some information\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>\n<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>\n<p>更多的知识就不讨论了，这里是内存世界！不是什么WeakMap专场哦。</p>\n<p>怎么验证？emmmmm….这里我copy一下阮一峰老师的内容。</p>\n<h3 id=\"阮老师的demo\"><a href=\"#阮老师的demo\" class=\"headerlink\" title=\"阮老师的demo\"></a>阮老师的demo</h3><p>首先，打开 Node 命令行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node --expose-gc</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>\n<p>然后，执行下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">21106688</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">7376896</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">4153936</span>,</span><br><span class=\"line\">  external: <span class=\"number\">9059</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; <span class=\"keyword\">let</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个变量 key，指向一个 5*1024*1024 的数组</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 WeakMap 实例的键名，也指向 key 数组</span></span><br><span class=\"line\"><span class=\"comment\">// 这时，key 数组实际被引用了两次，</span></span><br><span class=\"line\"><span class=\"comment\">// 变量 key 引用一次，WeakMap 的键名引用了第二次</span></span><br><span class=\"line\"><span class=\"comment\">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1</span></span><br><span class=\"line\">&gt; wm.set(key, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">WeakMap</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这时内存占用 heapUsed 增加到 45M 了</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">67538944</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">7376896</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">45782816</span>,</span><br><span class=\"line\">  external: <span class=\"number\">8945</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除变量 key 对数组的引用，</span></span><br><span class=\"line\"><span class=\"comment\">// 但没有手动清除 WeakMap 实例的键名对数组的引用</span></span><br><span class=\"line\">&gt; key = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次执行垃圾回收</span></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内存占用 heapUsed 变回 4M 左右，</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">20639744</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">8425472</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">3979792</span>,</span><br><span class=\"line\">  external: <span class=\"number\">8956</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>\n<h2 id=\"看完几件事\"><a href=\"#看完几件事\" class=\"headerlink\" title=\"看完几件事\"></a>看完几件事</h2><p>如果你觉得对你有帮助，就帮我点个赞吧，也算是对我的肯定。谢谢，如果有错误的地方欢迎大家指出来。一起讨论学习。我是Derrick，一名正在去阿里路上的前端开发工程师。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><blockquote>\n<p><a href=\"https://muyiy.cn/blog/1/1.3.html#栈数据结构\" target=\"_blank\" rel=\"noopener\">https://muyiy.cn/blog/1/1.3.html#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>\n<p><a href=\"https://juejin.im/post/6844903615300108302\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903615300108302</a></p>\n<p><a href=\"https://juejin.im/post/6844903591510016007\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903591510016007</a></p>\n<p>JavaScript高级程序设计（第三版）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用于记录本人的学习过程，希望可以帮助到大家~🤠</p>\n<p>JavaScript有自动垃圾回收机制，可能因为这个自动让我们前端开发人员忽略了对他的认识（包括我自己），但是阿里的面试官可不会和你嘻嘻哈哈。</p>\n<p>“垃圾回收的机制是什么？什么时候会去触发”</p>\n<p>我一脸懵逼….啥…这个不是他自己运行的吗…🤕</p>\n<p>还是老规矩，黄金圈法则：</p>\n<h3 id=\"为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\"><a href=\"#为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\" class=\"headerlink\" title=\"为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？\"></a>为什么有垃圾回收♻️，或者说垃圾回收的作用是什么？</h3><p>计算机在启动一个程序的时候，会为他分配一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。我们知道电脑的内存其实是有限的，比如常见的8G、16G等等，甚至还有一些什么虚拟内存就讨论了。我们关注点在于内存是一个种稀缺资源，对于不用的东西我们不要#占着茅坑不拉屎#。</p>\n<p><strong>所以垃圾回收的作用就是释放一下不再使用的内存空间。</strong></p>\n<h3 id=\"内存的结构\"><a href=\"#内存的结构\" class=\"headerlink\" title=\"内存的结构\"></a>内存的结构</h3><p>JavaScript中，分为两种内存空间</p>\n<ul>\n<li>堆内存-&gt;存储引用类型</li>\n<li>栈内存-&gt;存储基本类型</li>\n</ul>\n<blockquote>\n<p>基本类型又叫原始类型；因为本人已经说习惯了基本类型，所以以下都叫做基本类型哈。</p>\n</blockquote>\n<h2 id=\"引用类型、基本类型与堆栈的爱恨纠葛\"><a href=\"#引用类型、基本类型与堆栈的爱恨纠葛\" class=\"headerlink\" title=\"引用类型、基本类型与堆栈的爱恨纠葛\"></a>引用类型、基本类型与堆栈的爱恨纠葛</h2><h3 id=\"变量存放\"><a href=\"#变量存放\" class=\"headerlink\" title=\"变量存放\"></a>变量存放</h3><h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><p>截止北京时间2020年8月25日；</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\" target=\"_blank\" rel=\"noopener\">MDN</a>中显示的基本类型（原始类型）有以下7种</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean\" target=\"_blank\" rel=\"noopener\">Boolean</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Null\" target=\"_blank\" rel=\"noopener\">Null</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/undefined\" target=\"_blank\" rel=\"noopener\">Undefined</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Number\" target=\"_blank\" rel=\"noopener\">Number</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt\" target=\"_blank\" rel=\"noopener\">BigInt</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/字符串\" target=\"_blank\" rel=\"noopener\">String</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol\" target=\"_blank\" rel=\"noopener\">Symbol</a> </li>\n</ul>\n<p>基本类型是存储在栈内存里面的。栈内存里面还存着指向堆内存的内存地址。</p>\n<blockquote>\n<p>PS：闭包中，基本类型也是存放在堆内存中的哦，要注意一下。</p>\n</blockquote>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>除了基本类型的数据结构就是引用类型，包括什么数组（Array）、函数（Function）、对象（Object）之类的都是引用类型。</p>\n<p>引用类型和闭包的变量都是存储在堆内存中的。而指针或者说内存地址是存在栈内存的。</p>\n<blockquote>\n<p>当查询引用类型的变量时， 先从<strong>栈中读取内存地址</strong>， 然后再通过地址<strong>找到堆中的值</strong>。对于这种，我们把它叫做按引用访问。</p>\n</blockquote>\n<p>干说有点难理解。身为马良的我给大家画一幅画，帮助理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">'123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"number\">123n</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"comment\">// 字太丑了。。。代码可以看这里</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/1.jpeg\" alt=\"1\"></p>\n<h3 id=\"堆内存和栈内存的总结\"><a href=\"#堆内存和栈内存的总结\" class=\"headerlink\" title=\"堆内存和栈内存的总结\"></a>堆内存和栈内存的总结</h3><table>\n<thead>\n<tr>\n<th><strong>栈内存</strong></th>\n<th>堆内存</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储基础数据类型以及内存地址</td>\n<td>存储引用数据类型以及闭包变量</td>\n</tr>\n<tr>\n<td>按值访问</td>\n<td>按引用（内存地址）访问</td>\n</tr>\n<tr>\n<td>存储的值大小固定</td>\n<td>存储的值大小不定，可动态调整</td>\n</tr>\n<tr>\n<td>由系统自动分配内存空间</td>\n<td>由代码进行指定分配</td>\n</tr>\n<tr>\n<td>空间小，运行效率高</td>\n<td>空间大，运行效率相对较低</td>\n</tr>\n</tbody></table>\n<h2 id=\"深拷贝、浅拷贝、赋值铁人三项的不解渊源\"><a href=\"#深拷贝、浅拷贝、赋值铁人三项的不解渊源\" class=\"headerlink\" title=\"深拷贝、浅拷贝、赋值铁人三项的不解渊源\"></a>深拷贝、浅拷贝、赋值铁人三项的不解渊源</h2><h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>赋值分两种情况：</p>\n<ol>\n<li><p>创建新值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这种就是赋新值的情况。</p>\n</li>\n<li><p>赋值已有的变量的值</p>\n<p>在上面的例子基础上修改一下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> B = b;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况就是赋值已有变量。</p>\n</li>\n</ol>\n<p>👌，接下来来看一个例子，还是把👆的🌰修改一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> A = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> B = b;</span><br><span class=\"line\"></span><br><span class=\"line\">A = <span class=\"number\">1234</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(A);</span><br><span class=\"line\">B.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(B);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>带🔥自己打开控制台，参与进来！看完之后然后再看看和自己的理解是不是一样，如果是一样的话，说明你很👍，不是的话就一起来看看👇的解释吧。</p>\n<p>我们观察之后发现，我们只修改了<code>B</code>但是，我们英俊的<code>b</code>也被修改了。</p>\n<p>？？？（脑补黑人问号脸）</p>\n<p>其实我们在开发过程中肯定是不希望这种情况的发生的，我们修改的只是<code>B</code>，不希望修改<code>b</code>的，不然我们肯定会写<code>b.push(4)</code>。</p>\n<p>这时就需要用到铁人三项的另外两个项目：浅拷贝和深拷贝。</p>\n<h3 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h3><p>刚刚说到引用类型其实是放在堆内存中的，而栈内存里面只存指向堆内存的地址。（有点拗口….🧘‍♂️）</p>\n<p>浅拷贝浅拷贝，顾名思义。就是浅一点的拷贝，有多浅呢？</p>\n<p>一层那么浅。</p>\n<p>也就是说除了第一层的东西，第一层之外更深的层级就不是拷贝了，叫拿别人的地址。</p>\n<p>口说无凭，我弄个demo给大家🔥see see。</p>\n<p><img src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/2.png\" alt=\"2\"></p>\n<p>可以很清晰，清晰的不能再清晰的看到，浅拷贝出来的对象里面的属性<code>b</code>其实还是指向之前的对象，之前说过，再深的他就不拷贝了，验证的话就交给大家了，毕竟我们是一个动手节目组！</p>\n<p>那么浅拷贝有哪些方法呢？</p>\n<ol>\n<li>Object.assign()</li>\n<li>es6的扩展运算符<code>{...xxx}</code></li>\n<li>Array.prototype.slice()</li>\n</ol>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>看看我那个完美的图就已经知道了，深拷贝就是完美的弄一个一模一样的出来。</p>\n<p>帅哥帅哥，深拷贝有啥办法捏？</p>\n<ol>\n<li>JSON.parse(JSON.stringify(object))<ol>\n<li>会忽略 <code>undefined</code></li>\n<li>会忽略 <code>symbol</code></li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象</li>\n<li>不能正确处理`new Date()</li>\n<li>不能处理正则</li>\n</ol>\n</li>\n<li>自己写一个递归然后疯狂浅拷贝….</li>\n<li>终极方案：lodash的<a href=\"https://www.lodashjs.com/docs/lodash.cloneDeep\" target=\"_blank\" rel=\"noopener\"><code>cloneDeep</code></a></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>和原数据是否指向同一对象</th>\n<th>第一层数据为基本数据类型</th>\n<th>原数据中包含子对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>赋值</td>\n<td>是</td>\n<td>改变会使原数据一起改变</td>\n<td>改变会使原数据一起改变</td>\n</tr>\n<tr>\n<td>浅拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一起改变</td>\n<td>改变会使原数据一起改变</td>\n</tr>\n<tr>\n<td>深拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一起改变</td>\n<td>改变不会使原数据一起改变</td>\n</tr>\n</tbody></table>\n<h2 id=\"垃圾回收机制♻️\"><a href=\"#垃圾回收机制♻️\" class=\"headerlink\" title=\"垃圾回收机制♻️\"></a>垃圾回收机制♻️</h2><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间或者达到某个阈值就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p>\n<h3 id=\"判断方式\"><a href=\"#判断方式\" class=\"headerlink\" title=\"判断方式\"></a>判断方式</h3><p>JavaScript是怎么判断某个变量是否需要被回收的？</p>\n<p>有以下几个方法</p>\n<h3 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h3><p>比如一个函数内部声明的一个变量，一旦我们的主线程离开了这个函数，那么这个函数声明的一些变量外部就无法用到，那么就会被标记为”离开环境”。这样在下一个垃圾回收周期来领的时候，就自动释放了这些变量占用的内存。</p>\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。</p>\n<p>引用计数有一个非常严重的BUG就是，如果存在循环引用的话，系统就无法判断你这个内存到底要不要回收了。而且引用的数字永远都不会是0。举个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"some_element\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">myObject.element = element;</span><br><span class=\"line\">element.someObject = myObject;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话<code>element</code>和<code>myObject</code>这对情侣就永远如胶似漆，系统无法将他们送上天堂。</p>\n<p>那咋办？要拆散他们有一个主意，就是在不用的时候给他们置为<code>null</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.element = <span class=\"literal\">null</span>; </span><br><span class=\"line\">element.someObject = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。</p>\n<p>插播一个小故事</p>\n<blockquote>\n<p>IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。</p>\n<p>随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式:触发垃圾收集的变量分配、 字面量和(或)数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。</p>\n<p>—-摘自JavaScript高级程序设计</p>\n</blockquote>\n<h2 id=\"V8垃圾回收策略\"><a href=\"#V8垃圾回收策略\" class=\"headerlink\" title=\"V8垃圾回收策略\"></a>V8垃圾回收策略</h2><h3 id=\"什么是V8？\"><a href=\"#什么是V8？\" class=\"headerlink\" title=\"什么是V8？\"></a>什么是V8？</h3><p>简单介绍一下什么是V8？</p>\n<blockquote>\n<p><strong>V8</strong>是一个由<a href=\"https://zh.wikipedia.org/wiki/Google\" target=\"_blank\" rel=\"noopener\">Google</a>开发的<a href=\"https://zh.wikipedia.org/wiki/开源\" target=\"_blank\" rel=\"noopener\">开源</a><a href=\"https://zh.wikipedia.org/wiki/JavaScript引擎\" target=\"_blank\" rel=\"noopener\">JavaScript引擎</a>，用于<a href=\"https://zh.wikipedia.org/wiki/Google_Chrome\" target=\"_blank\" rel=\"noopener\">Google Chrome</a>及<a href=\"https://zh.wikipedia.org/wiki/Chromium\" target=\"_blank\" rel=\"noopener\">Chromium</a>中<a href=\"https://zh.wikipedia.org/wiki/V8_(JavaScript引擎)#cite_note-comic-2\" target=\"_blank\" rel=\"noopener\">[2]</a>。</p>\n<p>—摘自维基百科</p>\n</blockquote>\n<p>既然V8是Chrome的引擎，那么别的浏览器呢？</p>\n<p>世界上主要的浏览器有以下三种。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/V8_(JavaScript_engine)\" target=\"_blank\" rel=\"noopener\"><strong>V8</strong></a>——开源，由 Google 开发，使用 C++ 编写</p>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine)\" target=\"_blank\" rel=\"noopener\">SpiderMonkey</a></strong>——第一个 JavaScript 引擎，该引擎过去驱动 Netscape Navigator，如今驱动 Firefox 浏览器。</p>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/JavaScriptCore\" target=\"_blank\" rel=\"noopener\">JavaScriptCore</a></strong>——开源，苹果公司为 Safair 浏览器开发的</p>\n<p>okokok，收！回归初心。</p>\n<h3 id=\"V8的垃圾回收策略\"><a href=\"#V8的垃圾回收策略\" class=\"headerlink\" title=\"V8的垃圾回收策略\"></a>V8的垃圾回收策略</h3><p>我们的伟大的Chrome，根据不同的情况有不同的对策。他把内存分成两块</p>\n<ul>\n<li>新生代</li>\n<li>老生代</li>\n</ul>\n<h4 id=\"分代内存\"><a href=\"#分代内存\" class=\"headerlink\" title=\"分代内存\"></a>分代内存</h4><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p>\n<p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p>\n<h4 id=\"新生代算法\"><a href=\"#新生代算法\" class=\"headerlink\" title=\"新生代算法\"></a>新生代算法</h4><p>首先，我们科普一下什么是新生代。</p>\n<p>新生代的内存呢，就是存活时间比较短的对象。如果存活的时间比较长的话就会《晋升》为老生代。等一下会稍微详细的说一下《晋升》这个概念。</p>\n<p>新生代采用<strong>Scavenge GC</strong>垃圾回收算法，在算法实现时主要采用<strong>Cheney</strong>算法。</p>\n<p>Cheney算法呢是将内存一分为二，一块暂时把他叫做《From》，另一块暂时叫做《To》。看一下下图，就可以很清晰的知道V8是怎么分割内存的。</p>\n<p><img src=\"/image/%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C/3.png\" alt=\"3\"></p>\n<p>内存的到来先进入From，然后等到From满了之后，新生代的GC就会启动。</p>\n<p>首先释放掉一些不再使用的内存，然后将From和To两个功能进行更换，也就是说之前的From -&gt; To  之前的  To -&gt; From。这样的话新生代的一轮GC就此结束了。</p>\n<p>这种算法有点类似空间换时间，而新生代的对象生命一般都是比较短的，所以所以非常适合新生代。</p>\n<h4 id=\"晋升\"><a href=\"#晋升\" class=\"headerlink\" title=\"晋升\"></a>晋升</h4><p>对象的晋升其实主要有两个要求，就好像在来P6升P7有一堆的要求一样。</p>\n<ol>\n<li>新生代算法刚刚我们已经学习过了，就是From和To的互换功能。如果一个对象他经历了两次的新生代的更替，还没有被回收内存，说明他很强。就需要晋升为老生代，让老生代的算法来对付他。就好像在阿里的一个P6两轮361都没有被淘汰说明他很有实力，所以直接升级他为P7。</li>\n<li>如果一个对象在To的内存占比超过了25%，在第一次更替的时候就直接将他晋升为老生代了。可以理解为一个技术大牛，像马云，一去阿里就被星探发现，直接就是P7评级，不需要经过什么复杂的面试或者什么。</li>\n</ol>\n<h4 id=\"老生代算法\"><a href=\"#老生代算法\" class=\"headerlink\" title=\"老生代算法\"></a>老生代算法</h4><p>根据刚刚对《晋升》的了解，我们知道了在老生代里面的对象都是一些难缠的选手，比如本来就占内存比例很大，或者经历过2次的新生代GC，依旧坚挺的选手。</p>\n<p>所以，V8在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>相结合的方式进行垃圾回收。</p>\n<p>在介绍老生代算法之前，先科普一下<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>。</p>\n<h5 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a><strong>Mark-Sweep</strong></h5><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。</p>\n<p>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p>\n<p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p>\n<blockquote>\n<p>在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href=\"https://v8project.blogspot.com/2018/06/concurrent-marking.html\" target=\"_blank\" rel=\"noopener\">该博客</a> 详细阅读。</p>\n</blockquote>\n<h5 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a><strong>Mark-Compact</strong></h5><p>在清除完对象后，这些对象在内存内部就不是连续的。这样内存地址就无法很好地利用起来，因为他们需要连续的内存，有的大的对象就无法塞入刚刚释放的小内存当中。</p>\n<p>而Mark-Compact就是用于解决内存碎片的问题，他主要干的活就是移动这些对象，让他们变成紧凑起来。</p>\n<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。</p>\n<p>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p>\n<h2 id=\"JavaScript内存泄漏\"><a href=\"#JavaScript内存泄漏\" class=\"headerlink\" title=\"JavaScript内存泄漏\"></a>JavaScript内存泄漏</h2><h3 id=\"什么是内存泄漏\"><a href=\"#什么是内存泄漏\" class=\"headerlink\" title=\"什么是内存泄漏\"></a>什么是内存泄漏</h3><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p><strong>不再用到的内存，没有及时释放，就叫做内存泄漏</strong>（memory leak）。</p>\n<h3 id=\"常见的内存泄漏\"><a href=\"#常见的内存泄漏\" class=\"headerlink\" title=\"常见的内存泄漏\"></a>常见的内存泄漏</h3><ol>\n<li><p>定时器未及时清除</p>\n</li>\n<li><p>意外的全局变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    bar = <span class=\"string\">\"this is a hidden global variable\"</span>;  <span class=\"comment\">// 意外挂在在 window 全局变量，导致内存泄漏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是想说一下高程（JavaScript高级程序设计第三版）里面的一个非常经典的demo。</p>\n</li>\n<li><p>闭包的滥用</p>\n</li>\n</ol>\n<h3 id=\"WeakMap与WeakSet\"><a href=\"#WeakMap与WeakSet\" class=\"headerlink\" title=\"WeakMap与WeakSet\"></a>WeakMap与WeakSet</h3><p>其实这两个在这篇文章里面的意义相同，只需要介绍一个就行。</p>\n<p>我们知道Map是简单的key-value。而且key可以为任意类型，比如引用类型，如果我们的key是引用类型那么他所占据的内存就无法被释放了。</p>\n<p>又有同学问题了，我有毛病啊，我非要引用类型吗？我string和number他不香吗？</p>\n<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">wm.set(element, <span class=\"string\">'some information'</span>);</span><br><span class=\"line\">wm.get(element) <span class=\"comment\">// \"some information\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>\n<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>\n<p>更多的知识就不讨论了，这里是内存世界！不是什么WeakMap专场哦。</p>\n<p>怎么验证？emmmmm….这里我copy一下阮一峰老师的内容。</p>\n<h3 id=\"阮老师的demo\"><a href=\"#阮老师的demo\" class=\"headerlink\" title=\"阮老师的demo\"></a>阮老师的demo</h3><p>首先，打开 Node 命令行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node --expose-gc</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>\n<p>然后，执行下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">21106688</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">7376896</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">4153936</span>,</span><br><span class=\"line\">  external: <span class=\"number\">9059</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; <span class=\"keyword\">let</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个变量 key，指向一个 5*1024*1024 的数组</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 WeakMap 实例的键名，也指向 key 数组</span></span><br><span class=\"line\"><span class=\"comment\">// 这时，key 数组实际被引用了两次，</span></span><br><span class=\"line\"><span class=\"comment\">// 变量 key 引用一次，WeakMap 的键名引用了第二次</span></span><br><span class=\"line\"><span class=\"comment\">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1</span></span><br><span class=\"line\">&gt; wm.set(key, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">WeakMap</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这时内存占用 heapUsed 增加到 45M 了</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">67538944</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">7376896</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">45782816</span>,</span><br><span class=\"line\">  external: <span class=\"number\">8945</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除变量 key 对数组的引用，</span></span><br><span class=\"line\"><span class=\"comment\">// 但没有手动清除 WeakMap 实例的键名对数组的引用</span></span><br><span class=\"line\">&gt; key = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次执行垃圾回收</span></span><br><span class=\"line\">&gt; global.gc();</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内存占用 heapUsed 变回 4M 左右，</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收</span></span><br><span class=\"line\">&gt; process.memoryUsage();</span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">20639744</span>,</span><br><span class=\"line\">  heapTotal: <span class=\"number\">8425472</span>,</span><br><span class=\"line\">  heapUsed: <span class=\"number\">3979792</span>,</span><br><span class=\"line\">  external: <span class=\"number\">8956</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>\n<h2 id=\"看完几件事\"><a href=\"#看完几件事\" class=\"headerlink\" title=\"看完几件事\"></a>看完几件事</h2><p>如果你觉得对你有帮助，就帮我点个赞吧，也算是对我的肯定。谢谢，如果有错误的地方欢迎大家指出来。一起讨论学习。我是Derrick，一名正在去阿里路上的前端开发工程师。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><blockquote>\n<p><a href=\"https://muyiy.cn/blog/1/1.3.html#栈数据结构\" target=\"_blank\" rel=\"noopener\">https://muyiy.cn/blog/1/1.3.html#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>\n<p><a href=\"https://juejin.im/post/6844903615300108302\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903615300108302</a></p>\n<p><a href=\"https://juejin.im/post/6844903591510016007\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903591510016007</a></p>\n<p>JavaScript高级程序设计（第三版）</p>\n</blockquote>\n"},{"title":"【重识前端】暴走的异步编程","date":"2020-08-28T14:47:09.000Z","cover":"/image/cover/web.jpeg","_content":"\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n[【重识前端】暴走的异步编程](https://juejin.im/post/6867814019055484942)\n\n## 前言\n\n老规矩，还是先了解一下什么是异步。异步其实是一个相对比较高级的一个概念。\n\n通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.\n\n如果说一个事情需要等待上一件事情做完才能做，但是他们之前又没有强耦合关系。这样就在那里干等就毫无意义。特别是现在计算机普遍都有多核CPU的时代。\n\n举一个形象的🌰。\n\n我们现在要去吃海底捞（海底捞打钱！），我们发现要排队，需要排2个小时左右，这个时候我们要干嘛？难道是干等吗？肯定不是！那样蠢蠢的硬等很呆，我们可能会拿出手机刷刷朋友圈，或者玩一把紧张刺激的王者荣耀又或者去看一场电影等等....在我们做这些事情的时候我们的排队并没有被耽误，甚至可以和服务员说快到了打个电话给我（这个是常见的callback方法，待会讨论）\n\n> 这样你可以同时完成其他工作，这就是**异步编程**的出发点。\n\n本文总结了几个异步的方案，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。\n\n## 异步callback\n\n上来就是一个英俊的例子\n\n```js\nvar response = fetch('myImage.png');\nvar blob = response.blob();\n```\n\n没有人可以完美预测到每种网络情况下这个response，是否可以完美获得fetch获得的内容，很有可能会报错。\n\n这个时候我们的callback就✨bu ling bu ling的登场啦。\n\n有些小伙伴可能觉得callback似乎和自己没有太大关系。。。emmmm....\n\n```js\nbtn.addEventListener('click', () => {\n  alert('You clicked me!');\n});\n```\n\n这样呢？有没有感觉有点儿熟悉了，其他这个就相当于react中的\n\n```html\n<div onclick={() =>{alert('You clicked me!');}}>\n\t点我  \n</div>\n```\n\n是不是很熟悉，这个其实就是最常见的callback（回调函数）。\n\n又或者比较常见的\n\n```js\nsetTimeout(() => {\n\talert('You clicked me!');\n}，2000)\n```\n\n很常见，大致意思就是2秒钟之后会回调一下这个匿名函数，虽然不一定会准确执行，这个涉及到事件循环，感兴趣的可以去找一下我前阵子写的事件循环😊。\n\n## 发布-订阅模式\n\n发布-订阅模式：又称为观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。\n\n在写React的时候，有一个非常非常非常常见的🌰：\n\n```jsx\nimport React, {useState, useEffect} from 'react';\nconst test = () => {\n  const [derrick, setDerrick] = useState(0)\n  useEffect(()=> {\n    console.log(derrick)\n  }, [derrick])\n  return(\n    <button onClick={() => {setDerrick(derrick+1)}}>点我</button>\n  )\n}\n```\n\nuseEffect订阅了derrick这个变量的变化，然后监听到变化之后就会进行一次log，打印出derrick变量的值。\n\n## Promise\n\n### 回调救星\n\n之前介绍过回调函数这种异步编程。\n\n加入我希望在A执行完之后执行B，然后执行C，然后执行D....最后执行Z\n\n写出来的代码可能是这样的\n\n```js\nvar sayhello = function (name, callback) {\n  setTimeout(function () {\n    console.log(name);\n    callback();\n  }, 1000);\n}\nsayhello(\"first\", function () {\n  sayhello(\"second\", function () {\n    sayhello(\"third\", function () {\n      console.log(\"end\");\n    });\n  });\n});\n```\n\n像本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复 杂的功能时，回调函数也会存在问题:若想让两个异步操作并行运行，并且在它们都结束后 提醒你，那该怎么做?若想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么 做?\n\n在这些情况下，你需要追踪多个回调函数并做清理操作， 不过好在promise横空出世拯救了世界。\n\n### 涉及面试题\n\n> promise用过吗？请你介绍一下promise。\n\n其实这里很多同学可能就不知道怎么介绍了，可能只停留在怎么用。我们可以从几个方面来介绍。\n\n- promise是什么？\n- promise解决了什么问题\n- promise的优缺点\n\n#### promise是什么？\n\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n#### promise解决了什么问题？\n\n1. 解决可读性的问题\n2. 解决信任问题\n\n##### 可读性\n\n可读性，之前的回调地狱promise就可以优雅的解决。(还有更加优雅的，待会会介绍。)\n\n```js\nvar sayhello = function (name) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      console.log(name);\n      resolve();　　//在异步操作执行完后执行 resolve() 函数\n    }, 10000);\n  });\n}\nsayhello(\"first\").then(function () {\n  return sayhello(\"second\");　　//仍然返回一个 Promise 对象\n}).then(function () {\n  return sayhello(\"third\");\n}).then(function () {\n  console.log('end');\n}).catch(function (err) {\n  console.log(err);\n})\n```\n\n##### 信任问题\n\n这个问题可以用promise的几个特点来解释：\n\n> （1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n>\n> （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。\n\n```js\n//信任问题演示\n\n//回调\nfunction method(cb){\n    setTimeout(function(){\n        cb && cb();\n        //因为某些bug导致某个函数多执行了一次\n        cb && cb();\n    },1000);\n}\n\n//promise\nfunction method2(){\n    return new Promise(resolve=>{\n        setTimeout(function(){\n            resolve();\n            //resolve成功调用一次之后，后面的不会再执行\n            resolve();\n        },1000);        \n    })\n}\n```\n\n控制反转。体现在对于函数的把控，比如this等。\n\n```js\n//回调\nfunction method(cb){\n    setTimeout(function(){\n        cb && cb.call({a:1,b:2});//执行回调，但是添油加醋\n    },1000);\n}\n\n//promise\nfunction method2(){\n    return new Promise(resolve=>{\n        setTimeout(function(){\n            resolve();//调用的resolve都是自己写的，改善了控制反转的问题\n        },1000);        \n    })\n}\n```\n\n### 手撕A+规范的promise\n\n> 面试题：你知道promise的A+规范吗？（本人在浩鲸科技被问到的，当时答的支支吾吾。。。）\n\n我何止是知道，我甚至可以手写一个符合A+规范的promise！\n\nA+规范快速入口，[点我](https://promisesaplus.com/)\n\n\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n    }\n  }\n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n    }\n  }\n  \n  executor(resolve, reject);\n}\n```\n\npromise里面最难的就是then了，我们必须将这个方法写在他的原型链上面，并且他接受两个参数，一个是成功的回调，一个是失败的回调。\n\n废话不多说，开冲！\n\n#### 支持异步\n\n在此之前，我们需要加两个变量。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n    }\n  }\n  \n  executor(resolve, reject);\n}\n```\n\n颜值高又细心的同学会发现，我多加了两个变量。\n\n```js\n// 存储成功的回调\nself.onResolved = [];\n// 存储失败的回调\nself.onRejected = [];\n```\n\n这两个变量呢，也非常好理解，就是存储回调的。那么有一个非常非常重要的问题，我写的时候也困扰了好久，为什么一定要是一个数组呢？我存储为一个函数不行吗？到时候执行就行啦。。。\n\nqs，和我想一样的帅哥靓女可能比较多。这里我统一回复：\n\n假如说。以下的情况出现的话，咋办。\n\n```js\nvar p = new Promise((resolve, reject)=>{\n    setTimeout(()=>{\n        resolve(4)\n    }, 1000)\n})\np.then((res)=>{\n    //4 res\n    console.log(res, 'res')\n})\np.then((res1)=>{\n    //4 res1\n    console.log(res1, 'res1')\n})\n```\n\n这种情况出现，如果我们只是一个函数，那么我们的`console.log(res, 'res')`这辈子都无法问世，为什么？因为被后门的`console.log(res1, 'res')`给覆盖了呀。对不对，如果说这个`resolve`他延迟执行，这个时候我们需要做的是把`then`函数给保存下来，等到`resolve`被执行的时候，依次执行我们所有创建的`then`里面的回调函数。\n\n听懂掌声！\n\n没听懂的接着往下看，我们把剩余工作做完，然后举一个例子。马上就能明白了。\n\n刚刚说到，我们补充两个变量，然后写下我们的`then`函数。\n\n```js\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {onFulfilled(self.value)})\n    self.onRejected.push(() => {onRejected(self.reason)})\n  }\n}\n```\n\n然后我们还需要在`resolve`或者`reject`的时候执行我们存储起来的这些函数。\n\n完整代码如下：\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  \n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {onFulfilled(self.value)})\n    self.onRejected.push(() => {onRejected(self.reason)})\n  }\n}\n```\n\nOK。我们先试试我们自己写的promise。跑一下demo吧。为了给懒同学便捷的调试，直接CV下面就好啦。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n\n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n\nvar p = new MyPromise((resolve, reject)=>{\n  setTimeout(()=>{\n    resolve(4)\n  }, 1000)\n})\np.then((res)=>{\n  //4 res\n  console.log(res, 'res')\n})\np.then((res1)=>{\n  //4 res1\n  console.log(res1, 'res1')\n})\n```\n\n嗯~如愿输出了，那回到刚刚的问题。我们把回调的地方不要用数组而用函数呢？不用同学们打字了，直接CV👇的代码就好了。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n\n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n\nvar p = new MyPromise((resolve, reject)=>{\n  setTimeout(()=>{\n    resolve(4)\n  }, 1000)\n})\np.then((res)=>{\n  //4 res\n  console.log(res, 'res')\n})\np.then((res1)=>{\n  //4 res1\n  console.log(res1, 'res1')\n})\n```\n\n是不是只有`console.log(res1, 'res1')`啦？因为执行`then`的时候，我们的resolve还有没有被调用，如果我们有多个`then`的话，我们需要把他们存储起来，然后依次调用。所以我们需要用到数组，当然也可以是别的方法，核心思想就是把他们存起来，在需要调用的时候调用。\n\n是不是很好理解？！！\n\n听懂掌声！\n\n而且A+也要求了。\n\n> `2.2.6:then` may be called multiple times on the same promise.\n>\n> （promise 的 `then` 可以链式调用多次）\n>\n> 2.2.6.1：If/when `promise` is fulfilled, all respective `onFulfilled` callbacks must execute in the order of their originating calls to `then`.\n>\n> （如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行）\n>\n> 2.2.6.2：If/when `promise` is rejected, all respective `onRejected` callbacks must execute in the order of their originating calls to `then`.\n>\n> （如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行）\n\n我们对promise的理解更进一步了。记得把代码改回去，继续往下走。\n\n刚刚我们的demo还不够鲁棒，而且我们的测试用例都是完美情况下。\n\n接下来要剑走偏锋了。\n\n> A+:\n>\n> 2.2.1：Both `onFulfilled` and `onRejected` are optional arguments:\n>\n> （onFulfilled 和 onRejected 都是可选参数：）\n>\n> 2.2.1.1 If `onFulfilled` is not a function, it must be ignored.\n>\n> （如果 onFulfilled 不是函数，它会被忽略）\n>\n> 2.2.1.2 If `onRejected` is not a function, it must be ignored.\n>\n> （如果 onRejected 不是函数，它会被忽略）\n>\n> 2.2.7.2: If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected with `e` as the reason.\n>\n> （如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））\n\n所以我们首先要做的就是，把错误给提前捕获，然后丢给`reject`\n\nemmm....接下我贴代码都是一起贴了，因为我怕有同学会掉队，里面也会有相应的注释帮助会走神的同学跟紧这辆五菱宏光。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  // 捕获错误传给reject。法律规定！\n\ttry{\n  \texecutor(resolve, reject);\n  } catch(e) {\n    reject(e);\n  }\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  // 如果不是函数就忽略 2.2.1.1\n  if(self.status === 'fulfilled') {\n    typeof onFulfilled === 'function' && onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    typeof onFulfilled === 'function' && onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  // 如果不是函数就忽略 2.2.1.2\n  if(self.status === 'pending') {\n    // 如果不是函数就忽略 2.2.1.1\n    typeof onFulfilled === 'function' && self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    // 如果不是函数就忽略 2.2.1.2\n    typeof onFulfilled === 'function' && self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n```\n\n#### 链式调用then\n\n开始准备进入promise的难点以及核心点：链式调用。\n\n> 2.2.7：`then` must return a promise\n>\n> （then 方法一定返回一个 promise）\n\n我们需要返回新的promise的话，可以简单实现，快速迭代。\n\n```js\nPromise.prototype.then = function (onFulfilled, onRejected) {\n    let promise2 = new Promise((resolve, reject)=>{\n    })\n    return promise2\n}\n```\n\n> 2.2.7.1：If either `onFulfilled` or `onRejected` returns a value `x`, run the Promise Resolution Procedure `[[Resolve]](promise2, x)`.\n>\n> （如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以[[Resolve]](promise2, x)` 处理解析）\n>\n> 2.2.7.2：If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected with `e` as the reason.\n>\n> （如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））\n>\n> 2.2.7.3：If `onFulfilled` is not a function and `promise1` is fulfilled, `promise2` must be fulfilled with the same value as `promise1`.\n>\n> （如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value）\n>\n> 2.2.7.4：If `onRejected` is not a function and `promise1` is rejected, `promise2` must be rejected with the same reason as `promise1`.\n>\n> （如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason）\n\n我们需要将返回内容promise化，需要对onFulfilled和onRejected进行错误处理，这个我们之前就处理过了，如果onFulfilled和onRejected没有传参就继续传递，原生🌰来：\n\n```js\nvar p = new Promise(function(resolve, reject){\n    setTimeout(function(){\n        resolve(3)\n    }, 1000)\n});\np.then(1,1)\n.then('','')\n.then()\n.then(function(res){\n    //3\n    console.log(res)\n})\n```\n\n这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；要做的事情太多了，不当当是判断函数这种简单的判断了，所以我们要抽离一个新的函数来复用统一处理。因此我们进行如下完善：\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  // 捕获错误传给reject。法律规定！\n\ttry{\n  \texecutor(resolve, reject);\n  } catch(e) {\n    reject(e);\n  }\n}\n\nfunction resolvePromise(promise2, res, resolve, reject) {\n  // 如果promise2和结果相同，就自己无限循环调用自己的then了，死亡循环。\n  // 举个🌰：var a = function(){return a}，这个then又会自己无限触发。所以就玩完了。\n  if(promise2 === res) {\n    return reject(new TypeError('循环引用'))\n  }\n  if(\n    res !== null \n    && (typeof res === 'object') || typeof res === 'function')\n  ) {\n    try {\n      // 保存是否已经调用过函数。\n      // 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.(如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）)\n      let used = false;\n      \n      // 2.3.3.1：Let then be x.then. [3.5](把 x.then 赋值给 then 变量)\n      // 可以提防有人恶搞。像👇\n      // Object.defineProperty(Promise, 'then', {\n      //    get: function(){\n      //        throw Error('error')\n      //    }\n      // })\n      // 这样的话我们取值就会报错。\n      let then = res.then;\n      // 如果then是函数，就默认是promise了   \n      if(typeof then === 'function') {\n        then.call(\n          res, \n          value => {\n            if(used) {\n              return;\n            }\n            used = true;\n            // 递归解析，直到不是一个promise为止\n            resolvePromise(promise2, value, resolve, reject);\n        \t},\n          reason => {\n            if(used) {\n              return;\n            }\n            used = true;\n            reject(reason);\n          }\n        )\n      }\n    } catch (e) {\n      if(used) {\n        return;\n      }\n      used = true;\n      reject(e);\n    }\n  } else {\n    // 如果不是函数或者对象也不为空就直接继续传递这个值。\n\t  resolve(res);  \n  }\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 只有promise才可以持续的链式调用then,所以这里弄了一个新的promise\n  let promise2 = new MyPromise((resolve, reject) => {\n    // 当前的状态（fulfilled/rejected/pending），默认值为pending\n    if(self.status === 'fulfilled') {\n      let res = onFulfilled(self.value);\n      resolvePromise(promise2, res, resolve, reject);\n    }\n    // 当前的状态（fulfilled/rejected/pending），默认值为pending\n    if(self.status === 'rejected') {\n      let res = onRejected(self.reason);\n      resolvePromise(promise2, res, resolve, reject);\n    }\n    // 如果是pending应该存储当前的回调函数\n    if(self.status === 'pending') {\n      self.onResolved.push(() => {\n        let res = onFulfilled(self.value);\n      resolvePromise(promise2, res, resolve, reject);\n      })\n      self.onRejected.push(() => {\n        let res = onRejected(self.reason);\n      resolvePromise(promise2, res, resolve, reject);\n      })\n    }\n  })\n}\n```\n\n以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。\n\n## Generator\n\n> 面试题：介绍一下generator吧。\n\n很多小伙伴可能和我一样，只是会用，但是你硬要我介绍，那我咋搞？generator的拼写是g e n e r a t o r？\n\n“哔………………………………”\n\n其实我重温了一下阮老师的es6课程，发现可以从以下几个方面来介绍。\n\n- 形式上\n  - generator和普通的函数不同点在于，对一个`*`号，函数内部使用了yield表达式\n- 语法上\n  -  Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。\n- 调用上\n  -  普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。\n\n其实我觉得，如果能把下面的这个案例弄清楚，generator就算过关了。\n\n```js\nfunction *foo(x) {\n  let y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\nlet it = foo(5)\nconsole.log(it.next())   // => {value: 6, done: false}\nconsole.log(it.next(12)) // => {value: 8, done: false}\nconsole.log(it.next(13)) // => {value: 42, done: true}\n```\n\n- 首先 `Generator` 函数调用和普通函数不同，它会返回一个迭代器\n- 当执行第一次 `next` 时，传参会被忽略，并且函数暂停在 `yield (x + 1)` 处，所以返回 `5 + 1 = 6`\n- 当执行第二次 `next` 时，传入的参数等于上一个 `yield` 的返回值，如果你不传参，`yield` 永远返回 `undefined`。此时 `let y = 2 * 12`，所以第二个 `yield` 等于 `2 * 12 / 3 = 8`\n- 当执行第三次 `next` 时，传入的参数会传递给 `z`，所以 `z = 13, x = 5, y = 24`，相加等于 `42`\n\n## async/await\n\n> 什么是async/await？\n\n其实就一句话：**async 函数就是 Generator 函数的语法糖。**\n\ngenerator：\n\n```js\nvar gen = function* (){\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\nAsync:\n\n```js\nvar asyncReadFile = async function (){\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。\n\nasync对generator进行了以下三点的改进：\n\n1. **内置执行器。** Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n2. **更好的语义。** async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n3. **更广的适用性。** co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n一个函数如果加上了async，那么就会默认返回一个promise\n\n```js\nasync function fn(args){\n  // ...\n}\n\n// 等同于\n\nfunction fn(args){ \n  return spawn(function*() {\n    // ...\n  }); \n}\n```\n\n### 注意\n\nawait 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise().catch(function (err){\n    console.log(err);\n  });\n}\n```\n\nawait 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n\n```\n\n\n\n## Reference\n\n> https://es6.ruanyifeng.com/#docs/generator\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【重识前端】暴走的异步编程.md","raw":"---\ntitle: 【重识前端】暴走的异步编程\ndate: 2020-08-28 22:47:09\ntags: [JavaScript]\ncategory: [重拾前端]\ncover: /image/cover/web.jpeg\n---\n\n最近在写【重拾前端】系列，下面有几个快速通道，大家自取\n\n[【重识前端】原型/原型链和继承](https://juejin.im/post/6850418113944420359)\n\n[【重识前端】闭包与模块](https://juejin.im/post/6850418117508759566)\n\n[【重识前端】全面攻破this](https://juejin.im/post/6854573215658803208)\n\n[【重识前端】一次搞定JavaScript的执行机制](https://juejin.im/post/6859911609633767438)\n\n[【重识前端】什么是BFC、IFC、GFC 和 FFC](https://juejin.im/post/6860375101322461198)\n\n[【重识前端】深入内存世界](https://juejin.im/post/6865204092877144077)\n\n[【重识前端】暴走的异步编程](https://juejin.im/post/6867814019055484942)\n\n## 前言\n\n老规矩，还是先了解一下什么是异步。异步其实是一个相对比较高级的一个概念。\n\n通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.\n\n如果说一个事情需要等待上一件事情做完才能做，但是他们之前又没有强耦合关系。这样就在那里干等就毫无意义。特别是现在计算机普遍都有多核CPU的时代。\n\n举一个形象的🌰。\n\n我们现在要去吃海底捞（海底捞打钱！），我们发现要排队，需要排2个小时左右，这个时候我们要干嘛？难道是干等吗？肯定不是！那样蠢蠢的硬等很呆，我们可能会拿出手机刷刷朋友圈，或者玩一把紧张刺激的王者荣耀又或者去看一场电影等等....在我们做这些事情的时候我们的排队并没有被耽误，甚至可以和服务员说快到了打个电话给我（这个是常见的callback方法，待会讨论）\n\n> 这样你可以同时完成其他工作，这就是**异步编程**的出发点。\n\n本文总结了几个异步的方案，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。\n\n## 异步callback\n\n上来就是一个英俊的例子\n\n```js\nvar response = fetch('myImage.png');\nvar blob = response.blob();\n```\n\n没有人可以完美预测到每种网络情况下这个response，是否可以完美获得fetch获得的内容，很有可能会报错。\n\n这个时候我们的callback就✨bu ling bu ling的登场啦。\n\n有些小伙伴可能觉得callback似乎和自己没有太大关系。。。emmmm....\n\n```js\nbtn.addEventListener('click', () => {\n  alert('You clicked me!');\n});\n```\n\n这样呢？有没有感觉有点儿熟悉了，其他这个就相当于react中的\n\n```html\n<div onclick={() =>{alert('You clicked me!');}}>\n\t点我  \n</div>\n```\n\n是不是很熟悉，这个其实就是最常见的callback（回调函数）。\n\n又或者比较常见的\n\n```js\nsetTimeout(() => {\n\talert('You clicked me!');\n}，2000)\n```\n\n很常见，大致意思就是2秒钟之后会回调一下这个匿名函数，虽然不一定会准确执行，这个涉及到事件循环，感兴趣的可以去找一下我前阵子写的事件循环😊。\n\n## 发布-订阅模式\n\n发布-订阅模式：又称为观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。\n\n在写React的时候，有一个非常非常非常常见的🌰：\n\n```jsx\nimport React, {useState, useEffect} from 'react';\nconst test = () => {\n  const [derrick, setDerrick] = useState(0)\n  useEffect(()=> {\n    console.log(derrick)\n  }, [derrick])\n  return(\n    <button onClick={() => {setDerrick(derrick+1)}}>点我</button>\n  )\n}\n```\n\nuseEffect订阅了derrick这个变量的变化，然后监听到变化之后就会进行一次log，打印出derrick变量的值。\n\n## Promise\n\n### 回调救星\n\n之前介绍过回调函数这种异步编程。\n\n加入我希望在A执行完之后执行B，然后执行C，然后执行D....最后执行Z\n\n写出来的代码可能是这样的\n\n```js\nvar sayhello = function (name, callback) {\n  setTimeout(function () {\n    console.log(name);\n    callback();\n  }, 1000);\n}\nsayhello(\"first\", function () {\n  sayhello(\"second\", function () {\n    sayhello(\"third\", function () {\n      console.log(\"end\");\n    });\n  });\n});\n```\n\n像本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复 杂的功能时，回调函数也会存在问题:若想让两个异步操作并行运行，并且在它们都结束后 提醒你，那该怎么做?若想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么 做?\n\n在这些情况下，你需要追踪多个回调函数并做清理操作， 不过好在promise横空出世拯救了世界。\n\n### 涉及面试题\n\n> promise用过吗？请你介绍一下promise。\n\n其实这里很多同学可能就不知道怎么介绍了，可能只停留在怎么用。我们可以从几个方面来介绍。\n\n- promise是什么？\n- promise解决了什么问题\n- promise的优缺点\n\n#### promise是什么？\n\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n#### promise解决了什么问题？\n\n1. 解决可读性的问题\n2. 解决信任问题\n\n##### 可读性\n\n可读性，之前的回调地狱promise就可以优雅的解决。(还有更加优雅的，待会会介绍。)\n\n```js\nvar sayhello = function (name) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      console.log(name);\n      resolve();　　//在异步操作执行完后执行 resolve() 函数\n    }, 10000);\n  });\n}\nsayhello(\"first\").then(function () {\n  return sayhello(\"second\");　　//仍然返回一个 Promise 对象\n}).then(function () {\n  return sayhello(\"third\");\n}).then(function () {\n  console.log('end');\n}).catch(function (err) {\n  console.log(err);\n})\n```\n\n##### 信任问题\n\n这个问题可以用promise的几个特点来解释：\n\n> （1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n>\n> （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。\n\n```js\n//信任问题演示\n\n//回调\nfunction method(cb){\n    setTimeout(function(){\n        cb && cb();\n        //因为某些bug导致某个函数多执行了一次\n        cb && cb();\n    },1000);\n}\n\n//promise\nfunction method2(){\n    return new Promise(resolve=>{\n        setTimeout(function(){\n            resolve();\n            //resolve成功调用一次之后，后面的不会再执行\n            resolve();\n        },1000);        \n    })\n}\n```\n\n控制反转。体现在对于函数的把控，比如this等。\n\n```js\n//回调\nfunction method(cb){\n    setTimeout(function(){\n        cb && cb.call({a:1,b:2});//执行回调，但是添油加醋\n    },1000);\n}\n\n//promise\nfunction method2(){\n    return new Promise(resolve=>{\n        setTimeout(function(){\n            resolve();//调用的resolve都是自己写的，改善了控制反转的问题\n        },1000);        \n    })\n}\n```\n\n### 手撕A+规范的promise\n\n> 面试题：你知道promise的A+规范吗？（本人在浩鲸科技被问到的，当时答的支支吾吾。。。）\n\n我何止是知道，我甚至可以手写一个符合A+规范的promise！\n\nA+规范快速入口，[点我](https://promisesaplus.com/)\n\n\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n    }\n  }\n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n    }\n  }\n  \n  executor(resolve, reject);\n}\n```\n\npromise里面最难的就是then了，我们必须将这个方法写在他的原型链上面，并且他接受两个参数，一个是成功的回调，一个是失败的回调。\n\n废话不多说，开冲！\n\n#### 支持异步\n\n在此之前，我们需要加两个变量。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n    }\n  }\n  \n  executor(resolve, reject);\n}\n```\n\n颜值高又细心的同学会发现，我多加了两个变量。\n\n```js\n// 存储成功的回调\nself.onResolved = [];\n// 存储失败的回调\nself.onRejected = [];\n```\n\n这两个变量呢，也非常好理解，就是存储回调的。那么有一个非常非常重要的问题，我写的时候也困扰了好久，为什么一定要是一个数组呢？我存储为一个函数不行吗？到时候执行就行啦。。。\n\nqs，和我想一样的帅哥靓女可能比较多。这里我统一回复：\n\n假如说。以下的情况出现的话，咋办。\n\n```js\nvar p = new Promise((resolve, reject)=>{\n    setTimeout(()=>{\n        resolve(4)\n    }, 1000)\n})\np.then((res)=>{\n    //4 res\n    console.log(res, 'res')\n})\np.then((res1)=>{\n    //4 res1\n    console.log(res1, 'res1')\n})\n```\n\n这种情况出现，如果我们只是一个函数，那么我们的`console.log(res, 'res')`这辈子都无法问世，为什么？因为被后门的`console.log(res1, 'res')`给覆盖了呀。对不对，如果说这个`resolve`他延迟执行，这个时候我们需要做的是把`then`函数给保存下来，等到`resolve`被执行的时候，依次执行我们所有创建的`then`里面的回调函数。\n\n听懂掌声！\n\n没听懂的接着往下看，我们把剩余工作做完，然后举一个例子。马上就能明白了。\n\n刚刚说到，我们补充两个变量，然后写下我们的`then`函数。\n\n```js\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {onFulfilled(self.value)})\n    self.onRejected.push(() => {onRejected(self.reason)})\n  }\n}\n```\n\n然后我们还需要在`resolve`或者`reject`的时候执行我们存储起来的这些函数。\n\n完整代码如下：\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  \n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {onFulfilled(self.value)})\n    self.onRejected.push(() => {onRejected(self.reason)})\n  }\n}\n```\n\nOK。我们先试试我们自己写的promise。跑一下demo吧。为了给懒同学便捷的调试，直接CV下面就好啦。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n\n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n\nvar p = new MyPromise((resolve, reject)=>{\n  setTimeout(()=>{\n    resolve(4)\n  }, 1000)\n})\np.then((res)=>{\n  //4 res\n  console.log(res, 'res')\n})\np.then((res1)=>{\n  //4 res1\n  console.log(res1, 'res1')\n})\n```\n\n嗯~如愿输出了，那回到刚刚的问题。我们把回调的地方不要用数组而用函数呢？不用同学们打字了，直接CV👇的代码就好了。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n\n  executor(resolve, reject);\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'fulfilled') {\n    onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  if(self.status === 'pending') {\n    self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n\nvar p = new MyPromise((resolve, reject)=>{\n  setTimeout(()=>{\n    resolve(4)\n  }, 1000)\n})\np.then((res)=>{\n  //4 res\n  console.log(res, 'res')\n})\np.then((res1)=>{\n  //4 res1\n  console.log(res1, 'res1')\n})\n```\n\n是不是只有`console.log(res1, 'res1')`啦？因为执行`then`的时候，我们的resolve还有没有被调用，如果我们有多个`then`的话，我们需要把他们存储起来，然后依次调用。所以我们需要用到数组，当然也可以是别的方法，核心思想就是把他们存起来，在需要调用的时候调用。\n\n是不是很好理解？！！\n\n听懂掌声！\n\n而且A+也要求了。\n\n> `2.2.6:then` may be called multiple times on the same promise.\n>\n> （promise 的 `then` 可以链式调用多次）\n>\n> 2.2.6.1：If/when `promise` is fulfilled, all respective `onFulfilled` callbacks must execute in the order of their originating calls to `then`.\n>\n> （如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行）\n>\n> 2.2.6.2：If/when `promise` is rejected, all respective `onRejected` callbacks must execute in the order of their originating calls to `then`.\n>\n> （如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行）\n\n我们对promise的理解更进一步了。记得把代码改回去，继续往下走。\n\n刚刚我们的demo还不够鲁棒，而且我们的测试用例都是完美情况下。\n\n接下来要剑走偏锋了。\n\n> A+:\n>\n> 2.2.1：Both `onFulfilled` and `onRejected` are optional arguments:\n>\n> （onFulfilled 和 onRejected 都是可选参数：）\n>\n> 2.2.1.1 If `onFulfilled` is not a function, it must be ignored.\n>\n> （如果 onFulfilled 不是函数，它会被忽略）\n>\n> 2.2.1.2 If `onRejected` is not a function, it must be ignored.\n>\n> （如果 onRejected 不是函数，它会被忽略）\n>\n> 2.2.7.2: If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected with `e` as the reason.\n>\n> （如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））\n\n所以我们首先要做的就是，把错误给提前捕获，然后丢给`reject`\n\nemmm....接下我贴代码都是一起贴了，因为我怕有同学会掉队，里面也会有相应的注释帮助会走神的同学跟紧这辆五菱宏光。\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  // 捕获错误传给reject。法律规定！\n\ttry{\n  \texecutor(resolve, reject);\n  } catch(e) {\n    reject(e);\n  }\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  // 如果不是函数就忽略 2.2.1.1\n  if(self.status === 'fulfilled') {\n    typeof onFulfilled === 'function' && onFulfilled(self.value);\n  }\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  if(self.status === 'rejected') {\n    typeof onFulfilled === 'function' && onRejected(self.reason);\n  }\n  // 如果是pending应该存储当前的回调函数\n  // 如果不是函数就忽略 2.2.1.2\n  if(self.status === 'pending') {\n    // 如果不是函数就忽略 2.2.1.1\n    typeof onFulfilled === 'function' && self.onResolved.push(() => {\n      onFulfilled(self.value)\n    })\n    // 如果不是函数就忽略 2.2.1.2\n    typeof onFulfilled === 'function' && self.onRejected.push(() => {\n      onRejected(self.reason)\n    })\n  }\n}\n```\n\n#### 链式调用then\n\n开始准备进入promise的难点以及核心点：链式调用。\n\n> 2.2.7：`then` must return a promise\n>\n> （then 方法一定返回一个 promise）\n\n我们需要返回新的promise的话，可以简单实现，快速迭代。\n\n```js\nPromise.prototype.then = function (onFulfilled, onRejected) {\n    let promise2 = new Promise((resolve, reject)=>{\n    })\n    return promise2\n}\n```\n\n> 2.2.7.1：If either `onFulfilled` or `onRejected` returns a value `x`, run the Promise Resolution Procedure `[[Resolve]](promise2, x)`.\n>\n> （如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以[[Resolve]](promise2, x)` 处理解析）\n>\n> 2.2.7.2：If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected with `e` as the reason.\n>\n> （如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））\n>\n> 2.2.7.3：If `onFulfilled` is not a function and `promise1` is fulfilled, `promise2` must be fulfilled with the same value as `promise1`.\n>\n> （如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value）\n>\n> 2.2.7.4：If `onRejected` is not a function and `promise1` is rejected, `promise2` must be rejected with the same reason as `promise1`.\n>\n> （如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason）\n\n我们需要将返回内容promise化，需要对onFulfilled和onRejected进行错误处理，这个我们之前就处理过了，如果onFulfilled和onRejected没有传参就继续传递，原生🌰来：\n\n```js\nvar p = new Promise(function(resolve, reject){\n    setTimeout(function(){\n        resolve(3)\n    }, 1000)\n});\np.then(1,1)\n.then('','')\n.then()\n.then(function(res){\n    //3\n    console.log(res)\n})\n```\n\n这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；要做的事情太多了，不当当是判断函数这种简单的判断了，所以我们要抽离一个新的函数来复用统一处理。因此我们进行如下完善：\n\n```js\nfunction MyPromise(executor) {\n  // 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。\n  let self = this;\n  // 当前的状态（fulfilled/rejected/pending），默认值为pending\n  self.status = 'pending';\n  // 存储成功的值\n  self.value = null;\n  // 存储失败的值\n  self.reason = null;\n  // 存储成功的回调\n  self.onResolved = [];\n  // 存储失败的回调\n  self.onRejected = [];\n  \n  function resolve(value) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下成功的值\n      self.value = value\n      self.status = 'fulfilled';\n      // 执行我们存储的函数;\n      self.onResolved.forEach(fn => fn())\n    }\n  }\n  \n  function reject(reason) {\n    // 2.1.1规定只有在pending状态的时候才可以转变\n    if(self.status === 'pending') {\n      // 存下失败的值\n      self.reason = reason\n      self.status = 'rejected';\n      // 执行我们存储的函数;\n      self.onRejected.forEach(fn => fn())\n    }\n  }\n  // 捕获错误传给reject。法律规定！\n\ttry{\n  \texecutor(resolve, reject);\n  } catch(e) {\n    reject(e);\n  }\n}\n\nfunction resolvePromise(promise2, res, resolve, reject) {\n  // 如果promise2和结果相同，就自己无限循环调用自己的then了，死亡循环。\n  // 举个🌰：var a = function(){return a}，这个then又会自己无限触发。所以就玩完了。\n  if(promise2 === res) {\n    return reject(new TypeError('循环引用'))\n  }\n  if(\n    res !== null \n    && (typeof res === 'object') || typeof res === 'function')\n  ) {\n    try {\n      // 保存是否已经调用过函数。\n      // 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.(如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）)\n      let used = false;\n      \n      // 2.3.3.1：Let then be x.then. [3.5](把 x.then 赋值给 then 变量)\n      // 可以提防有人恶搞。像👇\n      // Object.defineProperty(Promise, 'then', {\n      //    get: function(){\n      //        throw Error('error')\n      //    }\n      // })\n      // 这样的话我们取值就会报错。\n      let then = res.then;\n      // 如果then是函数，就默认是promise了   \n      if(typeof then === 'function') {\n        then.call(\n          res, \n          value => {\n            if(used) {\n              return;\n            }\n            used = true;\n            // 递归解析，直到不是一个promise为止\n            resolvePromise(promise2, value, resolve, reject);\n        \t},\n          reason => {\n            if(used) {\n              return;\n            }\n            used = true;\n            reject(reason);\n          }\n        )\n      }\n    } catch (e) {\n      if(used) {\n        return;\n      }\n      used = true;\n      reject(e);\n    }\n  } else {\n    // 如果不是函数或者对象也不为空就直接继续传递这个值。\n\t  resolve(res);  \n  }\n}\n\nMyPromise.prototype.then = function(onFulfilled, onRejected){\n  let self = this;\n  // 只有promise才可以持续的链式调用then,所以这里弄了一个新的promise\n  let promise2 = new MyPromise((resolve, reject) => {\n    // 当前的状态（fulfilled/rejected/pending），默认值为pending\n    if(self.status === 'fulfilled') {\n      let res = onFulfilled(self.value);\n      resolvePromise(promise2, res, resolve, reject);\n    }\n    // 当前的状态（fulfilled/rejected/pending），默认值为pending\n    if(self.status === 'rejected') {\n      let res = onRejected(self.reason);\n      resolvePromise(promise2, res, resolve, reject);\n    }\n    // 如果是pending应该存储当前的回调函数\n    if(self.status === 'pending') {\n      self.onResolved.push(() => {\n        let res = onFulfilled(self.value);\n      resolvePromise(promise2, res, resolve, reject);\n      })\n      self.onRejected.push(() => {\n        let res = onRejected(self.reason);\n      resolvePromise(promise2, res, resolve, reject);\n      })\n    }\n  })\n}\n```\n\n以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。\n\n## Generator\n\n> 面试题：介绍一下generator吧。\n\n很多小伙伴可能和我一样，只是会用，但是你硬要我介绍，那我咋搞？generator的拼写是g e n e r a t o r？\n\n“哔………………………………”\n\n其实我重温了一下阮老师的es6课程，发现可以从以下几个方面来介绍。\n\n- 形式上\n  - generator和普通的函数不同点在于，对一个`*`号，函数内部使用了yield表达式\n- 语法上\n  -  Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。\n- 调用上\n  -  普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。\n\n其实我觉得，如果能把下面的这个案例弄清楚，generator就算过关了。\n\n```js\nfunction *foo(x) {\n  let y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\nlet it = foo(5)\nconsole.log(it.next())   // => {value: 6, done: false}\nconsole.log(it.next(12)) // => {value: 8, done: false}\nconsole.log(it.next(13)) // => {value: 42, done: true}\n```\n\n- 首先 `Generator` 函数调用和普通函数不同，它会返回一个迭代器\n- 当执行第一次 `next` 时，传参会被忽略，并且函数暂停在 `yield (x + 1)` 处，所以返回 `5 + 1 = 6`\n- 当执行第二次 `next` 时，传入的参数等于上一个 `yield` 的返回值，如果你不传参，`yield` 永远返回 `undefined`。此时 `let y = 2 * 12`，所以第二个 `yield` 等于 `2 * 12 / 3 = 8`\n- 当执行第三次 `next` 时，传入的参数会传递给 `z`，所以 `z = 13, x = 5, y = 24`，相加等于 `42`\n\n## async/await\n\n> 什么是async/await？\n\n其实就一句话：**async 函数就是 Generator 函数的语法糖。**\n\ngenerator：\n\n```js\nvar gen = function* (){\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\nAsync:\n\n```js\nvar asyncReadFile = async function (){\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。\n\nasync对generator进行了以下三点的改进：\n\n1. **内置执行器。** Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n2. **更好的语义。** async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n3. **更广的适用性。** co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n一个函数如果加上了async，那么就会默认返回一个promise\n\n```js\nasync function fn(args){\n  // ...\n}\n\n// 等同于\n\nfunction fn(args){ \n  return spawn(function*() {\n    // ...\n  }); \n}\n```\n\n### 注意\n\nawait 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise().catch(function (err){\n    console.log(err);\n  });\n}\n```\n\nawait 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\n\n```js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n\n```\n\n\n\n## Reference\n\n> https://es6.ruanyifeng.com/#docs/generator\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【重识前端】暴走的异步编程","published":1,"updated":"2021-06-24T14:00:06.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8t0028lwrd3exr9n33","content":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<p><a href=\"https://juejin.im/post/6867814019055484942\" target=\"_blank\" rel=\"noopener\">【重识前端】暴走的异步编程</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>老规矩，还是先了解一下什么是异步。异步其实是一个相对比较高级的一个概念。</p>\n<p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p>\n<p>如果说一个事情需要等待上一件事情做完才能做，但是他们之前又没有强耦合关系。这样就在那里干等就毫无意义。特别是现在计算机普遍都有多核CPU的时代。</p>\n<p>举一个形象的🌰。</p>\n<p>我们现在要去吃海底捞（海底捞打钱！），我们发现要排队，需要排2个小时左右，这个时候我们要干嘛？难道是干等吗？肯定不是！那样蠢蠢的硬等很呆，我们可能会拿出手机刷刷朋友圈，或者玩一把紧张刺激的王者荣耀又或者去看一场电影等等….在我们做这些事情的时候我们的排队并没有被耽误，甚至可以和服务员说快到了打个电话给我（这个是常见的callback方法，待会讨论）</p>\n<blockquote>\n<p>这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。</p>\n</blockquote>\n<p>本文总结了几个异步的方案，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。</p>\n<h2 id=\"异步callback\"><a href=\"#异步callback\" class=\"headerlink\" title=\"异步callback\"></a>异步callback</h2><p>上来就是一个英俊的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> response = fetch(<span class=\"string\">'myImage.png'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = response.blob();</span><br></pre></td></tr></table></figure>\n\n<p>没有人可以完美预测到每种网络情况下这个response，是否可以完美获得fetch获得的内容，很有可能会报错。</p>\n<p>这个时候我们的callback就✨bu ling bu ling的登场啦。</p>\n<p>有些小伙伴可能觉得callback似乎和自己没有太大关系。。。emmmm….</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'You clicked me!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样呢？有没有感觉有点儿熟悉了，其他这个就相当于react中的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#123;()</span> =&gt;</span>&#123;alert('You clicked me!');&#125;&#125;&gt;</span><br><span class=\"line\">\t点我  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很熟悉，这个其实就是最常见的callback（回调函数）。</p>\n<p>又或者比较常见的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\talert(<span class=\"string\">'You clicked me!'</span>);</span><br><span class=\"line\">&#125;，<span class=\"number\">2000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>很常见，大致意思就是2秒钟之后会回调一下这个匿名函数，虽然不一定会准确执行，这个涉及到事件循环，感兴趣的可以去找一下我前阵子写的事件循环😊。</p>\n<h2 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布-订阅模式\"></a>发布-订阅模式</h2><p>发布-订阅模式：又称为观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。</p>\n<p>在写React的时候，有一个非常非常非常常见的🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;useState, useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [derrick, setDerrick] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(derrick)</span><br><span class=\"line\">  &#125;, [derrick])</span><br><span class=\"line\">  <span class=\"keyword\">return</span>(</span><br><span class=\"line\">    &lt;button onClick=&#123;() =&gt; &#123;setDerrick(derrick+<span class=\"number\">1</span>)&#125;&#125;&gt;点我&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>useEffect订阅了derrick这个变量的变化，然后监听到变化之后就会进行一次log，打印出derrick变量的值。</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"回调救星\"><a href=\"#回调救星\" class=\"headerlink\" title=\"回调救星\"></a>回调救星</h3><p>之前介绍过回调函数这种异步编程。</p>\n<p>加入我希望在A执行完之后执行B，然后执行C，然后执行D….最后执行Z</p>\n<p>写出来的代码可能是这样的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayhello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayhello(<span class=\"string\">\"first\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sayhello(<span class=\"string\">\"second\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    sayhello(<span class=\"string\">\"third\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"end\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>像本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复 杂的功能时，回调函数也会存在问题:若想让两个异步操作并行运行，并且在它们都结束后 提醒你，那该怎么做?若想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么 做?</p>\n<p>在这些情况下，你需要追踪多个回调函数并做清理操作， 不过好在promise横空出世拯救了世界。</p>\n<h3 id=\"涉及面试题\"><a href=\"#涉及面试题\" class=\"headerlink\" title=\"涉及面试题\"></a>涉及面试题</h3><blockquote>\n<p>promise用过吗？请你介绍一下promise。</p>\n</blockquote>\n<p>其实这里很多同学可能就不知道怎么介绍了，可能只停留在怎么用。我们可以从几个方面来介绍。</p>\n<ul>\n<li>promise是什么？</li>\n<li>promise解决了什么问题</li>\n<li>promise的优缺点</li>\n</ul>\n<h4 id=\"promise是什么？\"><a href=\"#promise是什么？\" class=\"headerlink\" title=\"promise是什么？\"></a>promise是什么？</h4><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"promise解决了什么问题？\"><a href=\"#promise解决了什么问题？\" class=\"headerlink\" title=\"promise解决了什么问题？\"></a>promise解决了什么问题？</h4><ol>\n<li>解决可读性的问题</li>\n<li>解决信任问题</li>\n</ol>\n<h5 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h5><p>可读性，之前的回调地狱promise就可以优雅的解决。(还有更加优雅的，待会会介绍。)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayhello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">      resolve();　　<span class=\"comment\">//在异步操作执行完后执行 resolve() 函数</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayhello(<span class=\"string\">\"first\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sayhello(<span class=\"string\">\"second\"</span>);　　<span class=\"comment\">//仍然返回一个 Promise 对象</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sayhello(<span class=\"string\">\"third\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"信任问题\"><a href=\"#信任问题\" class=\"headerlink\" title=\"信任问题\"></a>信任问题</h5><p>这个问题可以用promise的几个特点来解释：</p>\n<blockquote>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n</blockquote>\n<p>由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//信任问题演示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//回调</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        cb &amp;&amp; cb();</span><br><span class=\"line\">        <span class=\"comment\">//因为某些bug导致某个函数多执行了一次</span></span><br><span class=\"line\">        cb &amp;&amp; cb();</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">            <span class=\"comment\">//resolve成功调用一次之后，后面的不会再执行</span></span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>);        </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制反转。体现在对于函数的把控，比如this等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//回调</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        cb &amp;&amp; cb.call(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;);<span class=\"comment\">//执行回调，但是添油加醋</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            resolve();<span class=\"comment\">//调用的resolve都是自己写的，改善了控制反转的问题</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>);        </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手撕A-规范的promise\"><a href=\"#手撕A-规范的promise\" class=\"headerlink\" title=\"手撕A+规范的promise\"></a>手撕A+规范的promise</h3><blockquote>\n<p>面试题：你知道promise的A+规范吗？（本人在浩鲸科技被问到的，当时答的支支吾吾。。。）</p>\n</blockquote>\n<p>我何止是知道，我甚至可以手写一个符合A+规范的promise！</p>\n<p>A+规范快速入口，<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">点我</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>promise里面最难的就是then了，我们必须将这个方法写在他的原型链上面，并且他接受两个参数，一个是成功的回调，一个是失败的回调。</p>\n<p>废话不多说，开冲！</p>\n<h4 id=\"支持异步\"><a href=\"#支持异步\" class=\"headerlink\" title=\"支持异步\"></a>支持异步</h4><p>在此之前，我们需要加两个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>颜值高又细心的同学会发现，我多加了两个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">self.onResolved = [];</span><br><span class=\"line\"><span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">self.onRejected = [];</span><br></pre></td></tr></table></figure>\n\n<p>这两个变量呢，也非常好理解，就是存储回调的。那么有一个非常非常重要的问题，我写的时候也困扰了好久，为什么一定要是一个数组呢？我存储为一个函数不行吗？到时候执行就行啦。。。</p>\n<p>qs，和我想一样的帅哥靓女可能比较多。这里我统一回复：</p>\n<p>假如说。以下的情况出现的话，咋办。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//4 res</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种情况出现，如果我们只是一个函数，那么我们的<code>console.log(res, &#39;res&#39;)</code>这辈子都无法问世，为什么？因为被后门的<code>console.log(res1, &#39;res&#39;)</code>给覆盖了呀。对不对，如果说这个<code>resolve</code>他延迟执行，这个时候我们需要做的是把<code>then</code>函数给保存下来，等到<code>resolve</code>被执行的时候，依次执行我们所有创建的<code>then</code>里面的回调函数。</p>\n<p>听懂掌声！</p>\n<p>没听懂的接着往下看，我们把剩余工作做完，然后举一个例子。马上就能明白了。</p>\n<p>刚刚说到，我们补充两个变量，然后写下我们的<code>then</code>函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们还需要在<code>resolve</code>或者<code>reject</code>的时候执行我们存储起来的这些函数。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK。我们先试试我们自己写的promise。跑一下demo吧。为了给懒同学便捷的调试，直接CV下面就好啦。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>嗯~如愿输出了，那回到刚刚的问题。我们把回调的地方不要用数组而用函数呢？不用同学们打字了，直接CV👇的代码就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>是不是只有<code>console.log(res1, &#39;res1&#39;)</code>啦？因为执行<code>then</code>的时候，我们的resolve还有没有被调用，如果我们有多个<code>then</code>的话，我们需要把他们存储起来，然后依次调用。所以我们需要用到数组，当然也可以是别的方法，核心思想就是把他们存起来，在需要调用的时候调用。</p>\n<p>是不是很好理解？！！</p>\n<p>听懂掌声！</p>\n<p>而且A+也要求了。</p>\n<blockquote>\n<p><code>2.2.6:then</code> may be called multiple times on the same promise.</p>\n<p>（promise 的 <code>then</code> 可以链式调用多次）</p>\n<p>2.2.6.1：If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>\n<p>（如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行）</p>\n<p>2.2.6.2：If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>\n<p>（如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行）</p>\n</blockquote>\n<p>我们对promise的理解更进一步了。记得把代码改回去，继续往下走。</p>\n<p>刚刚我们的demo还不够鲁棒，而且我们的测试用例都是完美情况下。</p>\n<p>接下来要剑走偏锋了。</p>\n<blockquote>\n<p>A+:</p>\n<p>2.2.1：Both <code>onFulfilled</code> and <code>onRejected</code> are optional arguments:</p>\n<p>（onFulfilled 和 onRejected 都是可选参数：）</p>\n<p>2.2.1.1 If <code>onFulfilled</code> is not a function, it must be ignored.</p>\n<p>（如果 onFulfilled 不是函数，它会被忽略）</p>\n<p>2.2.1.2 If <code>onRejected</code> is not a function, it must be ignored.</p>\n<p>（如果 onRejected 不是函数，它会被忽略）</p>\n<p>2.2.7.2: If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>\n<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>\n</blockquote>\n<p>所以我们首先要做的就是，把错误给提前捕获，然后丢给<code>reject</code></p>\n<p>emmm….接下我贴代码都是一起贴了，因为我怕有同学会掉队，里面也会有相应的注释帮助会走神的同学跟紧这辆五菱宏光。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误传给reject。法律规定！</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  \texecutor(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    reject(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链式调用then\"><a href=\"#链式调用then\" class=\"headerlink\" title=\"链式调用then\"></a>链式调用then</h4><p>开始准备进入promise的难点以及核心点：链式调用。</p>\n<blockquote>\n<p>2.2.7：<code>then</code> must return a promise</p>\n<p>（then 方法一定返回一个 promise）</p>\n</blockquote>\n<p>我们需要返回新的promise的话，可以简单实现，快速迭代。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2.2.7.1：If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>.</p>\n<p>（如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以[[Resolve]](promise2, x)` 处理解析）</p>\n<p>2.2.7.2：If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>\n<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>\n<p>2.2.7.3：If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.</p>\n<p>（如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value）</p>\n<p>2.2.7.4：If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</p>\n<p>（如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason）</p>\n</blockquote>\n<p>我们需要将返回内容promise化，需要对onFulfilled和onRejected进行错误处理，这个我们之前就处理过了，如果onFulfilled和onRejected没有传参就继续传递，原生🌰来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">.then(<span class=\"string\">''</span>,<span class=\"string\">''</span>)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；要做的事情太多了，不当当是判断函数这种简单的判断了，所以我们要抽离一个新的函数来复用统一处理。因此我们进行如下完善：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误传给reject。法律规定！</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  \texecutor(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    reject(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, res, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果promise2和结果相同，就自己无限循环调用自己的then了，死亡循环。</span></span><br><span class=\"line\">  <span class=\"comment\">// 举个🌰：var a = function()&#123;return a&#125;，这个then又会自己无限触发。所以就玩完了。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(promise2 === res) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(</span><br><span class=\"line\">    res !== <span class=\"literal\">null</span> </span><br><span class=\"line\">    &amp;&amp; (<span class=\"keyword\">typeof</span> res === <span class=\"string\">'object'</span>) || <span class=\"keyword\">typeof</span> res === <span class=\"string\">'function'</span>)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存是否已经调用过函数。</span></span><br><span class=\"line\">      <span class=\"comment\">// 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.(如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）)</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> used = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 2.3.3.1：Let then be x.then. [3.5](把 x.then 赋值给 then 变量)</span></span><br><span class=\"line\">      <span class=\"comment\">// 可以提防有人恶搞。像👇</span></span><br><span class=\"line\">      <span class=\"comment\">// Object.defineProperty(Promise, 'then', &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//    get: function()&#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//        throw Error('error')</span></span><br><span class=\"line\">      <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// &#125;)</span></span><br><span class=\"line\">      <span class=\"comment\">// 这样的话我们取值就会报错。</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> then = res.then;</span><br><span class=\"line\">      <span class=\"comment\">// 如果then是函数，就默认是promise了   </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        then.call(</span><br><span class=\"line\">          res, </span><br><span class=\"line\">          value =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 递归解析，直到不是一个promise为止</span></span><br><span class=\"line\">            resolvePromise(promise2, value, resolve, reject);</span><br><span class=\"line\">        \t&#125;,</span><br><span class=\"line\">          reason =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(reason);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数或者对象也不为空就直接继续传递这个值。</span></span><br><span class=\"line\">\t  resolve(res);  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 只有promise才可以持续的链式调用then,所以这里弄了一个新的promise</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = onFulfilled(self.value);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = onRejected(self.reason);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = onFulfilled(self.value);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = onRejected(self.reason);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。</p>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><blockquote>\n<p>面试题：介绍一下generator吧。</p>\n</blockquote>\n<p>很多小伙伴可能和我一样，只是会用，但是你硬要我介绍，那我咋搞？generator的拼写是g e n e r a t o r？</p>\n<p>“哔………………………………”</p>\n<p>其实我重温了一下阮老师的es6课程，发现可以从以下几个方面来介绍。</p>\n<ul>\n<li>形式上<ul>\n<li>generator和普通的函数不同点在于，对一个<code>*</code>号，函数内部使用了yield表达式</li>\n</ul>\n</li>\n<li>语法上<ul>\n<li>Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。</li>\n</ul>\n</li>\n<li>调用上<ul>\n<li>普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。</li>\n</ul>\n</li>\n</ul>\n<p>其实我觉得，如果能把下面的这个案例弄清楚，generator就算过关了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> y = <span class=\"number\">2</span> * (<span class=\"keyword\">yield</span> (x + <span class=\"number\">1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">let</span> z = <span class=\"keyword\">yield</span> (y / <span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y + z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = foo(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next())   <span class=\"comment\">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(<span class=\"number\">12</span>)) <span class=\"comment\">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(<span class=\"number\">13</span>)) <span class=\"comment\">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>\n<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>\n<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>\n<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><blockquote>\n<p>什么是async/await？</p>\n</blockquote>\n<p>其实就一句话：<strong>async 函数就是 Generator 函数的语法糖。</strong></p>\n<p>generator：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Async:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>\n<p>async对generator进行了以下三点的改进：</p>\n<ol>\n<li><strong>内置执行器。</strong> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>\n<li><strong>更好的语义。</strong> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>\n<li><strong>更广的适用性。</strong> co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n</ol>\n<p>一个函数如果加上了async，那么就会默认返回一个promise</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><blockquote>\n<p><a href=\"https://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">https://es6.ruanyifeng.com/#docs/generator</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写【重拾前端】系列，下面有几个快速通道，大家自取</p>\n<p><a href=\"https://juejin.im/post/6850418113944420359\" target=\"_blank\" rel=\"noopener\">【重识前端】原型/原型链和继承</a></p>\n<p><a href=\"https://juejin.im/post/6850418117508759566\" target=\"_blank\" rel=\"noopener\">【重识前端】闭包与模块</a></p>\n<p><a href=\"https://juejin.im/post/6854573215658803208\" target=\"_blank\" rel=\"noopener\">【重识前端】全面攻破this</a></p>\n<p><a href=\"https://juejin.im/post/6859911609633767438\" target=\"_blank\" rel=\"noopener\">【重识前端】一次搞定JavaScript的执行机制</a></p>\n<p><a href=\"https://juejin.im/post/6860375101322461198\" target=\"_blank\" rel=\"noopener\">【重识前端】什么是BFC、IFC、GFC 和 FFC</a></p>\n<p><a href=\"https://juejin.im/post/6865204092877144077\" target=\"_blank\" rel=\"noopener\">【重识前端】深入内存世界</a></p>\n<p><a href=\"https://juejin.im/post/6867814019055484942\" target=\"_blank\" rel=\"noopener\">【重识前端】暴走的异步编程</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>老规矩，还是先了解一下什么是异步。异步其实是一个相对比较高级的一个概念。</p>\n<p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p>\n<p>如果说一个事情需要等待上一件事情做完才能做，但是他们之前又没有强耦合关系。这样就在那里干等就毫无意义。特别是现在计算机普遍都有多核CPU的时代。</p>\n<p>举一个形象的🌰。</p>\n<p>我们现在要去吃海底捞（海底捞打钱！），我们发现要排队，需要排2个小时左右，这个时候我们要干嘛？难道是干等吗？肯定不是！那样蠢蠢的硬等很呆，我们可能会拿出手机刷刷朋友圈，或者玩一把紧张刺激的王者荣耀又或者去看一场电影等等….在我们做这些事情的时候我们的排队并没有被耽误，甚至可以和服务员说快到了打个电话给我（这个是常见的callback方法，待会讨论）</p>\n<blockquote>\n<p>这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。</p>\n</blockquote>\n<p>本文总结了几个异步的方案，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。</p>\n<h2 id=\"异步callback\"><a href=\"#异步callback\" class=\"headerlink\" title=\"异步callback\"></a>异步callback</h2><p>上来就是一个英俊的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> response = fetch(<span class=\"string\">'myImage.png'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = response.blob();</span><br></pre></td></tr></table></figure>\n\n<p>没有人可以完美预测到每种网络情况下这个response，是否可以完美获得fetch获得的内容，很有可能会报错。</p>\n<p>这个时候我们的callback就✨bu ling bu ling的登场啦。</p>\n<p>有些小伙伴可能觉得callback似乎和自己没有太大关系。。。emmmm….</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'You clicked me!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样呢？有没有感觉有点儿熟悉了，其他这个就相当于react中的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#123;()</span> =&gt;</span>&#123;alert('You clicked me!');&#125;&#125;&gt;</span><br><span class=\"line\">\t点我  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很熟悉，这个其实就是最常见的callback（回调函数）。</p>\n<p>又或者比较常见的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\talert(<span class=\"string\">'You clicked me!'</span>);</span><br><span class=\"line\">&#125;，<span class=\"number\">2000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>很常见，大致意思就是2秒钟之后会回调一下这个匿名函数，虽然不一定会准确执行，这个涉及到事件循环，感兴趣的可以去找一下我前阵子写的事件循环😊。</p>\n<h2 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布-订阅模式\"></a>发布-订阅模式</h2><p>发布-订阅模式：又称为观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。</p>\n<p>在写React的时候，有一个非常非常非常常见的🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;useState, useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [derrick, setDerrick] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(derrick)</span><br><span class=\"line\">  &#125;, [derrick])</span><br><span class=\"line\">  <span class=\"keyword\">return</span>(</span><br><span class=\"line\">    &lt;button onClick=&#123;() =&gt; &#123;setDerrick(derrick+<span class=\"number\">1</span>)&#125;&#125;&gt;点我&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>useEffect订阅了derrick这个变量的变化，然后监听到变化之后就会进行一次log，打印出derrick变量的值。</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"回调救星\"><a href=\"#回调救星\" class=\"headerlink\" title=\"回调救星\"></a>回调救星</h3><p>之前介绍过回调函数这种异步编程。</p>\n<p>加入我希望在A执行完之后执行B，然后执行C，然后执行D….最后执行Z</p>\n<p>写出来的代码可能是这样的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayhello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayhello(<span class=\"string\">\"first\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sayhello(<span class=\"string\">\"second\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    sayhello(<span class=\"string\">\"third\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"end\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>像本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复 杂的功能时，回调函数也会存在问题:若想让两个异步操作并行运行，并且在它们都结束后 提醒你，那该怎么做?若想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么 做?</p>\n<p>在这些情况下，你需要追踪多个回调函数并做清理操作， 不过好在promise横空出世拯救了世界。</p>\n<h3 id=\"涉及面试题\"><a href=\"#涉及面试题\" class=\"headerlink\" title=\"涉及面试题\"></a>涉及面试题</h3><blockquote>\n<p>promise用过吗？请你介绍一下promise。</p>\n</blockquote>\n<p>其实这里很多同学可能就不知道怎么介绍了，可能只停留在怎么用。我们可以从几个方面来介绍。</p>\n<ul>\n<li>promise是什么？</li>\n<li>promise解决了什么问题</li>\n<li>promise的优缺点</li>\n</ul>\n<h4 id=\"promise是什么？\"><a href=\"#promise是什么？\" class=\"headerlink\" title=\"promise是什么？\"></a>promise是什么？</h4><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"promise解决了什么问题？\"><a href=\"#promise解决了什么问题？\" class=\"headerlink\" title=\"promise解决了什么问题？\"></a>promise解决了什么问题？</h4><ol>\n<li>解决可读性的问题</li>\n<li>解决信任问题</li>\n</ol>\n<h5 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h5><p>可读性，之前的回调地狱promise就可以优雅的解决。(还有更加优雅的，待会会介绍。)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayhello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">      resolve();　　<span class=\"comment\">//在异步操作执行完后执行 resolve() 函数</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayhello(<span class=\"string\">\"first\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sayhello(<span class=\"string\">\"second\"</span>);　　<span class=\"comment\">//仍然返回一个 Promise 对象</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sayhello(<span class=\"string\">\"third\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"信任问题\"><a href=\"#信任问题\" class=\"headerlink\" title=\"信任问题\"></a>信任问题</h5><p>这个问题可以用promise的几个特点来解释：</p>\n<blockquote>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n</blockquote>\n<p>由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//信任问题演示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//回调</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        cb &amp;&amp; cb();</span><br><span class=\"line\">        <span class=\"comment\">//因为某些bug导致某个函数多执行了一次</span></span><br><span class=\"line\">        cb &amp;&amp; cb();</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">            <span class=\"comment\">//resolve成功调用一次之后，后面的不会再执行</span></span><br><span class=\"line\">            resolve();</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>);        </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制反转。体现在对于函数的把控，比如this等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//回调</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        cb &amp;&amp; cb.call(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;);<span class=\"comment\">//执行回调，但是添油加醋</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            resolve();<span class=\"comment\">//调用的resolve都是自己写的，改善了控制反转的问题</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>);        </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手撕A-规范的promise\"><a href=\"#手撕A-规范的promise\" class=\"headerlink\" title=\"手撕A+规范的promise\"></a>手撕A+规范的promise</h3><blockquote>\n<p>面试题：你知道promise的A+规范吗？（本人在浩鲸科技被问到的，当时答的支支吾吾。。。）</p>\n</blockquote>\n<p>我何止是知道，我甚至可以手写一个符合A+规范的promise！</p>\n<p>A+规范快速入口，<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">点我</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>promise里面最难的就是then了，我们必须将这个方法写在他的原型链上面，并且他接受两个参数，一个是成功的回调，一个是失败的回调。</p>\n<p>废话不多说，开冲！</p>\n<h4 id=\"支持异步\"><a href=\"#支持异步\" class=\"headerlink\" title=\"支持异步\"></a>支持异步</h4><p>在此之前，我们需要加两个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>颜值高又细心的同学会发现，我多加了两个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">self.onResolved = [];</span><br><span class=\"line\"><span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">self.onRejected = [];</span><br></pre></td></tr></table></figure>\n\n<p>这两个变量呢，也非常好理解，就是存储回调的。那么有一个非常非常重要的问题，我写的时候也困扰了好久，为什么一定要是一个数组呢？我存储为一个函数不行吗？到时候执行就行啦。。。</p>\n<p>qs，和我想一样的帅哥靓女可能比较多。这里我统一回复：</p>\n<p>假如说。以下的情况出现的话，咋办。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//4 res</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种情况出现，如果我们只是一个函数，那么我们的<code>console.log(res, &#39;res&#39;)</code>这辈子都无法问世，为什么？因为被后门的<code>console.log(res1, &#39;res&#39;)</code>给覆盖了呀。对不对，如果说这个<code>resolve</code>他延迟执行，这个时候我们需要做的是把<code>then</code>函数给保存下来，等到<code>resolve</code>被执行的时候，依次执行我们所有创建的<code>then</code>里面的回调函数。</p>\n<p>听懂掌声！</p>\n<p>没听懂的接着往下看，我们把剩余工作做完，然后举一个例子。马上就能明白了。</p>\n<p>刚刚说到，我们补充两个变量，然后写下我们的<code>then</code>函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们还需要在<code>resolve</code>或者<code>reject</code>的时候执行我们存储起来的这些函数。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onFulfilled(self.value)&#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;onRejected(self.reason)&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK。我们先试试我们自己写的promise。跑一下demo吧。为了给懒同学便捷的调试，直接CV下面就好啦。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>嗯~如愿输出了，那回到刚刚的问题。我们把回调的地方不要用数组而用函数呢？不用同学们打字了，直接CV👇的代码就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'res'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res1</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//4 res1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1, <span class=\"string\">'res1'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>是不是只有<code>console.log(res1, &#39;res1&#39;)</code>啦？因为执行<code>then</code>的时候，我们的resolve还有没有被调用，如果我们有多个<code>then</code>的话，我们需要把他们存储起来，然后依次调用。所以我们需要用到数组，当然也可以是别的方法，核心思想就是把他们存起来，在需要调用的时候调用。</p>\n<p>是不是很好理解？！！</p>\n<p>听懂掌声！</p>\n<p>而且A+也要求了。</p>\n<blockquote>\n<p><code>2.2.6:then</code> may be called multiple times on the same promise.</p>\n<p>（promise 的 <code>then</code> 可以链式调用多次）</p>\n<p>2.2.6.1：If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>\n<p>（如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行）</p>\n<p>2.2.6.2：If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.</p>\n<p>（如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行）</p>\n</blockquote>\n<p>我们对promise的理解更进一步了。记得把代码改回去，继续往下走。</p>\n<p>刚刚我们的demo还不够鲁棒，而且我们的测试用例都是完美情况下。</p>\n<p>接下来要剑走偏锋了。</p>\n<blockquote>\n<p>A+:</p>\n<p>2.2.1：Both <code>onFulfilled</code> and <code>onRejected</code> are optional arguments:</p>\n<p>（onFulfilled 和 onRejected 都是可选参数：）</p>\n<p>2.2.1.1 If <code>onFulfilled</code> is not a function, it must be ignored.</p>\n<p>（如果 onFulfilled 不是函数，它会被忽略）</p>\n<p>2.2.1.2 If <code>onRejected</code> is not a function, it must be ignored.</p>\n<p>（如果 onRejected 不是函数，它会被忽略）</p>\n<p>2.2.7.2: If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>\n<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>\n</blockquote>\n<p>所以我们首先要做的就是，把错误给提前捕获，然后丢给<code>reject</code></p>\n<p>emmm….接下我贴代码都是一起贴了，因为我怕有同学会掉队，里面也会有相应的注释帮助会走神的同学跟紧这辆五菱宏光。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误传给reject。法律规定！</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  \texecutor(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    reject(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; onFulfilled(self.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; onRejected(self.reason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数就忽略 2.2.1.1</span></span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onFulfilled(self.value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数就忽略 2.2.1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      onRejected(self.reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链式调用then\"><a href=\"#链式调用then\" class=\"headerlink\" title=\"链式调用then\"></a>链式调用then</h4><p>开始准备进入promise的难点以及核心点：链式调用。</p>\n<blockquote>\n<p>2.2.7：<code>then</code> must return a promise</p>\n<p>（then 方法一定返回一个 promise）</p>\n</blockquote>\n<p>我们需要返回新的promise的话，可以简单实现，快速迭代。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2.2.7.1：If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>.</p>\n<p>（如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以[[Resolve]](promise2, x)` 处理解析）</p>\n<p>2.2.7.2：If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>\n<p>（如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数））</p>\n<p>2.2.7.3：If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.</p>\n<p>（如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value）</p>\n<p>2.2.7.4：If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</p>\n<p>（如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason）</p>\n</blockquote>\n<p>我们需要将返回内容promise化，需要对onFulfilled和onRejected进行错误处理，这个我们之前就处理过了，如果onFulfilled和onRejected没有传参就继续传递，原生🌰来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">.then(<span class=\"string\">''</span>,<span class=\"string\">''</span>)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；要做的事情太多了，不当当是判断函数这种简单的判断了，所以我们要抽离一个新的函数来复用统一处理。因此我们进行如下完善：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错this的指向，后面可能会有回调函数，然后会隐式丢失啊之类的。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的值</span></span><br><span class=\"line\">  self.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的值</span></span><br><span class=\"line\">  self.reason = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 存储成功的回调</span></span><br><span class=\"line\">  self.onResolved = [];</span><br><span class=\"line\">  <span class=\"comment\">// 存储失败的回调</span></span><br><span class=\"line\">  self.onRejected = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下成功的值</span></span><br><span class=\"line\">      self.value = value</span><br><span class=\"line\">      self.status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onResolved.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1.1规定只有在pending状态的时候才可以转变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 存下失败的值</span></span><br><span class=\"line\">      self.reason = reason</span><br><span class=\"line\">      self.status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 执行我们存储的函数;</span></span><br><span class=\"line\">      self.onRejected.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误传给reject。法律规定！</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  \texecutor(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    reject(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, res, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果promise2和结果相同，就自己无限循环调用自己的then了，死亡循环。</span></span><br><span class=\"line\">  <span class=\"comment\">// 举个🌰：var a = function()&#123;return a&#125;，这个then又会自己无限触发。所以就玩完了。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(promise2 === res) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(</span><br><span class=\"line\">    res !== <span class=\"literal\">null</span> </span><br><span class=\"line\">    &amp;&amp; (<span class=\"keyword\">typeof</span> res === <span class=\"string\">'object'</span>) || <span class=\"keyword\">typeof</span> res === <span class=\"string\">'function'</span>)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存是否已经调用过函数。</span></span><br><span class=\"line\">      <span class=\"comment\">// 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.(如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）)</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> used = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 2.3.3.1：Let then be x.then. [3.5](把 x.then 赋值给 then 变量)</span></span><br><span class=\"line\">      <span class=\"comment\">// 可以提防有人恶搞。像👇</span></span><br><span class=\"line\">      <span class=\"comment\">// Object.defineProperty(Promise, 'then', &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//    get: function()&#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//        throw Error('error')</span></span><br><span class=\"line\">      <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// &#125;)</span></span><br><span class=\"line\">      <span class=\"comment\">// 这样的话我们取值就会报错。</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> then = res.then;</span><br><span class=\"line\">      <span class=\"comment\">// 如果then是函数，就默认是promise了   </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        then.call(</span><br><span class=\"line\">          res, </span><br><span class=\"line\">          value =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 递归解析，直到不是一个promise为止</span></span><br><span class=\"line\">            resolvePromise(promise2, value, resolve, reject);</span><br><span class=\"line\">        \t&#125;,</span><br><span class=\"line\">          reason =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(reason);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(used) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      used = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是函数或者对象也不为空就直接继续传递这个值。</span></span><br><span class=\"line\">\t  resolve(res);  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 只有promise才可以持续的链式调用then,所以这里弄了一个新的promise</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'fulfilled'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = onFulfilled(self.value);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的状态（fulfilled/rejected/pending），默认值为pending</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = onRejected(self.reason);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是pending应该存储当前的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">      self.onResolved.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = onFulfilled(self.value);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      self.onRejected.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = onRejected(self.reason);</span><br><span class=\"line\">      resolvePromise(promise2, res, resolve, reject);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。</p>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><blockquote>\n<p>面试题：介绍一下generator吧。</p>\n</blockquote>\n<p>很多小伙伴可能和我一样，只是会用，但是你硬要我介绍，那我咋搞？generator的拼写是g e n e r a t o r？</p>\n<p>“哔………………………………”</p>\n<p>其实我重温了一下阮老师的es6课程，发现可以从以下几个方面来介绍。</p>\n<ul>\n<li>形式上<ul>\n<li>generator和普通的函数不同点在于，对一个<code>*</code>号，函数内部使用了yield表达式</li>\n</ul>\n</li>\n<li>语法上<ul>\n<li>Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。</li>\n</ul>\n</li>\n<li>调用上<ul>\n<li>普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。</li>\n</ul>\n</li>\n</ul>\n<p>其实我觉得，如果能把下面的这个案例弄清楚，generator就算过关了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> y = <span class=\"number\">2</span> * (<span class=\"keyword\">yield</span> (x + <span class=\"number\">1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">let</span> z = <span class=\"keyword\">yield</span> (y / <span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y + z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = foo(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next())   <span class=\"comment\">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(<span class=\"number\">12</span>)) <span class=\"comment\">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next(<span class=\"number\">13</span>)) <span class=\"comment\">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>\n<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>\n<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>\n<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><blockquote>\n<p>什么是async/await？</p>\n</blockquote>\n<p>其实就一句话：<strong>async 函数就是 Generator 函数的语法糖。</strong></p>\n<p>generator：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Async:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>\n<p>async对generator进行了以下三点的改进：</p>\n<ol>\n<li><strong>内置执行器。</strong> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>\n<li><strong>更好的语义。</strong> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>\n<li><strong>更广的适用性。</strong> co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n</ol>\n<p>一个函数如果加上了async，那么就会默认返回一个promise</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><blockquote>\n<p><a href=\"https://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">https://es6.ruanyifeng.com/#docs/generator</a></p>\n</blockquote>\n"},{"title":"【面经】2年前端杭州面试集合","date":"2020-10-28T13:53:09.000Z","cover":"/image/cover/bg.jpg","_content":"\n# 前言\n\n说一点废话吧，算是吐槽。\n\n现在杭州的氛围很怪，双休都可以拿出来吹的那种。唉，不过虽然是疫情，前端的岗位还是蛮多的，我基本上一天2个面试。在未来科技城和滨江两头跑。不过现在已经入职啦。\n\n# 公司列表\n\n- 安恒科技 -> 挂在4面副总裁。\n  - 看了知乎上面的评价然后去面的副总裁，发现加班严重，然后期望薪资开的比较高，而且副总裁期间一直在摆弄手机不知道是不是比较忙，场面经常冷静好一会。\n- 博圣生物 -> offer，但是薪资开的比较低，所以没去\n- 数秦科技 -> 已经入职啦\n- 火石创造 -> 挂在HR那边了，估计是我跳槽比较频繁，而且那天很晚过去的，人很疲惫没什么精神，HR还问我平常是不是也是这样没精神....尴尬\n- 博联智能 -> 后面发现前端团队只有一个人，而且面试官好像工作没多久。。。全是网上的题目，二面就没去了\n- 婚礼纪 -> 挂在2面，前端leader觉得我node不太熟悉，广度不够....\n- 数立信息 -> 挂在二面，不知道具体哪里不行....我感觉我都答上来了...\n- 阿里零售事业部 -> 一面就挂了，那个时候刚刚坐动车到杭州，确实也没怎么准备，很可惜！\n- 光云科技 -> 我期望开的太高了....然后挂在了HR\n\n# 面经\n\n## 阿里-零售部\n\n### 1面\n\n1. jsbridge的原理\n2. 跨域的场景你用到那些？\n3. jsonp的原理，jsonp怎么用\n4. 有数据相关的吗？比如PV，UV\n5. px to rem的原理能说一下吗？\n6. 具体怎么算的可以说一下吗？\n7. onClick是什么时候执行的？\n8. 如果我写了一个addListener，然后又写了onCLick，这个时候点击一下会发生什么事情？\n9. 前端性能优化\n10. happypack原理\n11. react的虚拟DOM算法\n\n## 安恒科技\n\n### 1面\n\n1. 类组件和函数式组件的区别，或者说一下你使用最直接的感受，以及他们的优缺点\n2. 有试过自己封装Hook吗？\n3. 改变this指向的方式除了bind以及箭头函数还有哪些？\n4. 为什么React中onClick在点击的时候会执行？\n5. React中key的作用\n6. React Fiber你了解吗？\n7. 说一下虚拟DOM的优缺点\n8. 开发中用到Redux是自己封装的吗？\n9. React类组件的extends和createElement有什么区别吗？\n10. 组件名字首字母为什么一定要大写？\n11. ES5中判断数组有什么方式？\n12. 怎么样并发请求？\n13. 前端性能优化\n14. 有用过Typescript吗？介绍一下你平常常用的\n15. 工作中遇到最难的问题\n16. 平常是怎么学习的\n\n### 2面\n\n本来要面试我的二面的面试官零时有事，这个是隔壁组的leader。。\n\n1. 封装一个网络请求是怎么封装的，要达到什么样的效果（因为我简历写了\n2. 说一下你封装表单组件的想法（也是简历。。。\n3. 说一下你的鉴权思路（也是简历\n4. 现在Typescript有用吗？你觉得自己Typescript用的怎么样？\n5. 说一下React最新的生命周期\n6. 有写过Redux的中间件吗？\n7. 说一下React Fiber做了一件什么事情\n\n### 3面\n\n忘记录音了。。。靠记忆力想想\n\n1. 说一下事件循环\n2. 我们写的onClick是事件捕获吗？和事件冒泡的顺序是怎么样的\n3. CSS的权重\n4. 对于跨域你是怎看待的\n5. 说一下你对JavaScript内存的理解\n6. 介绍一下Promise吧\n7. 输入URL到页面渲染发生了什么\n8. 平常是怎么学习的？\n\n题目太宽泛了。。。考察知识深度。。\n\n### 4面\n\n1. 为什么从上家公司离职\n2. 说一下你对加班的理解\n3. 对未来的规划\n\n## 博圣生物\n\n### 1面\n\n1. 离职原因\n2. 项目中印象中比较深刻的\n3. 对于移动端的适配\n4. 高清屏1px的兼容，高清屏变粗问题\n   1. 要精确到每一行。。。\n5. 说一下防抖节流的原理\n6. JS拖拽原理\n7. 说一下flex的每个属性对应的意思\n8. CSS水平垂直居中\n9. 有自己写过webpack loader和plugin吗？他们的原理和区别\n\n### 2面\n\n1. React源码有读过吗？\n2. Fiber是怎么做调度的，js不是单线程吗？是怎么打断计算的？\n3. 说一下你平常用的Hooks吧\n4. 介绍前端性能优化\n5. 对于前端代码攻击你了解哪些？\n6. cookie的存储有哪些新的属性\n7. Http2有哪些新功能\n8. http和https有什么区别\n9. 介绍一下非对称加密\n10. JavaScript继承熟悉吗？有哪些方式？\n\n### 3面HR\n\n上来就源码我以为我要凉了，不过后面都有复习到，算是扳回一城。谈薪。\n\n## 火石创造\n\n是一家前端主导的团队，前端人超级多\n\n### 1面\n\n1. 说一下移动端适配的原理\n2. 说一下前端性能优化\n3. 平常对于跨域是怎么做的\n4. webpack的plugin有做过吗？\n5. JS的继承\n6. 看你有封装过echarts，你是怎么封装的\n7. Vue和React的区别\n8. 说一下CSS动画\n9. 说一下key在React和Vue中的作用，如果没有会怎么样？会有什么问题，具体\n10. RN有做过吗？Taro呢？\n11. 现在我有一个数组，我想针对每个元素的后面都加入一个新的元素，有哪些方法\n12. 假如我用for的索引来加，会有什么问题？\n\n### 2面HR\n\n可能是太晚了，火石是第三家面试了，而且我坐了很久的地铁，HR可能觉得我人没精神，也有可能我确实有毛病。。。\n\n## 博联智能\n\n### 1面\n\n基本上都是很基础的题目。感觉是之前团队全部跑路了，只有他一个前端，而且加班很严重，他的好像才刚刚毕业....\n\n## 婚礼纪\n\n### 1面\n\n1. 你用过哪些Hook\n2. Hook的规则原理\n3. 为什么要移除那些生命周期\n4. 说一下时间循环\n5. setState是同步还是异步？\n6. setState的回调函数是宏任务还是微任务\n7. webpack热更新原理\n8. webpack的loader的作用\n9. 为什么Fiber可以中断正在进行中的计算？\n10. JSX编译之后是什么样子的？\n11. React中那些props不能传递，为什么？\n12. 假如我要封装一下上拉加载的Hook要怎么封装？\n\n### 2面\n\n1. nodejs 常用命令你知道哪些？\n2. 介绍一下JavaScript的内存\n3. WeakMap和Map有什么区别\n4. Post和Get有什么区别\n5. 返回的状态码一定200就是对的吗？\n6. 那我返回300也可以是对的吗？\n7. electron用过吗？\n8. RN会吗？\n9. Webpack的原理\n10. 现在让你手写一个Webpack，你要怎么来写？\n11. Webpack优化知道哪些？\n\n凉凉。。。广度不够。。。555\n\n## 数立信息\n\n### 1面\n\n1. 什么是原型链\n2. 手写寄生组合继承\n3. this指向优先级\n4. 什么叫做闭包？\n5. useEffect的回调函数每次都会执行还是在卸载的时候执行？\n6. 类组件的this变量，在函数是组件中怎么表示？\n7. setState的链表是环形的吗？为什么？\n8. 跨域\n\n### 2面\n\n1. redux源码读过吗？\n2. redux中间件的设计理念是什么？\n3. sticky用过吗？\n4. px to rem的计算原理\n5. Webpack的tree shanking了解吗？原理？怎么写？\n6. BFC为什么会有那些特性？\n7. React事件集合原理\n8. 为什么虚拟DOM可以做跨平台\n\n## 光云科技\n\n### 1面\n\n1. var let const区别\n2. localStorage sessionStorage cookie token区别\n3. token的组成\n4. React为什么移除那些生命周期\n5. Hook的设计理念，Hook规则原理\n6. key的作用\n7. 说一下你了解的闭包\n8. 自定义loader写过吗？\n9. 跨域的方式方法\n\n### 2面\n\n1. https和http的区别\n2. http请求头的组成\n3. cookie的作用\n4. cookie的新的属性\n5. 怎么阻止第三方攻击\n6. 假如让你设计一个秒杀页面你会想到那些场景和应对方式\n\n# 总结\n\n我个人认为必考的几个点，如果复习好了的话。1面应该问题不大\n\n1. URL到页面渲染过程\n2. JavaScript继承\n3. 闭包\n4. Promise\n5. http请求头，码，方法之间的区别，http2，https\n6. 跨域\n7. React Fiber原理\n8. Hook规则原理\n9. setState是否异步\n10. 前端性能优化（Webpack，js，css，重绘，回流，防抖，节流\n11. React生命周期，官方的Hooks烂熟于心\n12. Flex，BFC，居中\n\n\n\n","source":"_posts/【面经】2年前端杭州面试集合.md","raw":"---\ntitle: 【面经】2年前端杭州面试集合\ndate: 2020-10-28 21:53:09\ntags: [面经]\ncategories: [面经]\ncover: /image/cover/bg.jpg\n---\n\n# 前言\n\n说一点废话吧，算是吐槽。\n\n现在杭州的氛围很怪，双休都可以拿出来吹的那种。唉，不过虽然是疫情，前端的岗位还是蛮多的，我基本上一天2个面试。在未来科技城和滨江两头跑。不过现在已经入职啦。\n\n# 公司列表\n\n- 安恒科技 -> 挂在4面副总裁。\n  - 看了知乎上面的评价然后去面的副总裁，发现加班严重，然后期望薪资开的比较高，而且副总裁期间一直在摆弄手机不知道是不是比较忙，场面经常冷静好一会。\n- 博圣生物 -> offer，但是薪资开的比较低，所以没去\n- 数秦科技 -> 已经入职啦\n- 火石创造 -> 挂在HR那边了，估计是我跳槽比较频繁，而且那天很晚过去的，人很疲惫没什么精神，HR还问我平常是不是也是这样没精神....尴尬\n- 博联智能 -> 后面发现前端团队只有一个人，而且面试官好像工作没多久。。。全是网上的题目，二面就没去了\n- 婚礼纪 -> 挂在2面，前端leader觉得我node不太熟悉，广度不够....\n- 数立信息 -> 挂在二面，不知道具体哪里不行....我感觉我都答上来了...\n- 阿里零售事业部 -> 一面就挂了，那个时候刚刚坐动车到杭州，确实也没怎么准备，很可惜！\n- 光云科技 -> 我期望开的太高了....然后挂在了HR\n\n# 面经\n\n## 阿里-零售部\n\n### 1面\n\n1. jsbridge的原理\n2. 跨域的场景你用到那些？\n3. jsonp的原理，jsonp怎么用\n4. 有数据相关的吗？比如PV，UV\n5. px to rem的原理能说一下吗？\n6. 具体怎么算的可以说一下吗？\n7. onClick是什么时候执行的？\n8. 如果我写了一个addListener，然后又写了onCLick，这个时候点击一下会发生什么事情？\n9. 前端性能优化\n10. happypack原理\n11. react的虚拟DOM算法\n\n## 安恒科技\n\n### 1面\n\n1. 类组件和函数式组件的区别，或者说一下你使用最直接的感受，以及他们的优缺点\n2. 有试过自己封装Hook吗？\n3. 改变this指向的方式除了bind以及箭头函数还有哪些？\n4. 为什么React中onClick在点击的时候会执行？\n5. React中key的作用\n6. React Fiber你了解吗？\n7. 说一下虚拟DOM的优缺点\n8. 开发中用到Redux是自己封装的吗？\n9. React类组件的extends和createElement有什么区别吗？\n10. 组件名字首字母为什么一定要大写？\n11. ES5中判断数组有什么方式？\n12. 怎么样并发请求？\n13. 前端性能优化\n14. 有用过Typescript吗？介绍一下你平常常用的\n15. 工作中遇到最难的问题\n16. 平常是怎么学习的\n\n### 2面\n\n本来要面试我的二面的面试官零时有事，这个是隔壁组的leader。。\n\n1. 封装一个网络请求是怎么封装的，要达到什么样的效果（因为我简历写了\n2. 说一下你封装表单组件的想法（也是简历。。。\n3. 说一下你的鉴权思路（也是简历\n4. 现在Typescript有用吗？你觉得自己Typescript用的怎么样？\n5. 说一下React最新的生命周期\n6. 有写过Redux的中间件吗？\n7. 说一下React Fiber做了一件什么事情\n\n### 3面\n\n忘记录音了。。。靠记忆力想想\n\n1. 说一下事件循环\n2. 我们写的onClick是事件捕获吗？和事件冒泡的顺序是怎么样的\n3. CSS的权重\n4. 对于跨域你是怎看待的\n5. 说一下你对JavaScript内存的理解\n6. 介绍一下Promise吧\n7. 输入URL到页面渲染发生了什么\n8. 平常是怎么学习的？\n\n题目太宽泛了。。。考察知识深度。。\n\n### 4面\n\n1. 为什么从上家公司离职\n2. 说一下你对加班的理解\n3. 对未来的规划\n\n## 博圣生物\n\n### 1面\n\n1. 离职原因\n2. 项目中印象中比较深刻的\n3. 对于移动端的适配\n4. 高清屏1px的兼容，高清屏变粗问题\n   1. 要精确到每一行。。。\n5. 说一下防抖节流的原理\n6. JS拖拽原理\n7. 说一下flex的每个属性对应的意思\n8. CSS水平垂直居中\n9. 有自己写过webpack loader和plugin吗？他们的原理和区别\n\n### 2面\n\n1. React源码有读过吗？\n2. Fiber是怎么做调度的，js不是单线程吗？是怎么打断计算的？\n3. 说一下你平常用的Hooks吧\n4. 介绍前端性能优化\n5. 对于前端代码攻击你了解哪些？\n6. cookie的存储有哪些新的属性\n7. Http2有哪些新功能\n8. http和https有什么区别\n9. 介绍一下非对称加密\n10. JavaScript继承熟悉吗？有哪些方式？\n\n### 3面HR\n\n上来就源码我以为我要凉了，不过后面都有复习到，算是扳回一城。谈薪。\n\n## 火石创造\n\n是一家前端主导的团队，前端人超级多\n\n### 1面\n\n1. 说一下移动端适配的原理\n2. 说一下前端性能优化\n3. 平常对于跨域是怎么做的\n4. webpack的plugin有做过吗？\n5. JS的继承\n6. 看你有封装过echarts，你是怎么封装的\n7. Vue和React的区别\n8. 说一下CSS动画\n9. 说一下key在React和Vue中的作用，如果没有会怎么样？会有什么问题，具体\n10. RN有做过吗？Taro呢？\n11. 现在我有一个数组，我想针对每个元素的后面都加入一个新的元素，有哪些方法\n12. 假如我用for的索引来加，会有什么问题？\n\n### 2面HR\n\n可能是太晚了，火石是第三家面试了，而且我坐了很久的地铁，HR可能觉得我人没精神，也有可能我确实有毛病。。。\n\n## 博联智能\n\n### 1面\n\n基本上都是很基础的题目。感觉是之前团队全部跑路了，只有他一个前端，而且加班很严重，他的好像才刚刚毕业....\n\n## 婚礼纪\n\n### 1面\n\n1. 你用过哪些Hook\n2. Hook的规则原理\n3. 为什么要移除那些生命周期\n4. 说一下时间循环\n5. setState是同步还是异步？\n6. setState的回调函数是宏任务还是微任务\n7. webpack热更新原理\n8. webpack的loader的作用\n9. 为什么Fiber可以中断正在进行中的计算？\n10. JSX编译之后是什么样子的？\n11. React中那些props不能传递，为什么？\n12. 假如我要封装一下上拉加载的Hook要怎么封装？\n\n### 2面\n\n1. nodejs 常用命令你知道哪些？\n2. 介绍一下JavaScript的内存\n3. WeakMap和Map有什么区别\n4. Post和Get有什么区别\n5. 返回的状态码一定200就是对的吗？\n6. 那我返回300也可以是对的吗？\n7. electron用过吗？\n8. RN会吗？\n9. Webpack的原理\n10. 现在让你手写一个Webpack，你要怎么来写？\n11. Webpack优化知道哪些？\n\n凉凉。。。广度不够。。。555\n\n## 数立信息\n\n### 1面\n\n1. 什么是原型链\n2. 手写寄生组合继承\n3. this指向优先级\n4. 什么叫做闭包？\n5. useEffect的回调函数每次都会执行还是在卸载的时候执行？\n6. 类组件的this变量，在函数是组件中怎么表示？\n7. setState的链表是环形的吗？为什么？\n8. 跨域\n\n### 2面\n\n1. redux源码读过吗？\n2. redux中间件的设计理念是什么？\n3. sticky用过吗？\n4. px to rem的计算原理\n5. Webpack的tree shanking了解吗？原理？怎么写？\n6. BFC为什么会有那些特性？\n7. React事件集合原理\n8. 为什么虚拟DOM可以做跨平台\n\n## 光云科技\n\n### 1面\n\n1. var let const区别\n2. localStorage sessionStorage cookie token区别\n3. token的组成\n4. React为什么移除那些生命周期\n5. Hook的设计理念，Hook规则原理\n6. key的作用\n7. 说一下你了解的闭包\n8. 自定义loader写过吗？\n9. 跨域的方式方法\n\n### 2面\n\n1. https和http的区别\n2. http请求头的组成\n3. cookie的作用\n4. cookie的新的属性\n5. 怎么阻止第三方攻击\n6. 假如让你设计一个秒杀页面你会想到那些场景和应对方式\n\n# 总结\n\n我个人认为必考的几个点，如果复习好了的话。1面应该问题不大\n\n1. URL到页面渲染过程\n2. JavaScript继承\n3. 闭包\n4. Promise\n5. http请求头，码，方法之间的区别，http2，https\n6. 跨域\n7. React Fiber原理\n8. Hook规则原理\n9. setState是否异步\n10. 前端性能优化（Webpack，js，css，重绘，回流，防抖，节流\n11. React生命周期，官方的Hooks烂熟于心\n12. Flex，BFC，居中\n\n\n\n","slug":"【面经】2年前端杭州面试集合","published":1,"updated":"2021-06-24T14:00:06.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8u0029lwrd6zz2auvz","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>说一点废话吧，算是吐槽。</p>\n<p>现在杭州的氛围很怪，双休都可以拿出来吹的那种。唉，不过虽然是疫情，前端的岗位还是蛮多的，我基本上一天2个面试。在未来科技城和滨江两头跑。不过现在已经入职啦。</p>\n<h1 id=\"公司列表\"><a href=\"#公司列表\" class=\"headerlink\" title=\"公司列表\"></a>公司列表</h1><ul>\n<li>安恒科技 -&gt; 挂在4面副总裁。<ul>\n<li>看了知乎上面的评价然后去面的副总裁，发现加班严重，然后期望薪资开的比较高，而且副总裁期间一直在摆弄手机不知道是不是比较忙，场面经常冷静好一会。</li>\n</ul>\n</li>\n<li>博圣生物 -&gt; offer，但是薪资开的比较低，所以没去</li>\n<li>数秦科技 -&gt; 已经入职啦</li>\n<li>火石创造 -&gt; 挂在HR那边了，估计是我跳槽比较频繁，而且那天很晚过去的，人很疲惫没什么精神，HR还问我平常是不是也是这样没精神….尴尬</li>\n<li>博联智能 -&gt; 后面发现前端团队只有一个人，而且面试官好像工作没多久。。。全是网上的题目，二面就没去了</li>\n<li>婚礼纪 -&gt; 挂在2面，前端leader觉得我node不太熟悉，广度不够….</li>\n<li>数立信息 -&gt; 挂在二面，不知道具体哪里不行….我感觉我都答上来了…</li>\n<li>阿里零售事业部 -&gt; 一面就挂了，那个时候刚刚坐动车到杭州，确实也没怎么准备，很可惜！</li>\n<li>光云科技 -&gt; 我期望开的太高了….然后挂在了HR</li>\n</ul>\n<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><h2 id=\"阿里-零售部\"><a href=\"#阿里-零售部\" class=\"headerlink\" title=\"阿里-零售部\"></a>阿里-零售部</h2><h3 id=\"1面\"><a href=\"#1面\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>jsbridge的原理</li>\n<li>跨域的场景你用到那些？</li>\n<li>jsonp的原理，jsonp怎么用</li>\n<li>有数据相关的吗？比如PV，UV</li>\n<li>px to rem的原理能说一下吗？</li>\n<li>具体怎么算的可以说一下吗？</li>\n<li>onClick是什么时候执行的？</li>\n<li>如果我写了一个addListener，然后又写了onCLick，这个时候点击一下会发生什么事情？</li>\n<li>前端性能优化</li>\n<li>happypack原理</li>\n<li>react的虚拟DOM算法</li>\n</ol>\n<h2 id=\"安恒科技\"><a href=\"#安恒科技\" class=\"headerlink\" title=\"安恒科技\"></a>安恒科技</h2><h3 id=\"1面-1\"><a href=\"#1面-1\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>类组件和函数式组件的区别，或者说一下你使用最直接的感受，以及他们的优缺点</li>\n<li>有试过自己封装Hook吗？</li>\n<li>改变this指向的方式除了bind以及箭头函数还有哪些？</li>\n<li>为什么React中onClick在点击的时候会执行？</li>\n<li>React中key的作用</li>\n<li>React Fiber你了解吗？</li>\n<li>说一下虚拟DOM的优缺点</li>\n<li>开发中用到Redux是自己封装的吗？</li>\n<li>React类组件的extends和createElement有什么区别吗？</li>\n<li>组件名字首字母为什么一定要大写？</li>\n<li>ES5中判断数组有什么方式？</li>\n<li>怎么样并发请求？</li>\n<li>前端性能优化</li>\n<li>有用过Typescript吗？介绍一下你平常常用的</li>\n<li>工作中遇到最难的问题</li>\n<li>平常是怎么学习的</li>\n</ol>\n<h3 id=\"2面\"><a href=\"#2面\" class=\"headerlink\" title=\"2面\"></a>2面</h3><p>本来要面试我的二面的面试官零时有事，这个是隔壁组的leader。。</p>\n<ol>\n<li>封装一个网络请求是怎么封装的，要达到什么样的效果（因为我简历写了</li>\n<li>说一下你封装表单组件的想法（也是简历。。。</li>\n<li>说一下你的鉴权思路（也是简历</li>\n<li>现在Typescript有用吗？你觉得自己Typescript用的怎么样？</li>\n<li>说一下React最新的生命周期</li>\n<li>有写过Redux的中间件吗？</li>\n<li>说一下React Fiber做了一件什么事情</li>\n</ol>\n<h3 id=\"3面\"><a href=\"#3面\" class=\"headerlink\" title=\"3面\"></a>3面</h3><p>忘记录音了。。。靠记忆力想想</p>\n<ol>\n<li>说一下事件循环</li>\n<li>我们写的onClick是事件捕获吗？和事件冒泡的顺序是怎么样的</li>\n<li>CSS的权重</li>\n<li>对于跨域你是怎看待的</li>\n<li>说一下你对JavaScript内存的理解</li>\n<li>介绍一下Promise吧</li>\n<li>输入URL到页面渲染发生了什么</li>\n<li>平常是怎么学习的？</li>\n</ol>\n<p>题目太宽泛了。。。考察知识深度。。</p>\n<h3 id=\"4面\"><a href=\"#4面\" class=\"headerlink\" title=\"4面\"></a>4面</h3><ol>\n<li>为什么从上家公司离职</li>\n<li>说一下你对加班的理解</li>\n<li>对未来的规划</li>\n</ol>\n<h2 id=\"博圣生物\"><a href=\"#博圣生物\" class=\"headerlink\" title=\"博圣生物\"></a>博圣生物</h2><h3 id=\"1面-2\"><a href=\"#1面-2\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>离职原因</li>\n<li>项目中印象中比较深刻的</li>\n<li>对于移动端的适配</li>\n<li>高清屏1px的兼容，高清屏变粗问题<ol>\n<li>要精确到每一行。。。</li>\n</ol>\n</li>\n<li>说一下防抖节流的原理</li>\n<li>JS拖拽原理</li>\n<li>说一下flex的每个属性对应的意思</li>\n<li>CSS水平垂直居中</li>\n<li>有自己写过webpack loader和plugin吗？他们的原理和区别</li>\n</ol>\n<h3 id=\"2面-1\"><a href=\"#2面-1\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>React源码有读过吗？</li>\n<li>Fiber是怎么做调度的，js不是单线程吗？是怎么打断计算的？</li>\n<li>说一下你平常用的Hooks吧</li>\n<li>介绍前端性能优化</li>\n<li>对于前端代码攻击你了解哪些？</li>\n<li>cookie的存储有哪些新的属性</li>\n<li>Http2有哪些新功能</li>\n<li>http和https有什么区别</li>\n<li>介绍一下非对称加密</li>\n<li>JavaScript继承熟悉吗？有哪些方式？</li>\n</ol>\n<h3 id=\"3面HR\"><a href=\"#3面HR\" class=\"headerlink\" title=\"3面HR\"></a>3面HR</h3><p>上来就源码我以为我要凉了，不过后面都有复习到，算是扳回一城。谈薪。</p>\n<h2 id=\"火石创造\"><a href=\"#火石创造\" class=\"headerlink\" title=\"火石创造\"></a>火石创造</h2><p>是一家前端主导的团队，前端人超级多</p>\n<h3 id=\"1面-3\"><a href=\"#1面-3\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>说一下移动端适配的原理</li>\n<li>说一下前端性能优化</li>\n<li>平常对于跨域是怎么做的</li>\n<li>webpack的plugin有做过吗？</li>\n<li>JS的继承</li>\n<li>看你有封装过echarts，你是怎么封装的</li>\n<li>Vue和React的区别</li>\n<li>说一下CSS动画</li>\n<li>说一下key在React和Vue中的作用，如果没有会怎么样？会有什么问题，具体</li>\n<li>RN有做过吗？Taro呢？</li>\n<li>现在我有一个数组，我想针对每个元素的后面都加入一个新的元素，有哪些方法</li>\n<li>假如我用for的索引来加，会有什么问题？</li>\n</ol>\n<h3 id=\"2面HR\"><a href=\"#2面HR\" class=\"headerlink\" title=\"2面HR\"></a>2面HR</h3><p>可能是太晚了，火石是第三家面试了，而且我坐了很久的地铁，HR可能觉得我人没精神，也有可能我确实有毛病。。。</p>\n<h2 id=\"博联智能\"><a href=\"#博联智能\" class=\"headerlink\" title=\"博联智能\"></a>博联智能</h2><h3 id=\"1面-4\"><a href=\"#1面-4\" class=\"headerlink\" title=\"1面\"></a>1面</h3><p>基本上都是很基础的题目。感觉是之前团队全部跑路了，只有他一个前端，而且加班很严重，他的好像才刚刚毕业….</p>\n<h2 id=\"婚礼纪\"><a href=\"#婚礼纪\" class=\"headerlink\" title=\"婚礼纪\"></a>婚礼纪</h2><h3 id=\"1面-5\"><a href=\"#1面-5\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>你用过哪些Hook</li>\n<li>Hook的规则原理</li>\n<li>为什么要移除那些生命周期</li>\n<li>说一下时间循环</li>\n<li>setState是同步还是异步？</li>\n<li>setState的回调函数是宏任务还是微任务</li>\n<li>webpack热更新原理</li>\n<li>webpack的loader的作用</li>\n<li>为什么Fiber可以中断正在进行中的计算？</li>\n<li>JSX编译之后是什么样子的？</li>\n<li>React中那些props不能传递，为什么？</li>\n<li>假如我要封装一下上拉加载的Hook要怎么封装？</li>\n</ol>\n<h3 id=\"2面-2\"><a href=\"#2面-2\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>nodejs 常用命令你知道哪些？</li>\n<li>介绍一下JavaScript的内存</li>\n<li>WeakMap和Map有什么区别</li>\n<li>Post和Get有什么区别</li>\n<li>返回的状态码一定200就是对的吗？</li>\n<li>那我返回300也可以是对的吗？</li>\n<li>electron用过吗？</li>\n<li>RN会吗？</li>\n<li>Webpack的原理</li>\n<li>现在让你手写一个Webpack，你要怎么来写？</li>\n<li>Webpack优化知道哪些？</li>\n</ol>\n<p>凉凉。。。广度不够。。。555</p>\n<h2 id=\"数立信息\"><a href=\"#数立信息\" class=\"headerlink\" title=\"数立信息\"></a>数立信息</h2><h3 id=\"1面-6\"><a href=\"#1面-6\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>什么是原型链</li>\n<li>手写寄生组合继承</li>\n<li>this指向优先级</li>\n<li>什么叫做闭包？</li>\n<li>useEffect的回调函数每次都会执行还是在卸载的时候执行？</li>\n<li>类组件的this变量，在函数是组件中怎么表示？</li>\n<li>setState的链表是环形的吗？为什么？</li>\n<li>跨域</li>\n</ol>\n<h3 id=\"2面-3\"><a href=\"#2面-3\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>redux源码读过吗？</li>\n<li>redux中间件的设计理念是什么？</li>\n<li>sticky用过吗？</li>\n<li>px to rem的计算原理</li>\n<li>Webpack的tree shanking了解吗？原理？怎么写？</li>\n<li>BFC为什么会有那些特性？</li>\n<li>React事件集合原理</li>\n<li>为什么虚拟DOM可以做跨平台</li>\n</ol>\n<h2 id=\"光云科技\"><a href=\"#光云科技\" class=\"headerlink\" title=\"光云科技\"></a>光云科技</h2><h3 id=\"1面-7\"><a href=\"#1面-7\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>var let const区别</li>\n<li>localStorage sessionStorage cookie token区别</li>\n<li>token的组成</li>\n<li>React为什么移除那些生命周期</li>\n<li>Hook的设计理念，Hook规则原理</li>\n<li>key的作用</li>\n<li>说一下你了解的闭包</li>\n<li>自定义loader写过吗？</li>\n<li>跨域的方式方法</li>\n</ol>\n<h3 id=\"2面-4\"><a href=\"#2面-4\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>https和http的区别</li>\n<li>http请求头的组成</li>\n<li>cookie的作用</li>\n<li>cookie的新的属性</li>\n<li>怎么阻止第三方攻击</li>\n<li>假如让你设计一个秒杀页面你会想到那些场景和应对方式</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我个人认为必考的几个点，如果复习好了的话。1面应该问题不大</p>\n<ol>\n<li>URL到页面渲染过程</li>\n<li>JavaScript继承</li>\n<li>闭包</li>\n<li>Promise</li>\n<li>http请求头，码，方法之间的区别，http2，https</li>\n<li>跨域</li>\n<li>React Fiber原理</li>\n<li>Hook规则原理</li>\n<li>setState是否异步</li>\n<li>前端性能优化（Webpack，js，css，重绘，回流，防抖，节流</li>\n<li>React生命周期，官方的Hooks烂熟于心</li>\n<li>Flex，BFC，居中</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>说一点废话吧，算是吐槽。</p>\n<p>现在杭州的氛围很怪，双休都可以拿出来吹的那种。唉，不过虽然是疫情，前端的岗位还是蛮多的，我基本上一天2个面试。在未来科技城和滨江两头跑。不过现在已经入职啦。</p>\n<h1 id=\"公司列表\"><a href=\"#公司列表\" class=\"headerlink\" title=\"公司列表\"></a>公司列表</h1><ul>\n<li>安恒科技 -&gt; 挂在4面副总裁。<ul>\n<li>看了知乎上面的评价然后去面的副总裁，发现加班严重，然后期望薪资开的比较高，而且副总裁期间一直在摆弄手机不知道是不是比较忙，场面经常冷静好一会。</li>\n</ul>\n</li>\n<li>博圣生物 -&gt; offer，但是薪资开的比较低，所以没去</li>\n<li>数秦科技 -&gt; 已经入职啦</li>\n<li>火石创造 -&gt; 挂在HR那边了，估计是我跳槽比较频繁，而且那天很晚过去的，人很疲惫没什么精神，HR还问我平常是不是也是这样没精神….尴尬</li>\n<li>博联智能 -&gt; 后面发现前端团队只有一个人，而且面试官好像工作没多久。。。全是网上的题目，二面就没去了</li>\n<li>婚礼纪 -&gt; 挂在2面，前端leader觉得我node不太熟悉，广度不够….</li>\n<li>数立信息 -&gt; 挂在二面，不知道具体哪里不行….我感觉我都答上来了…</li>\n<li>阿里零售事业部 -&gt; 一面就挂了，那个时候刚刚坐动车到杭州，确实也没怎么准备，很可惜！</li>\n<li>光云科技 -&gt; 我期望开的太高了….然后挂在了HR</li>\n</ul>\n<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><h2 id=\"阿里-零售部\"><a href=\"#阿里-零售部\" class=\"headerlink\" title=\"阿里-零售部\"></a>阿里-零售部</h2><h3 id=\"1面\"><a href=\"#1面\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>jsbridge的原理</li>\n<li>跨域的场景你用到那些？</li>\n<li>jsonp的原理，jsonp怎么用</li>\n<li>有数据相关的吗？比如PV，UV</li>\n<li>px to rem的原理能说一下吗？</li>\n<li>具体怎么算的可以说一下吗？</li>\n<li>onClick是什么时候执行的？</li>\n<li>如果我写了一个addListener，然后又写了onCLick，这个时候点击一下会发生什么事情？</li>\n<li>前端性能优化</li>\n<li>happypack原理</li>\n<li>react的虚拟DOM算法</li>\n</ol>\n<h2 id=\"安恒科技\"><a href=\"#安恒科技\" class=\"headerlink\" title=\"安恒科技\"></a>安恒科技</h2><h3 id=\"1面-1\"><a href=\"#1面-1\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>类组件和函数式组件的区别，或者说一下你使用最直接的感受，以及他们的优缺点</li>\n<li>有试过自己封装Hook吗？</li>\n<li>改变this指向的方式除了bind以及箭头函数还有哪些？</li>\n<li>为什么React中onClick在点击的时候会执行？</li>\n<li>React中key的作用</li>\n<li>React Fiber你了解吗？</li>\n<li>说一下虚拟DOM的优缺点</li>\n<li>开发中用到Redux是自己封装的吗？</li>\n<li>React类组件的extends和createElement有什么区别吗？</li>\n<li>组件名字首字母为什么一定要大写？</li>\n<li>ES5中判断数组有什么方式？</li>\n<li>怎么样并发请求？</li>\n<li>前端性能优化</li>\n<li>有用过Typescript吗？介绍一下你平常常用的</li>\n<li>工作中遇到最难的问题</li>\n<li>平常是怎么学习的</li>\n</ol>\n<h3 id=\"2面\"><a href=\"#2面\" class=\"headerlink\" title=\"2面\"></a>2面</h3><p>本来要面试我的二面的面试官零时有事，这个是隔壁组的leader。。</p>\n<ol>\n<li>封装一个网络请求是怎么封装的，要达到什么样的效果（因为我简历写了</li>\n<li>说一下你封装表单组件的想法（也是简历。。。</li>\n<li>说一下你的鉴权思路（也是简历</li>\n<li>现在Typescript有用吗？你觉得自己Typescript用的怎么样？</li>\n<li>说一下React最新的生命周期</li>\n<li>有写过Redux的中间件吗？</li>\n<li>说一下React Fiber做了一件什么事情</li>\n</ol>\n<h3 id=\"3面\"><a href=\"#3面\" class=\"headerlink\" title=\"3面\"></a>3面</h3><p>忘记录音了。。。靠记忆力想想</p>\n<ol>\n<li>说一下事件循环</li>\n<li>我们写的onClick是事件捕获吗？和事件冒泡的顺序是怎么样的</li>\n<li>CSS的权重</li>\n<li>对于跨域你是怎看待的</li>\n<li>说一下你对JavaScript内存的理解</li>\n<li>介绍一下Promise吧</li>\n<li>输入URL到页面渲染发生了什么</li>\n<li>平常是怎么学习的？</li>\n</ol>\n<p>题目太宽泛了。。。考察知识深度。。</p>\n<h3 id=\"4面\"><a href=\"#4面\" class=\"headerlink\" title=\"4面\"></a>4面</h3><ol>\n<li>为什么从上家公司离职</li>\n<li>说一下你对加班的理解</li>\n<li>对未来的规划</li>\n</ol>\n<h2 id=\"博圣生物\"><a href=\"#博圣生物\" class=\"headerlink\" title=\"博圣生物\"></a>博圣生物</h2><h3 id=\"1面-2\"><a href=\"#1面-2\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>离职原因</li>\n<li>项目中印象中比较深刻的</li>\n<li>对于移动端的适配</li>\n<li>高清屏1px的兼容，高清屏变粗问题<ol>\n<li>要精确到每一行。。。</li>\n</ol>\n</li>\n<li>说一下防抖节流的原理</li>\n<li>JS拖拽原理</li>\n<li>说一下flex的每个属性对应的意思</li>\n<li>CSS水平垂直居中</li>\n<li>有自己写过webpack loader和plugin吗？他们的原理和区别</li>\n</ol>\n<h3 id=\"2面-1\"><a href=\"#2面-1\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>React源码有读过吗？</li>\n<li>Fiber是怎么做调度的，js不是单线程吗？是怎么打断计算的？</li>\n<li>说一下你平常用的Hooks吧</li>\n<li>介绍前端性能优化</li>\n<li>对于前端代码攻击你了解哪些？</li>\n<li>cookie的存储有哪些新的属性</li>\n<li>Http2有哪些新功能</li>\n<li>http和https有什么区别</li>\n<li>介绍一下非对称加密</li>\n<li>JavaScript继承熟悉吗？有哪些方式？</li>\n</ol>\n<h3 id=\"3面HR\"><a href=\"#3面HR\" class=\"headerlink\" title=\"3面HR\"></a>3面HR</h3><p>上来就源码我以为我要凉了，不过后面都有复习到，算是扳回一城。谈薪。</p>\n<h2 id=\"火石创造\"><a href=\"#火石创造\" class=\"headerlink\" title=\"火石创造\"></a>火石创造</h2><p>是一家前端主导的团队，前端人超级多</p>\n<h3 id=\"1面-3\"><a href=\"#1面-3\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>说一下移动端适配的原理</li>\n<li>说一下前端性能优化</li>\n<li>平常对于跨域是怎么做的</li>\n<li>webpack的plugin有做过吗？</li>\n<li>JS的继承</li>\n<li>看你有封装过echarts，你是怎么封装的</li>\n<li>Vue和React的区别</li>\n<li>说一下CSS动画</li>\n<li>说一下key在React和Vue中的作用，如果没有会怎么样？会有什么问题，具体</li>\n<li>RN有做过吗？Taro呢？</li>\n<li>现在我有一个数组，我想针对每个元素的后面都加入一个新的元素，有哪些方法</li>\n<li>假如我用for的索引来加，会有什么问题？</li>\n</ol>\n<h3 id=\"2面HR\"><a href=\"#2面HR\" class=\"headerlink\" title=\"2面HR\"></a>2面HR</h3><p>可能是太晚了，火石是第三家面试了，而且我坐了很久的地铁，HR可能觉得我人没精神，也有可能我确实有毛病。。。</p>\n<h2 id=\"博联智能\"><a href=\"#博联智能\" class=\"headerlink\" title=\"博联智能\"></a>博联智能</h2><h3 id=\"1面-4\"><a href=\"#1面-4\" class=\"headerlink\" title=\"1面\"></a>1面</h3><p>基本上都是很基础的题目。感觉是之前团队全部跑路了，只有他一个前端，而且加班很严重，他的好像才刚刚毕业….</p>\n<h2 id=\"婚礼纪\"><a href=\"#婚礼纪\" class=\"headerlink\" title=\"婚礼纪\"></a>婚礼纪</h2><h3 id=\"1面-5\"><a href=\"#1面-5\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>你用过哪些Hook</li>\n<li>Hook的规则原理</li>\n<li>为什么要移除那些生命周期</li>\n<li>说一下时间循环</li>\n<li>setState是同步还是异步？</li>\n<li>setState的回调函数是宏任务还是微任务</li>\n<li>webpack热更新原理</li>\n<li>webpack的loader的作用</li>\n<li>为什么Fiber可以中断正在进行中的计算？</li>\n<li>JSX编译之后是什么样子的？</li>\n<li>React中那些props不能传递，为什么？</li>\n<li>假如我要封装一下上拉加载的Hook要怎么封装？</li>\n</ol>\n<h3 id=\"2面-2\"><a href=\"#2面-2\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>nodejs 常用命令你知道哪些？</li>\n<li>介绍一下JavaScript的内存</li>\n<li>WeakMap和Map有什么区别</li>\n<li>Post和Get有什么区别</li>\n<li>返回的状态码一定200就是对的吗？</li>\n<li>那我返回300也可以是对的吗？</li>\n<li>electron用过吗？</li>\n<li>RN会吗？</li>\n<li>Webpack的原理</li>\n<li>现在让你手写一个Webpack，你要怎么来写？</li>\n<li>Webpack优化知道哪些？</li>\n</ol>\n<p>凉凉。。。广度不够。。。555</p>\n<h2 id=\"数立信息\"><a href=\"#数立信息\" class=\"headerlink\" title=\"数立信息\"></a>数立信息</h2><h3 id=\"1面-6\"><a href=\"#1面-6\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>什么是原型链</li>\n<li>手写寄生组合继承</li>\n<li>this指向优先级</li>\n<li>什么叫做闭包？</li>\n<li>useEffect的回调函数每次都会执行还是在卸载的时候执行？</li>\n<li>类组件的this变量，在函数是组件中怎么表示？</li>\n<li>setState的链表是环形的吗？为什么？</li>\n<li>跨域</li>\n</ol>\n<h3 id=\"2面-3\"><a href=\"#2面-3\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>redux源码读过吗？</li>\n<li>redux中间件的设计理念是什么？</li>\n<li>sticky用过吗？</li>\n<li>px to rem的计算原理</li>\n<li>Webpack的tree shanking了解吗？原理？怎么写？</li>\n<li>BFC为什么会有那些特性？</li>\n<li>React事件集合原理</li>\n<li>为什么虚拟DOM可以做跨平台</li>\n</ol>\n<h2 id=\"光云科技\"><a href=\"#光云科技\" class=\"headerlink\" title=\"光云科技\"></a>光云科技</h2><h3 id=\"1面-7\"><a href=\"#1面-7\" class=\"headerlink\" title=\"1面\"></a>1面</h3><ol>\n<li>var let const区别</li>\n<li>localStorage sessionStorage cookie token区别</li>\n<li>token的组成</li>\n<li>React为什么移除那些生命周期</li>\n<li>Hook的设计理念，Hook规则原理</li>\n<li>key的作用</li>\n<li>说一下你了解的闭包</li>\n<li>自定义loader写过吗？</li>\n<li>跨域的方式方法</li>\n</ol>\n<h3 id=\"2面-4\"><a href=\"#2面-4\" class=\"headerlink\" title=\"2面\"></a>2面</h3><ol>\n<li>https和http的区别</li>\n<li>http请求头的组成</li>\n<li>cookie的作用</li>\n<li>cookie的新的属性</li>\n<li>怎么阻止第三方攻击</li>\n<li>假如让你设计一个秒杀页面你会想到那些场景和应对方式</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我个人认为必考的几个点，如果复习好了的话。1面应该问题不大</p>\n<ol>\n<li>URL到页面渲染过程</li>\n<li>JavaScript继承</li>\n<li>闭包</li>\n<li>Promise</li>\n<li>http请求头，码，方法之间的区别，http2，https</li>\n<li>跨域</li>\n<li>React Fiber原理</li>\n<li>Hook规则原理</li>\n<li>setState是否异步</li>\n<li>前端性能优化（Webpack，js，css，重绘，回流，防抖，节流</li>\n<li>React生命周期，官方的Hooks烂熟于心</li>\n<li>Flex，BFC，居中</li>\n</ol>\n"},{"title":"你真的懂React Hook吗？","date":"2020-05-19T16:19:44.000Z","cover":"/image/cover/React.jpeg","_content":"## 前言\n\n1. 读这篇文章的前提是你已经对React Hook有所了解的情况下，如果你还没有了解，请先移步官网学习一下。\n   1. 最好不要去网上看别人的总结之类的，无非就是超的官网的，而且这样会让你的认知从一开始就走偏。\n2. 这篇文章主要是探究Hook的动机，使用中的一些疑问；\n   1. 使用的话React官网已经讲得很详细了，这里就不多赘述了。\n3. 有需要看接下来的疑难点的伙伴欢迎直接跳过探究直接看具体的疑问；\n\n## 探究\n\n主要从3个方面研究React Hook\n\n根据黄金思维圈（What、How、Why）\n\n### What\n\n什么是Hook？\n\n打开Google翻译，得到的解释：*钩、钩子*\n\n> 再看看React官网的解释：They let you use state and other React features without writing a class.（它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。）\n\n所以，结合一下。我个人的理解是这样的：对于函数式的组件，可以用钩子（Hook）将想要的外部功能给“钩”进来。\n\n在React Hook出来之前，函数式组件都是无状态的组件，最多就是根据`props`来加一些判断的逻辑；而在React Hook出来之后就可以在函数式组件里面加入状态（useState），类生命周期（useEffect），甚至是一些自己的复用逻辑（自定义Hook）等等这些外部的功能。\n\n\n\n### How\n\n怎么使用Hook？\n\n大家一起看一下官网的一个例子。\n\n题目：显示一个计数器。当你点击按钮，计数器的值就会增加。\n\n#### Class组件\n\n\n\n```javascript\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n\n\n#### React Hook\n\n\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个叫 \"count\" 的 state 变量  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n\n\n这样就算是完成了一个最简单的React Hook 实践，关于一些官方提供的Hook晚点会介绍。\n\n\n\n### Why\n\n- 为什么会有Hooks？\n- Hook能解决什么问题？\n\n做任何一件事情我觉得都应该理清这个两个问题，这样的话就会事半功倍。\n\n我们先看看React官方是怎么解释“Why”的\n\n> 1. 在组件之间复用状态逻辑很难\n> 2. 复杂组件变得难以理解\n> 3. 难以理解的 class\n\n本人个人认为第三点是来凑数的....\n\n为什么这么说？\n\n因为React用了这么久了基本都是在使用Class组件，这个是在之前，哪怕是现在学习React的必经之路吧！所以，这点我接下来就会跳过了😂\n\n### 在组件之间服用状态逻辑很难\n\n其实高阶组件或者说是props都是很好的解决了复杂的聚合业务逻辑，那为什么说在**组件之间服用状态逻辑很难**呢？\n\n其实道理非常简单。\n\n举个简单的例子，方便大家理解。\n\n场景：有 请求A，请求B，请求C，请求D。他们的请求都有相互依赖关系比如，发请求B的时候必须拿到请求A的结果中的某个值，而请求C也必须拿到请求B的结果中的某个值。以此类推请求D。\n\nPromise出来之前是怎么做的呢？\n\n```javascript\n$.ajax({\n    type:\"post\",\n    success: function(){//成功回调\n        //再次异步请求\n        $.ajax({\n            type:\"post\",\n            url:\"...\",\n            success:function(){//成功回调\n              //再次异步请求\n              $.ajax({\n                  type:\"post\",\n                  url:\"...\",\n                  success:function(){\n                      .......//如此循环\n                  }\n              })\n          }\n        })\n    }\n})\n```\n\n这还只是3层，如果是100层呢？那看起来就非常的难受了！\n\nPromise较好的解决了这个问题\n\n```javascript\nnew Promise(f1)\n .then(f2)\n .then(f3)\n .then(f4)\n .then(f5)\n .then(f5)\n…………\n```\n\n然后是async/await。这里就不展开了，有兴趣的可以自己去了解一下。\n\n结论\n\n之所以这么大费周章的讲是为了解释，React中的高阶组件（HOC）。他的逻辑其实和回调地狱类似，一个两个其实都还算优雅或者说舒服，一旦多了的话。。。\n\n```javascript\nexport default withHover(\n  withTheme(\n    withAuth(\n      withRepos(Profile)\n    )\n  )\n)\n\n// 就会变成这样，不够优雅\n<WithHover>\n  <WithTheme hovering={false}>\n    <WithAuth hovering={false} theme='dark'>\n      <WithRepos hovering={false} theme='dark' authed={true}>\n        <Profile \n          id='JavaScript'\n          loading={true} \n          repos={[]}\n          authed={true}\n          theme='dark'\n          hovering={false}\n        />\n      </WithRepos>\n    </WithAuth>\n  <WithTheme>\n</WithHover>\n```\n\n而且每个高阶组件的逻辑复用我们可能还要一个个去研读。\n\n\n\n### 复杂组件变得难以理解\n\n其实，这点非常好理解。举一个非常简单常见的例子大家就会明白了。\n\n场景：假如我有一个子组件Child，他的功能是这样的：父组建会给一个id，在组件创建的时候获取一下有关信息，在id改变的时候再重新获取。\n\n#### Class组件\n\n```javascript\ncomponentDidMount () {\n    this.fetch(this.props.id)\n }\ncomponentDidUpdate (prevProps) {\n  if (prevProps.id !== this.props.id) {\n    this.fetch(this.props.id)\n  }\n}\nfetch = id => {\n  this.setState({ loading: true })\n  fetchInfo(id)\n    .then(info => this.setState({\n    info,\n    loading: false\n  }))\n}\n```\n\n#### React Hook：\n\n```javascript\nconst fetch = id => {\n  this.setState({ loading: true })\n  fetchInfo(id)\n    .then(info => this.setState({\n    info,\n    loading: false\n  }))\n}\nuseEffect(() => {\n  fetch(this.props.id)\n}, [this.props.id])\n```\n\n\n\n### 结论\n\n简单的说一下他的优点吧。\n\n1. 复用代码更加简单（需要什么就“钩”进来）\n2. 清爽的代码风格，一目了然。（useState支持数组和对象，可以清晰的定义特殊的字段等等）\n3. 代码量更少（可以看一下我之前的子父组建的例子）\n4. 更愿意去写一些小组件复用（我个人喜欢React就是因为他的组件写起来非常的顺手！ps：没有贬低其他框架的意思。。）\n5. 其实我个人认为React Hook在宣扬一个观念“按需加载”。\n\n## useState\n\n### 使用\n\n简单的使用在上面的探究-How里面有介绍，更多的在React官网也有介绍。\n\n#### 请回答以下代码的运行结果\n\n![](https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif)\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <button onClick={handleAlertClick}>\n        Show alert\n      </button>\n    </div>\n  );\n}\n```\n\n你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。\n\n> 分割线\n\n来自己 [试试吧！](https://codesandbox.io/s/w2wxl3yo0l)\n\n#### 答案是\n\n3\n\n这是为什么呢？function组建究竟是如果工作的呢？\n\n我们发现`count`在每一次函数调用中都是一个常量值。值得强调的是 — **我们的组件函数每次渲染都会被调用，但是每一次调用中`count`值都是常量，并且它被赋予了当前渲染中的状态值。**\n\n这并不是React特有的，普通的函数也有类似的行为：\n\n```jsx\nfunction sayHi(person) {\n  const name = person.name;  setTimeout(() => {\n    alert('Hello, ' + name);\n  }, 3000);\n}\n\nlet someone = {name: 'Dan'};\nsayHi(someone);\n\nsomeone = {name: 'Yuzhi'};\nsayHi(someone);\n\nsomeone = {name: 'Dominic'};\nsayHi(someone);\n```\n\n在 [这个例子](https://codesandbox.io/s/mm6ww11lk8)中, 外层的`someone`会被赋值很多次（就像在React中，*当前*的组件状态会改变一样）。**然后，在`sayHi`函数中，局部常量`name`会和某次调用中的`person`关联。**因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的`name`。\n\n这就解释了我们的事件处理函数如何捕获了点击时候的`count`值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的`count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n```\n\n所以实际上，每一次渲染都有一个“新版本”的`handleAlertClick`。每一个版本的`handleAlertClick`“记住” 了它自己的 `count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 0);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 0 inside  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 1);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 1 inside  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 2);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 2 inside  // ...\n}\n```\n\n这就是为什么[在这个demo中](https://codesandbox.io/s/w2wxl3yo0l)中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中`counter`的状态值。\n\n**在任意一次渲染中，props和state是始终保持不变的。**如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的`count`值。\n\n#### 请回答以下代码的运行结果\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const addCount = () => {\n    setCount(count+1)\n    setCount(count+2)\n    setCount(count+3)\n    setCount(count+4)\n    setCount(count+5)\n  }\n\n  console.log(count)\n  \n  return (\n    <div>\n      <button onClick={addCount}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n> 分割线\n\n#### 答案是\n\n5\n\n为什么呢？\n\nuseState的更新究竟是如何工作的呢？\n\n我们进入`ReactHooks.js`来看看，发现`useState`的实现竟然异常简单，只有短短两行\n\n```js\n// ReactHooks.js\nexport function useState<S>(initialState: (() => S) | S) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n```\n\n其实可以这样理解useState，useState其实就是useReducer的一个语法糖；但是这个不在这个问题的讨论范围内；\n\n好，收回来。\n\n其实我们在`const [xx, setXx] = useState(xx)`的时候就生成一个队列，我们暂时叫它为queue；所有这一轮运行读取到的state都被放到一个链表的队列里面去，然后再用do-while循环，每次都是拿到最新的值，但是不是Object.assgin的形式，而是直接赋值。话不多说直接源码。\n\n```js\nfunction updateReducer(reducer, initialArg, init) {\n// 获取初始化时的 hook\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  // 开始渲染更新\n  if (numberOfReRenders > 0) {\n    const dispatch = queue.dispatch;\n    if (renderPhaseUpdates !== null) {\n      // 获取Hook对象上的 queue，内部存有本次更新的一系列数据\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        // 获取更新后的state\n        do {\n          const action = update.action;\n          // 此时的reducer是basicStateReducer，直接返回action的值\n          // 注意，这里是等于号所以\n          /**\n          *\n          * setObj({ a: 1, b: 1, c: 1 })\n        \t* setObj({ a: 2, b: 2 })\n        \t* setObj({ a: 3 })\n        \t*\n        \t* 到最后也只有只有{ a: 3 }，而b和c全没了\n          *\n          **/\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null);\n        // 对 更新hook.memoized \n        hook.memoizedState = newState;\n        // 返回新的 state，及更新 hook 的 dispatch 方法\n        return [newState, dispatch];\n      }\n    }\n  }\n```\n\n\n\n## useEffect/useLayoutEffect\n\n### 提示\n\n在学习useEffect这个Hook的时候，淡化你知道的“生命周期”这个概念。\n\n#### useEffect和useLayoutEffect两兄弟的区别是什么？\n\n执行的时机不同\n\n那么具体哪里不同呢？\n\n其实在初始化useEffect和useLayoutEffect是没有区别的，他们真正的区别在于初始化之后；\n\n举个非常形象的例子🌰：\n\n除了初始化之后的一轮更新：\n\n> 浏览器：我要绘制了！\n>\n> React：等等，我有一个哥们临时有事要处理，他是：useLayoutEffect\n>\n> useLayoutEffect执行....\n>\n> React：好了，你可以开始绘制了～@浏览器\n>\n> 浏览器：好的\n>\n> 浏览器更新UI...\n>\n> 浏览器：我更新好了。你有什么事要做的吗？@React\n>\n> React：有的，useEffect你上\n>\n> useEffect执行....\n\n可能有点废话了。其实区别就是\n\n> useLayoutEffect()\n>\n> 浏览器绘制\n>\n> useEffect()\n\n这样其实大家也能很直接的看到弊端了。那就是useLayoutEffect如果有大量的计算的话，那样可能会阻塞UI更新，或者说UI渲染。所以还是要谨慎使用。\n\n一般来说他们没有什么太大的区别的，如果真的要使用useLayoutEffect的话要谨慎一些。不然可能会导致UI渲染阻塞之类的问题。\n\n但是，也不是没有使用场景。\n\n比如下面的这个代码就很需要useLayoutEffect\n\n```js\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  useLayoutEffect(() => {\n    if (count === 0) {\n      const randomNum = 10 + Math.random()*200\n      setCount(10 + Math.random()*200);\n    }\n  }, [count]);\n\n  return (\n      <div onClick={() => setCount(0)}>{count}</div>\n  );\n}\n\n//   我是分割线\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    if (count === 0) {\n      const randomNum = 10 + Math.random()*200\n      setCount(10 + Math.random()*200);\n    }\n  }, [count]);\n\n  return (\n      <div onClick={() => setCount(0)}>{count}</div>\n  );\n}\n```\n\n其实明白的同学一下就看出来了，如果使用useEffect的话会出现闪烁，会先回到0然后再更新新的随机数。而反观useLayoutEffect则不会，他会很自然的过渡。\n\n总结：\n\nuseLayoutEffect的使用场景为：有一个中间状态希望隐藏的时候再使用。\n\n大部分情况下useEffect可以适用于99%的场景。\n\n####  useEffect的错误事例。看看有没有你\n\n```js\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // Imagine this function is also long\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  // Imagine this function is also long\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n```\n\n#### 为什么错了？\n\n不难看出上面代码的意思是。想要模仿componentDidMount的生命周期，在页面或者组件加载之后发送一个请求。咋一看好像没有什么问题（实际在运行的过程中也没有什么问题，在写这篇文章之前我也是这么做的。）\n\n但是大家可以想象一下，如果这个函数组件，是现在的5倍大，这个didMount里面调用的请求，未来依赖的东西你都可以100%的察觉到吗？\n\n我觉得难！难免会有疏忽。到时候可能就会出现state或者props读取错误的情况。因为每一次render的state和props都是独立的。\n\n那么，该如何解决呢？\n\n有一个很土的办法，直接把函数扔到useEffect里面去\n\n```jsx\nfunction SearchResults() {\n  // ...\n  useEffect(() => {\n    // We moved these functions inside!    \n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=react';\n    }\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n    fetchData();\n  }, []); // ✅ Deps are OK\n  // ...\n}\n```\n\n那高级点的办法呢？\n\n```js\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback((query) => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n将函数用useCallback包裹，这样的话我们只需要做useEffect的依赖里面写上我们的函数，然后在useCallback里面写上我们的依赖。\n\n#### 我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\n\n\n\n```js\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n  useEffect(() => {\n    prevCountRef.current = count;\n  });\n  const prevCount = prevCountRef.current;\n\n  return <h1>Now: {count}, before: {prevCount}</h1>;\n}\n```\n\n其实很好理解，如果看了前面useEffect和useLayoutEffect区别的同学一下就可以知道这个的实现原理。\n\n首先，在一切都更新之后，然后会会执行useEffect内部的回调函数，将prevCount给赋值，由于没有触发渲染，所以只是单纯的赋值。这样就看起来prevCount的值永远都慢一步。\n\n### 总结\n\n其实在学习useEffect的时候。应该忘记你对React的一些知识。比如生命周期，在函数组件里面没有生命周期这个概念了。\n\n每一次的render他都有自己的state和props。state和props更应该被看作一个常量，哪怕是const bar = xx这样的常量。这样理解起来useEffect这个副作用其实会更加顺畅，也不容易进入他的“陷阱”\n\n## useRef\n\n### 前言\n\n为什么我把useRef单独拎出来说，不把他和`useImperativeHandle`放在一起讲，因为\n\n> （官网原话）它创建的是一个普通 Javascript 对象。而 `useRef()` 和自建一个 `{current: ...}` 对象的唯一区别是，`useRef` 会在每次渲染时返回同一个 ref 对象。\n\n记住`useRef`不单单用于获取`DOM节点和组件实例`，还有一个巧妙的用法就是`作为容器保留可变变量`，可以这样说：`无法自如地使用useRef会让你失去hook将近一半的能力`\n\n#### useRef 与 createRef 的区别\n\n`useRef` 仅能用在 FunctionComponent，`createRef` 仅能用在 ClassComponent。\n\n`useRef` 仅能用在 FunctionComponent，`createRef` 仅能用在 ClassComponent。\n\n第一句话是显然的，因为 Hooks 不能用在 ClassComponent。\n\n第二句话的原因是，`createRef` 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：\n\n```\nfunction App() {\n  // 错误用法，永远也拿不到 ref\n  const valueRef = React.createRef();\n  return <div ref={valueRef} />;\n}\n复制代码\n```\n\n上述 `valueRef` 会随着 App 函数的 Render 而重复初始化，**这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变**。\n\n为什么 `createRef` 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 `componentDidMount` 等初始化时机仅执行一次。\n\n#### 如何解决每次render带来类闭包问题？\n\n首先，题目怎么理解？[题目](https://codesandbox.io/s/w2wxl3yo0l)\n\n如果我们希望他alert的时候可以获取到最新的值的话，可以使用useRef来解决\n\n```js\nconst Counter = () => {\n  const [count, setCount] = useState<number>(0)\n  const countRef = useRef<number>(count)\n\n  useEffect(() => {\n    countRef.current = count\n  })\n\n  const handleCount = () => {\n    setTimeout(() => {\n      alert('current count: ' + countRef.current)\n    }, 3000);\n  }\n\n  //...\n}\n\nexport default Counter\n```\n\n\n\n## memo\n\n#### memo没有回调函数的话是怎么浅比较的？\n\n先来看看memo没有回调函数的时候他做了什么。\n\nmemo它是一个高阶组件（HOC）他与React.PureComponent十分相似。除了使用的地方不同（Class组件和Function组件）之外几乎一致。\n\nMemo内部和PureComponent一样使用Object.is用于前对比，如果传入的props内存地址不变的话，那就不会渲染了（或者说复用最近的一次渲染）。\n\n下面可以看源码事例\n\n```js\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n\n  /* ...省略...*/\n\n  // 判断更新的过期时间是否小于渲染的过期时间\n  if (updateExpirationTime < renderExpirationTime) {\n    const prevProps = currentChild.memoizedProps;\n\n    // 如果自定义了compare函数，则采用自定义的compare函数，否则采用官方的shallowEqual(浅比较)函数。（下面有解析）\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    /**\n     * 1. 判断当前 props 与 nextProps 是否相等；\n     * 2. 判断即将渲染组件的引用是否与workInProgress Fiber中的引用是否一致；\n     *\n     * 只有两者都为真，才会退出渲染。\n     */\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      // 如果都为真，则退出渲染\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n  }\n\n  /* ...省略...*/\n\n```\n\nshallowEqual（浅比较）\n\n```js\n// 用原型链的方法\nconst hasOwn = Object.prototype.hasOwnProperty\n\n// 这个函数实际上是Object.is()的polyfill\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\n  } else {\n    return x !== x && y !== y\n  }\n}\n\nexport default function shallowEqual(objA, objB) {\n  // 首先对基本数据类型的比较\n  if (is(objA, objB)) return true\n  // 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等\n  // 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object\n  // 之后，就可以返回false了\n  if (typeof objA !== 'object' || objA === null ||\n      typeof objB !== 'object' || objB === null) {\n    return false\n  }\n\n  // 过滤掉基本数据类型之后，就是对对象的比较了\n  // 首先拿出key值，对key的长度进行对比\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  // 长度不等直接返回false\n  if (keysA.length !== keysB.length) return false\n  // key相等的情况下，在去循环比较\n  for (let i = 0; i < keysA.length; i++) {\n  // key值相等的时候\n  // 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值\n  // 属性的顺序不影响结果也就是{name:'daisy', age:'24'} 跟{age:'24'，name:'daisy' }是一样的\n  // 最后，对对象的value进行一个基本数据类型的比较，返回结果\n    if (!hasOwn.call(objB, keysA[i]) ||\n        !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false\n    }\n  }\n\n  return truea\n}\n```\n\n由源码可以知道，加入没有传一个比较的回调函数会使用官方的浅比较。具体的可以看注释\n\n#### memo的回调函数\n\n我们都知道react的生命周期中有一个shouldComponentUpdate。在这个函数中返回true的话就代表本次render需要执行，而返回false就可以跳过本次的render。\n\n而memo正好相反，返回true表示本次跳过，返回false就表示本次需要执行render。\n\n具体怎么用呢？\n\n大家可以自己运行一下，看看效果。一定要自己试一下，不然很容易和shouldComponentUpdate弄混了。学习还是要自己动手才行。\n\n```js\nfunction ChangeLog({w = ''}){\n  // 省略\n  console.log('====render====')\n}\nexport default memo(ChangeLog, (prevProps, nextProps) => {\n  if (prevProps.w !== nextProps.w) {\n    return false\n  }\n  return true\n});\n```\n\n## useMemo/useCallback\n\n ### 前言\n\n之所以把这useMomo/useCallack两兄弟和在一起。是因为他们其实十分相似。\n\n> 一个是缓存变量（useMemo），一个是缓存函数（useCallback）。\n\n其实这么一说就清晰很多了。\n\n具体的使用和useEffect一样，都是第一个参数为调用时的回调函数，第二个参数是调用判断所监听的值（可以是变量，也可以是函数）\n\n```js\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\nconst memoizedValue = useCallback(() => computeExpensiveValue(a, b), [a, b]);\n```\n\nuseMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）\n\nmemoized 值不变的情况下，不会重新触发渲染逻辑。\n\n说起渲染逻辑，需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作，比如网络请求等。\n\n如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner\n\nuseCallback也是一样的，这里就不多赘述了。\n\n## useReducer/useContext\n\n### 前言\n\n帮他们两兄弟和在一起说主要说因为他们两兄弟在一般情况下是可以与Redux一战的。\n\n但是！！\n\n但是啊，但是如果你需要中间价，或者说需要“时间旅行”，又或者临时需要跨页面级的数据共享，那你还是需要redux来解决的。不过基本上的场景我们使用useReducer和useContext就可以完美的替代redux了。\n\n### 怎么做？\n\n其实之前由于要起一个新项目，但是突然发现有一个爷爷组件的值为需要通知给孙子组件，然后孙子组件可能会用掉回调函数调用爷爷组件的方法。那个时候其实已经用Hook写了一半了，懒得加Redux了，又不想一层层传props下去。怎么办？\n\n通过了解，我知道了useReducer/useContext刚刚好可以解决我的需求。\n\n```js\nconst TodosDispatch = React.createContext(null);\n\nconst initialState = { bar: null };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setCenter':\n      return { ...state, bar: action.bar };\n    default:\n      return state\n  }\n}\n\n// 虽然这个是自组件，但是哪怕是曾曾曾孙子组件都可以直接用useContext拿到dispatch\nfunction DeepChild(props) {\n  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。\n  const dispatch = useContext(TodosDispatch);\n\n  function handleClick() {\n    dispatch({ type: 'add', text: 'hello' });\n  }\n\n  return (\n    <button onClick={handleClick}>Add todo</button>\n  );\n}\n\nfunction TodosApp() {\n  // 提示：`dispatch` 不会在重新渲染之间变化\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <TodosDispatch.Provider value={dispatch}>\n      <DeepTree todos={todos} />\n    </TodosDispatch.Provider>\n  );\n}\n```\n\n## useImperativeHandle/forwardRef\n\n这里就不多说了，基本上没有什么坑点和疑难点。\n\n说一下基本用法和ant-design form中的使用\n\n### 正常使用\n\n```js\nuseImperativeHandle(ref, createHandle, [deps])\n```\n\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。`useImperativeHandle` 应当与 `forwardRef`一起使用：\n\n```js\nfunction FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n```\n\n在本例中，渲染<FancyInput ref={inputRef} />的父组件可以调用 `inputRef.current.focus()`。\n\n### ant-design form\n\n```js\n// ref从第二个参数取，这里都是一致的\nconst Example = (props,ref) => {\n  const bar = () => {}\n  useImperativeHandle(ref, () => ({\n    text: bar,\n  }));\n  return (\n    <>\n        <Form>\n    \t\t\t{//....}\n        </Form>\n    </>\n  );\n};\n\nexport default memo(Form.create()(forwardRef(Example)));\n\n```\n\n```js\n\nconst Parent = () => {\n  return (\n    <>\n      <Example\n      \t// 注意这个不再是传ref了，而是传wrappedComponentRef。因为antd的form他返回的是一个新的对象，这个是他自定义的一个接收ref的值\n        wrappedComponentRef={editTemplateRef}\n      />\n    </>\n  );\n};\n```\n\n\n\n## useDebugValue/自定义Hook\n\n### 前言\n\nuseDebugValue是专门用于服务自定义的Hook的。\n\n具体看看使用就好\n\n\n\nuseDebugValue，目的是能在react的浏览器调试工具上显示你的自定义hooks，或者给hooks标记一些东西\n当使用一个参数的时候，就是把第一个参数标记在react的调试工具上,下面写一个简单的例子\n\n```js\nimport React, { useDebugValue, useState } from 'react';\n\nconst useTest = () => {\n    const [str, setStr] = useState<string>('');\n    useDebugValue('debug');\n    return {\n        str, setStr\n    }\n}\nexport default (): JSX.Element => {\n    const { str, setStr } = useTest();\n    return (\n        <>\n            <h2>{str}</h2>\n            <button onClick={() => {\n                setStr('重新渲染');\n            }}>这是？？？</button>\n        </>\n    );\n}\n```\n\n\n\n![](/image/你真的懂ReactHook吗/20190818212347571.png)\n\n\n\n会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用\n\n当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示\n\n```js\nimport React, { useDebugValue, useState } from 'react';\n\nconst useTest = () => {\n    const [str, setStr] = useState<string>('');\n    useDebugValue(str, (value:string) => {\n        console.log(value);\n        return '这是改造后的' + value;\n    });\n    return {\n        str, setStr\n    }\n}\nexport default (): JSX.Element => {\n    const { str, setStr } = useTest();\n    return (\n        <>\n\n            <h2>{str}</h2>\n\n            <button onClick={() => {\n                setStr('重新渲染');\n           }}>这是？？？</button>\n       </>\n    );\n}\n```\n\n结果:\n\n![](/image/你真的懂ReactHook吗/2019081821194714.png)\n\n\n同时在控制台上打印了一个空字符\n\n\n由于str的初始值是空的，所以打印就是空的了，这只是调试使用，hooks差不多就这些了，没有其他的了\n\n\n\n## 观看之后\n\n如果有哪里写的不对或者有疑问的欢迎大家在评论区互动。🙏\n\n\n\n\n","source":"_posts/你真的懂React-Hook吗.md","raw":"---\ntitle: 你真的懂React Hook吗？\ndate: 2020-05-20 00:19:44\ntags: [React, ReactHook]\ncategory: [React]\ncover: /image/cover/React.jpeg\n---\n## 前言\n\n1. 读这篇文章的前提是你已经对React Hook有所了解的情况下，如果你还没有了解，请先移步官网学习一下。\n   1. 最好不要去网上看别人的总结之类的，无非就是超的官网的，而且这样会让你的认知从一开始就走偏。\n2. 这篇文章主要是探究Hook的动机，使用中的一些疑问；\n   1. 使用的话React官网已经讲得很详细了，这里就不多赘述了。\n3. 有需要看接下来的疑难点的伙伴欢迎直接跳过探究直接看具体的疑问；\n\n## 探究\n\n主要从3个方面研究React Hook\n\n根据黄金思维圈（What、How、Why）\n\n### What\n\n什么是Hook？\n\n打开Google翻译，得到的解释：*钩、钩子*\n\n> 再看看React官网的解释：They let you use state and other React features without writing a class.（它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。）\n\n所以，结合一下。我个人的理解是这样的：对于函数式的组件，可以用钩子（Hook）将想要的外部功能给“钩”进来。\n\n在React Hook出来之前，函数式组件都是无状态的组件，最多就是根据`props`来加一些判断的逻辑；而在React Hook出来之后就可以在函数式组件里面加入状态（useState），类生命周期（useEffect），甚至是一些自己的复用逻辑（自定义Hook）等等这些外部的功能。\n\n\n\n### How\n\n怎么使用Hook？\n\n大家一起看一下官网的一个例子。\n\n题目：显示一个计数器。当你点击按钮，计数器的值就会增加。\n\n#### Class组件\n\n\n\n```javascript\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n\n\n#### React Hook\n\n\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个叫 \"count\" 的 state 变量  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n\n\n这样就算是完成了一个最简单的React Hook 实践，关于一些官方提供的Hook晚点会介绍。\n\n\n\n### Why\n\n- 为什么会有Hooks？\n- Hook能解决什么问题？\n\n做任何一件事情我觉得都应该理清这个两个问题，这样的话就会事半功倍。\n\n我们先看看React官方是怎么解释“Why”的\n\n> 1. 在组件之间复用状态逻辑很难\n> 2. 复杂组件变得难以理解\n> 3. 难以理解的 class\n\n本人个人认为第三点是来凑数的....\n\n为什么这么说？\n\n因为React用了这么久了基本都是在使用Class组件，这个是在之前，哪怕是现在学习React的必经之路吧！所以，这点我接下来就会跳过了😂\n\n### 在组件之间服用状态逻辑很难\n\n其实高阶组件或者说是props都是很好的解决了复杂的聚合业务逻辑，那为什么说在**组件之间服用状态逻辑很难**呢？\n\n其实道理非常简单。\n\n举个简单的例子，方便大家理解。\n\n场景：有 请求A，请求B，请求C，请求D。他们的请求都有相互依赖关系比如，发请求B的时候必须拿到请求A的结果中的某个值，而请求C也必须拿到请求B的结果中的某个值。以此类推请求D。\n\nPromise出来之前是怎么做的呢？\n\n```javascript\n$.ajax({\n    type:\"post\",\n    success: function(){//成功回调\n        //再次异步请求\n        $.ajax({\n            type:\"post\",\n            url:\"...\",\n            success:function(){//成功回调\n              //再次异步请求\n              $.ajax({\n                  type:\"post\",\n                  url:\"...\",\n                  success:function(){\n                      .......//如此循环\n                  }\n              })\n          }\n        })\n    }\n})\n```\n\n这还只是3层，如果是100层呢？那看起来就非常的难受了！\n\nPromise较好的解决了这个问题\n\n```javascript\nnew Promise(f1)\n .then(f2)\n .then(f3)\n .then(f4)\n .then(f5)\n .then(f5)\n…………\n```\n\n然后是async/await。这里就不展开了，有兴趣的可以自己去了解一下。\n\n结论\n\n之所以这么大费周章的讲是为了解释，React中的高阶组件（HOC）。他的逻辑其实和回调地狱类似，一个两个其实都还算优雅或者说舒服，一旦多了的话。。。\n\n```javascript\nexport default withHover(\n  withTheme(\n    withAuth(\n      withRepos(Profile)\n    )\n  )\n)\n\n// 就会变成这样，不够优雅\n<WithHover>\n  <WithTheme hovering={false}>\n    <WithAuth hovering={false} theme='dark'>\n      <WithRepos hovering={false} theme='dark' authed={true}>\n        <Profile \n          id='JavaScript'\n          loading={true} \n          repos={[]}\n          authed={true}\n          theme='dark'\n          hovering={false}\n        />\n      </WithRepos>\n    </WithAuth>\n  <WithTheme>\n</WithHover>\n```\n\n而且每个高阶组件的逻辑复用我们可能还要一个个去研读。\n\n\n\n### 复杂组件变得难以理解\n\n其实，这点非常好理解。举一个非常简单常见的例子大家就会明白了。\n\n场景：假如我有一个子组件Child，他的功能是这样的：父组建会给一个id，在组件创建的时候获取一下有关信息，在id改变的时候再重新获取。\n\n#### Class组件\n\n```javascript\ncomponentDidMount () {\n    this.fetch(this.props.id)\n }\ncomponentDidUpdate (prevProps) {\n  if (prevProps.id !== this.props.id) {\n    this.fetch(this.props.id)\n  }\n}\nfetch = id => {\n  this.setState({ loading: true })\n  fetchInfo(id)\n    .then(info => this.setState({\n    info,\n    loading: false\n  }))\n}\n```\n\n#### React Hook：\n\n```javascript\nconst fetch = id => {\n  this.setState({ loading: true })\n  fetchInfo(id)\n    .then(info => this.setState({\n    info,\n    loading: false\n  }))\n}\nuseEffect(() => {\n  fetch(this.props.id)\n}, [this.props.id])\n```\n\n\n\n### 结论\n\n简单的说一下他的优点吧。\n\n1. 复用代码更加简单（需要什么就“钩”进来）\n2. 清爽的代码风格，一目了然。（useState支持数组和对象，可以清晰的定义特殊的字段等等）\n3. 代码量更少（可以看一下我之前的子父组建的例子）\n4. 更愿意去写一些小组件复用（我个人喜欢React就是因为他的组件写起来非常的顺手！ps：没有贬低其他框架的意思。。）\n5. 其实我个人认为React Hook在宣扬一个观念“按需加载”。\n\n## useState\n\n### 使用\n\n简单的使用在上面的探究-How里面有介绍，更多的在React官网也有介绍。\n\n#### 请回答以下代码的运行结果\n\n![](https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif)\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <button onClick={handleAlertClick}>\n        Show alert\n      </button>\n    </div>\n  );\n}\n```\n\n你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。\n\n> 分割线\n\n来自己 [试试吧！](https://codesandbox.io/s/w2wxl3yo0l)\n\n#### 答案是\n\n3\n\n这是为什么呢？function组建究竟是如果工作的呢？\n\n我们发现`count`在每一次函数调用中都是一个常量值。值得强调的是 — **我们的组件函数每次渲染都会被调用，但是每一次调用中`count`值都是常量，并且它被赋予了当前渲染中的状态值。**\n\n这并不是React特有的，普通的函数也有类似的行为：\n\n```jsx\nfunction sayHi(person) {\n  const name = person.name;  setTimeout(() => {\n    alert('Hello, ' + name);\n  }, 3000);\n}\n\nlet someone = {name: 'Dan'};\nsayHi(someone);\n\nsomeone = {name: 'Yuzhi'};\nsayHi(someone);\n\nsomeone = {name: 'Dominic'};\nsayHi(someone);\n```\n\n在 [这个例子](https://codesandbox.io/s/mm6ww11lk8)中, 外层的`someone`会被赋值很多次（就像在React中，*当前*的组件状态会改变一样）。**然后，在`sayHi`函数中，局部常量`name`会和某次调用中的`person`关联。**因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的`name`。\n\n这就解释了我们的事件处理函数如何捕获了点击时候的`count`值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的`count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n```\n\n所以实际上，每一次渲染都有一个“新版本”的`handleAlertClick`。每一个版本的`handleAlertClick`“记住” 了它自己的 `count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 0);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 0 inside  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 1);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 1 inside  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 2);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 2 inside  // ...\n}\n```\n\n这就是为什么[在这个demo中](https://codesandbox.io/s/w2wxl3yo0l)中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中`counter`的状态值。\n\n**在任意一次渲染中，props和state是始终保持不变的。**如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的`count`值。\n\n#### 请回答以下代码的运行结果\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const addCount = () => {\n    setCount(count+1)\n    setCount(count+2)\n    setCount(count+3)\n    setCount(count+4)\n    setCount(count+5)\n  }\n\n  console.log(count)\n  \n  return (\n    <div>\n      <button onClick={addCount}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n> 分割线\n\n#### 答案是\n\n5\n\n为什么呢？\n\nuseState的更新究竟是如何工作的呢？\n\n我们进入`ReactHooks.js`来看看，发现`useState`的实现竟然异常简单，只有短短两行\n\n```js\n// ReactHooks.js\nexport function useState<S>(initialState: (() => S) | S) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n```\n\n其实可以这样理解useState，useState其实就是useReducer的一个语法糖；但是这个不在这个问题的讨论范围内；\n\n好，收回来。\n\n其实我们在`const [xx, setXx] = useState(xx)`的时候就生成一个队列，我们暂时叫它为queue；所有这一轮运行读取到的state都被放到一个链表的队列里面去，然后再用do-while循环，每次都是拿到最新的值，但是不是Object.assgin的形式，而是直接赋值。话不多说直接源码。\n\n```js\nfunction updateReducer(reducer, initialArg, init) {\n// 获取初始化时的 hook\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  // 开始渲染更新\n  if (numberOfReRenders > 0) {\n    const dispatch = queue.dispatch;\n    if (renderPhaseUpdates !== null) {\n      // 获取Hook对象上的 queue，内部存有本次更新的一系列数据\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        // 获取更新后的state\n        do {\n          const action = update.action;\n          // 此时的reducer是basicStateReducer，直接返回action的值\n          // 注意，这里是等于号所以\n          /**\n          *\n          * setObj({ a: 1, b: 1, c: 1 })\n        \t* setObj({ a: 2, b: 2 })\n        \t* setObj({ a: 3 })\n        \t*\n        \t* 到最后也只有只有{ a: 3 }，而b和c全没了\n          *\n          **/\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null);\n        // 对 更新hook.memoized \n        hook.memoizedState = newState;\n        // 返回新的 state，及更新 hook 的 dispatch 方法\n        return [newState, dispatch];\n      }\n    }\n  }\n```\n\n\n\n## useEffect/useLayoutEffect\n\n### 提示\n\n在学习useEffect这个Hook的时候，淡化你知道的“生命周期”这个概念。\n\n#### useEffect和useLayoutEffect两兄弟的区别是什么？\n\n执行的时机不同\n\n那么具体哪里不同呢？\n\n其实在初始化useEffect和useLayoutEffect是没有区别的，他们真正的区别在于初始化之后；\n\n举个非常形象的例子🌰：\n\n除了初始化之后的一轮更新：\n\n> 浏览器：我要绘制了！\n>\n> React：等等，我有一个哥们临时有事要处理，他是：useLayoutEffect\n>\n> useLayoutEffect执行....\n>\n> React：好了，你可以开始绘制了～@浏览器\n>\n> 浏览器：好的\n>\n> 浏览器更新UI...\n>\n> 浏览器：我更新好了。你有什么事要做的吗？@React\n>\n> React：有的，useEffect你上\n>\n> useEffect执行....\n\n可能有点废话了。其实区别就是\n\n> useLayoutEffect()\n>\n> 浏览器绘制\n>\n> useEffect()\n\n这样其实大家也能很直接的看到弊端了。那就是useLayoutEffect如果有大量的计算的话，那样可能会阻塞UI更新，或者说UI渲染。所以还是要谨慎使用。\n\n一般来说他们没有什么太大的区别的，如果真的要使用useLayoutEffect的话要谨慎一些。不然可能会导致UI渲染阻塞之类的问题。\n\n但是，也不是没有使用场景。\n\n比如下面的这个代码就很需要useLayoutEffect\n\n```js\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  useLayoutEffect(() => {\n    if (count === 0) {\n      const randomNum = 10 + Math.random()*200\n      setCount(10 + Math.random()*200);\n    }\n  }, [count]);\n\n  return (\n      <div onClick={() => setCount(0)}>{count}</div>\n  );\n}\n\n//   我是分割线\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    if (count === 0) {\n      const randomNum = 10 + Math.random()*200\n      setCount(10 + Math.random()*200);\n    }\n  }, [count]);\n\n  return (\n      <div onClick={() => setCount(0)}>{count}</div>\n  );\n}\n```\n\n其实明白的同学一下就看出来了，如果使用useEffect的话会出现闪烁，会先回到0然后再更新新的随机数。而反观useLayoutEffect则不会，他会很自然的过渡。\n\n总结：\n\nuseLayoutEffect的使用场景为：有一个中间状态希望隐藏的时候再使用。\n\n大部分情况下useEffect可以适用于99%的场景。\n\n####  useEffect的错误事例。看看有没有你\n\n```js\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // Imagine this function is also long\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  // Imagine this function is also long\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n```\n\n#### 为什么错了？\n\n不难看出上面代码的意思是。想要模仿componentDidMount的生命周期，在页面或者组件加载之后发送一个请求。咋一看好像没有什么问题（实际在运行的过程中也没有什么问题，在写这篇文章之前我也是这么做的。）\n\n但是大家可以想象一下，如果这个函数组件，是现在的5倍大，这个didMount里面调用的请求，未来依赖的东西你都可以100%的察觉到吗？\n\n我觉得难！难免会有疏忽。到时候可能就会出现state或者props读取错误的情况。因为每一次render的state和props都是独立的。\n\n那么，该如何解决呢？\n\n有一个很土的办法，直接把函数扔到useEffect里面去\n\n```jsx\nfunction SearchResults() {\n  // ...\n  useEffect(() => {\n    // We moved these functions inside!    \n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=react';\n    }\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n    fetchData();\n  }, []); // ✅ Deps are OK\n  // ...\n}\n```\n\n那高级点的办法呢？\n\n```js\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback((query) => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n将函数用useCallback包裹，这样的话我们只需要做useEffect的依赖里面写上我们的函数，然后在useCallback里面写上我们的依赖。\n\n#### 我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\n\n\n\n```js\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n  useEffect(() => {\n    prevCountRef.current = count;\n  });\n  const prevCount = prevCountRef.current;\n\n  return <h1>Now: {count}, before: {prevCount}</h1>;\n}\n```\n\n其实很好理解，如果看了前面useEffect和useLayoutEffect区别的同学一下就可以知道这个的实现原理。\n\n首先，在一切都更新之后，然后会会执行useEffect内部的回调函数，将prevCount给赋值，由于没有触发渲染，所以只是单纯的赋值。这样就看起来prevCount的值永远都慢一步。\n\n### 总结\n\n其实在学习useEffect的时候。应该忘记你对React的一些知识。比如生命周期，在函数组件里面没有生命周期这个概念了。\n\n每一次的render他都有自己的state和props。state和props更应该被看作一个常量，哪怕是const bar = xx这样的常量。这样理解起来useEffect这个副作用其实会更加顺畅，也不容易进入他的“陷阱”\n\n## useRef\n\n### 前言\n\n为什么我把useRef单独拎出来说，不把他和`useImperativeHandle`放在一起讲，因为\n\n> （官网原话）它创建的是一个普通 Javascript 对象。而 `useRef()` 和自建一个 `{current: ...}` 对象的唯一区别是，`useRef` 会在每次渲染时返回同一个 ref 对象。\n\n记住`useRef`不单单用于获取`DOM节点和组件实例`，还有一个巧妙的用法就是`作为容器保留可变变量`，可以这样说：`无法自如地使用useRef会让你失去hook将近一半的能力`\n\n#### useRef 与 createRef 的区别\n\n`useRef` 仅能用在 FunctionComponent，`createRef` 仅能用在 ClassComponent。\n\n`useRef` 仅能用在 FunctionComponent，`createRef` 仅能用在 ClassComponent。\n\n第一句话是显然的，因为 Hooks 不能用在 ClassComponent。\n\n第二句话的原因是，`createRef` 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：\n\n```\nfunction App() {\n  // 错误用法，永远也拿不到 ref\n  const valueRef = React.createRef();\n  return <div ref={valueRef} />;\n}\n复制代码\n```\n\n上述 `valueRef` 会随着 App 函数的 Render 而重复初始化，**这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变**。\n\n为什么 `createRef` 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 `componentDidMount` 等初始化时机仅执行一次。\n\n#### 如何解决每次render带来类闭包问题？\n\n首先，题目怎么理解？[题目](https://codesandbox.io/s/w2wxl3yo0l)\n\n如果我们希望他alert的时候可以获取到最新的值的话，可以使用useRef来解决\n\n```js\nconst Counter = () => {\n  const [count, setCount] = useState<number>(0)\n  const countRef = useRef<number>(count)\n\n  useEffect(() => {\n    countRef.current = count\n  })\n\n  const handleCount = () => {\n    setTimeout(() => {\n      alert('current count: ' + countRef.current)\n    }, 3000);\n  }\n\n  //...\n}\n\nexport default Counter\n```\n\n\n\n## memo\n\n#### memo没有回调函数的话是怎么浅比较的？\n\n先来看看memo没有回调函数的时候他做了什么。\n\nmemo它是一个高阶组件（HOC）他与React.PureComponent十分相似。除了使用的地方不同（Class组件和Function组件）之外几乎一致。\n\nMemo内部和PureComponent一样使用Object.is用于前对比，如果传入的props内存地址不变的话，那就不会渲染了（或者说复用最近的一次渲染）。\n\n下面可以看源码事例\n\n```js\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n\n  /* ...省略...*/\n\n  // 判断更新的过期时间是否小于渲染的过期时间\n  if (updateExpirationTime < renderExpirationTime) {\n    const prevProps = currentChild.memoizedProps;\n\n    // 如果自定义了compare函数，则采用自定义的compare函数，否则采用官方的shallowEqual(浅比较)函数。（下面有解析）\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    /**\n     * 1. 判断当前 props 与 nextProps 是否相等；\n     * 2. 判断即将渲染组件的引用是否与workInProgress Fiber中的引用是否一致；\n     *\n     * 只有两者都为真，才会退出渲染。\n     */\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      // 如果都为真，则退出渲染\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n  }\n\n  /* ...省略...*/\n\n```\n\nshallowEqual（浅比较）\n\n```js\n// 用原型链的方法\nconst hasOwn = Object.prototype.hasOwnProperty\n\n// 这个函数实际上是Object.is()的polyfill\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\n  } else {\n    return x !== x && y !== y\n  }\n}\n\nexport default function shallowEqual(objA, objB) {\n  // 首先对基本数据类型的比较\n  if (is(objA, objB)) return true\n  // 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等\n  // 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object\n  // 之后，就可以返回false了\n  if (typeof objA !== 'object' || objA === null ||\n      typeof objB !== 'object' || objB === null) {\n    return false\n  }\n\n  // 过滤掉基本数据类型之后，就是对对象的比较了\n  // 首先拿出key值，对key的长度进行对比\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  // 长度不等直接返回false\n  if (keysA.length !== keysB.length) return false\n  // key相等的情况下，在去循环比较\n  for (let i = 0; i < keysA.length; i++) {\n  // key值相等的时候\n  // 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值\n  // 属性的顺序不影响结果也就是{name:'daisy', age:'24'} 跟{age:'24'，name:'daisy' }是一样的\n  // 最后，对对象的value进行一个基本数据类型的比较，返回结果\n    if (!hasOwn.call(objB, keysA[i]) ||\n        !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false\n    }\n  }\n\n  return truea\n}\n```\n\n由源码可以知道，加入没有传一个比较的回调函数会使用官方的浅比较。具体的可以看注释\n\n#### memo的回调函数\n\n我们都知道react的生命周期中有一个shouldComponentUpdate。在这个函数中返回true的话就代表本次render需要执行，而返回false就可以跳过本次的render。\n\n而memo正好相反，返回true表示本次跳过，返回false就表示本次需要执行render。\n\n具体怎么用呢？\n\n大家可以自己运行一下，看看效果。一定要自己试一下，不然很容易和shouldComponentUpdate弄混了。学习还是要自己动手才行。\n\n```js\nfunction ChangeLog({w = ''}){\n  // 省略\n  console.log('====render====')\n}\nexport default memo(ChangeLog, (prevProps, nextProps) => {\n  if (prevProps.w !== nextProps.w) {\n    return false\n  }\n  return true\n});\n```\n\n## useMemo/useCallback\n\n ### 前言\n\n之所以把这useMomo/useCallack两兄弟和在一起。是因为他们其实十分相似。\n\n> 一个是缓存变量（useMemo），一个是缓存函数（useCallback）。\n\n其实这么一说就清晰很多了。\n\n具体的使用和useEffect一样，都是第一个参数为调用时的回调函数，第二个参数是调用判断所监听的值（可以是变量，也可以是函数）\n\n```js\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\nconst memoizedValue = useCallback(() => computeExpensiveValue(a, b), [a, b]);\n```\n\nuseMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）\n\nmemoized 值不变的情况下，不会重新触发渲染逻辑。\n\n说起渲染逻辑，需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作，比如网络请求等。\n\n如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner\n\nuseCallback也是一样的，这里就不多赘述了。\n\n## useReducer/useContext\n\n### 前言\n\n帮他们两兄弟和在一起说主要说因为他们两兄弟在一般情况下是可以与Redux一战的。\n\n但是！！\n\n但是啊，但是如果你需要中间价，或者说需要“时间旅行”，又或者临时需要跨页面级的数据共享，那你还是需要redux来解决的。不过基本上的场景我们使用useReducer和useContext就可以完美的替代redux了。\n\n### 怎么做？\n\n其实之前由于要起一个新项目，但是突然发现有一个爷爷组件的值为需要通知给孙子组件，然后孙子组件可能会用掉回调函数调用爷爷组件的方法。那个时候其实已经用Hook写了一半了，懒得加Redux了，又不想一层层传props下去。怎么办？\n\n通过了解，我知道了useReducer/useContext刚刚好可以解决我的需求。\n\n```js\nconst TodosDispatch = React.createContext(null);\n\nconst initialState = { bar: null };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setCenter':\n      return { ...state, bar: action.bar };\n    default:\n      return state\n  }\n}\n\n// 虽然这个是自组件，但是哪怕是曾曾曾孙子组件都可以直接用useContext拿到dispatch\nfunction DeepChild(props) {\n  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。\n  const dispatch = useContext(TodosDispatch);\n\n  function handleClick() {\n    dispatch({ type: 'add', text: 'hello' });\n  }\n\n  return (\n    <button onClick={handleClick}>Add todo</button>\n  );\n}\n\nfunction TodosApp() {\n  // 提示：`dispatch` 不会在重新渲染之间变化\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <TodosDispatch.Provider value={dispatch}>\n      <DeepTree todos={todos} />\n    </TodosDispatch.Provider>\n  );\n}\n```\n\n## useImperativeHandle/forwardRef\n\n这里就不多说了，基本上没有什么坑点和疑难点。\n\n说一下基本用法和ant-design form中的使用\n\n### 正常使用\n\n```js\nuseImperativeHandle(ref, createHandle, [deps])\n```\n\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。`useImperativeHandle` 应当与 `forwardRef`一起使用：\n\n```js\nfunction FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n```\n\n在本例中，渲染<FancyInput ref={inputRef} />的父组件可以调用 `inputRef.current.focus()`。\n\n### ant-design form\n\n```js\n// ref从第二个参数取，这里都是一致的\nconst Example = (props,ref) => {\n  const bar = () => {}\n  useImperativeHandle(ref, () => ({\n    text: bar,\n  }));\n  return (\n    <>\n        <Form>\n    \t\t\t{//....}\n        </Form>\n    </>\n  );\n};\n\nexport default memo(Form.create()(forwardRef(Example)));\n\n```\n\n```js\n\nconst Parent = () => {\n  return (\n    <>\n      <Example\n      \t// 注意这个不再是传ref了，而是传wrappedComponentRef。因为antd的form他返回的是一个新的对象，这个是他自定义的一个接收ref的值\n        wrappedComponentRef={editTemplateRef}\n      />\n    </>\n  );\n};\n```\n\n\n\n## useDebugValue/自定义Hook\n\n### 前言\n\nuseDebugValue是专门用于服务自定义的Hook的。\n\n具体看看使用就好\n\n\n\nuseDebugValue，目的是能在react的浏览器调试工具上显示你的自定义hooks，或者给hooks标记一些东西\n当使用一个参数的时候，就是把第一个参数标记在react的调试工具上,下面写一个简单的例子\n\n```js\nimport React, { useDebugValue, useState } from 'react';\n\nconst useTest = () => {\n    const [str, setStr] = useState<string>('');\n    useDebugValue('debug');\n    return {\n        str, setStr\n    }\n}\nexport default (): JSX.Element => {\n    const { str, setStr } = useTest();\n    return (\n        <>\n            <h2>{str}</h2>\n            <button onClick={() => {\n                setStr('重新渲染');\n            }}>这是？？？</button>\n        </>\n    );\n}\n```\n\n\n\n![](/image/你真的懂ReactHook吗/20190818212347571.png)\n\n\n\n会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用\n\n当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示\n\n```js\nimport React, { useDebugValue, useState } from 'react';\n\nconst useTest = () => {\n    const [str, setStr] = useState<string>('');\n    useDebugValue(str, (value:string) => {\n        console.log(value);\n        return '这是改造后的' + value;\n    });\n    return {\n        str, setStr\n    }\n}\nexport default (): JSX.Element => {\n    const { str, setStr } = useTest();\n    return (\n        <>\n\n            <h2>{str}</h2>\n\n            <button onClick={() => {\n                setStr('重新渲染');\n           }}>这是？？？</button>\n       </>\n    );\n}\n```\n\n结果:\n\n![](/image/你真的懂ReactHook吗/2019081821194714.png)\n\n\n同时在控制台上打印了一个空字符\n\n\n由于str的初始值是空的，所以打印就是空的了，这只是调试使用，hooks差不多就这些了，没有其他的了\n\n\n\n## 观看之后\n\n如果有哪里写的不对或者有疑问的欢迎大家在评论区互动。🙏\n\n\n\n\n","slug":"你真的懂React-Hook吗","published":1,"updated":"2021-06-24T14:00:06.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8w002dlwrdgcig9ihz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li>读这篇文章的前提是你已经对React Hook有所了解的情况下，如果你还没有了解，请先移步官网学习一下。<ol>\n<li>最好不要去网上看别人的总结之类的，无非就是超的官网的，而且这样会让你的认知从一开始就走偏。</li>\n</ol>\n</li>\n<li>这篇文章主要是探究Hook的动机，使用中的一些疑问；<ol>\n<li>使用的话React官网已经讲得很详细了，这里就不多赘述了。</li>\n</ol>\n</li>\n<li>有需要看接下来的疑难点的伙伴欢迎直接跳过探究直接看具体的疑问；</li>\n</ol>\n<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究\"></a>探究</h2><p>主要从3个方面研究React Hook</p>\n<p>根据黄金思维圈（What、How、Why）</p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>什么是Hook？</p>\n<p>打开Google翻译，得到的解释：<em>钩、钩子</em></p>\n<blockquote>\n<p>再看看React官网的解释：They let you use state and other React features without writing a class.（它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。）</p>\n</blockquote>\n<p>所以，结合一下。我个人的理解是这样的：对于函数式的组件，可以用钩子（Hook）将想要的外部功能给“钩”进来。</p>\n<p>在React Hook出来之前，函数式组件都是无状态的组件，最多就是根据<code>props</code>来加一些判断的逻辑；而在React Hook出来之后就可以在函数式组件里面加入状态（useState），类生命周期（useEffect），甚至是一些自己的复用逻辑（自定义Hook）等等这些外部的功能。</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>怎么使用Hook？</p>\n<p>大家一起看一下官网的一个例子。</p>\n<p>题目：显示一个计数器。当你点击按钮，计数器的值就会增加。</p>\n<h4 id=\"Class组件\"><a href=\"#Class组件\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          Click me</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"React-Hook\"><a href=\"#React-Hook\" class=\"headerlink\" title=\"React Hook\"></a>React Hook</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个叫 \"count\" 的 state 变量  const [count, setCount] = useState(0);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样就算是完成了一个最简单的React Hook 实践，关于一些官方提供的Hook晚点会介绍。</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><ul>\n<li>为什么会有Hooks？</li>\n<li>Hook能解决什么问题？</li>\n</ul>\n<p>做任何一件事情我觉得都应该理清这个两个问题，这样的话就会事半功倍。</p>\n<p>我们先看看React官方是怎么解释“Why”的</p>\n<blockquote>\n<ol>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class</li>\n</ol>\n</blockquote>\n<p>本人个人认为第三点是来凑数的….</p>\n<p>为什么这么说？</p>\n<p>因为React用了这么久了基本都是在使用Class组件，这个是在之前，哪怕是现在学习React的必经之路吧！所以，这点我接下来就会跳过了😂</p>\n<h3 id=\"在组件之间服用状态逻辑很难\"><a href=\"#在组件之间服用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间服用状态逻辑很难\"></a>在组件之间服用状态逻辑很难</h3><p>其实高阶组件或者说是props都是很好的解决了复杂的聚合业务逻辑，那为什么说在<strong>组件之间服用状态逻辑很难</strong>呢？</p>\n<p>其实道理非常简单。</p>\n<p>举个简单的例子，方便大家理解。</p>\n<p>场景：有 请求A，请求B，请求C，请求D。他们的请求都有相互依赖关系比如，发请求B的时候必须拿到请求A的结果中的某个值，而请求C也必须拿到请求B的结果中的某个值。以此类推请求D。</p>\n<p>Promise出来之前是怎么做的呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//成功回调</span></span><br><span class=\"line\">        <span class=\"comment\">//再次异步请求</span></span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">            url:<span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">            success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//成功回调</span></span><br><span class=\"line\">              <span class=\"comment\">//再次异步请求</span></span><br><span class=\"line\">              $.ajax(&#123;</span><br><span class=\"line\">                  type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">                  url:<span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">                  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                      .......<span class=\"comment\">//如此循环</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这还只是3层，如果是100层呢？那看起来就非常的难受了！</p>\n<p>Promise较好的解决了这个问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(f1)</span><br><span class=\"line\"> .then(f2)</span><br><span class=\"line\"> .then(f3)</span><br><span class=\"line\"> .then(f4)</span><br><span class=\"line\"> .then(f5)</span><br><span class=\"line\"> .then(f5)</span><br><span class=\"line\">…………</span><br></pre></td></tr></table></figure>\n\n<p>然后是async/await。这里就不展开了，有兴趣的可以自己去了解一下。</p>\n<p>结论</p>\n<p>之所以这么大费周章的讲是为了解释，React中的高阶组件（HOC）。他的逻辑其实和回调地狱类似，一个两个其实都还算优雅或者说舒服，一旦多了的话。。。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withHover(</span><br><span class=\"line\">  withTheme(</span><br><span class=\"line\">    withAuth(</span><br><span class=\"line\">      withRepos(Profile)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 就会变成这样，不够优雅</span></span><br><span class=\"line\">&lt;WithHover&gt;</span><br><span class=\"line\">  &lt;WithTheme hovering=&#123;<span class=\"literal\">false</span>&#125;&gt;</span><br><span class=\"line\">    &lt;WithAuth hovering=&#123;<span class=\"literal\">false</span>&#125; theme=<span class=\"string\">'dark'</span>&gt;</span><br><span class=\"line\">      &lt;WithRepos hovering=&#123;<span class=\"literal\">false</span>&#125; theme=<span class=\"string\">'dark'</span> authed=&#123;<span class=\"literal\">true</span>&#125;&gt;</span><br><span class=\"line\">        &lt;Profile </span><br><span class=\"line\">          id=<span class=\"string\">'JavaScript'</span></span><br><span class=\"line\">          loading=&#123;<span class=\"literal\">true</span>&#125; </span><br><span class=\"line\">          repos=&#123;[]&#125;</span><br><span class=\"line\">          authed=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">          theme=<span class=\"string\">'dark'</span></span><br><span class=\"line\">          hovering=&#123;<span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/WithRepos&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>WithAuth&gt;</span><br><span class=\"line\">  &lt;WithTheme&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/WithHover&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而且每个高阶组件的逻辑复用我们可能还要一个个去研读。</p>\n<h3 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a>复杂组件变得难以理解</h3><p>其实，这点非常好理解。举一个非常简单常见的例子大家就会明白了。</p>\n<p>场景：假如我有一个子组件Child，他的功能是这样的：父组建会给一个id，在组件创建的时候获取一下有关信息，在id改变的时候再重新获取。</p>\n<h4 id=\"Class组件-1\"><a href=\"#Class组件-1\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">componentDidUpdate (prevProps) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prevProps.id !== <span class=\"keyword\">this</span>.props.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetch = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">loading</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  fetchInfo(id)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    info,</span><br><span class=\"line\">    loading: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"React-Hook：\"><a href=\"#React-Hook：\" class=\"headerlink\" title=\"React Hook：\"></a>React Hook：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetch = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">loading</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  fetchInfo(id)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    info,</span><br><span class=\"line\">    loading: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">&#125;, [<span class=\"keyword\">this</span>.props.id])</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>简单的说一下他的优点吧。</p>\n<ol>\n<li>复用代码更加简单（需要什么就“钩”进来）</li>\n<li>清爽的代码风格，一目了然。（useState支持数组和对象，可以清晰的定义特殊的字段等等）</li>\n<li>代码量更少（可以看一下我之前的子父组建的例子）</li>\n<li>更愿意去写一些小组件复用（我个人喜欢React就是因为他的组件写起来非常的顺手！ps：没有贬低其他框架的意思。。）</li>\n<li>其实我个人认为React Hook在宣扬一个观念“按需加载”。</li>\n</ol>\n<h2 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>简单的使用在上面的探究-How里面有介绍，更多的在React官网也有介绍。</p>\n<h4 id=\"请回答以下代码的运行结果\"><a href=\"#请回答以下代码的运行结果\" class=\"headerlink\" title=\"请回答以下代码的运行结果\"></a>请回答以下代码的运行结果</h4><p><img src=\"/\" class=\"lazyload\" data-src=\"https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif\"  alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class=\"line\">        Show alert</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。</p>\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<p>来自己 <a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">试试吧！</a></p>\n<h4 id=\"答案是\"><a href=\"#答案是\" class=\"headerlink\" title=\"答案是\"></a>答案是</h4><p>3</p>\n<p>这是为什么呢？function组建究竟是如果工作的呢？</p>\n<p>我们发现<code>count</code>在每一次函数调用中都是一个常量值。值得强调的是 — <strong>我们的组件函数每次渲染都会被调用，但是每一次调用中<code>count</code>值都是常量，并且它被赋予了当前渲染中的状态值。</strong></p>\n<p>这并不是React特有的，普通的函数也有类似的行为：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = person.name;  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Dan'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br><span class=\"line\"></span><br><span class=\"line\">someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Yuzhi'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br><span class=\"line\"></span><br><span class=\"line\">someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Dominic'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br></pre></td></tr></table></figure>\n\n<p>在 <a href=\"https://codesandbox.io/s/mm6ww11lk8\" target=\"_blank\" rel=\"noopener\">这个例子</a>中, 外层的<code>someone</code>会被赋值很多次（就像在React中，<em>当前</em>的组件状态会改变一样）。<strong>然后，在<code>sayHi</code>函数中，局部常量<code>name</code>会和某次调用中的<code>person</code>关联。</strong>因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的<code>name</code>。</p>\n<p>这就解释了我们的事件处理函数如何捕获了点击时候的<code>count</code>值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的<code>count</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// During first render</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">0</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After a click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After another click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">2</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以实际上，每一次渲染都有一个“新版本”的<code>handleAlertClick</code>。每一个版本的<code>handleAlertClick</code>“记住” 了它自己的 <code>count</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// During first render</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">0</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 0 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After a click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">1</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 1 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After another click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">2</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 2 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是为什么<a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">在这个demo中</a>中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中<code>counter</code>的状态值。</p>\n<p><strong>在任意一次渲染中，props和state是始终保持不变的。</strong>如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>\n<h4 id=\"请回答以下代码的运行结果-1\"><a href=\"#请回答以下代码的运行结果-1\" class=\"headerlink\" title=\"请回答以下代码的运行结果\"></a>请回答以下代码的运行结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> addCount = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">2</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">3</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">4</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">5</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;addCount&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<h4 id=\"答案是-1\"><a href=\"#答案是-1\" class=\"headerlink\" title=\"答案是\"></a>答案是</h4><p>5</p>\n<p>为什么呢？</p>\n<p>useState的更新究竟是如何工作的呢？</p>\n<p>我们进入<code>ReactHooks.js</code>来看看，发现<code>useState</code>的实现竟然异常简单，只有短短两行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactHooks.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useState</span>&lt;<span class=\"title\">S</span>&gt;(<span class=\"params\">initialState: ((</span>) =&gt; <span class=\"title\">S</span>) | <span class=\"title\">S</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatcher = resolveDispatcher();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatcher.useState(initialState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实可以这样理解useState，useState其实就是useReducer的一个语法糖；但是这个不在这个问题的讨论范围内；</p>\n<p>好，收回来。</p>\n<p>其实我们在<code>const [xx, setXx] = useState(xx)</code>的时候就生成一个队列，我们暂时叫它为queue；所有这一轮运行读取到的state都被放到一个链表的队列里面去，然后再用do-while循环，每次都是拿到最新的值，但是不是Object.assgin的形式，而是直接赋值。话不多说直接源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateReducer</span>(<span class=\"params\">reducer, initialArg, init</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 获取初始化时的 hook</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = updateWorkInProgressHook();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = hook.queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始渲染更新</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numberOfReRenders &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dispatch = queue.dispatch;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (renderPhaseUpdates !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取Hook对象上的 queue，内部存有本次更新的一系列数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstRenderPhaseUpdate !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        renderPhaseUpdates.delete(queue);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newState = hook.memoizedState;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> update = firstRenderPhaseUpdate;</span><br><span class=\"line\">        <span class=\"comment\">// 获取更新后的state</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> action = update.action;</span><br><span class=\"line\">          <span class=\"comment\">// 此时的reducer是basicStateReducer，直接返回action的值</span></span><br><span class=\"line\">          <span class=\"comment\">// 注意，这里是等于号所以</span></span><br><span class=\"line\">          <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">          *</span></span><br><span class=\"line\"><span class=\"comment\">          * setObj(&#123; a: 1, b: 1, c: 1 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t* setObj(&#123; a: 2, b: 2 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t* setObj(&#123; a: 3 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t*</span></span><br><span class=\"line\"><span class=\"comment\">        \t* 到最后也只有只有&#123; a: 3 &#125;，而b和c全没了</span></span><br><span class=\"line\"><span class=\"comment\">          *</span></span><br><span class=\"line\"><span class=\"comment\">          **/</span></span><br><span class=\"line\">          newState = reducer(newState, action);</span><br><span class=\"line\">          update = update.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (update !== <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 对 更新hook.memoized </span></span><br><span class=\"line\">        hook.memoizedState = newState;</span><br><span class=\"line\">        <span class=\"comment\">// 返回新的 state，及更新 hook 的 dispatch 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [newState, dispatch];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"useEffect-useLayoutEffect\"><a href=\"#useEffect-useLayoutEffect\" class=\"headerlink\" title=\"useEffect/useLayoutEffect\"></a>useEffect/useLayoutEffect</h2><h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><p>在学习useEffect这个Hook的时候，淡化你知道的“生命周期”这个概念。</p>\n<h4 id=\"useEffect和useLayoutEffect两兄弟的区别是什么？\"><a href=\"#useEffect和useLayoutEffect两兄弟的区别是什么？\" class=\"headerlink\" title=\"useEffect和useLayoutEffect两兄弟的区别是什么？\"></a>useEffect和useLayoutEffect两兄弟的区别是什么？</h4><p>执行的时机不同</p>\n<p>那么具体哪里不同呢？</p>\n<p>其实在初始化useEffect和useLayoutEffect是没有区别的，他们真正的区别在于初始化之后；</p>\n<p>举个非常形象的例子🌰：</p>\n<p>除了初始化之后的一轮更新：</p>\n<blockquote>\n<p>浏览器：我要绘制了！</p>\n<p>React：等等，我有一个哥们临时有事要处理，他是：useLayoutEffect</p>\n<p>useLayoutEffect执行….</p>\n<p>React：好了，你可以开始绘制了～@浏览器</p>\n<p>浏览器：好的</p>\n<p>浏览器更新UI…</p>\n<p>浏览器：我更新好了。你有什么事要做的吗？@React</p>\n<p>React：有的，useEffect你上</p>\n<p>useEffect执行….</p>\n</blockquote>\n<p>可能有点废话了。其实区别就是</p>\n<blockquote>\n<p>useLayoutEffect()</p>\n<p>浏览器绘制</p>\n<p>useEffect()</p>\n</blockquote>\n<p>这样其实大家也能很直接的看到弊端了。那就是useLayoutEffect如果有大量的计算的话，那样可能会阻塞UI更新，或者说UI渲染。所以还是要谨慎使用。</p>\n<p>一般来说他们没有什么太大的区别的，如果真的要使用useLayoutEffect的话要谨慎一些。不然可能会导致UI渲染阻塞之类的问题。</p>\n<p>但是，也不是没有使用场景。</p>\n<p>比如下面的这个代码就很需要useLayoutEffect</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  useLayoutEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> randomNum = <span class=\"number\">10</span> + <span class=\"built_in\">Math</span>.random()*<span class=\"number\">200</span></span><br><span class=\"line\">      setCount(<span class=\"number\">10</span> + <span class=\"built_in\">Math</span>.random()*<span class=\"number\">200</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [count]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;() =&gt; setCount(<span class=\"number\">0</span>)&#125;&gt;&#123;count&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/   我是分割线</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const [count, setCount] = useState(0);</span></span><br><span class=\"line\"><span class=\"regexp\">  </span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    if (count === 0) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      const randomNum = 10 + Math.random()*200</span></span><br><span class=\"line\"><span class=\"regexp\">      setCount(10 + Math.random()*200);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;, [count]);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div onClick=&#123;() =&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实明白的同学一下就看出来了，如果使用useEffect的话会出现闪烁，会先回到0然后再更新新的随机数。而反观useLayoutEffect则不会，他会很自然的过渡。</p>\n<p>总结：</p>\n<p>useLayoutEffect的使用场景为：有一个中间状态希望隐藏的时候再使用。</p>\n<p>大部分情况下useEffect可以适用于99%的场景。</p>\n<h4 id=\"useEffect的错误事例。看看有没有你\"><a href=\"#useEffect的错误事例。看看有没有你\" class=\"headerlink\" title=\"useEffect的错误事例。看看有没有你\"></a>useEffect的错误事例。看看有没有你</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Imagine this function is also long</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Imagine this function is also long</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> axios(getFetchUrl());</span><br><span class=\"line\">    setData(result.data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么错了？\"><a href=\"#为什么错了？\" class=\"headerlink\" title=\"为什么错了？\"></a>为什么错了？</h4><p>不难看出上面代码的意思是。想要模仿componentDidMount的生命周期，在页面或者组件加载之后发送一个请求。咋一看好像没有什么问题（实际在运行的过程中也没有什么问题，在写这篇文章之前我也是这么做的。）</p>\n<p>但是大家可以想象一下，如果这个函数组件，是现在的5倍大，这个didMount里面调用的请求，未来依赖的东西你都可以100%的察觉到吗？</p>\n<p>我觉得难！难免会有疏忽。到时候可能就会出现state或者props读取错误的情况。因为每一次render的state和props都是独立的。</p>\n<p>那么，该如何解决呢？</p>\n<p>有一个很土的办法，直接把函数扔到useEffect里面去</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// We moved these functions inside!    </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query=react'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> axios(getFetchUrl());</span><br><span class=\"line\">      setData(result.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那高级点的办法呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity when its own deps are the same</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\">(<span class=\"params\">query</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class=\"line\">  &#125;, []);  <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">'react'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将函数用useCallback包裹，这样的话我们只需要做useEffect的依赖里面写上我们的函数，然后在useCallback里面写上我们的依赖。</p>\n<h4 id=\"我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\"><a href=\"#我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\" class=\"headerlink\" title=\"我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\"></a>我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevCountRef = useRef();</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    prevCountRef.current = count;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevCount = prevCountRef.current;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实很好理解，如果看了前面useEffect和useLayoutEffect区别的同学一下就可以知道这个的实现原理。</p>\n<p>首先，在一切都更新之后，然后会会执行useEffect内部的回调函数，将prevCount给赋值，由于没有触发渲染，所以只是单纯的赋值。这样就看起来prevCount的值永远都慢一步。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实在学习useEffect的时候。应该忘记你对React的一些知识。比如生命周期，在函数组件里面没有生命周期这个概念了。</p>\n<p>每一次的render他都有自己的state和props。state和props更应该被看作一个常量，哪怕是const bar = xx这样的常量。这样理解起来useEffect这个副作用其实会更加顺畅，也不容易进入他的“陷阱”</p>\n<h2 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>为什么我把useRef单独拎出来说，不把他和<code>useImperativeHandle</code>放在一起讲，因为</p>\n<blockquote>\n<p>（官网原话）它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>\n</blockquote>\n<p>记住<code>useRef</code>不单单用于获取<code>DOM节点和组件实例</code>，还有一个巧妙的用法就是<code>作为容器保留可变变量</code>，可以这样说：<code>无法自如地使用useRef会让你失去hook将近一半的能力</code></p>\n<h4 id=\"useRef-与-createRef-的区别\"><a href=\"#useRef-与-createRef-的区别\" class=\"headerlink\" title=\"useRef 与 createRef 的区别\"></a>useRef 与 createRef 的区别</h4><p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>\n<p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>\n<p>第一句话是显然的，因为 Hooks 不能用在 ClassComponent。</p>\n<p>第二句话的原因是，<code>createRef</code> 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 错误用法，永远也拿不到 ref</span><br><span class=\"line\">  const valueRef &#x3D; React.createRef();</span><br><span class=\"line\">  return &lt;div ref&#x3D;&#123;valueRef&#125; &#x2F;&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>上述 <code>valueRef</code> 会随着 App 函数的 Render 而重复初始化，<strong>这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变</strong>。</p>\n<p>为什么 <code>createRef</code> 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 <code>componentDidMount</code> 等初始化时机仅执行一次。</p>\n<h4 id=\"如何解决每次render带来类闭包问题？\"><a href=\"#如何解决每次render带来类闭包问题？\" class=\"headerlink\" title=\"如何解决每次render带来类闭包问题？\"></a>如何解决每次render带来类闭包问题？</h4><p>首先，题目怎么理解？<a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">题目</a></p>\n<p>如果我们希望他alert的时候可以获取到最新的值的话，可以使用useRef来解决</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState&lt;number&gt;(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> countRef = useRef&lt;number&gt;(count)</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    countRef.current = count</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleCount = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'current count: '</span> + countRef.current)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Counter</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"memo\"><a href=\"#memo\" class=\"headerlink\" title=\"memo\"></a>memo</h2><h4 id=\"memo没有回调函数的话是怎么浅比较的？\"><a href=\"#memo没有回调函数的话是怎么浅比较的？\" class=\"headerlink\" title=\"memo没有回调函数的话是怎么浅比较的？\"></a>memo没有回调函数的话是怎么浅比较的？</h4><p>先来看看memo没有回调函数的时候他做了什么。</p>\n<p>memo它是一个高阶组件（HOC）他与React.PureComponent十分相似。除了使用的地方不同（Class组件和Function组件）之外几乎一致。</p>\n<p>Memo内部和PureComponent一样使用Object.is用于前对比，如果传入的props内存地址不变的话，那就不会渲染了（或者说复用最近的一次渲染）。</p>\n<p>下面可以看源码事例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateMemoComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  current: Fiber | null,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  workInProgress: Fiber,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  Component: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  nextProps: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  updateExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">null</span> | <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* ...省略...*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断更新的过期时间是否小于渲染的过期时间</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prevProps = currentChild.memoizedProps;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果自定义了compare函数，则采用自定义的compare函数，否则采用官方的shallowEqual(浅比较)函数。（下面有解析）</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> compare = Component.compare;</span><br><span class=\"line\">    compare = compare !== <span class=\"literal\">null</span> ? compare : shallowEqual;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 判断当前 props 与 nextProps 是否相等；</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 判断即将渲染组件的引用是否与workInProgress Fiber中的引用是否一致；</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 只有两者都为真，才会退出渲染。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果都为真，则退出渲染</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class=\"line\">        current,</span><br><span class=\"line\">        workInProgress,</span><br><span class=\"line\">        renderExpirationTime,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* ...省略...*/</span></span><br></pre></td></tr></table></figure>\n\n<p>shallowEqual（浅比较）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用原型链的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasOwn = <span class=\"built_in\">Object</span>.prototype.hasOwnProperty</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个函数实际上是Object.is()的polyfill</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x !== <span class=\"number\">0</span> || y !== <span class=\"number\">0</span> || <span class=\"number\">1</span> / x === <span class=\"number\">1</span> / y</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x !== x &amp;&amp; y !== y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA, objB</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 首先对基本数据类型的比较</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is(objA, objB)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等</span></span><br><span class=\"line\">  <span class=\"comment\">// 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span></span><br><span class=\"line\">  <span class=\"comment\">// 之后，就可以返回false了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> objA !== <span class=\"string\">'object'</span> || objA === <span class=\"literal\">null</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> objB !== <span class=\"string\">'object'</span> || objB === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 过滤掉基本数据类型之后，就是对对象的比较了</span></span><br><span class=\"line\">  <span class=\"comment\">// 首先拿出key值，对key的长度进行对比</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 长度不等直接返回false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// key相等的情况下，在去循环比较</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// key值相等的时候</span></span><br><span class=\"line\">  <span class=\"comment\">// 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性的顺序不影响结果也就是&#123;name:'daisy', age:'24'&#125; 跟&#123;age:'24'，name:'daisy' &#125;是一样的</span></span><br><span class=\"line\">  <span class=\"comment\">// 最后，对对象的value进行一个基本数据类型的比较，返回结果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn.call(objB, keysA[i]) ||</span><br><span class=\"line\">        !is(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> truea</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由源码可以知道，加入没有传一个比较的回调函数会使用官方的浅比较。具体的可以看注释</p>\n<h4 id=\"memo的回调函数\"><a href=\"#memo的回调函数\" class=\"headerlink\" title=\"memo的回调函数\"></a>memo的回调函数</h4><p>我们都知道react的生命周期中有一个shouldComponentUpdate。在这个函数中返回true的话就代表本次render需要执行，而返回false就可以跳过本次的render。</p>\n<p>而memo正好相反，返回true表示本次跳过，返回false就表示本次需要执行render。</p>\n<p>具体怎么用呢？</p>\n<p>大家可以自己运行一下，看看效果。一定要自己试一下，不然很容易和shouldComponentUpdate弄混了。学习还是要自己动手才行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChangeLog</span>(<span class=\"params\">&#123;w = <span class=\"string\">''</span>&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'====render===='</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> memo(ChangeLog, (prevProps, nextProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prevProps.w !== nextProps.w) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useMemo-useCallback\"><a href=\"#useMemo-useCallback\" class=\"headerlink\" title=\"useMemo/useCallback\"></a>useMemo/useCallback</h2><h3 id=\"前言-2\"><a href=\"#前言-2\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之所以把这useMomo/useCallack两兄弟和在一起。是因为他们其实十分相似。</p>\n<blockquote>\n<p>一个是缓存变量（useMemo），一个是缓存函数（useCallback）。</p>\n</blockquote>\n<p>其实这么一说就清晰很多了。</p>\n<p>具体的使用和useEffect一样，都是第一个参数为调用时的回调函数，第二个参数是调用判断所监听的值（可以是变量，也可以是函数）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useMemo(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useCallback(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<p>useMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）</p>\n<p>memoized 值不变的情况下，不会重新触发渲染逻辑。</p>\n<p>说起渲染逻辑，需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作，比如网络请求等。</p>\n<p>如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner</p>\n<p>useCallback也是一样的，这里就不多赘述了。</p>\n<h2 id=\"useReducer-useContext\"><a href=\"#useReducer-useContext\" class=\"headerlink\" title=\"useReducer/useContext\"></a>useReducer/useContext</h2><h3 id=\"前言-3\"><a href=\"#前言-3\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>帮他们两兄弟和在一起说主要说因为他们两兄弟在一般情况下是可以与Redux一战的。</p>\n<p>但是！！</p>\n<p>但是啊，但是如果你需要中间价，或者说需要“时间旅行”，又或者临时需要跨页面级的数据共享，那你还是需要redux来解决的。不过基本上的场景我们使用useReducer和useContext就可以完美的替代redux了。</p>\n<h3 id=\"怎么做？\"><a href=\"#怎么做？\" class=\"headerlink\" title=\"怎么做？\"></a>怎么做？</h3><p>其实之前由于要起一个新项目，但是突然发现有一个爷爷组件的值为需要通知给孙子组件，然后孙子组件可能会用掉回调函数调用爷爷组件的方法。那个时候其实已经用Hook写了一半了，懒得加Redux了，又不想一层层传props下去。怎么办？</p>\n<p>通过了解，我知道了useReducer/useContext刚刚好可以解决我的需求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TodosDispatch = React.createContext(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123; <span class=\"attr\">bar</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'setCenter'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">bar</span>: action.bar &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 虽然这个是自组件，但是哪怕是曾曾曾孙子组件都可以直接用useContext拿到dispatch</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DeepChild</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatch = useContext(TodosDispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'add'</span>, <span class=\"attr\">text</span>: <span class=\"string\">'hello'</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123;handleClick&#125;&gt;Add todo&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function TodosApp() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class=\"line\"><span class=\"regexp\">  const [state, dispatch] = useReducer(reducer, initialState);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;DeepTree todos=&#123;todos&#125; /</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/TodosDispatch.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useImperativeHandle-forwardRef\"><a href=\"#useImperativeHandle-forwardRef\" class=\"headerlink\" title=\"useImperativeHandle/forwardRef\"></a>useImperativeHandle/forwardRef</h2><p>这里就不多说了，基本上没有什么坑点和疑难点。</p>\n<p>说一下基本用法和ant-design form中的使用</p>\n<h3 id=\"正常使用\"><a href=\"#正常使用\" class=\"headerlink\" title=\"正常使用\"></a>正常使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>\n\n<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code>一起使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyInput</span>(<span class=\"params\">props, ref</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputRef = useRef();</span><br><span class=\"line\">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class=\"line\">    focus: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      inputRef.current.focus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputRef&#125;</span> <span class=\"attr\">...</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>\n\n<p>在本例中，渲染<FancyInput ref={inputRef} />的父组件可以调用 <code>inputRef.current.focus()</code>。</p>\n<h3 id=\"ant-design-form\"><a href=\"#ant-design-form\" class=\"headerlink\" title=\"ant-design form\"></a>ant-design form</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref从第二个参数取，这里都是一致的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Example = <span class=\"function\">(<span class=\"params\">props,ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class=\"line\">    text: bar,</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">        &lt;Form&gt;</span><br><span class=\"line\">    \t\t\t&#123;<span class=\"comment\">//....&#125;</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> memo(Form.create()(forwardRef(Example)));</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Parent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;Example</span><br><span class=\"line\">      \t<span class=\"comment\">// 注意这个不再是传ref了，而是传wrappedComponentRef。因为antd的form他返回的是一个新的对象，这个是他自定义的一个接收ref的值</span></span><br><span class=\"line\">        wrappedComponentRef=&#123;editTemplateRef&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"useDebugValue-自定义Hook\"><a href=\"#useDebugValue-自定义Hook\" class=\"headerlink\" title=\"useDebugValue/自定义Hook\"></a>useDebugValue/自定义Hook</h2><h3 id=\"前言-4\"><a href=\"#前言-4\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>useDebugValue是专门用于服务自定义的Hook的。</p>\n<p>具体看看使用就好</p>\n<p>useDebugValue，目的是能在react的浏览器调试工具上显示你的自定义hooks，或者给hooks标记一些东西<br>当使用一个参数的时候，就是把第一个参数标记在react的调试工具上,下面写一个简单的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useDebugValue, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> useTest = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [str, setStr] = useState&lt;string&gt;(<span class=\"string\">''</span>);</span><br><span class=\"line\">    useDebugValue(<span class=\"string\">'debug'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        str, setStr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (): JSX.Element =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;h2&gt;&#123;str&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                setStr('重新渲染');</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/20190818212347571.png\"  alt=\"\"></p>\n<p>会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用</p>\n<p>当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useDebugValue, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> useTest = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [str, setStr] = useState&lt;string&gt;(<span class=\"string\">''</span>);</span><br><span class=\"line\">    useDebugValue(str, (value:string) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'这是改造后的'</span> + value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        str, setStr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (): JSX.Element =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;h2&gt;&#123;str&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                setStr('重新渲染');</span></span><br><span class=\"line\"><span class=\"regexp\">           &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class=\"line\">       &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/2019081821194714.png\"  alt=\"\"></p>\n<p>同时在控制台上打印了一个空字符</p>\n<p>由于str的初始值是空的，所以打印就是空的了，这只是调试使用，hooks差不多就这些了，没有其他的了</p>\n<h2 id=\"观看之后\"><a href=\"#观看之后\" class=\"headerlink\" title=\"观看之后\"></a>观看之后</h2><p>如果有哪里写的不对或者有疑问的欢迎大家在评论区互动。🙏</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li>读这篇文章的前提是你已经对React Hook有所了解的情况下，如果你还没有了解，请先移步官网学习一下。<ol>\n<li>最好不要去网上看别人的总结之类的，无非就是超的官网的，而且这样会让你的认知从一开始就走偏。</li>\n</ol>\n</li>\n<li>这篇文章主要是探究Hook的动机，使用中的一些疑问；<ol>\n<li>使用的话React官网已经讲得很详细了，这里就不多赘述了。</li>\n</ol>\n</li>\n<li>有需要看接下来的疑难点的伙伴欢迎直接跳过探究直接看具体的疑问；</li>\n</ol>\n<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究\"></a>探究</h2><p>主要从3个方面研究React Hook</p>\n<p>根据黄金思维圈（What、How、Why）</p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>什么是Hook？</p>\n<p>打开Google翻译，得到的解释：<em>钩、钩子</em></p>\n<blockquote>\n<p>再看看React官网的解释：They let you use state and other React features without writing a class.（它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。）</p>\n</blockquote>\n<p>所以，结合一下。我个人的理解是这样的：对于函数式的组件，可以用钩子（Hook）将想要的外部功能给“钩”进来。</p>\n<p>在React Hook出来之前，函数式组件都是无状态的组件，最多就是根据<code>props</code>来加一些判断的逻辑；而在React Hook出来之后就可以在函数式组件里面加入状态（useState），类生命周期（useEffect），甚至是一些自己的复用逻辑（自定义Hook）等等这些外部的功能。</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>怎么使用Hook？</p>\n<p>大家一起看一下官网的一个例子。</p>\n<p>题目：显示一个计数器。当你点击按钮，计数器的值就会增加。</p>\n<h4 id=\"Class组件\"><a href=\"#Class组件\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          Click me</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"React-Hook\"><a href=\"#React-Hook\" class=\"headerlink\" title=\"React Hook\"></a>React Hook</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个叫 \"count\" 的 state 变量  const [count, setCount] = useState(0);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样就算是完成了一个最简单的React Hook 实践，关于一些官方提供的Hook晚点会介绍。</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><ul>\n<li>为什么会有Hooks？</li>\n<li>Hook能解决什么问题？</li>\n</ul>\n<p>做任何一件事情我觉得都应该理清这个两个问题，这样的话就会事半功倍。</p>\n<p>我们先看看React官方是怎么解释“Why”的</p>\n<blockquote>\n<ol>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class</li>\n</ol>\n</blockquote>\n<p>本人个人认为第三点是来凑数的….</p>\n<p>为什么这么说？</p>\n<p>因为React用了这么久了基本都是在使用Class组件，这个是在之前，哪怕是现在学习React的必经之路吧！所以，这点我接下来就会跳过了😂</p>\n<h3 id=\"在组件之间服用状态逻辑很难\"><a href=\"#在组件之间服用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间服用状态逻辑很难\"></a>在组件之间服用状态逻辑很难</h3><p>其实高阶组件或者说是props都是很好的解决了复杂的聚合业务逻辑，那为什么说在<strong>组件之间服用状态逻辑很难</strong>呢？</p>\n<p>其实道理非常简单。</p>\n<p>举个简单的例子，方便大家理解。</p>\n<p>场景：有 请求A，请求B，请求C，请求D。他们的请求都有相互依赖关系比如，发请求B的时候必须拿到请求A的结果中的某个值，而请求C也必须拿到请求B的结果中的某个值。以此类推请求D。</p>\n<p>Promise出来之前是怎么做的呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//成功回调</span></span><br><span class=\"line\">        <span class=\"comment\">//再次异步请求</span></span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">            url:<span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">            success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//成功回调</span></span><br><span class=\"line\">              <span class=\"comment\">//再次异步请求</span></span><br><span class=\"line\">              $.ajax(&#123;</span><br><span class=\"line\">                  type:<span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">                  url:<span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">                  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                      .......<span class=\"comment\">//如此循环</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这还只是3层，如果是100层呢？那看起来就非常的难受了！</p>\n<p>Promise较好的解决了这个问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(f1)</span><br><span class=\"line\"> .then(f2)</span><br><span class=\"line\"> .then(f3)</span><br><span class=\"line\"> .then(f4)</span><br><span class=\"line\"> .then(f5)</span><br><span class=\"line\"> .then(f5)</span><br><span class=\"line\">…………</span><br></pre></td></tr></table></figure>\n\n<p>然后是async/await。这里就不展开了，有兴趣的可以自己去了解一下。</p>\n<p>结论</p>\n<p>之所以这么大费周章的讲是为了解释，React中的高阶组件（HOC）。他的逻辑其实和回调地狱类似，一个两个其实都还算优雅或者说舒服，一旦多了的话。。。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withHover(</span><br><span class=\"line\">  withTheme(</span><br><span class=\"line\">    withAuth(</span><br><span class=\"line\">      withRepos(Profile)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 就会变成这样，不够优雅</span></span><br><span class=\"line\">&lt;WithHover&gt;</span><br><span class=\"line\">  &lt;WithTheme hovering=&#123;<span class=\"literal\">false</span>&#125;&gt;</span><br><span class=\"line\">    &lt;WithAuth hovering=&#123;<span class=\"literal\">false</span>&#125; theme=<span class=\"string\">'dark'</span>&gt;</span><br><span class=\"line\">      &lt;WithRepos hovering=&#123;<span class=\"literal\">false</span>&#125; theme=<span class=\"string\">'dark'</span> authed=&#123;<span class=\"literal\">true</span>&#125;&gt;</span><br><span class=\"line\">        &lt;Profile </span><br><span class=\"line\">          id=<span class=\"string\">'JavaScript'</span></span><br><span class=\"line\">          loading=&#123;<span class=\"literal\">true</span>&#125; </span><br><span class=\"line\">          repos=&#123;[]&#125;</span><br><span class=\"line\">          authed=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">          theme=<span class=\"string\">'dark'</span></span><br><span class=\"line\">          hovering=&#123;<span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/WithRepos&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>WithAuth&gt;</span><br><span class=\"line\">  &lt;WithTheme&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/WithHover&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而且每个高阶组件的逻辑复用我们可能还要一个个去研读。</p>\n<h3 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a>复杂组件变得难以理解</h3><p>其实，这点非常好理解。举一个非常简单常见的例子大家就会明白了。</p>\n<p>场景：假如我有一个子组件Child，他的功能是这样的：父组建会给一个id，在组件创建的时候获取一下有关信息，在id改变的时候再重新获取。</p>\n<h4 id=\"Class组件-1\"><a href=\"#Class组件-1\" class=\"headerlink\" title=\"Class组件\"></a>Class组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">componentDidUpdate (prevProps) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prevProps.id !== <span class=\"keyword\">this</span>.props.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetch = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">loading</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  fetchInfo(id)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    info,</span><br><span class=\"line\">    loading: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"React-Hook：\"><a href=\"#React-Hook：\" class=\"headerlink\" title=\"React Hook：\"></a>React Hook：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetch = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">loading</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  fetchInfo(id)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    info,</span><br><span class=\"line\">    loading: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">&#125;, [<span class=\"keyword\">this</span>.props.id])</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>简单的说一下他的优点吧。</p>\n<ol>\n<li>复用代码更加简单（需要什么就“钩”进来）</li>\n<li>清爽的代码风格，一目了然。（useState支持数组和对象，可以清晰的定义特殊的字段等等）</li>\n<li>代码量更少（可以看一下我之前的子父组建的例子）</li>\n<li>更愿意去写一些小组件复用（我个人喜欢React就是因为他的组件写起来非常的顺手！ps：没有贬低其他框架的意思。。）</li>\n<li>其实我个人认为React Hook在宣扬一个观念“按需加载”。</li>\n</ol>\n<h2 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>简单的使用在上面的探究-How里面有介绍，更多的在React官网也有介绍。</p>\n<h4 id=\"请回答以下代码的运行结果\"><a href=\"#请回答以下代码的运行结果\" class=\"headerlink\" title=\"请回答以下代码的运行结果\"></a>请回答以下代码的运行结果</h4><p><img src=\"https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class=\"line\">        Show alert</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。</p>\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<p>来自己 <a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">试试吧！</a></p>\n<h4 id=\"答案是\"><a href=\"#答案是\" class=\"headerlink\" title=\"答案是\"></a>答案是</h4><p>3</p>\n<p>这是为什么呢？function组建究竟是如果工作的呢？</p>\n<p>我们发现<code>count</code>在每一次函数调用中都是一个常量值。值得强调的是 — <strong>我们的组件函数每次渲染都会被调用，但是每一次调用中<code>count</code>值都是常量，并且它被赋予了当前渲染中的状态值。</strong></p>\n<p>这并不是React特有的，普通的函数也有类似的行为：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = person.name;  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Dan'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br><span class=\"line\"></span><br><span class=\"line\">someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Yuzhi'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br><span class=\"line\"></span><br><span class=\"line\">someone = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Dominic'</span>&#125;;</span><br><span class=\"line\">sayHi(someone);</span><br></pre></td></tr></table></figure>\n\n<p>在 <a href=\"https://codesandbox.io/s/mm6ww11lk8\" target=\"_blank\" rel=\"noopener\">这个例子</a>中, 外层的<code>someone</code>会被赋值很多次（就像在React中，<em>当前</em>的组件状态会改变一样）。<strong>然后，在<code>sayHi</code>函数中，局部常量<code>name</code>会和某次调用中的<code>person</code>关联。</strong>因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的<code>name</code>。</p>\n<p>这就解释了我们的事件处理函数如何捕获了点击时候的<code>count</code>值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的<code>count</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// During first render</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">0</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After a click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After another click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">2</span>; <span class=\"comment\">// Returned by useState()  // ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + count);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以实际上，每一次渲染都有一个“新版本”的<code>handleAlertClick</code>。每一个版本的<code>handleAlertClick</code>“记住” 了它自己的 <code>count</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// During first render</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">0</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 0 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After a click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">1</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 1 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// After another click, our function is called again</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAlertClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'You clicked on: '</span> + <span class=\"number\">2</span>);    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class=\"comment\">// The one with 2 inside  // ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是为什么<a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">在这个demo中</a>中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中<code>counter</code>的状态值。</p>\n<p><strong>在任意一次渲染中，props和state是始终保持不变的。</strong>如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>\n<h4 id=\"请回答以下代码的运行结果-1\"><a href=\"#请回答以下代码的运行结果-1\" class=\"headerlink\" title=\"请回答以下代码的运行结果\"></a>请回答以下代码的运行结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> addCount = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">2</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">3</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">4</span>)</span><br><span class=\"line\">    setCount(count+<span class=\"number\">5</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;addCount&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>分割线</p>\n</blockquote>\n<h4 id=\"答案是-1\"><a href=\"#答案是-1\" class=\"headerlink\" title=\"答案是\"></a>答案是</h4><p>5</p>\n<p>为什么呢？</p>\n<p>useState的更新究竟是如何工作的呢？</p>\n<p>我们进入<code>ReactHooks.js</code>来看看，发现<code>useState</code>的实现竟然异常简单，只有短短两行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactHooks.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useState</span>&lt;<span class=\"title\">S</span>&gt;(<span class=\"params\">initialState: ((</span>) =&gt; <span class=\"title\">S</span>) | <span class=\"title\">S</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatcher = resolveDispatcher();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatcher.useState(initialState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实可以这样理解useState，useState其实就是useReducer的一个语法糖；但是这个不在这个问题的讨论范围内；</p>\n<p>好，收回来。</p>\n<p>其实我们在<code>const [xx, setXx] = useState(xx)</code>的时候就生成一个队列，我们暂时叫它为queue；所有这一轮运行读取到的state都被放到一个链表的队列里面去，然后再用do-while循环，每次都是拿到最新的值，但是不是Object.assgin的形式，而是直接赋值。话不多说直接源码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateReducer</span>(<span class=\"params\">reducer, initialArg, init</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 获取初始化时的 hook</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = updateWorkInProgressHook();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = hook.queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始渲染更新</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numberOfReRenders &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dispatch = queue.dispatch;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (renderPhaseUpdates !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取Hook对象上的 queue，内部存有本次更新的一系列数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstRenderPhaseUpdate !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        renderPhaseUpdates.delete(queue);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newState = hook.memoizedState;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> update = firstRenderPhaseUpdate;</span><br><span class=\"line\">        <span class=\"comment\">// 获取更新后的state</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> action = update.action;</span><br><span class=\"line\">          <span class=\"comment\">// 此时的reducer是basicStateReducer，直接返回action的值</span></span><br><span class=\"line\">          <span class=\"comment\">// 注意，这里是等于号所以</span></span><br><span class=\"line\">          <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">          *</span></span><br><span class=\"line\"><span class=\"comment\">          * setObj(&#123; a: 1, b: 1, c: 1 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t* setObj(&#123; a: 2, b: 2 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t* setObj(&#123; a: 3 &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">        \t*</span></span><br><span class=\"line\"><span class=\"comment\">        \t* 到最后也只有只有&#123; a: 3 &#125;，而b和c全没了</span></span><br><span class=\"line\"><span class=\"comment\">          *</span></span><br><span class=\"line\"><span class=\"comment\">          **/</span></span><br><span class=\"line\">          newState = reducer(newState, action);</span><br><span class=\"line\">          update = update.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (update !== <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 对 更新hook.memoized </span></span><br><span class=\"line\">        hook.memoizedState = newState;</span><br><span class=\"line\">        <span class=\"comment\">// 返回新的 state，及更新 hook 的 dispatch 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [newState, dispatch];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"useEffect-useLayoutEffect\"><a href=\"#useEffect-useLayoutEffect\" class=\"headerlink\" title=\"useEffect/useLayoutEffect\"></a>useEffect/useLayoutEffect</h2><h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><p>在学习useEffect这个Hook的时候，淡化你知道的“生命周期”这个概念。</p>\n<h4 id=\"useEffect和useLayoutEffect两兄弟的区别是什么？\"><a href=\"#useEffect和useLayoutEffect两兄弟的区别是什么？\" class=\"headerlink\" title=\"useEffect和useLayoutEffect两兄弟的区别是什么？\"></a>useEffect和useLayoutEffect两兄弟的区别是什么？</h4><p>执行的时机不同</p>\n<p>那么具体哪里不同呢？</p>\n<p>其实在初始化useEffect和useLayoutEffect是没有区别的，他们真正的区别在于初始化之后；</p>\n<p>举个非常形象的例子🌰：</p>\n<p>除了初始化之后的一轮更新：</p>\n<blockquote>\n<p>浏览器：我要绘制了！</p>\n<p>React：等等，我有一个哥们临时有事要处理，他是：useLayoutEffect</p>\n<p>useLayoutEffect执行….</p>\n<p>React：好了，你可以开始绘制了～@浏览器</p>\n<p>浏览器：好的</p>\n<p>浏览器更新UI…</p>\n<p>浏览器：我更新好了。你有什么事要做的吗？@React</p>\n<p>React：有的，useEffect你上</p>\n<p>useEffect执行….</p>\n</blockquote>\n<p>可能有点废话了。其实区别就是</p>\n<blockquote>\n<p>useLayoutEffect()</p>\n<p>浏览器绘制</p>\n<p>useEffect()</p>\n</blockquote>\n<p>这样其实大家也能很直接的看到弊端了。那就是useLayoutEffect如果有大量的计算的话，那样可能会阻塞UI更新，或者说UI渲染。所以还是要谨慎使用。</p>\n<p>一般来说他们没有什么太大的区别的，如果真的要使用useLayoutEffect的话要谨慎一些。不然可能会导致UI渲染阻塞之类的问题。</p>\n<p>但是，也不是没有使用场景。</p>\n<p>比如下面的这个代码就很需要useLayoutEffect</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  useLayoutEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> randomNum = <span class=\"number\">10</span> + <span class=\"built_in\">Math</span>.random()*<span class=\"number\">200</span></span><br><span class=\"line\">      setCount(<span class=\"number\">10</span> + <span class=\"built_in\">Math</span>.random()*<span class=\"number\">200</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [count]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;() =&gt; setCount(<span class=\"number\">0</span>)&#125;&gt;&#123;count&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/   我是分割线</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const [count, setCount] = useState(0);</span></span><br><span class=\"line\"><span class=\"regexp\">  </span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    if (count === 0) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      const randomNum = 10 + Math.random()*200</span></span><br><span class=\"line\"><span class=\"regexp\">      setCount(10 + Math.random()*200);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;, [count]);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div onClick=&#123;() =&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实明白的同学一下就看出来了，如果使用useEffect的话会出现闪烁，会先回到0然后再更新新的随机数。而反观useLayoutEffect则不会，他会很自然的过渡。</p>\n<p>总结：</p>\n<p>useLayoutEffect的使用场景为：有一个中间状态希望隐藏的时候再使用。</p>\n<p>大部分情况下useEffect可以适用于99%的场景。</p>\n<h4 id=\"useEffect的错误事例。看看有没有你\"><a href=\"#useEffect的错误事例。看看有没有你\" class=\"headerlink\" title=\"useEffect的错误事例。看看有没有你\"></a>useEffect的错误事例。看看有没有你</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Imagine this function is also long</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Imagine this function is also long</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> axios(getFetchUrl());</span><br><span class=\"line\">    setData(result.data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么错了？\"><a href=\"#为什么错了？\" class=\"headerlink\" title=\"为什么错了？\"></a>为什么错了？</h4><p>不难看出上面代码的意思是。想要模仿componentDidMount的生命周期，在页面或者组件加载之后发送一个请求。咋一看好像没有什么问题（实际在运行的过程中也没有什么问题，在写这篇文章之前我也是这么做的。）</p>\n<p>但是大家可以想象一下，如果这个函数组件，是现在的5倍大，这个didMount里面调用的请求，未来依赖的东西你都可以100%的察觉到吗？</p>\n<p>我觉得难！难免会有疏忽。到时候可能就会出现state或者props读取错误的情况。因为每一次render的state和props都是独立的。</p>\n<p>那么，该如何解决呢？</p>\n<p>有一个很土的办法，直接把函数扔到useEffect里面去</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// We moved these functions inside!    </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query=react'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> axios(getFetchUrl());</span><br><span class=\"line\">      setData(result.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那高级点的办法呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity when its own deps are the same</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\">(<span class=\"params\">query</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class=\"line\">  &#125;, []);  <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">'react'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将函数用useCallback包裹，这样的话我们只需要做useEffect的依赖里面写上我们的函数，然后在useCallback里面写上我们的依赖。</p>\n<h4 id=\"我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\"><a href=\"#我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\" class=\"headerlink\" title=\"我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？\"></a>我们都知道，每一次effect都是全新的state和props，那我要如何获得上一轮更新的state呢？</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevCountRef = useRef();</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    prevCountRef.current = count;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevCount = prevCountRef.current;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实很好理解，如果看了前面useEffect和useLayoutEffect区别的同学一下就可以知道这个的实现原理。</p>\n<p>首先，在一切都更新之后，然后会会执行useEffect内部的回调函数，将prevCount给赋值，由于没有触发渲染，所以只是单纯的赋值。这样就看起来prevCount的值永远都慢一步。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实在学习useEffect的时候。应该忘记你对React的一些知识。比如生命周期，在函数组件里面没有生命周期这个概念了。</p>\n<p>每一次的render他都有自己的state和props。state和props更应该被看作一个常量，哪怕是const bar = xx这样的常量。这样理解起来useEffect这个副作用其实会更加顺畅，也不容易进入他的“陷阱”</p>\n<h2 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>为什么我把useRef单独拎出来说，不把他和<code>useImperativeHandle</code>放在一起讲，因为</p>\n<blockquote>\n<p>（官网原话）它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>\n</blockquote>\n<p>记住<code>useRef</code>不单单用于获取<code>DOM节点和组件实例</code>，还有一个巧妙的用法就是<code>作为容器保留可变变量</code>，可以这样说：<code>无法自如地使用useRef会让你失去hook将近一半的能力</code></p>\n<h4 id=\"useRef-与-createRef-的区别\"><a href=\"#useRef-与-createRef-的区别\" class=\"headerlink\" title=\"useRef 与 createRef 的区别\"></a>useRef 与 createRef 的区别</h4><p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>\n<p><code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>\n<p>第一句话是显然的，因为 Hooks 不能用在 ClassComponent。</p>\n<p>第二句话的原因是，<code>createRef</code> 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 错误用法，永远也拿不到 ref</span><br><span class=\"line\">  const valueRef &#x3D; React.createRef();</span><br><span class=\"line\">  return &lt;div ref&#x3D;&#123;valueRef&#125; &#x2F;&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>上述 <code>valueRef</code> 会随着 App 函数的 Render 而重复初始化，<strong>这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变</strong>。</p>\n<p>为什么 <code>createRef</code> 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 <code>componentDidMount</code> 等初始化时机仅执行一次。</p>\n<h4 id=\"如何解决每次render带来类闭包问题？\"><a href=\"#如何解决每次render带来类闭包问题？\" class=\"headerlink\" title=\"如何解决每次render带来类闭包问题？\"></a>如何解决每次render带来类闭包问题？</h4><p>首先，题目怎么理解？<a href=\"https://codesandbox.io/s/w2wxl3yo0l\" target=\"_blank\" rel=\"noopener\">题目</a></p>\n<p>如果我们希望他alert的时候可以获取到最新的值的话，可以使用useRef来解决</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState&lt;number&gt;(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> countRef = useRef&lt;number&gt;(count)</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    countRef.current = count</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleCount = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'current count: '</span> + countRef.current)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Counter</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"memo\"><a href=\"#memo\" class=\"headerlink\" title=\"memo\"></a>memo</h2><h4 id=\"memo没有回调函数的话是怎么浅比较的？\"><a href=\"#memo没有回调函数的话是怎么浅比较的？\" class=\"headerlink\" title=\"memo没有回调函数的话是怎么浅比较的？\"></a>memo没有回调函数的话是怎么浅比较的？</h4><p>先来看看memo没有回调函数的时候他做了什么。</p>\n<p>memo它是一个高阶组件（HOC）他与React.PureComponent十分相似。除了使用的地方不同（Class组件和Function组件）之外几乎一致。</p>\n<p>Memo内部和PureComponent一样使用Object.is用于前对比，如果传入的props内存地址不变的话，那就不会渲染了（或者说复用最近的一次渲染）。</p>\n<p>下面可以看源码事例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateMemoComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  current: Fiber | null,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  workInProgress: Fiber,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  Component: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  nextProps: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  updateExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">null</span> | <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* ...省略...*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断更新的过期时间是否小于渲染的过期时间</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prevProps = currentChild.memoizedProps;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果自定义了compare函数，则采用自定义的compare函数，否则采用官方的shallowEqual(浅比较)函数。（下面有解析）</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> compare = Component.compare;</span><br><span class=\"line\">    compare = compare !== <span class=\"literal\">null</span> ? compare : shallowEqual;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 判断当前 props 与 nextProps 是否相等；</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 判断即将渲染组件的引用是否与workInProgress Fiber中的引用是否一致；</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 只有两者都为真，才会退出渲染。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果都为真，则退出渲染</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class=\"line\">        current,</span><br><span class=\"line\">        workInProgress,</span><br><span class=\"line\">        renderExpirationTime,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* ...省略...*/</span></span><br></pre></td></tr></table></figure>\n\n<p>shallowEqual（浅比较）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用原型链的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasOwn = <span class=\"built_in\">Object</span>.prototype.hasOwnProperty</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个函数实际上是Object.is()的polyfill</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x !== <span class=\"number\">0</span> || y !== <span class=\"number\">0</span> || <span class=\"number\">1</span> / x === <span class=\"number\">1</span> / y</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x !== x &amp;&amp; y !== y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA, objB</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 首先对基本数据类型的比较</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is(objA, objB)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等</span></span><br><span class=\"line\">  <span class=\"comment\">// 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span></span><br><span class=\"line\">  <span class=\"comment\">// 之后，就可以返回false了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> objA !== <span class=\"string\">'object'</span> || objA === <span class=\"literal\">null</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> objB !== <span class=\"string\">'object'</span> || objB === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 过滤掉基本数据类型之后，就是对对象的比较了</span></span><br><span class=\"line\">  <span class=\"comment\">// 首先拿出key值，对key的长度进行对比</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 长度不等直接返回false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// key相等的情况下，在去循环比较</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// key值相等的时候</span></span><br><span class=\"line\">  <span class=\"comment\">// 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性的顺序不影响结果也就是&#123;name:'daisy', age:'24'&#125; 跟&#123;age:'24'，name:'daisy' &#125;是一样的</span></span><br><span class=\"line\">  <span class=\"comment\">// 最后，对对象的value进行一个基本数据类型的比较，返回结果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn.call(objB, keysA[i]) ||</span><br><span class=\"line\">        !is(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> truea</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由源码可以知道，加入没有传一个比较的回调函数会使用官方的浅比较。具体的可以看注释</p>\n<h4 id=\"memo的回调函数\"><a href=\"#memo的回调函数\" class=\"headerlink\" title=\"memo的回调函数\"></a>memo的回调函数</h4><p>我们都知道react的生命周期中有一个shouldComponentUpdate。在这个函数中返回true的话就代表本次render需要执行，而返回false就可以跳过本次的render。</p>\n<p>而memo正好相反，返回true表示本次跳过，返回false就表示本次需要执行render。</p>\n<p>具体怎么用呢？</p>\n<p>大家可以自己运行一下，看看效果。一定要自己试一下，不然很容易和shouldComponentUpdate弄混了。学习还是要自己动手才行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChangeLog</span>(<span class=\"params\">&#123;w = <span class=\"string\">''</span>&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'====render===='</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> memo(ChangeLog, (prevProps, nextProps) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prevProps.w !== nextProps.w) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useMemo-useCallback\"><a href=\"#useMemo-useCallback\" class=\"headerlink\" title=\"useMemo/useCallback\"></a>useMemo/useCallback</h2><h3 id=\"前言-2\"><a href=\"#前言-2\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之所以把这useMomo/useCallack两兄弟和在一起。是因为他们其实十分相似。</p>\n<blockquote>\n<p>一个是缓存变量（useMemo），一个是缓存函数（useCallback）。</p>\n</blockquote>\n<p>其实这么一说就清晰很多了。</p>\n<p>具体的使用和useEffect一样，都是第一个参数为调用时的回调函数，第二个参数是调用判断所监听的值（可以是变量，也可以是函数）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useMemo(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useCallback(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<p>useMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）</p>\n<p>memoized 值不变的情况下，不会重新触发渲染逻辑。</p>\n<p>说起渲染逻辑，需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作，比如网络请求等。</p>\n<p>如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner</p>\n<p>useCallback也是一样的，这里就不多赘述了。</p>\n<h2 id=\"useReducer-useContext\"><a href=\"#useReducer-useContext\" class=\"headerlink\" title=\"useReducer/useContext\"></a>useReducer/useContext</h2><h3 id=\"前言-3\"><a href=\"#前言-3\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>帮他们两兄弟和在一起说主要说因为他们两兄弟在一般情况下是可以与Redux一战的。</p>\n<p>但是！！</p>\n<p>但是啊，但是如果你需要中间价，或者说需要“时间旅行”，又或者临时需要跨页面级的数据共享，那你还是需要redux来解决的。不过基本上的场景我们使用useReducer和useContext就可以完美的替代redux了。</p>\n<h3 id=\"怎么做？\"><a href=\"#怎么做？\" class=\"headerlink\" title=\"怎么做？\"></a>怎么做？</h3><p>其实之前由于要起一个新项目，但是突然发现有一个爷爷组件的值为需要通知给孙子组件，然后孙子组件可能会用掉回调函数调用爷爷组件的方法。那个时候其实已经用Hook写了一半了，懒得加Redux了，又不想一层层传props下去。怎么办？</p>\n<p>通过了解，我知道了useReducer/useContext刚刚好可以解决我的需求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TodosDispatch = React.createContext(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123; <span class=\"attr\">bar</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'setCenter'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">bar</span>: action.bar &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 虽然这个是自组件，但是哪怕是曾曾曾孙子组件都可以直接用useContext拿到dispatch</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DeepChild</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatch = useContext(TodosDispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'add'</span>, <span class=\"attr\">text</span>: <span class=\"string\">'hello'</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123;handleClick&#125;&gt;Add todo&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function TodosApp() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class=\"line\"><span class=\"regexp\">  const [state, dispatch] = useReducer(reducer, initialState);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;DeepTree todos=&#123;todos&#125; /</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/TodosDispatch.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useImperativeHandle-forwardRef\"><a href=\"#useImperativeHandle-forwardRef\" class=\"headerlink\" title=\"useImperativeHandle/forwardRef\"></a>useImperativeHandle/forwardRef</h2><p>这里就不多说了，基本上没有什么坑点和疑难点。</p>\n<p>说一下基本用法和ant-design form中的使用</p>\n<h3 id=\"正常使用\"><a href=\"#正常使用\" class=\"headerlink\" title=\"正常使用\"></a>正常使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>\n\n<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code>一起使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyInput</span>(<span class=\"params\">props, ref</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputRef = useRef();</span><br><span class=\"line\">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class=\"line\">    focus: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      inputRef.current.focus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputRef&#125;</span> <span class=\"attr\">...</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>\n\n<p>在本例中，渲染<FancyInput ref={inputRef} />的父组件可以调用 <code>inputRef.current.focus()</code>。</p>\n<h3 id=\"ant-design-form\"><a href=\"#ant-design-form\" class=\"headerlink\" title=\"ant-design form\"></a>ant-design form</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref从第二个参数取，这里都是一致的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Example = <span class=\"function\">(<span class=\"params\">props,ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class=\"line\">    text: bar,</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">        &lt;Form&gt;</span><br><span class=\"line\">    \t\t\t&#123;<span class=\"comment\">//....&#125;</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> memo(Form.create()(forwardRef(Example)));</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Parent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;Example</span><br><span class=\"line\">      \t<span class=\"comment\">// 注意这个不再是传ref了，而是传wrappedComponentRef。因为antd的form他返回的是一个新的对象，这个是他自定义的一个接收ref的值</span></span><br><span class=\"line\">        wrappedComponentRef=&#123;editTemplateRef&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"useDebugValue-自定义Hook\"><a href=\"#useDebugValue-自定义Hook\" class=\"headerlink\" title=\"useDebugValue/自定义Hook\"></a>useDebugValue/自定义Hook</h2><h3 id=\"前言-4\"><a href=\"#前言-4\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>useDebugValue是专门用于服务自定义的Hook的。</p>\n<p>具体看看使用就好</p>\n<p>useDebugValue，目的是能在react的浏览器调试工具上显示你的自定义hooks，或者给hooks标记一些东西<br>当使用一个参数的时候，就是把第一个参数标记在react的调试工具上,下面写一个简单的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useDebugValue, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> useTest = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [str, setStr] = useState&lt;string&gt;(<span class=\"string\">''</span>);</span><br><span class=\"line\">    useDebugValue(<span class=\"string\">'debug'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        str, setStr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (): JSX.Element =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;h2&gt;&#123;str&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                setStr('重新渲染');</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/20190818212347571.png\" alt=\"\"></p>\n<p>会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用</p>\n<p>当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useDebugValue, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> useTest = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [str, setStr] = useState&lt;string&gt;(<span class=\"string\">''</span>);</span><br><span class=\"line\">    useDebugValue(str, (value:string) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'这是改造后的'</span> + value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        str, setStr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (): JSX.Element =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; str, setStr &#125; = useTest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;h2&gt;&#123;str&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                setStr('重新渲染');</span></span><br><span class=\"line\"><span class=\"regexp\">           &#125;&#125;&gt;这是？？？&lt;/</span>button&gt;</span><br><span class=\"line\">       &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<p><img src=\"/image/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ReactHook%E5%90%97/2019081821194714.png\" alt=\"\"></p>\n<p>同时在控制台上打印了一个空字符</p>\n<p>由于str的初始值是空的，所以打印就是空的了，这只是调试使用，hooks差不多就这些了，没有其他的了</p>\n<h2 id=\"观看之后\"><a href=\"#观看之后\" class=\"headerlink\" title=\"观看之后\"></a>观看之后</h2><p>如果有哪里写的不对或者有疑问的欢迎大家在评论区互动。🙏</p>\n"},{"title":"从零配置你的Webpack","date":"2020-06-06T22:11:13.000Z","cover":"/image/cover/webpack.png","_content":"\n# 从零配置你的Webpack\n\n## 前言\n\n上篇文章简单的介绍了一下，前端进阶之脚手架的搭建。其实我个人认为重要的还是Webpack的配置出来的template，至于脚手架的交互体验可以后期去优化，也可以更加的个性化。但是我们的核心还是放在Webpack等一系列的配置上。\n\n这篇文章的目的\n\n- 可以给自己一个回顾的地方\n- 加强对Webpack的理解，每个知识点都会认认真真的彻查！尽量让每一步都是非常清晰明了的！\n- 如果可以帮助到大家那是更好不过了\n\n好了，收！话不多说开始！\n\n\n\n## 前提\n\n相信来到这里的小伙伴，都是有一些些前端的经验了，至于什么node安装环境变量这里就不赘述了。本人使用的是mac os，如果是Windows的并且碰到问题的话，可以留言，或者直接Google。\n\n\n\n## 开始\n\n### 建立一个空的文件夹📁\n\n新建一个文件夹，名为【webpackInit】\n\n并且使用你的编辑器打开他，然后打开命令行执行：\n\n```js\nnpm init -y\n```\n\n这个命令是node帮你初始化一个项目用的，帮你新建一个`package.json`。\n\n至于`-y`是用于默认都以**yes**继续执行。如果想了解一下里面到底有什么的同学可以不用*-y*继续跑一遍。其实里面的东西后期都可以自己修改`package.json`。所以不需要太在意。\n\n### 安装Webpack🔧\n\n现在是北京时间：2020/06/07 06:42:49。\n\nWebpack5有Beta版，这里就不考虑了，后续上正式版的话我应该会出新的文章介绍。\n\n因为我们使用的是 `webpack 4+` 版本，还需要安装 `webpack-cli` ，执行以下命令：\n\n```js\nnpm install --save-dev webpack webpack-cli\n```\n\n因为Webpack主要是编译时使用所以放到“devDependencies”。\n\n确认一下现在的目录结构，以防有同学掉队！\n\n```diff\nwebpackInit\n  |- node_modules\n  |- package-lock.json\n  |- package.json\n```\n\n这里说下题外话。\n\n##### package.json和package-lock.json的区别\n\npackage.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，`npm install` 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。\n\n那如果我们安装时的包有bug，后面需要更新怎么办？\n\n在以前可能就是直接改 package.json 里面的版本，然后再 `npm install` 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 `npm install xxx@x.x.x` 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。\n\n### 新建配置文件📃\n\n我们在根目录新建文件夹【config】用于存储一些相关的配置文件，然后在【config】里面新建一个文件夹【webpack】表示，专门用于存储webpack的配置文件。然后在【webpack】这个文件夹下面新建文件【webpack.common.config.js】\n\n并敲入以下代码\n\n\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  // 配置入口文件\n  entry: {\n    app: './src/index.js',\n  },\n  // 打包📦之后的出口\n  output: {\n    // 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n    /**\n     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，\n     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。\n     * path.resolve\n     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径\n     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz\n     * 3.如果传入的绝对路径不存在，那么当前目录将被使用\n     * 4.当传入的参数没有/时，将被传入解析到当前根目录\n     * 5.零长度的路径将被忽略\n     * 6.如果没有传入参数，将返回当前根目录\n     * \n     * _dirname表示绝对路径\n     * 我们碰到的./xx就是相对路径\n     * 1.只传入__dirname也可以自动调用path.resolve方法\n     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败\n     * 3.__dirname代表的是当前文件（a.js）的绝对路径\n     * 4.从右至左解析，遇到了绝对路径/src，因此直接返\n     */\n    path: path.resolve(__dirname, '../../dist')\n  }\n}\n```\n\n> webpack 配置是标准的 Node.js的CommonJS 模块，它通过require来引入其他模块，通过module.exports导出模块，由 webpack 根据对象定义的属性进行解析。\n\n在根目录新建【src】文件夹📁\n\n在【src】文件夹下新建文件index.js\n\nok👌，确认一下目录结构\n\n```diff\nwebpackInit\n+ |- config\n+ \t|- webpack\n+     |- webpack.common.config.js\n  |- node_modules\n+ |- src\n+     |- index.js\n  |- package.json\n  |- package-lock.json\n```\n\n那我们怎么打包呢？在 `package.json` 中配置如下属性：\n\n```diff\n\"scripts\": {\n- \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n+ \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\"\n},\n\n```\n\n好了，我们试试怎么打包吧，虽然你的 `index.js` 中什么代码也没有。\n在控制台中输入以下代码：\n\n```\nnpm run start\n```\n\nnpm run xxxx 会去执行当前目录下package.json里面的script同名脚本\n\n我们的【npm run start】相当于直接执行了我们写在【start】里面的代码。\n\n执行之后，你会发现根目录多出了一个文件夹： `dist/js` ，其中有一个js文件： `bundle.js` ，那么至此，我们已经成功编译打包了一个js文件，即入口文件： `index.js` 。\n\n### 安装React\n\n在控制台输入以下代码：\n\n```\nnpm install --save react react-dom\n```\n\n--save就是运行时会用到的代码\n\n具体和--dev-save的区别可以自己Google一下\n\n在【src/index.js】里面加入以下代码\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () => (\n  <>\n    Hello World！\n  </>\n)\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n在根目录加入文件夹【public】，然后在【public】里面加入【index.html】\n\n目录如下：\n\n```diff\nwebpackInit\n+ |- public\n+ \t|- index.html\n  |- config\n  \t|- webpack\n      |- webpack.common.config.js\n  |- node_modules\n  |- src\n      |- index.js\n  |- package.json\n  |- package-lock.json\n```\n\n然后在【index.html】加入以下代码：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\">\n    <meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no, width=device-width\">\n  <title>从零配置Webpack</title>\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n```\n\nOK\n\n万事俱备，我们运行：\n\n```\nnpm run start\n```\n\n打包失败了。。。为什么呢？\n\n### 使用babel\n\n为什么我们上面写jsx会打包不了呢，因为webpack根本识别不了jsx语法，那怎么办？使用loader对文件进行预处理。\n其中，babel-loader，就是这样一个预处理插件，它加载 ES2015+ 代码，然后使用 Babel 转译为 ES5。那开始配置它吧！\n\n首先安装babel相关的模块：\n\n```\nnpm install --save-dev babel-loader @babel/preset-react @babel/preset-env @babel/core babel-plugin-import\n```\n\n- **babel-loader：**使用Babel和webpack来转译JavaScript文件。\n- **@babel/preset-react：**转译react的JSX\n- **@babel/preset-env：**转译ES2015+的语法\n- **@babel/core：**babel的核心模块\n- **babel-plugin-import**：按需加载所需要的babel解析\n\n理论上我们可以直接在 `webpack.common.config.js` 中配置\"options\"，但最好在当前根目录，注意，一定要是根目录！！！ 新建一个配置文件 `.babelrc` 配置相关的\"presets\"：\n\n```js\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"targets\": {\n          // 大于相关浏览器版本无需用到 preset-env\n          \"edge\": 17,\n          \"firefox\": 60,\n          \"chrome\": 67,\n          \"safari\": 11,\n          // 兼容到android4 ios6\n          \"browsers\": [\"Android >= 4.0\", \"ios >= 6\"]\n        }\n      }\n    ],\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"antd-mobile\", \"style\": \"css\" }] // `style: true` 会加载 less 文件\n  ]\n}\n```\n\n这里有关[bebel的配置](https://www.babeljs.cn/docs/babel-preset-env)可上官网查询文档。\n\n再修改 `webpack.common.config.js` ，添加如下代码：\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  // 配置入口文件\n  entry: {\n    app: './src/index.js',\n  },\n  // 打包📦之后的出口\n  output: {\n    // 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n    /**\n     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，\n     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。\n     * path.resolve\n     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径\n     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz\n     * 3.如果传入的绝对路径不存在，那么当前目录将被使用\n     * 4.当传入的参数没有/时，将被传入解析到当前根目录\n     * 5.零长度的路径将被忽略\n     * 6.如果没有传入参数，将返回当前根目录\n     * \n     * _dirname表示绝对路径\n     * 我们碰到的./xx就是相对路径\n     * 1.只传入__dirname也可以自动调用path.resolve方法\n     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败\n     * 3.__dirname代表的是当前文件（a.js）的绝对路径\n     * 4.从右至左解析，遇到了绝对路径/src，因此直接返\n     */\n    path: path.resolve(__dirname, '../../dist')\n  },\n  module: {\n    /**\n     * test 规定了作用于以规则中匹配到的后缀结尾的文件， \n     * use 即是使用 babel-loader 必须的属性， \n     * exclude 告诉我们不需要去转译\"node_modules\"这里面的文件。\n     */\n    rules:[\n      {\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n      },\n    ]\n  }\n}\n```\n\n接下来激动人心的时刻：\n\n```\nnpm run start\n```\n\n是不是能打包成功了呢？\n\n打开【dist/】你的html页面，看一下是否是“Hello World！”吧！\n\n### 使用webpack-merge🈴️\n\n我们将使用一个名为 [webpack-merge](https://github.com/survivejs/webpack-merge) 的工具。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。简单来说就是生产环境不同，我们要给的配置也有所不同，但是可以共用一个共有的配置。\n\n我们先从安装 [webpack-merge](https://github.com/survivejs/webpack-merge) 开始：\n\n```\nnpm install --save-dev webpack-merge\n```\n\n安装结束之后，我们在 `config` 这个文件夹下新建两个文件，分别为 `webpack.prod.config.js` 和 `webpack.dev.config.js` ，这两个文件分别对应生产和开发两个环境的配置。当然你也可以添加test环境。名字也可以自己取，尽量保持一致。\n\n\n\n现在的目录结构：\n\n```diff\n  webpackInit\n\t|- config\n\t\t|- webpack\n\t    |- webpack.common.config.js\n+     |- webpack.prod.config.js\n  省略\n```\n\n在【webpack.prod.config.js】加入\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n});\n```\n\n然后修改【package.json】\n\n```diff\n{\n  \"name\": \"webpackInit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",\n+   \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.10.2\",\n    \"@babel/preset-env\": \"^7.10.2\",\n    \"@babel/preset-react\": \"^7.10.1\",\n    \"babel-loader\": \"^8.1.0\",\n    \"babel-plugin-import\": \"^1.13.0\",\n    \"webpack\": \"^4.43.0\",\n    \"webpack-cli\": \"^3.3.11\",\n    \"webpack-merge\": \"^4.2.2\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.13.1\",\n    \"react-dom\": \"^16.13.1\"\n  }\n}\n\n```\n\n然后\n\n删除【dist文件夹】\n\n之后\n\n```\nnpm run build\n```\n\n是不是也build也打包成功了！\n\nhtml是不是也可以正常访问！\n\n但是没有显示Hello World，仔细一看还报错了。。。为什么呢。。因为\n\n```\n// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n```\n\n我们给js文件设置了hash值。不能够直接在html里面加上【<script src=\"../dist/js/bundle.js\"></script>】这么一句，而且每次生成的hash值都会变，那么我们要怎么处理这个问题呢？\n\n\n\n### 使用[HtmlWebpackPlugin](https://www.webpackjs.com/plugins/html-webpack-plugin/)\n\n\n\n安装[HtmlWebpackPlugin](https://www.webpackjs.com/plugins/html-webpack-plugin/)\n\n在控制台执行以下代码：\n\n```\nnpm install --save-dev html-webpack-plugin\n```\n\n修改【webpack.prod.config.js】\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    })\n  ]\n});\n```\n\n\n\n现在我们再来打包试试\n\n```\nnpm run build\n```\n\n看看dist中是不是多出了html文件，并且自动引入了script，用浏览器打开它试试看是不是能正确输出内容了！\n\n起飞！！🛫️\n\n### 使用clean-webpack-plugin\n\n有些同学已经厌倦了每次都需要删除dist文件夹来验证是否成功。\n\n其实假如我们不删除的话，我们需要修改js文件，这样让webpack知道我们改了东西，他就会重新打包，但是我们每次测试都没有去修改，所以我们需要删除。\n\n但是，如果说我们不去删除dist文件夹的话，我们修改了【src/index.js】。然后再重新build，就会发现【dist/js】下面会又多出一个js文件，这样的话我们就需要观察日志，查看新鲜“出炉”的是哪一个，然后删掉别的。这样非常麻烦。\n\nOK，我们现在就来解决一下这个问题\n\n安装clean-webpack-plugin\n\n```\nnpm install --save-dev clean-webpack-plugin\n```\n\n修改【webpck.prod.config.js】\n\n```diff\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n+ const { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    }),\n+   new CleanWebpackPlugin()\n  ]\n});\n```\n\n我们先查看现在的js文件前面的hash值。然后我们修改【src/index.js】，随便改成什么，再重新\n\n```\nnpm run build\n```\n\n就会发现文件并没有新增，而且换了新鲜的哈希值。\n\n当然了，我之前说的那些话，同学不相信的话，可以把【new CleanWebpackPlugin()】这一行注释掉，然后再修改【src/index.js】，会发现【dist/js】下面的js文件会增多一条。\n\n### 使用webpack-dev-server\n\n既然刚刚都提到优化了，我们每次都需要build一下，感觉很呆。而webpack官方也提供热部署，那我们现在就使用起来\n\n安装webpack-dev-server\n\n```\nnpm install webpack-dev-server --save-dev\n```\n\n新建文件【webpack.dev.config.js】📃\n\n```diff\n  webpackInit\n\t|- config\n\t\t|- webpack\n\t    |- webpack.common.config.js\n      |- webpack.prod.config.js\n+     |- webpack.dev.config.js\n  省略\n```\n\n然后加入如下代码\n\n```js\nconst path = require('path');\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  output: {\n    filename: 'js/[name].[hash:8].bundle.js',\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, '../dist'),\n    open: true,\n    port: 9000,\n    compress: true,\n    hot: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: 'public/index.html',\n      inject: 'body',\n      hash: false\n    }),\n    new webpack.HotModuleReplacementPlugin()\n  ]\n});\n```\n\n修改文件【package.json】📃\n\n```diff\n\"scripts\": {\n-   \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",\n+   \"start\": \"webpack-dev-server --inline --config ./config/webpack/webpack.dev.config.js\",\n    \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\",\n  },\n```\n\n然后我们\n\n```\nnpm run start\n```\n\n是不是自动开了一个端口为9000的网页，上面是我们写的页面内容，这和我们的配置都是一一对应的。\n现在你随意修改index.js中的代码，再回到页面看下是不是也跟着变了，那我们就整合webpack-dev-server成功！\n\n### 使用source-map\n\nsource-map可以展示我们代码的错误位置，因为我们的代码都是被webpack打包过的，只有机器看得懂，我们人类无法正常识别。所以需要他。\n\n想试一下未开启是什么状态的同学可以自己故意把代码写错，然后看看控制台的报错。\n\n开启也十分简单。\n\n它的配置非常简单，只需要在 【webpack.dev.config.js】 中增加一个 `devtool` 属性即可！\n\n```diff\nmodule.exports = {\n+  devtool: 'cheap-module-eval-source-map',\n\t//...\n}\n```\n\n因为我们只有自己写代码的时候才需要查看，到生产环境就要关闭啦，不然我们的智慧结晶就要被【窃取】啦！所以我放在了\n\n## 中场休息\n\n这里回顾一下知识点。\n\n1. 我们先npm init 新建一个空白项目。\n2. 然后安装webpack，react。\n3. 发现无法编译jsx。\n4. 所以我们寻求了babel的帮助，并配置了所需要解析的内容。\n5. 觉得在html里面加入js很呆，所以引入了HtmlWebpackPlugin\n6. 因为觉得每次删除打包出来的东西很呆，所以引入了clean-webpack-plugin\n7. 因为每次都需要重新打包，所以使用webpack-dev\n8. 至于webpack-merge是为了打包和编译两个或者说多个状态做预备的，在上述的例子只有本地的dev和build两个环境。\n\n基本上上述的操作过程我都有解释，或者是注释，或者是在文章中说明。大家可以跟着节奏一步一步来，因为我也是一边写blog一边跑代码一边回顾知识点。\n\n至此，webpack算是告一……\n\n诶诶诶诶！js是可以解析了，那css呢！\n\n哦哦，好的，那我们继续启程\n\n## 重新起航\n\n### 使用css-loader和style-loader两兄弟  \n\n假如我们直接引用css的话，会报错了。这里就不演示了，有兴趣的同学可以自己试试。\n\n所以，我们先走命令行敲击\n\n```\nnpm install --save-dev style-loader css-loader \n```\n\n#### 两兄弟的关系\n\n来说说css-loader和style-loader他们这对鸳鸯的关系。\n\n首先css-loader会把你的CSS文件进行解析，因为webpack是用JS写的，运行在node环境，所以默认webpack打包的时候只会处理JS之间的依赖关系！\n\n所以我们之前的react里面的jsx需要babel的帮助，或者说需要【babel-loader】的帮助，所以我们的css同样需要【css-loader】的帮助，那么又关【style-loader】什么事？可不可以不装他呢？\n\n答案是：可以的，但是你使用起来会非常的麻烦。怎么个麻烦法呢？\n\n如果只用了【css-loader】解析出来的是这样的\n\n```\n[\"./src/index.css\", \".test{↵  color: red;↵}\", \"\"]\n```\n\n这样咋用嘛，你是解析了，可是你解析的是个XX。\n\n这个时候就需要我们的天降猛男【style-loader】\n\nstyle-loader 是通过一个JS脚本创建一个style标签，里面包含一些样式。style-loader是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个loader的功能都是单一的，各自拆分独立。\n\n#### 上手！\n\n加入index.css\n\n```diff\nsrc\n+  |- index.css\n   |- indexjs\n```\n\nindex.css文件的内容如下\n\n```css\n.test{\n  color: red;\n}\n```\n\n修改index.js\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'\n\nconst App = () => (\n  <div className=\"test\">\n    Hello World！!\n  </div>\n)\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n修改【webpack.common.config.js】📃\n\n```diff\n//...\nrules:[\n      {\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n      },\n+      {\n+        test: /\\.css$/,\n+        use: [ \n+          'css-loader', \n+          'style-loader',\n+        ]\n+      }\n    ]\n    //....\n```\n\n记得重新运行，因为webpack的配置他读取一次，所以如果你修改了配置，需要【ctrl+c】关闭重新运行。\n\n嘿嘿……是不是运行不了啊。\n\n其实我是故意的，我想告诉大家一个知识点。\n\n> loader的加载顺序是从右往左。这里的编译顺序是先用css-loader将css代码编译，再交给style-loader插入到网页里面去。所以css-loader在右，style-loader在左。\n\n虽然我们的数组换行了，但是仔细看不难看出顺序。\n\n所以我们只需要将他们换个位置就可以了。代码我就不贴了。\n\n现在大家应该记忆很深刻了吧！\n\n大家重新【ctrl+c】关闭重新运行就行了。我们的hello world是不是变红啦～\n\n### 安装less-loader\n\n说到css，说句实在话，没几人真的是在写纯css的吧？现在谁不是less，sass或者其他css预处理呢？而且这些预处理的好处我就不细说了，感兴趣的自己Google吧，本文用的是less（因为ant design用的也是less，哈哈，假装是蚂蚁的一员）\n\n在命令行输入\n\n```\nnpm install --save-dev less less-loader\n```\n\nless没什么好说的，用他肯定要装，less-loader，顾名思义，就是less的解析者。\n\n在【webpack.common.config.js】增加\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n        ]\n      },\n+      {\n+        test: /\\.less$/,\n+        use: [ \n+          'style-loader',\n+          'css-loader', \n+          'less-loader',\n+        ]\n+      }\n```\n\n依旧是顺序问题，先解析less，把less解析成常规的css，然后再解析css，最后插入到网页中去。\n\n修改【index.js】引入自己写的【.less】文件\n\n大家重新【ctrl+c】关闭重新运行就行了。至于你写了什么less特性，只要有效果就行了。\n\n### 安装url-loader和file-loader\n\n说完CSS，美丽的网页当然离不开我们动人的图片啦。\n\n【file-loader】的作用是，把你的文件打包起来，和js文件放在一起，这样用户访问我们的网页的时候，其实也需要访问我们的url，既增加了服务器的压力，也增加了用户升级流量的压力，需要去下载这个文件。\n\n【url-loader】\n\n如果页面图片较多，发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl并将其打包到文件中，最终只需要引入这个dataURL就能访问图片了。\n\nurl-loader和file-loader两兄弟的搭配可以有效的减少不必要的url请求，因为有的图片你要去请求url获取，如果小的话完全可以用base64替代。如果图片很大的话就用file-loader，这样可以减少编码的压力。\n\n在命令行输入\n\n```\nnpm install file-loader url-loader --save-dev\n```\n\n修改【webpack.common.config.js】📃\n\n```diff\nmodule: {\n  rules: [\n    //...\n+    {\n+      test: /\\.(jpg|png|gif)$/,\n+      use: {\n+        loader: 'url-loader',\n+        options: {\n+          name: '[name].[ext]', //输出的文件名\n+          outputPath: 'images/', // 输出到dist目录下的路径（dist/images/）\n\t\t\t\t\t\t/**\n             * 如果你这个图片文件大于8192b，即8kb，那我url-loader就不用，转而去使用file-loader，\n             * 把图片正常打包成一个单独的图片文件到设置的目录下，若是小于了8kb，\n             * 那好，我就将图片打包成base64的图片格式插入到bundle.js文件中，\n             * 这样做的好处是，减少了http请求，但是如果文件过大，js文件也会过大，\n             * 得不偿失，这是为什么有limit的原因！\n             */\n+          limit: 8192,\n+        },\n+      }\n+    }\n  ]\n}\n```\n\n\n\n## 进阶\n\n基本上我们的webpack可以正常运行了，css，js，jsx都可以解析了。但是我们需要考虑一些进阶的东西，优化。\n\n### 使用uglifyjs-webpack-plugin\n\n在控制台执行以下代码：\n\n```\nnpm install uglifyjs-webpack-plugin --save-dev\n```\n\n在【webpack.prod.config.js】添加代码\n\n```js\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n//...\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        test: /\\.js(\\?.*)?$/i,  //测试匹配文件,\n        include: /\\/includes/, //包含哪些文件\n        excluce: /\\/excludes/, //不包含哪些文件\n\n        cache: false,   //是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录\n        parallel: true,  //使用多进程并行运行来提高构建速度\n\n        //允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 \n        //返回true以uglify块，否则返回false。\n        chunkFilter: (chunk) => {\n            // `vendor` 模块不压缩\n            if (chunk.name === 'vendor') {\n              return false;\n            }\n            return true;\n          }\n        }),\n  \n    ],\n  },\n  //..\n};\n```\n\n### 使用splitChunks\n\n其实我们写的代码，有些库的代码是不需要每次都编译的，最简单的例子就是React，这个我们几乎每个js文件都会用到。所以我们可以将它们单独打包，这样只需要打包一次。\n\n修改【webpack.common.config.js】\n\n```diff\nentry: {\n     index: './src/index.js',\n+    common: ['react', 'react-dom']\n  },\n```\n\n修改【webpack.prod.config.js】\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    }),\n    new CleanWebpackPlugin()\n  ],\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        test: /\\.js(\\?.*)?$/i,  //测试匹配文件,\n        // include: /\\/includes/, //包含哪些文件\n        // excluce: /\\/excludes/, //不包含哪些文件\n\n        //允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 \n        //返回true以uglify块，否则返回false。\n        chunkFilter: (chunk) => {\n            // `vendor` 模块不压缩\n            if (chunk.name === 'vendor') {\n              return false;\n            }\n            return true;\n          }\n        }),\n  \n        cache: false,   //是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录\n        parallel: true,  //使用多进程并行运行来提高构建速度\n    ],\n    splitChunks: {\n      /**\n       * 默认值是async\n       * 拆分模块的范围，它有三个值async、initial和all。\n       * async表示只从异步加载得模块（动态加载import()）里面进行拆分\n       * initial表示只从入口模块进行拆分\n       * all表示以上两者都包括\n       */\n      chunks: 'all',\n      // minSize: 30000, // 生成chunk的最小大小（以字节为单位）。只有大于这个数字才可以成一个chunk \n      // minRemainingSize: 0, // 只有剩下一个chunk的时候才会生效，默认是和minSize一样的，开发的时候默认是0\n      // maxSize: 0, // 告诉webpack尝试将大于maxSize字节的块拆分为较小的部分。\n      // minChunks: 1, // 拆分前必须共享模块的最小块数。\n      // maxAsyncRequests: 6, // 按需加载时最大并行请求数。\n      // maxInitialRequests: 4, // 入口点的最大并行请求数。入口文件\n      // automaticNameDelimiter: '~', // 默认情况下，webpack将使用块的来源和名称生成名称（例如vendors~main.js）。此选项使您可以指定用于生成名称的定界符。\n      cacheGroups: {\n        /**\n         * 当webpack处理文件路径时，它们始终包含/在Unix系统和\\Windows上。\n         * 这就是为什么[\\\\/]在{cacheGroup}.test字段中使用in 来表示路径分隔符的原因。\n         * /或\\in {cacheGroup}.test会在跨平台使用时引起问题。\n         */\n        // defaultVendors: {\n        //   test: /[\\\\/]node_modules[\\\\/]/, // 分块目标\n        //   priority: -10 // 权重\n        // },\n        // default: {\n        //   minChunks: 2, // 最小引用\n        //   priority: -20, // 权重\n        //   // 如果当前块包含已从主捆绑包中拆分出的模块，则将重用该模块，而不是生成新的模块。这可能会影响块的结果文件名。\n        //   reuseExistingChunk: true\n        // },\n        // 上述的splitChunks全是webpack4未设置情况下的默认值，除了chunks从【async】->【all】其他都没有改\n        // ok，我们现在加入我们自己想要的代码分割\n        // 因为我准备加入react等业务千变万化而不会变的库\n        common: {\n          test: \"common\", // webpack扫面的关键字\n          name: \"common\", // 生成的名字\n          enforce: true // 是否缓存\n        },\n      }\n    }\n  },\n});\n```\n\n不想写diff啦，直接CV啦。。。\n\n为什么我需要把react提取出来，因为哪里都需要用，而且他几乎不可能会变，所以我特别提出来做了缓存，其余的还是使用的默认配置（除了chunk改为了‘all’）。\n\n> Tobias Koppers@Wsokra：optimization. splitchunks. chunks: althe only option you need for vendor and commons splitting in webpackBest combine it with html-webpack-plugin or equivalent html generation18120\n\n作者都发推特说了，那我们也就接受吧～就改个all，然后补一下react～\n\n再重新打包，你会发现index.bundle.js（不被缓存）的hash值变了，但是common.bundle.js（能被缓存）的hash值没变。\n\n### 使用mini-css-extract-plugin\n\njs都独立📦，那我css也要！\n\n其实如果把CSS打包成一个文件然后让html引用的话可以减小html文件的大小，暗合了HTTP2的多路复用，多文件小数量。包括之前的splitChunks里面我们配置的react也是为了HTTP2。\n\n在命令行输入：\n\n```\nnpm install --save-dev mini-css-extract-plugin\n```\n\n修改【webpack.common.config.js】\n\n```diff\n+ const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\n//...\nmodule:{\n    rules:[\n      {\n        test: /\\.css$/,\n        use: [ \n+          MiniCssExtractPlugin.loader,\n-          'style-loader',\n           'css-loader', \n        ]\n      },\n    ],\n  },\n+plugins: [\n+    new MiniCssExtractPlugin({\n+      filename: 'css/[name].[hash].css',\n+      chunkFilename: 'css/[id].[hash].css',\n+    }),\n  ]\n```\n\n\n\n### 使用CSS Module\n\n其实很简单，只需要修改一下配置【wbpack.common.config.js】\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          MiniCssExtractPlugin.loader,\n-          'css-loader'\n+          {\n+            loader: 'css-loader',\n+            options: {\n+              // importLoaders: 1,\n+              modules: true,\n+            },\n+          },\n        ]\n      },\n```\n\n### 使用PostCSS\n\n> postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如： 1 . 使用下一代css语法 2 . 自动补全浏览器前缀 3 . 自动把px代为转换成rem 4 . css 代码压缩等等 postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。\n\n安装postcss\n\n```\nnpm install postcss postcss-loader --save-dev\n```\n\n安装postcss某个插件，以Autoprefixer举例\n\n```\nnpm install postcss-aspect-ratio-mini postcss-write-svg postcss-px-to-viewport postcss-viewport-units postcss-flexbugs-fixes postcss-preset-env cssnano --save-dev\n```\n\n在根目标新建文件【postcss.config.js】\n\n```js\n/* eslint-disable import/no-extraneous-dependencies */\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst postcssAspectRatioMini = require('postcss-aspect-ratio-mini');\nconst postcssPxToViewport = require('postcss-px-to-viewport');\nconst postcssWriteSvg = require('postcss-write-svg');\nconst postcssViewportUnits = require('postcss-viewport-units');\nconst cssnano = require('cssnano');\nconst postcssPresetEnv = require('postcss-preset-env')\n\nconst postcssFlexbugsFixes = require('postcss-flexbugs-fixes')\n\nmodule.exports = {\n  plugins: [\n    postcssFlexbugsFixes,\n    // 在这个位置加入我们需要配置的代码\n    // 在这个位置加入我们需要配置的代码\n    // 在这个位置加入我们需要配置的代码\n    postcssAspectRatioMini({}),\n    postcssPxToViewport({\n      viewportWidth: 750, // 基准宽度（一般的设计都是这个基准\n      viewportHeight: 1334, // 基准高度（一般的设计都是这个基准\n      unitPrecision: 3, // (Number) The decimal numbers to allow the REM units to grow to.\n      viewportUnit: 'vw', // (String) 单位\n      selectorBlackList: ['.list-ignore', /notTransform/], // 带上这个单词的就不会fix为vw单位\n      minPixelValue: 1, // (Number) 最小像素\n      mediaQuery: false, // (Boolean) 允许在媒体查询中转换px。\n      exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/,\n    }),\n    postcssWriteSvg({\n      utf8: false\n    }),\n    postcssPresetEnv({}),\n    postcssViewportUnits({\n      filterRule: rule => rule.selector.includes('::after')\n        && rule.selector.includes('::before')\n        && rule.selector.includes(':after')\n        && rule.selector.includes(':before')\n    }),\n    cssnano({\n      \"cssnano-preset-advanced\": {\n        zindex: false,\n        autoprefixer: false\n      },\n    })\n  ]\n};\n```\n\n修改【webpack.common.config.js】\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n+          'postcss-loader'\n        ]\n      },\n      {\n        test: /\\.less$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n          'less-loader',\n+          'postcss-loader'\n        ]\n      }\n```\n\n然后，修改我们的css文件，看看我们写的单位为px的有没有被改为vw的自适应单位。\n\n顺便试一下带有【notTransform】的是不是还是px作为单位。\n\n## 结束\n\n到此，我们的webpack配置，就算是入门了，对于webpack的配置我们还有很长的路要走。大家加油！\n\n如果有哪里写的不好或者写错了，欢迎大家在评论区讨论。","source":"_posts/从零配置你的Webpack.md","raw":"---\ntitle: 从零配置你的Webpack\ndate: 2020-06-07 06:11:13\ntags: [Webpack]\ncategory: [Webpack]\ncover: /image/cover/webpack.png\n---\n\n# 从零配置你的Webpack\n\n## 前言\n\n上篇文章简单的介绍了一下，前端进阶之脚手架的搭建。其实我个人认为重要的还是Webpack的配置出来的template，至于脚手架的交互体验可以后期去优化，也可以更加的个性化。但是我们的核心还是放在Webpack等一系列的配置上。\n\n这篇文章的目的\n\n- 可以给自己一个回顾的地方\n- 加强对Webpack的理解，每个知识点都会认认真真的彻查！尽量让每一步都是非常清晰明了的！\n- 如果可以帮助到大家那是更好不过了\n\n好了，收！话不多说开始！\n\n\n\n## 前提\n\n相信来到这里的小伙伴，都是有一些些前端的经验了，至于什么node安装环境变量这里就不赘述了。本人使用的是mac os，如果是Windows的并且碰到问题的话，可以留言，或者直接Google。\n\n\n\n## 开始\n\n### 建立一个空的文件夹📁\n\n新建一个文件夹，名为【webpackInit】\n\n并且使用你的编辑器打开他，然后打开命令行执行：\n\n```js\nnpm init -y\n```\n\n这个命令是node帮你初始化一个项目用的，帮你新建一个`package.json`。\n\n至于`-y`是用于默认都以**yes**继续执行。如果想了解一下里面到底有什么的同学可以不用*-y*继续跑一遍。其实里面的东西后期都可以自己修改`package.json`。所以不需要太在意。\n\n### 安装Webpack🔧\n\n现在是北京时间：2020/06/07 06:42:49。\n\nWebpack5有Beta版，这里就不考虑了，后续上正式版的话我应该会出新的文章介绍。\n\n因为我们使用的是 `webpack 4+` 版本，还需要安装 `webpack-cli` ，执行以下命令：\n\n```js\nnpm install --save-dev webpack webpack-cli\n```\n\n因为Webpack主要是编译时使用所以放到“devDependencies”。\n\n确认一下现在的目录结构，以防有同学掉队！\n\n```diff\nwebpackInit\n  |- node_modules\n  |- package-lock.json\n  |- package.json\n```\n\n这里说下题外话。\n\n##### package.json和package-lock.json的区别\n\npackage.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，`npm install` 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。\n\n那如果我们安装时的包有bug，后面需要更新怎么办？\n\n在以前可能就是直接改 package.json 里面的版本，然后再 `npm install` 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 `npm install xxx@x.x.x` 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。\n\n### 新建配置文件📃\n\n我们在根目录新建文件夹【config】用于存储一些相关的配置文件，然后在【config】里面新建一个文件夹【webpack】表示，专门用于存储webpack的配置文件。然后在【webpack】这个文件夹下面新建文件【webpack.common.config.js】\n\n并敲入以下代码\n\n\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  // 配置入口文件\n  entry: {\n    app: './src/index.js',\n  },\n  // 打包📦之后的出口\n  output: {\n    // 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n    /**\n     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，\n     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。\n     * path.resolve\n     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径\n     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz\n     * 3.如果传入的绝对路径不存在，那么当前目录将被使用\n     * 4.当传入的参数没有/时，将被传入解析到当前根目录\n     * 5.零长度的路径将被忽略\n     * 6.如果没有传入参数，将返回当前根目录\n     * \n     * _dirname表示绝对路径\n     * 我们碰到的./xx就是相对路径\n     * 1.只传入__dirname也可以自动调用path.resolve方法\n     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败\n     * 3.__dirname代表的是当前文件（a.js）的绝对路径\n     * 4.从右至左解析，遇到了绝对路径/src，因此直接返\n     */\n    path: path.resolve(__dirname, '../../dist')\n  }\n}\n```\n\n> webpack 配置是标准的 Node.js的CommonJS 模块，它通过require来引入其他模块，通过module.exports导出模块，由 webpack 根据对象定义的属性进行解析。\n\n在根目录新建【src】文件夹📁\n\n在【src】文件夹下新建文件index.js\n\nok👌，确认一下目录结构\n\n```diff\nwebpackInit\n+ |- config\n+ \t|- webpack\n+     |- webpack.common.config.js\n  |- node_modules\n+ |- src\n+     |- index.js\n  |- package.json\n  |- package-lock.json\n```\n\n那我们怎么打包呢？在 `package.json` 中配置如下属性：\n\n```diff\n\"scripts\": {\n- \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n+ \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\"\n},\n\n```\n\n好了，我们试试怎么打包吧，虽然你的 `index.js` 中什么代码也没有。\n在控制台中输入以下代码：\n\n```\nnpm run start\n```\n\nnpm run xxxx 会去执行当前目录下package.json里面的script同名脚本\n\n我们的【npm run start】相当于直接执行了我们写在【start】里面的代码。\n\n执行之后，你会发现根目录多出了一个文件夹： `dist/js` ，其中有一个js文件： `bundle.js` ，那么至此，我们已经成功编译打包了一个js文件，即入口文件： `index.js` 。\n\n### 安装React\n\n在控制台输入以下代码：\n\n```\nnpm install --save react react-dom\n```\n\n--save就是运行时会用到的代码\n\n具体和--dev-save的区别可以自己Google一下\n\n在【src/index.js】里面加入以下代码\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () => (\n  <>\n    Hello World！\n  </>\n)\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n在根目录加入文件夹【public】，然后在【public】里面加入【index.html】\n\n目录如下：\n\n```diff\nwebpackInit\n+ |- public\n+ \t|- index.html\n  |- config\n  \t|- webpack\n      |- webpack.common.config.js\n  |- node_modules\n  |- src\n      |- index.js\n  |- package.json\n  |- package-lock.json\n```\n\n然后在【index.html】加入以下代码：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\">\n    <meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no, width=device-width\">\n  <title>从零配置Webpack</title>\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n```\n\nOK\n\n万事俱备，我们运行：\n\n```\nnpm run start\n```\n\n打包失败了。。。为什么呢？\n\n### 使用babel\n\n为什么我们上面写jsx会打包不了呢，因为webpack根本识别不了jsx语法，那怎么办？使用loader对文件进行预处理。\n其中，babel-loader，就是这样一个预处理插件，它加载 ES2015+ 代码，然后使用 Babel 转译为 ES5。那开始配置它吧！\n\n首先安装babel相关的模块：\n\n```\nnpm install --save-dev babel-loader @babel/preset-react @babel/preset-env @babel/core babel-plugin-import\n```\n\n- **babel-loader：**使用Babel和webpack来转译JavaScript文件。\n- **@babel/preset-react：**转译react的JSX\n- **@babel/preset-env：**转译ES2015+的语法\n- **@babel/core：**babel的核心模块\n- **babel-plugin-import**：按需加载所需要的babel解析\n\n理论上我们可以直接在 `webpack.common.config.js` 中配置\"options\"，但最好在当前根目录，注意，一定要是根目录！！！ 新建一个配置文件 `.babelrc` 配置相关的\"presets\"：\n\n```js\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"targets\": {\n          // 大于相关浏览器版本无需用到 preset-env\n          \"edge\": 17,\n          \"firefox\": 60,\n          \"chrome\": 67,\n          \"safari\": 11,\n          // 兼容到android4 ios6\n          \"browsers\": [\"Android >= 4.0\", \"ios >= 6\"]\n        }\n      }\n    ],\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"antd-mobile\", \"style\": \"css\" }] // `style: true` 会加载 less 文件\n  ]\n}\n```\n\n这里有关[bebel的配置](https://www.babeljs.cn/docs/babel-preset-env)可上官网查询文档。\n\n再修改 `webpack.common.config.js` ，添加如下代码：\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  // 配置入口文件\n  entry: {\n    app: './src/index.js',\n  },\n  // 打包📦之后的出口\n  output: {\n    // 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n    /**\n     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，\n     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。\n     * path.resolve\n     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径\n     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz\n     * 3.如果传入的绝对路径不存在，那么当前目录将被使用\n     * 4.当传入的参数没有/时，将被传入解析到当前根目录\n     * 5.零长度的路径将被忽略\n     * 6.如果没有传入参数，将返回当前根目录\n     * \n     * _dirname表示绝对路径\n     * 我们碰到的./xx就是相对路径\n     * 1.只传入__dirname也可以自动调用path.resolve方法\n     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败\n     * 3.__dirname代表的是当前文件（a.js）的绝对路径\n     * 4.从右至左解析，遇到了绝对路径/src，因此直接返\n     */\n    path: path.resolve(__dirname, '../../dist')\n  },\n  module: {\n    /**\n     * test 规定了作用于以规则中匹配到的后缀结尾的文件， \n     * use 即是使用 babel-loader 必须的属性， \n     * exclude 告诉我们不需要去转译\"node_modules\"这里面的文件。\n     */\n    rules:[\n      {\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n      },\n    ]\n  }\n}\n```\n\n接下来激动人心的时刻：\n\n```\nnpm run start\n```\n\n是不是能打包成功了呢？\n\n打开【dist/】你的html页面，看一下是否是“Hello World！”吧！\n\n### 使用webpack-merge🈴️\n\n我们将使用一个名为 [webpack-merge](https://github.com/survivejs/webpack-merge) 的工具。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。简单来说就是生产环境不同，我们要给的配置也有所不同，但是可以共用一个共有的配置。\n\n我们先从安装 [webpack-merge](https://github.com/survivejs/webpack-merge) 开始：\n\n```\nnpm install --save-dev webpack-merge\n```\n\n安装结束之后，我们在 `config` 这个文件夹下新建两个文件，分别为 `webpack.prod.config.js` 和 `webpack.dev.config.js` ，这两个文件分别对应生产和开发两个环境的配置。当然你也可以添加test环境。名字也可以自己取，尽量保持一致。\n\n\n\n现在的目录结构：\n\n```diff\n  webpackInit\n\t|- config\n\t\t|- webpack\n\t    |- webpack.common.config.js\n+     |- webpack.prod.config.js\n  省略\n```\n\n在【webpack.prod.config.js】加入\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n});\n```\n\n然后修改【package.json】\n\n```diff\n{\n  \"name\": \"webpackInit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",\n+   \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.10.2\",\n    \"@babel/preset-env\": \"^7.10.2\",\n    \"@babel/preset-react\": \"^7.10.1\",\n    \"babel-loader\": \"^8.1.0\",\n    \"babel-plugin-import\": \"^1.13.0\",\n    \"webpack\": \"^4.43.0\",\n    \"webpack-cli\": \"^3.3.11\",\n    \"webpack-merge\": \"^4.2.2\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.13.1\",\n    \"react-dom\": \"^16.13.1\"\n  }\n}\n\n```\n\n然后\n\n删除【dist文件夹】\n\n之后\n\n```\nnpm run build\n```\n\n是不是也build也打包成功了！\n\nhtml是不是也可以正常访问！\n\n但是没有显示Hello World，仔细一看还报错了。。。为什么呢。。因为\n\n```\n// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面\n    // 8是hash的长度，如果不设置，webpack会设置默认值为20。\n    filename: 'js/[name].[chunkhash:8].bundle.js',\n```\n\n我们给js文件设置了hash值。不能够直接在html里面加上【<script src=\"../dist/js/bundle.js\"></script>】这么一句，而且每次生成的hash值都会变，那么我们要怎么处理这个问题呢？\n\n\n\n### 使用[HtmlWebpackPlugin](https://www.webpackjs.com/plugins/html-webpack-plugin/)\n\n\n\n安装[HtmlWebpackPlugin](https://www.webpackjs.com/plugins/html-webpack-plugin/)\n\n在控制台执行以下代码：\n\n```\nnpm install --save-dev html-webpack-plugin\n```\n\n修改【webpack.prod.config.js】\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    })\n  ]\n});\n```\n\n\n\n现在我们再来打包试试\n\n```\nnpm run build\n```\n\n看看dist中是不是多出了html文件，并且自动引入了script，用浏览器打开它试试看是不是能正确输出内容了！\n\n起飞！！🛫️\n\n### 使用clean-webpack-plugin\n\n有些同学已经厌倦了每次都需要删除dist文件夹来验证是否成功。\n\n其实假如我们不删除的话，我们需要修改js文件，这样让webpack知道我们改了东西，他就会重新打包，但是我们每次测试都没有去修改，所以我们需要删除。\n\n但是，如果说我们不去删除dist文件夹的话，我们修改了【src/index.js】。然后再重新build，就会发现【dist/js】下面会又多出一个js文件，这样的话我们就需要观察日志，查看新鲜“出炉”的是哪一个，然后删掉别的。这样非常麻烦。\n\nOK，我们现在就来解决一下这个问题\n\n安装clean-webpack-plugin\n\n```\nnpm install --save-dev clean-webpack-plugin\n```\n\n修改【webpck.prod.config.js】\n\n```diff\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n+ const { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    }),\n+   new CleanWebpackPlugin()\n  ]\n});\n```\n\n我们先查看现在的js文件前面的hash值。然后我们修改【src/index.js】，随便改成什么，再重新\n\n```\nnpm run build\n```\n\n就会发现文件并没有新增，而且换了新鲜的哈希值。\n\n当然了，我之前说的那些话，同学不相信的话，可以把【new CleanWebpackPlugin()】这一行注释掉，然后再修改【src/index.js】，会发现【dist/js】下面的js文件会增多一条。\n\n### 使用webpack-dev-server\n\n既然刚刚都提到优化了，我们每次都需要build一下，感觉很呆。而webpack官方也提供热部署，那我们现在就使用起来\n\n安装webpack-dev-server\n\n```\nnpm install webpack-dev-server --save-dev\n```\n\n新建文件【webpack.dev.config.js】📃\n\n```diff\n  webpackInit\n\t|- config\n\t\t|- webpack\n\t    |- webpack.common.config.js\n      |- webpack.prod.config.js\n+     |- webpack.dev.config.js\n  省略\n```\n\n然后加入如下代码\n\n```js\nconst path = require('path');\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  output: {\n    filename: 'js/[name].[hash:8].bundle.js',\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, '../dist'),\n    open: true,\n    port: 9000,\n    compress: true,\n    hot: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: 'public/index.html',\n      inject: 'body',\n      hash: false\n    }),\n    new webpack.HotModuleReplacementPlugin()\n  ]\n});\n```\n\n修改文件【package.json】📃\n\n```diff\n\"scripts\": {\n-   \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",\n+   \"start\": \"webpack-dev-server --inline --config ./config/webpack/webpack.dev.config.js\",\n    \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\",\n  },\n```\n\n然后我们\n\n```\nnpm run start\n```\n\n是不是自动开了一个端口为9000的网页，上面是我们写的页面内容，这和我们的配置都是一一对应的。\n现在你随意修改index.js中的代码，再回到页面看下是不是也跟着变了，那我们就整合webpack-dev-server成功！\n\n### 使用source-map\n\nsource-map可以展示我们代码的错误位置，因为我们的代码都是被webpack打包过的，只有机器看得懂，我们人类无法正常识别。所以需要他。\n\n想试一下未开启是什么状态的同学可以自己故意把代码写错，然后看看控制台的报错。\n\n开启也十分简单。\n\n它的配置非常简单，只需要在 【webpack.dev.config.js】 中增加一个 `devtool` 属性即可！\n\n```diff\nmodule.exports = {\n+  devtool: 'cheap-module-eval-source-map',\n\t//...\n}\n```\n\n因为我们只有自己写代码的时候才需要查看，到生产环境就要关闭啦，不然我们的智慧结晶就要被【窃取】啦！所以我放在了\n\n## 中场休息\n\n这里回顾一下知识点。\n\n1. 我们先npm init 新建一个空白项目。\n2. 然后安装webpack，react。\n3. 发现无法编译jsx。\n4. 所以我们寻求了babel的帮助，并配置了所需要解析的内容。\n5. 觉得在html里面加入js很呆，所以引入了HtmlWebpackPlugin\n6. 因为觉得每次删除打包出来的东西很呆，所以引入了clean-webpack-plugin\n7. 因为每次都需要重新打包，所以使用webpack-dev\n8. 至于webpack-merge是为了打包和编译两个或者说多个状态做预备的，在上述的例子只有本地的dev和build两个环境。\n\n基本上上述的操作过程我都有解释，或者是注释，或者是在文章中说明。大家可以跟着节奏一步一步来，因为我也是一边写blog一边跑代码一边回顾知识点。\n\n至此，webpack算是告一……\n\n诶诶诶诶！js是可以解析了，那css呢！\n\n哦哦，好的，那我们继续启程\n\n## 重新起航\n\n### 使用css-loader和style-loader两兄弟  \n\n假如我们直接引用css的话，会报错了。这里就不演示了，有兴趣的同学可以自己试试。\n\n所以，我们先走命令行敲击\n\n```\nnpm install --save-dev style-loader css-loader \n```\n\n#### 两兄弟的关系\n\n来说说css-loader和style-loader他们这对鸳鸯的关系。\n\n首先css-loader会把你的CSS文件进行解析，因为webpack是用JS写的，运行在node环境，所以默认webpack打包的时候只会处理JS之间的依赖关系！\n\n所以我们之前的react里面的jsx需要babel的帮助，或者说需要【babel-loader】的帮助，所以我们的css同样需要【css-loader】的帮助，那么又关【style-loader】什么事？可不可以不装他呢？\n\n答案是：可以的，但是你使用起来会非常的麻烦。怎么个麻烦法呢？\n\n如果只用了【css-loader】解析出来的是这样的\n\n```\n[\"./src/index.css\", \".test{↵  color: red;↵}\", \"\"]\n```\n\n这样咋用嘛，你是解析了，可是你解析的是个XX。\n\n这个时候就需要我们的天降猛男【style-loader】\n\nstyle-loader 是通过一个JS脚本创建一个style标签，里面包含一些样式。style-loader是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个loader的功能都是单一的，各自拆分独立。\n\n#### 上手！\n\n加入index.css\n\n```diff\nsrc\n+  |- index.css\n   |- indexjs\n```\n\nindex.css文件的内容如下\n\n```css\n.test{\n  color: red;\n}\n```\n\n修改index.js\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'\n\nconst App = () => (\n  <div className=\"test\">\n    Hello World！!\n  </div>\n)\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n修改【webpack.common.config.js】📃\n\n```diff\n//...\nrules:[\n      {\n        test: /\\.(js|jsx)?$/,\n        // 开启缓存\n        options: { cacheDirectory: true },\n        loader: 'babel-loader',\n      },\n+      {\n+        test: /\\.css$/,\n+        use: [ \n+          'css-loader', \n+          'style-loader',\n+        ]\n+      }\n    ]\n    //....\n```\n\n记得重新运行，因为webpack的配置他读取一次，所以如果你修改了配置，需要【ctrl+c】关闭重新运行。\n\n嘿嘿……是不是运行不了啊。\n\n其实我是故意的，我想告诉大家一个知识点。\n\n> loader的加载顺序是从右往左。这里的编译顺序是先用css-loader将css代码编译，再交给style-loader插入到网页里面去。所以css-loader在右，style-loader在左。\n\n虽然我们的数组换行了，但是仔细看不难看出顺序。\n\n所以我们只需要将他们换个位置就可以了。代码我就不贴了。\n\n现在大家应该记忆很深刻了吧！\n\n大家重新【ctrl+c】关闭重新运行就行了。我们的hello world是不是变红啦～\n\n### 安装less-loader\n\n说到css，说句实在话，没几人真的是在写纯css的吧？现在谁不是less，sass或者其他css预处理呢？而且这些预处理的好处我就不细说了，感兴趣的自己Google吧，本文用的是less（因为ant design用的也是less，哈哈，假装是蚂蚁的一员）\n\n在命令行输入\n\n```\nnpm install --save-dev less less-loader\n```\n\nless没什么好说的，用他肯定要装，less-loader，顾名思义，就是less的解析者。\n\n在【webpack.common.config.js】增加\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n        ]\n      },\n+      {\n+        test: /\\.less$/,\n+        use: [ \n+          'style-loader',\n+          'css-loader', \n+          'less-loader',\n+        ]\n+      }\n```\n\n依旧是顺序问题，先解析less，把less解析成常规的css，然后再解析css，最后插入到网页中去。\n\n修改【index.js】引入自己写的【.less】文件\n\n大家重新【ctrl+c】关闭重新运行就行了。至于你写了什么less特性，只要有效果就行了。\n\n### 安装url-loader和file-loader\n\n说完CSS，美丽的网页当然离不开我们动人的图片啦。\n\n【file-loader】的作用是，把你的文件打包起来，和js文件放在一起，这样用户访问我们的网页的时候，其实也需要访问我们的url，既增加了服务器的压力，也增加了用户升级流量的压力，需要去下载这个文件。\n\n【url-loader】\n\n如果页面图片较多，发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl并将其打包到文件中，最终只需要引入这个dataURL就能访问图片了。\n\nurl-loader和file-loader两兄弟的搭配可以有效的减少不必要的url请求，因为有的图片你要去请求url获取，如果小的话完全可以用base64替代。如果图片很大的话就用file-loader，这样可以减少编码的压力。\n\n在命令行输入\n\n```\nnpm install file-loader url-loader --save-dev\n```\n\n修改【webpack.common.config.js】📃\n\n```diff\nmodule: {\n  rules: [\n    //...\n+    {\n+      test: /\\.(jpg|png|gif)$/,\n+      use: {\n+        loader: 'url-loader',\n+        options: {\n+          name: '[name].[ext]', //输出的文件名\n+          outputPath: 'images/', // 输出到dist目录下的路径（dist/images/）\n\t\t\t\t\t\t/**\n             * 如果你这个图片文件大于8192b，即8kb，那我url-loader就不用，转而去使用file-loader，\n             * 把图片正常打包成一个单独的图片文件到设置的目录下，若是小于了8kb，\n             * 那好，我就将图片打包成base64的图片格式插入到bundle.js文件中，\n             * 这样做的好处是，减少了http请求，但是如果文件过大，js文件也会过大，\n             * 得不偿失，这是为什么有limit的原因！\n             */\n+          limit: 8192,\n+        },\n+      }\n+    }\n  ]\n}\n```\n\n\n\n## 进阶\n\n基本上我们的webpack可以正常运行了，css，js，jsx都可以解析了。但是我们需要考虑一些进阶的东西，优化。\n\n### 使用uglifyjs-webpack-plugin\n\n在控制台执行以下代码：\n\n```\nnpm install uglifyjs-webpack-plugin --save-dev\n```\n\n在【webpack.prod.config.js】添加代码\n\n```js\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n//...\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        test: /\\.js(\\?.*)?$/i,  //测试匹配文件,\n        include: /\\/includes/, //包含哪些文件\n        excluce: /\\/excludes/, //不包含哪些文件\n\n        cache: false,   //是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录\n        parallel: true,  //使用多进程并行运行来提高构建速度\n\n        //允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 \n        //返回true以uglify块，否则返回false。\n        chunkFilter: (chunk) => {\n            // `vendor` 模块不压缩\n            if (chunk.name === 'vendor') {\n              return false;\n            }\n            return true;\n          }\n        }),\n  \n    ],\n  },\n  //..\n};\n```\n\n### 使用splitChunks\n\n其实我们写的代码，有些库的代码是不需要每次都编译的，最简单的例子就是React，这个我们几乎每个js文件都会用到。所以我们可以将它们单独打包，这样只需要打包一次。\n\n修改【webpack.common.config.js】\n\n```diff\nentry: {\n     index: './src/index.js',\n+    common: ['react', 'react-dom']\n  },\n```\n\n修改【webpack.prod.config.js】\n\n```js\nconst merge = require('webpack-merge'); // 版本为4.x\n// webpack-merge 5.x版本应该改为 const { merge } = require('webpack-merge');\nconst common = require('./webpack.common.config.js');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 打包之后的html文件名字\n      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'\n      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找\n      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script\n      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js\n      minify: { // 压缩html文件\n        removeComments: true, // 去除注释\n        collapseWhitespace: true, // 去除空格\n      },\n    }),\n    new CleanWebpackPlugin()\n  ],\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        test: /\\.js(\\?.*)?$/i,  //测试匹配文件,\n        // include: /\\/includes/, //包含哪些文件\n        // excluce: /\\/excludes/, //不包含哪些文件\n\n        //允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 \n        //返回true以uglify块，否则返回false。\n        chunkFilter: (chunk) => {\n            // `vendor` 模块不压缩\n            if (chunk.name === 'vendor') {\n              return false;\n            }\n            return true;\n          }\n        }),\n  \n        cache: false,   //是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录\n        parallel: true,  //使用多进程并行运行来提高构建速度\n    ],\n    splitChunks: {\n      /**\n       * 默认值是async\n       * 拆分模块的范围，它有三个值async、initial和all。\n       * async表示只从异步加载得模块（动态加载import()）里面进行拆分\n       * initial表示只从入口模块进行拆分\n       * all表示以上两者都包括\n       */\n      chunks: 'all',\n      // minSize: 30000, // 生成chunk的最小大小（以字节为单位）。只有大于这个数字才可以成一个chunk \n      // minRemainingSize: 0, // 只有剩下一个chunk的时候才会生效，默认是和minSize一样的，开发的时候默认是0\n      // maxSize: 0, // 告诉webpack尝试将大于maxSize字节的块拆分为较小的部分。\n      // minChunks: 1, // 拆分前必须共享模块的最小块数。\n      // maxAsyncRequests: 6, // 按需加载时最大并行请求数。\n      // maxInitialRequests: 4, // 入口点的最大并行请求数。入口文件\n      // automaticNameDelimiter: '~', // 默认情况下，webpack将使用块的来源和名称生成名称（例如vendors~main.js）。此选项使您可以指定用于生成名称的定界符。\n      cacheGroups: {\n        /**\n         * 当webpack处理文件路径时，它们始终包含/在Unix系统和\\Windows上。\n         * 这就是为什么[\\\\/]在{cacheGroup}.test字段中使用in 来表示路径分隔符的原因。\n         * /或\\in {cacheGroup}.test会在跨平台使用时引起问题。\n         */\n        // defaultVendors: {\n        //   test: /[\\\\/]node_modules[\\\\/]/, // 分块目标\n        //   priority: -10 // 权重\n        // },\n        // default: {\n        //   minChunks: 2, // 最小引用\n        //   priority: -20, // 权重\n        //   // 如果当前块包含已从主捆绑包中拆分出的模块，则将重用该模块，而不是生成新的模块。这可能会影响块的结果文件名。\n        //   reuseExistingChunk: true\n        // },\n        // 上述的splitChunks全是webpack4未设置情况下的默认值，除了chunks从【async】->【all】其他都没有改\n        // ok，我们现在加入我们自己想要的代码分割\n        // 因为我准备加入react等业务千变万化而不会变的库\n        common: {\n          test: \"common\", // webpack扫面的关键字\n          name: \"common\", // 生成的名字\n          enforce: true // 是否缓存\n        },\n      }\n    }\n  },\n});\n```\n\n不想写diff啦，直接CV啦。。。\n\n为什么我需要把react提取出来，因为哪里都需要用，而且他几乎不可能会变，所以我特别提出来做了缓存，其余的还是使用的默认配置（除了chunk改为了‘all’）。\n\n> Tobias Koppers@Wsokra：optimization. splitchunks. chunks: althe only option you need for vendor and commons splitting in webpackBest combine it with html-webpack-plugin or equivalent html generation18120\n\n作者都发推特说了，那我们也就接受吧～就改个all，然后补一下react～\n\n再重新打包，你会发现index.bundle.js（不被缓存）的hash值变了，但是common.bundle.js（能被缓存）的hash值没变。\n\n### 使用mini-css-extract-plugin\n\njs都独立📦，那我css也要！\n\n其实如果把CSS打包成一个文件然后让html引用的话可以减小html文件的大小，暗合了HTTP2的多路复用，多文件小数量。包括之前的splitChunks里面我们配置的react也是为了HTTP2。\n\n在命令行输入：\n\n```\nnpm install --save-dev mini-css-extract-plugin\n```\n\n修改【webpack.common.config.js】\n\n```diff\n+ const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\n//...\nmodule:{\n    rules:[\n      {\n        test: /\\.css$/,\n        use: [ \n+          MiniCssExtractPlugin.loader,\n-          'style-loader',\n           'css-loader', \n        ]\n      },\n    ],\n  },\n+plugins: [\n+    new MiniCssExtractPlugin({\n+      filename: 'css/[name].[hash].css',\n+      chunkFilename: 'css/[id].[hash].css',\n+    }),\n  ]\n```\n\n\n\n### 使用CSS Module\n\n其实很简单，只需要修改一下配置【wbpack.common.config.js】\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          MiniCssExtractPlugin.loader,\n-          'css-loader'\n+          {\n+            loader: 'css-loader',\n+            options: {\n+              // importLoaders: 1,\n+              modules: true,\n+            },\n+          },\n        ]\n      },\n```\n\n### 使用PostCSS\n\n> postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如： 1 . 使用下一代css语法 2 . 自动补全浏览器前缀 3 . 自动把px代为转换成rem 4 . css 代码压缩等等 postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。\n\n安装postcss\n\n```\nnpm install postcss postcss-loader --save-dev\n```\n\n安装postcss某个插件，以Autoprefixer举例\n\n```\nnpm install postcss-aspect-ratio-mini postcss-write-svg postcss-px-to-viewport postcss-viewport-units postcss-flexbugs-fixes postcss-preset-env cssnano --save-dev\n```\n\n在根目标新建文件【postcss.config.js】\n\n```js\n/* eslint-disable import/no-extraneous-dependencies */\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst postcssAspectRatioMini = require('postcss-aspect-ratio-mini');\nconst postcssPxToViewport = require('postcss-px-to-viewport');\nconst postcssWriteSvg = require('postcss-write-svg');\nconst postcssViewportUnits = require('postcss-viewport-units');\nconst cssnano = require('cssnano');\nconst postcssPresetEnv = require('postcss-preset-env')\n\nconst postcssFlexbugsFixes = require('postcss-flexbugs-fixes')\n\nmodule.exports = {\n  plugins: [\n    postcssFlexbugsFixes,\n    // 在这个位置加入我们需要配置的代码\n    // 在这个位置加入我们需要配置的代码\n    // 在这个位置加入我们需要配置的代码\n    postcssAspectRatioMini({}),\n    postcssPxToViewport({\n      viewportWidth: 750, // 基准宽度（一般的设计都是这个基准\n      viewportHeight: 1334, // 基准高度（一般的设计都是这个基准\n      unitPrecision: 3, // (Number) The decimal numbers to allow the REM units to grow to.\n      viewportUnit: 'vw', // (String) 单位\n      selectorBlackList: ['.list-ignore', /notTransform/], // 带上这个单词的就不会fix为vw单位\n      minPixelValue: 1, // (Number) 最小像素\n      mediaQuery: false, // (Boolean) 允许在媒体查询中转换px。\n      exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/,\n    }),\n    postcssWriteSvg({\n      utf8: false\n    }),\n    postcssPresetEnv({}),\n    postcssViewportUnits({\n      filterRule: rule => rule.selector.includes('::after')\n        && rule.selector.includes('::before')\n        && rule.selector.includes(':after')\n        && rule.selector.includes(':before')\n    }),\n    cssnano({\n      \"cssnano-preset-advanced\": {\n        zindex: false,\n        autoprefixer: false\n      },\n    })\n  ]\n};\n```\n\n修改【webpack.common.config.js】\n\n```diff\n{\n        test: /\\.css$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n+          'postcss-loader'\n        ]\n      },\n      {\n        test: /\\.less$/,\n        use: [ \n          'style-loader',\n          'css-loader', \n          'less-loader',\n+          'postcss-loader'\n        ]\n      }\n```\n\n然后，修改我们的css文件，看看我们写的单位为px的有没有被改为vw的自适应单位。\n\n顺便试一下带有【notTransform】的是不是还是px作为单位。\n\n## 结束\n\n到此，我们的webpack配置，就算是入门了，对于webpack的配置我们还有很长的路要走。大家加油！\n\n如果有哪里写的不好或者写错了，欢迎大家在评论区讨论。","slug":"从零配置你的Webpack","published":1,"updated":"2021-06-24T14:00:06.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8w002flwrd8dcy2bc7","content":"<h1 id=\"从零配置你的Webpack\"><a href=\"#从零配置你的Webpack\" class=\"headerlink\" title=\"从零配置你的Webpack\"></a>从零配置你的Webpack</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章简单的介绍了一下，前端进阶之脚手架的搭建。其实我个人认为重要的还是Webpack的配置出来的template，至于脚手架的交互体验可以后期去优化，也可以更加的个性化。但是我们的核心还是放在Webpack等一系列的配置上。</p>\n<p>这篇文章的目的</p>\n<ul>\n<li>可以给自己一个回顾的地方</li>\n<li>加强对Webpack的理解，每个知识点都会认认真真的彻查！尽量让每一步都是非常清晰明了的！</li>\n<li>如果可以帮助到大家那是更好不过了</li>\n</ul>\n<p>好了，收！话不多说开始！</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>相信来到这里的小伙伴，都是有一些些前端的经验了，至于什么node安装环境变量这里就不赘述了。本人使用的是mac os，如果是Windows的并且碰到问题的话，可以留言，或者直接Google。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"建立一个空的文件夹📁\"><a href=\"#建立一个空的文件夹📁\" class=\"headerlink\" title=\"建立一个空的文件夹📁\"></a>建立一个空的文件夹📁</h3><p>新建一个文件夹，名为【webpackInit】</p>\n<p>并且使用你的编辑器打开他，然后打开命令行执行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n\n<p>这个命令是node帮你初始化一个项目用的，帮你新建一个<code>package.json</code>。</p>\n<p>至于<code>-y</code>是用于默认都以<strong>yes</strong>继续执行。如果想了解一下里面到底有什么的同学可以不用<em>-y</em>继续跑一遍。其实里面的东西后期都可以自己修改<code>package.json</code>。所以不需要太在意。</p>\n<h3 id=\"安装Webpack🔧\"><a href=\"#安装Webpack🔧\" class=\"headerlink\" title=\"安装Webpack🔧\"></a>安装Webpack🔧</h3><p>现在是北京时间：2020/06/07 06:42:49。</p>\n<p>Webpack5有Beta版，这里就不考虑了，后续上正式版的话我应该会出新的文章介绍。</p>\n<p>因为我们使用的是 <code>webpack 4+</code> 版本，还需要安装 <code>webpack-cli</code> ，执行以下命令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure>\n\n<p>因为Webpack主要是编译时使用所以放到“devDependencies”。</p>\n<p>确认一下现在的目录结构，以防有同学掉队！</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\">  |- package-lock.json</span><br><span class=\"line\">  |- package.json</span><br></pre></td></tr></table></figure>\n\n<p>这里说下题外话。</p>\n<h5 id=\"package-json和package-lock-json的区别\"><a href=\"#package-json和package-lock-json的区别\" class=\"headerlink\" title=\"package.json和package-lock.json的区别\"></a>package.json和package-lock.json的区别</h5><p>package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，<code>npm install</code> 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。</p>\n<p>那如果我们安装时的包有bug，后面需要更新怎么办？</p>\n<p>在以前可能就是直接改 package.json 里面的版本，然后再 <code>npm install</code> 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 <code>npm install xxx@x.x.x</code> 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。</p>\n<h3 id=\"新建配置文件📃\"><a href=\"#新建配置文件📃\" class=\"headerlink\" title=\"新建配置文件📃\"></a>新建配置文件📃</h3><p>我们在根目录新建文件夹【config】用于存储一些相关的配置文件，然后在【config】里面新建一个文件夹【webpack】表示，专门用于存储webpack的配置文件。然后在【webpack】这个文件夹下面新建文件【webpack.common.config.js】</p>\n<p>并敲入以下代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 打包📦之后的出口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span></span><br><span class=\"line\">    <span class=\"comment\">// 8是hash的长度，如果不设置，webpack会设置默认值为20。</span></span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[chunkhash:8].bundle.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。</span></span><br><span class=\"line\"><span class=\"comment\">     * path.resolve</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果传入的绝对路径不存在，那么当前目录将被使用</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.当传入的参数没有/时，将被传入解析到当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * 5.零长度的路径将被忽略</span></span><br><span class=\"line\"><span class=\"comment\">     * 6.如果没有传入参数，将返回当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * _dirname表示绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 我们碰到的./xx就是相对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.只传入__dirname也可以自动调用path.resolve方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.__dirname代表的是当前文件（a.js）的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.从右至左解析，遇到了绝对路径/src，因此直接返</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>webpack 配置是标准的 Node.js的CommonJS 模块，它通过require来引入其他模块，通过module.exports导出模块，由 webpack 根据对象定义的属性进行解析。</p>\n</blockquote>\n<p>在根目录新建【src】文件夹📁</p>\n<p>在【src】文件夹下新建文件index.js</p>\n<p>ok👌，确认一下目录结构</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\"><span class=\"addition\">+ |- config</span></span><br><span class=\"line\"><span class=\"addition\">+ \t|- webpack</span></span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.common.config.js</span></span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\"><span class=\"addition\">+ |- src</span></span><br><span class=\"line\"><span class=\"addition\">+     |- index.js</span></span><br><span class=\"line\">  |- package.json</span><br><span class=\"line\">  |- package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>那我们怎么打包呢？在 <code>package.json</code> 中配置如下属性：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\"><span class=\"deletion\">- \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",</span></span><br><span class=\"line\"><span class=\"addition\">+ \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>好了，我们试试怎么打包吧，虽然你的 <code>index.js</code> 中什么代码也没有。<br>在控制台中输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>npm run xxxx 会去执行当前目录下package.json里面的script同名脚本</p>\n<p>我们的【npm run start】相当于直接执行了我们写在【start】里面的代码。</p>\n<p>执行之后，你会发现根目录多出了一个文件夹： <code>dist/js</code> ，其中有一个js文件： <code>bundle.js</code> ，那么至此，我们已经成功编译打包了一个js文件，即入口文件： <code>index.js</code> 。</p>\n<h3 id=\"安装React\"><a href=\"#安装React\" class=\"headerlink\" title=\"安装React\"></a>安装React</h3><p>在控制台输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react react-dom</span><br></pre></td></tr></table></figure>\n\n<p>–save就是运行时会用到的代码</p>\n<p>具体和–dev-save的区别可以自己Google一下</p>\n<p>在【src/index.js】里面加入以下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;&gt;</span><br><span class=\"line\">    Hello World！</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(&lt;App /</span>&gt;, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>在根目录加入文件夹【public】，然后在【public】里面加入【index.html】</p>\n<p>目录如下：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\"><span class=\"addition\">+ |- public</span></span><br><span class=\"line\"><span class=\"addition\">+ \t|- index.html</span></span><br><span class=\"line\">  |- config</span><br><span class=\"line\">  \t|- webpack</span><br><span class=\"line\">      |- webpack.common.config.js</span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\">  |- src</span><br><span class=\"line\">      |- index.js</span><br><span class=\"line\">  |- package.json</span><br><span class=\"line\">  |- package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>然后在【index.html】加入以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"initial-scale=1.0, user-scalable=no, width=device-width\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>从零配置Webpack<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>OK</p>\n<p>万事俱备，我们运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>打包失败了。。。为什么呢？</p>\n<h3 id=\"使用babel\"><a href=\"#使用babel\" class=\"headerlink\" title=\"使用babel\"></a>使用babel</h3><p>为什么我们上面写jsx会打包不了呢，因为webpack根本识别不了jsx语法，那怎么办？使用loader对文件进行预处理。<br>其中，babel-loader，就是这样一个预处理插件，它加载 ES2015+ 代码，然后使用 Babel 转译为 ES5。那开始配置它吧！</p>\n<p>首先安装babel相关的模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev babel-loader @babel&#x2F;preset-react @babel&#x2F;preset-env @babel&#x2F;core babel-plugin-import</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>babel-loader：</strong>使用Babel和webpack来转译JavaScript文件。</li>\n<li><strong>@babel/preset-react：</strong>转译react的JSX</li>\n<li><strong>@babel/preset-env：</strong>转译ES2015+的语法</li>\n<li><strong>@babel/core：</strong>babel的核心模块</li>\n<li><strong>babel-plugin-import</strong>：按需加载所需要的babel解析</li>\n</ul>\n<p>理论上我们可以直接在 <code>webpack.common.config.js</code> 中配置”options”，但最好在当前根目录，注意，一定要是根目录！！！ 新建一个配置文件 <code>.babelrc</code> 配置相关的”presets”：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/preset-env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"targets\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 大于相关浏览器版本无需用到 preset-env</span></span><br><span class=\"line\">          <span class=\"string\">\"edge\"</span>: <span class=\"number\">17</span>,</span><br><span class=\"line\">          <span class=\"string\">\"firefox\"</span>: <span class=\"number\">60</span>,</span><br><span class=\"line\">          <span class=\"string\">\"chrome\"</span>: <span class=\"number\">67</span>,</span><br><span class=\"line\">          <span class=\"string\">\"safari\"</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 兼容到android4 ios6</span></span><br><span class=\"line\">          <span class=\"string\">\"browsers\"</span>: [<span class=\"string\">\"Android &gt;= 4.0\"</span>, <span class=\"string\">\"ios &gt;= 6\"</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-react\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"import\"</span>, &#123; <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"antd-mobile\"</span>, <span class=\"string\">\"style\"</span>: <span class=\"string\">\"css\"</span> &#125;] <span class=\"comment\">// `style: true` 会加载 less 文件</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有关<a href=\"https://www.babeljs.cn/docs/babel-preset-env\" target=\"_blank\" rel=\"noopener\">bebel的配置</a>可上官网查询文档。</p>\n<p>再修改 <code>webpack.common.config.js</code> ，添加如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 打包📦之后的出口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span></span><br><span class=\"line\">    <span class=\"comment\">// 8是hash的长度，如果不设置，webpack会设置默认值为20。</span></span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[chunkhash:8].bundle.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。</span></span><br><span class=\"line\"><span class=\"comment\">     * path.resolve</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果传入的绝对路径不存在，那么当前目录将被使用</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.当传入的参数没有/时，将被传入解析到当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * 5.零长度的路径将被忽略</span></span><br><span class=\"line\"><span class=\"comment\">     * 6.如果没有传入参数，将返回当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * _dirname表示绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 我们碰到的./xx就是相对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.只传入__dirname也可以自动调用path.resolve方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.__dirname代表的是当前文件（a.js）的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.从右至左解析，遇到了绝对路径/src，因此直接返</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * test 规定了作用于以规则中匹配到的后缀结尾的文件， </span></span><br><span class=\"line\"><span class=\"comment\">     * use 即是使用 babel-loader 必须的属性， </span></span><br><span class=\"line\"><span class=\"comment\">     * exclude 告诉我们不需要去转译\"node_modules\"这里面的文件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(js|jsx)?$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 开启缓存</span></span><br><span class=\"line\">        options: &#123; <span class=\"attr\">cacheDirectory</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来激动人心的时刻：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>是不是能打包成功了呢？</p>\n<p>打开【dist/】你的html页面，看一下是否是“Hello World！”吧！</p>\n<h3 id=\"使用webpack-merge🈴️\"><a href=\"#使用webpack-merge🈴️\" class=\"headerlink\" title=\"使用webpack-merge🈴️\"></a>使用webpack-merge🈴️</h3><p>我们将使用一个名为 <a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a> 的工具。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。简单来说就是生产环境不同，我们要给的配置也有所不同，但是可以共用一个共有的配置。</p>\n<p>我们先从安装 <a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a> 开始：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure>\n\n<p>安装结束之后，我们在 <code>config</code> 这个文件夹下新建两个文件，分别为 <code>webpack.prod.config.js</code> 和 <code>webpack.dev.config.js</code> ，这两个文件分别对应生产和开发两个环境的配置。当然你也可以添加test环境。名字也可以自己取，尽量保持一致。</p>\n<p>现在的目录结构：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  webpackInit</span><br><span class=\"line\">\t|- config</span><br><span class=\"line\">\t\t|- webpack</span><br><span class=\"line\">\t    |- webpack.common.config.js</span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.prod.config.js</span></span><br><span class=\"line\">  省略</span><br></pre></td></tr></table></figure>\n\n<p>在【webpack.prod.config.js】加入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后修改【package.json】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  \"name\": \"webpackInit\",</span><br><span class=\"line\">  \"version\": \"1.0.0\",</span><br><span class=\"line\">  \"description\": \"\",</span><br><span class=\"line\">  \"main\": \"index.js\",</span><br><span class=\"line\">  \"scripts\": &#123;</span><br><span class=\"line\">    \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",</span><br><span class=\"line\"><span class=\"addition\">+   \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"keywords\": [],</span><br><span class=\"line\">  \"author\": \"\",</span><br><span class=\"line\">  \"license\": \"ISC\",</span><br><span class=\"line\">  \"devDependencies\": &#123;</span><br><span class=\"line\">    \"@babel/core\": \"^7.10.2\",</span><br><span class=\"line\">    \"@babel/preset-env\": \"^7.10.2\",</span><br><span class=\"line\">    \"@babel/preset-react\": \"^7.10.1\",</span><br><span class=\"line\">    \"babel-loader\": \"^8.1.0\",</span><br><span class=\"line\">    \"babel-plugin-import\": \"^1.13.0\",</span><br><span class=\"line\">    \"webpack\": \"^4.43.0\",</span><br><span class=\"line\">    \"webpack-cli\": \"^3.3.11\",</span><br><span class=\"line\">    \"webpack-merge\": \"^4.2.2\"</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"dependencies\": &#123;</span><br><span class=\"line\">    \"react\": \"^16.13.1\",</span><br><span class=\"line\">    \"react-dom\": \"^16.13.1\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后</p>\n<p>删除【dist文件夹】</p>\n<p>之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>是不是也build也打包成功了！</p>\n<p>html是不是也可以正常访问！</p>\n<p>但是没有显示Hello World，仔细一看还报错了。。。为什么呢。。因为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span><br><span class=\"line\">    &#x2F;&#x2F; 8是hash的长度，如果不设置，webpack会设置默认值为20。</span><br><span class=\"line\">    filename: &#39;js&#x2F;[name].[chunkhash:8].bundle.js&#39;,</span><br></pre></td></tr></table></figure>\n\n<p>我们给js文件设置了hash值。不能够直接在html里面加上【<script src=\"../dist/js/bundle.js\"></script>】这么一句，而且每次生成的hash值都会变，那么我们要怎么处理这个问题呢？</p>\n<h3 id=\"使用HtmlWebpackPlugin\"><a href=\"#使用HtmlWebpackPlugin\" class=\"headerlink\" title=\"使用HtmlWebpackPlugin\"></a>使用<a href=\"https://www.webpackjs.com/plugins/html-webpack-plugin/\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a></h3><p>安装<a href=\"https://www.webpackjs.com/plugins/html-webpack-plugin/\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a></p>\n<p>在控制台执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.prod.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 打包之后的html文件名字</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span></span><br><span class=\"line\">      <span class=\"comment\">// 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span></span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>, <span class=\"comment\">// 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span></span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,<span class=\"comment\">// 在body最底部引入js文件，如果是head，就是在head中引入js</span></span><br><span class=\"line\">      minify: &#123; <span class=\"comment\">// 压缩html文件</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除注释</span></span><br><span class=\"line\">        collapseWhitespace: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除空格</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>现在我们再来打包试试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>看看dist中是不是多出了html文件，并且自动引入了script，用浏览器打开它试试看是不是能正确输出内容了！</p>\n<p>起飞！！🛫️</p>\n<h3 id=\"使用clean-webpack-plugin\"><a href=\"#使用clean-webpack-plugin\" class=\"headerlink\" title=\"使用clean-webpack-plugin\"></a>使用clean-webpack-plugin</h3><p>有些同学已经厌倦了每次都需要删除dist文件夹来验证是否成功。</p>\n<p>其实假如我们不删除的话，我们需要修改js文件，这样让webpack知道我们改了东西，他就会重新打包，但是我们每次测试都没有去修改，所以我们需要删除。</p>\n<p>但是，如果说我们不去删除dist文件夹的话，我们修改了【src/index.js】。然后再重新build，就会发现【dist/js】下面会又多出一个js文件，这样的话我们就需要观察日志，查看新鲜“出炉”的是哪一个，然后删掉别的。这样非常麻烦。</p>\n<p>OK，我们现在就来解决一下这个问题</p>\n<p>安装clean-webpack-plugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpck.prod.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const merge = require('webpack-merge'); // 版本为4.x</span><br><span class=\"line\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span><br><span class=\"line\">const common = require('./webpack.common.config.js');</span><br><span class=\"line\"></span><br><span class=\"line\">const HtmlWebpackPlugin = require('html-webpack-plugin');</span><br><span class=\"line\"><span class=\"addition\">+ const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');</span></span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: 'production',</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: 'index.html', // 打包之后的html文件名字</span><br><span class=\"line\">      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span><br><span class=\"line\">      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span><br><span class=\"line\">      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span><br><span class=\"line\">      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js</span><br><span class=\"line\">      minify: &#123; // 压缩html文件</span><br><span class=\"line\">        removeComments: true, // 去除注释</span><br><span class=\"line\">        collapseWhitespace: true, // 去除空格</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\"><span class=\"addition\">+   new CleanWebpackPlugin()</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们先查看现在的js文件前面的hash值。然后我们修改【src/index.js】，随便改成什么，再重新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>就会发现文件并没有新增，而且换了新鲜的哈希值。</p>\n<p>当然了，我之前说的那些话，同学不相信的话，可以把【new CleanWebpackPlugin()】这一行注释掉，然后再修改【src/index.js】，会发现【dist/js】下面的js文件会增多一条。</p>\n<h3 id=\"使用webpack-dev-server\"><a href=\"#使用webpack-dev-server\" class=\"headerlink\" title=\"使用webpack-dev-server\"></a>使用webpack-dev-server</h3><p>既然刚刚都提到优化了，我们每次都需要build一下，感觉很呆。而webpack官方也提供热部署，那我们现在就使用起来</p>\n<p>安装webpack-dev-server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>新建文件【webpack.dev.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  webpackInit</span><br><span class=\"line\">\t|- config</span><br><span class=\"line\">\t\t|- webpack</span><br><span class=\"line\">\t    |- webpack.common.config.js</span><br><span class=\"line\">      |- webpack.prod.config.js</span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.dev.config.js</span></span><br><span class=\"line\">  省略</span><br></pre></td></tr></table></figure>\n\n<p>然后加入如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[hash:8].bundle.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">    open: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    port: <span class=\"number\">9000</span>,</span><br><span class=\"line\">    compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,</span><br><span class=\"line\">      hash: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>修改文件【package.json】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\"><span class=\"deletion\">-   \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",</span></span><br><span class=\"line\"><span class=\"addition\">+   \"start\": \"webpack-dev-server --inline --config ./config/webpack/webpack.dev.config.js\",</span></span><br><span class=\"line\">    \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\",</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>然后我们</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>是不是自动开了一个端口为9000的网页，上面是我们写的页面内容，这和我们的配置都是一一对应的。<br>现在你随意修改index.js中的代码，再回到页面看下是不是也跟着变了，那我们就整合webpack-dev-server成功！</p>\n<h3 id=\"使用source-map\"><a href=\"#使用source-map\" class=\"headerlink\" title=\"使用source-map\"></a>使用source-map</h3><p>source-map可以展示我们代码的错误位置，因为我们的代码都是被webpack打包过的，只有机器看得懂，我们人类无法正常识别。所以需要他。</p>\n<p>想试一下未开启是什么状态的同学可以自己故意把代码写错，然后看看控制台的报错。</p>\n<p>开启也十分简单。</p>\n<p>它的配置非常简单，只需要在 【webpack.dev.config.js】 中增加一个 <code>devtool</code> 属性即可！</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"><span class=\"addition\">+  devtool: 'cheap-module-eval-source-map',</span></span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们只有自己写代码的时候才需要查看，到生产环境就要关闭啦，不然我们的智慧结晶就要被【窃取】啦！所以我放在了</p>\n<h2 id=\"中场休息\"><a href=\"#中场休息\" class=\"headerlink\" title=\"中场休息\"></a>中场休息</h2><p>这里回顾一下知识点。</p>\n<ol>\n<li>我们先npm init 新建一个空白项目。</li>\n<li>然后安装webpack，react。</li>\n<li>发现无法编译jsx。</li>\n<li>所以我们寻求了babel的帮助，并配置了所需要解析的内容。</li>\n<li>觉得在html里面加入js很呆，所以引入了HtmlWebpackPlugin</li>\n<li>因为觉得每次删除打包出来的东西很呆，所以引入了clean-webpack-plugin</li>\n<li>因为每次都需要重新打包，所以使用webpack-dev</li>\n<li>至于webpack-merge是为了打包和编译两个或者说多个状态做预备的，在上述的例子只有本地的dev和build两个环境。</li>\n</ol>\n<p>基本上上述的操作过程我都有解释，或者是注释，或者是在文章中说明。大家可以跟着节奏一步一步来，因为我也是一边写blog一边跑代码一边回顾知识点。</p>\n<p>至此，webpack算是告一……</p>\n<p>诶诶诶诶！js是可以解析了，那css呢！</p>\n<p>哦哦，好的，那我们继续启程</p>\n<h2 id=\"重新起航\"><a href=\"#重新起航\" class=\"headerlink\" title=\"重新起航\"></a>重新起航</h2><h3 id=\"使用css-loader和style-loader两兄弟\"><a href=\"#使用css-loader和style-loader两兄弟\" class=\"headerlink\" title=\"使用css-loader和style-loader两兄弟\"></a>使用css-loader和style-loader两兄弟</h3><p>假如我们直接引用css的话，会报错了。这里就不演示了，有兴趣的同学可以自己试试。</p>\n<p>所以，我们先走命令行敲击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"两兄弟的关系\"><a href=\"#两兄弟的关系\" class=\"headerlink\" title=\"两兄弟的关系\"></a>两兄弟的关系</h4><p>来说说css-loader和style-loader他们这对鸳鸯的关系。</p>\n<p>首先css-loader会把你的CSS文件进行解析，因为webpack是用JS写的，运行在node环境，所以默认webpack打包的时候只会处理JS之间的依赖关系！</p>\n<p>所以我们之前的react里面的jsx需要babel的帮助，或者说需要【babel-loader】的帮助，所以我们的css同样需要【css-loader】的帮助，那么又关【style-loader】什么事？可不可以不装他呢？</p>\n<p>答案是：可以的，但是你使用起来会非常的麻烦。怎么个麻烦法呢？</p>\n<p>如果只用了【css-loader】解析出来的是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.&#x2F;src&#x2F;index.css&quot;, &quot;.test&#123;↵  color: red;↵&#125;&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>这样咋用嘛，你是解析了，可是你解析的是个XX。</p>\n<p>这个时候就需要我们的天降猛男【style-loader】</p>\n<p>style-loader 是通过一个JS脚本创建一个style标签，里面包含一些样式。style-loader是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个loader的功能都是单一的，各自拆分独立。</p>\n<h4 id=\"上手！\"><a href=\"#上手！\" class=\"headerlink\" title=\"上手！\"></a>上手！</h4><p>加入index.css</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"><span class=\"addition\">+  |- index.css</span></span><br><span class=\"line\">   |- indexjs</span><br></pre></td></tr></table></figure>\n\n<p>index.css文件的内容如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;div className=<span class=\"string\">\"test\"</span>&gt;</span><br><span class=\"line\">    Hello World！!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(&lt;App /</span>&gt;, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//...</span><br><span class=\"line\">rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(js|jsx)?$/,</span><br><span class=\"line\">        // 开启缓存</span><br><span class=\"line\">        options: &#123; cacheDirectory: true &#125;,</span><br><span class=\"line\">        loader: 'babel-loader',</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.css$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: [ </span></span><br><span class=\"line\"><span class=\"addition\">+          'css-loader', </span></span><br><span class=\"line\"><span class=\"addition\">+          'style-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        ]</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">    //....</span><br></pre></td></tr></table></figure>\n\n<p>记得重新运行，因为webpack的配置他读取一次，所以如果你修改了配置，需要【ctrl+c】关闭重新运行。</p>\n<p>嘿嘿……是不是运行不了啊。</p>\n<p>其实我是故意的，我想告诉大家一个知识点。</p>\n<blockquote>\n<p>loader的加载顺序是从右往左。这里的编译顺序是先用css-loader将css代码编译，再交给style-loader插入到网页里面去。所以css-loader在右，style-loader在左。</p>\n</blockquote>\n<p>虽然我们的数组换行了，但是仔细看不难看出顺序。</p>\n<p>所以我们只需要将他们换个位置就可以了。代码我就不贴了。</p>\n<p>现在大家应该记忆很深刻了吧！</p>\n<p>大家重新【ctrl+c】关闭重新运行就行了。我们的hello world是不是变红啦～</p>\n<h3 id=\"安装less-loader\"><a href=\"#安装less-loader\" class=\"headerlink\" title=\"安装less-loader\"></a>安装less-loader</h3><p>说到css，说句实在话，没几人真的是在写纯css的吧？现在谁不是less，sass或者其他css预处理呢？而且这些预处理的好处我就不细说了，感兴趣的自己Google吧，本文用的是less（因为ant design用的也是less，哈哈，假装是蚂蚁的一员）</p>\n<p>在命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev less less-loader</span><br></pre></td></tr></table></figure>\n\n<p>less没什么好说的，用他肯定要装，less-loader，顾名思义，就是less的解析者。</p>\n<p>在【webpack.common.config.js】增加</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.less$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: [ </span></span><br><span class=\"line\"><span class=\"addition\">+          'style-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+          'css-loader', </span></span><br><span class=\"line\"><span class=\"addition\">+          'less-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        ]</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依旧是顺序问题，先解析less，把less解析成常规的css，然后再解析css，最后插入到网页中去。</p>\n<p>修改【index.js】引入自己写的【.less】文件</p>\n<p>大家重新【ctrl+c】关闭重新运行就行了。至于你写了什么less特性，只要有效果就行了。</p>\n<h3 id=\"安装url-loader和file-loader\"><a href=\"#安装url-loader和file-loader\" class=\"headerlink\" title=\"安装url-loader和file-loader\"></a>安装url-loader和file-loader</h3><p>说完CSS，美丽的网页当然离不开我们动人的图片啦。</p>\n<p>【file-loader】的作用是，把你的文件打包起来，和js文件放在一起，这样用户访问我们的网页的时候，其实也需要访问我们的url，既增加了服务器的压力，也增加了用户升级流量的压力，需要去下载这个文件。</p>\n<p>【url-loader】</p>\n<p>如果页面图片较多，发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl并将其打包到文件中，最终只需要引入这个dataURL就能访问图片了。</p>\n<p>url-loader和file-loader两兄弟的搭配可以有效的减少不必要的url请求，因为有的图片你要去请求url获取，如果小的话完全可以用base64替代。如果图片很大的话就用file-loader，这样可以减少编码的压力。</p>\n<p>在命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\"><span class=\"addition\">+    &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+      test: /\\.(jpg|png|gif)$/,</span></span><br><span class=\"line\"><span class=\"addition\">+      use: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        loader: 'url-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        options: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+          name: '[name].[ext]', //输出的文件名</span></span><br><span class=\"line\"><span class=\"addition\">+          outputPath: 'images/', // 输出到dist目录下的路径（dist/images/）</span></span><br><span class=\"line\">\t\t\t\t\t\t/**</span><br><span class=\"line\">             * 如果你这个图片文件大于8192b，即8kb，那我url-loader就不用，转而去使用file-loader，</span><br><span class=\"line\">             * 把图片正常打包成一个单独的图片文件到设置的目录下，若是小于了8kb，</span><br><span class=\"line\">             * 那好，我就将图片打包成base64的图片格式插入到bundle.js文件中，</span><br><span class=\"line\">             * 这样做的好处是，减少了http请求，但是如果文件过大，js文件也会过大，</span><br><span class=\"line\">             * 得不偿失，这是为什么有limit的原因！</span><br><span class=\"line\">             */</span><br><span class=\"line\"><span class=\"addition\">+          limit: 8192,</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br><span class=\"line\"><span class=\"addition\">+    &#125;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>基本上我们的webpack可以正常运行了，css，js，jsx都可以解析了。但是我们需要考虑一些进阶的东西，优化。</p>\n<h3 id=\"使用uglifyjs-webpack-plugin\"><a href=\"#使用uglifyjs-webpack-plugin\" class=\"headerlink\" title=\"使用uglifyjs-webpack-plugin\"></a>使用uglifyjs-webpack-plugin</h3><p>在控制台执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>在【webpack.prod.config.js】添加代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyJsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js(\\?.*)?$/i</span>,  <span class=\"comment\">//测试匹配文件,</span></span><br><span class=\"line\">        include: <span class=\"regexp\">/\\/includes/</span>, <span class=\"comment\">//包含哪些文件</span></span><br><span class=\"line\">        excluce: <span class=\"regexp\">/\\/excludes/</span>, <span class=\"comment\">//不包含哪些文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cache: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录</span></span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,  <span class=\"comment\">//使用多进程并行运行来提高构建速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 </span></span><br><span class=\"line\">        <span class=\"comment\">//返回true以uglify块，否则返回false。</span></span><br><span class=\"line\">        chunkFilter: <span class=\"function\">(<span class=\"params\">chunk</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `vendor` 模块不压缩</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chunk.name === <span class=\"string\">'vendor'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用splitChunks\"><a href=\"#使用splitChunks\" class=\"headerlink\" title=\"使用splitChunks\"></a>使用splitChunks</h3><p>其实我们写的代码，有些库的代码是不需要每次都编译的，最简单的例子就是React，这个我们几乎每个js文件都会用到。所以我们可以将它们单独打包，这样只需要打包一次。</p>\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">     index: './src/index.js',</span><br><span class=\"line\"><span class=\"addition\">+    common: ['react', 'react-dom']</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.prod.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; CleanWebpackPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyJsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 打包之后的html文件名字</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span></span><br><span class=\"line\">      <span class=\"comment\">// 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span></span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>, <span class=\"comment\">// 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span></span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,<span class=\"comment\">// 在body最底部引入js文件，如果是head，就是在head中引入js</span></span><br><span class=\"line\">      minify: &#123; <span class=\"comment\">// 压缩html文件</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除注释</span></span><br><span class=\"line\">        collapseWhitespace: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除空格</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js(\\?.*)?$/i</span>,  <span class=\"comment\">//测试匹配文件,</span></span><br><span class=\"line\">        <span class=\"comment\">// include: /\\/includes/, //包含哪些文件</span></span><br><span class=\"line\">        <span class=\"comment\">// excluce: /\\/excludes/, //不包含哪些文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 </span></span><br><span class=\"line\">        <span class=\"comment\">//返回true以uglify块，否则返回false。</span></span><br><span class=\"line\">        chunkFilter: <span class=\"function\">(<span class=\"params\">chunk</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `vendor` 模块不压缩</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chunk.name === <span class=\"string\">'vendor'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">        cache: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录</span></span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,  <span class=\"comment\">//使用多进程并行运行来提高构建速度</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 默认值是async</span></span><br><span class=\"line\"><span class=\"comment\">       * 拆分模块的范围，它有三个值async、initial和all。</span></span><br><span class=\"line\"><span class=\"comment\">       * async表示只从异步加载得模块（动态加载import()）里面进行拆分</span></span><br><span class=\"line\"><span class=\"comment\">       * initial表示只从入口模块进行拆分</span></span><br><span class=\"line\"><span class=\"comment\">       * all表示以上两者都包括</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      chunks: <span class=\"string\">'all'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// minSize: 30000, // 生成chunk的最小大小（以字节为单位）。只有大于这个数字才可以成一个chunk </span></span><br><span class=\"line\">      <span class=\"comment\">// minRemainingSize: 0, // 只有剩下一个chunk的时候才会生效，默认是和minSize一样的，开发的时候默认是0</span></span><br><span class=\"line\">      <span class=\"comment\">// maxSize: 0, // 告诉webpack尝试将大于maxSize字节的块拆分为较小的部分。</span></span><br><span class=\"line\">      <span class=\"comment\">// minChunks: 1, // 拆分前必须共享模块的最小块数。</span></span><br><span class=\"line\">      <span class=\"comment\">// maxAsyncRequests: 6, // 按需加载时最大并行请求数。</span></span><br><span class=\"line\">      <span class=\"comment\">// maxInitialRequests: 4, // 入口点的最大并行请求数。入口文件</span></span><br><span class=\"line\">      <span class=\"comment\">// automaticNameDelimiter: '~', // 默认情况下，webpack将使用块的来源和名称生成名称（例如vendors~main.js）。此选项使您可以指定用于生成名称的定界符。</span></span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 当webpack处理文件路径时，它们始终包含/在Unix系统和\\Windows上。</span></span><br><span class=\"line\"><span class=\"comment\">         * 这就是为什么[\\\\/]在&#123;cacheGroup&#125;.test字段中使用in 来表示路径分隔符的原因。</span></span><br><span class=\"line\"><span class=\"comment\">         * /或\\in &#123;cacheGroup&#125;.test会在跨平台使用时引起问题。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// defaultVendors: &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//   test: /[\\\\/]node_modules[\\\\/]/, // 分块目标</span></span><br><span class=\"line\">        <span class=\"comment\">//   priority: -10 // 权重</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">        <span class=\"comment\">// default: &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//   minChunks: 2, // 最小引用</span></span><br><span class=\"line\">        <span class=\"comment\">//   priority: -20, // 权重</span></span><br><span class=\"line\">        <span class=\"comment\">//   // 如果当前块包含已从主捆绑包中拆分出的模块，则将重用该模块，而不是生成新的模块。这可能会影响块的结果文件名。</span></span><br><span class=\"line\">        <span class=\"comment\">//   reuseExistingChunk: true</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">        <span class=\"comment\">// 上述的splitChunks全是webpack4未设置情况下的默认值，除了chunks从【async】-&gt;【all】其他都没有改</span></span><br><span class=\"line\">        <span class=\"comment\">// ok，我们现在加入我们自己想要的代码分割</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为我准备加入react等业务千变万化而不会变的库</span></span><br><span class=\"line\">        common: &#123;</span><br><span class=\"line\">          test: <span class=\"string\">\"common\"</span>, <span class=\"comment\">// webpack扫面的关键字</span></span><br><span class=\"line\">          name: <span class=\"string\">\"common\"</span>, <span class=\"comment\">// 生成的名字</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 是否缓存</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不想写diff啦，直接CV啦。。。</p>\n<p>为什么我需要把react提取出来，因为哪里都需要用，而且他几乎不可能会变，所以我特别提出来做了缓存，其余的还是使用的默认配置（除了chunk改为了‘all’）。</p>\n<blockquote>\n<p>Tobias Koppers@Wsokra：optimization. splitchunks. chunks: althe only option you need for vendor and commons splitting in webpackBest combine it with html-webpack-plugin or equivalent html generation18120</p>\n</blockquote>\n<p>作者都发推特说了，那我们也就接受吧～就改个all，然后补一下react～</p>\n<p>再重新打包，你会发现index.bundle.js（不被缓存）的hash值变了，但是common.bundle.js（能被缓存）的hash值没变。</p>\n<h3 id=\"使用mini-css-extract-plugin\"><a href=\"#使用mini-css-extract-plugin\" class=\"headerlink\" title=\"使用mini-css-extract-plugin\"></a>使用mini-css-extract-plugin</h3><p>js都独立📦，那我css也要！</p>\n<p>其实如果把CSS打包成一个文件然后让html引用的话可以减小html文件的大小，暗合了HTTP2的多路复用，多文件小数量。包括之前的splitChunks里面我们配置的react也是为了HTTP2。</p>\n<p>在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"addition\">+ const MiniCssExtractPlugin = require('mini-css-extract-plugin');</span></span><br><span class=\"line\"></span><br><span class=\"line\">//...</span><br><span class=\"line\">module:&#123;</span><br><span class=\"line\">    rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\"><span class=\"addition\">+          MiniCssExtractPlugin.loader,</span></span><br><span class=\"line\"><span class=\"deletion\">-          'style-loader',</span></span><br><span class=\"line\">           'css-loader', </span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"><span class=\"addition\">+plugins: [</span></span><br><span class=\"line\"><span class=\"addition\">+    new MiniCssExtractPlugin(&#123;</span></span><br><span class=\"line\"><span class=\"addition\">+      filename: 'css/[name].[hash].css',</span></span><br><span class=\"line\"><span class=\"addition\">+      chunkFilename: 'css/[id].[hash].css',</span></span><br><span class=\"line\"><span class=\"addition\">+    &#125;),</span></span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用CSS-Module\"><a href=\"#使用CSS-Module\" class=\"headerlink\" title=\"使用CSS Module\"></a>使用CSS Module</h3><p>其实很简单，只需要修改一下配置【wbpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          MiniCssExtractPlugin.loader,</span><br><span class=\"line\"><span class=\"deletion\">-          'css-loader'</span></span><br><span class=\"line\"><span class=\"addition\">+          &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            loader: 'css-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+            options: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+              // importLoaders: 1,</span></span><br><span class=\"line\"><span class=\"addition\">+              modules: true,</span></span><br><span class=\"line\"><span class=\"addition\">+            &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#125;,</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用PostCSS\"><a href=\"#使用PostCSS\" class=\"headerlink\" title=\"使用PostCSS\"></a>使用PostCSS</h3><blockquote>\n<p>postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如： 1 . 使用下一代css语法 2 . 自动补全浏览器前缀 3 . 自动把px代为转换成rem 4 . css 代码压缩等等 postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。</p>\n</blockquote>\n<p>安装postcss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>安装postcss某个插件，以Autoprefixer举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss-aspect-ratio-mini postcss-write-svg postcss-px-to-viewport postcss-viewport-units postcss-flexbugs-fixes postcss-preset-env cssnano --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>在根目标新建文件【postcss.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* eslint-disable import/no-extraneous-dependencies */</span></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable @typescript-eslint/no-var-requires */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssAspectRatioMini = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-aspect-ratio-mini'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssPxToViewport = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-px-to-viewport'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssWriteSvg = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-write-svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssViewportUnits = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-viewport-units'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">'cssnano'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssPresetEnv = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-preset-env'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssFlexbugsFixes = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-flexbugs-fixes'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    postcssFlexbugsFixes,</span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    postcssAspectRatioMini(&#123;&#125;),</span><br><span class=\"line\">    postcssPxToViewport(&#123;</span><br><span class=\"line\">      viewportWidth: <span class=\"number\">750</span>, <span class=\"comment\">// 基准宽度（一般的设计都是这个基准</span></span><br><span class=\"line\">      viewportHeight: <span class=\"number\">1334</span>, <span class=\"comment\">// 基准高度（一般的设计都是这个基准</span></span><br><span class=\"line\">      unitPrecision: <span class=\"number\">3</span>, <span class=\"comment\">// (Number) The decimal numbers to allow the REM units to grow to.</span></span><br><span class=\"line\">      viewportUnit: <span class=\"string\">'vw'</span>, <span class=\"comment\">// (String) 单位</span></span><br><span class=\"line\">      selectorBlackList: [<span class=\"string\">'.list-ignore'</span>, /notTransform/], <span class=\"comment\">// 带上这个单词的就不会fix为vw单位</span></span><br><span class=\"line\">      minPixelValue: <span class=\"number\">1</span>, <span class=\"comment\">// (Number) 最小像素</span></span><br><span class=\"line\">      mediaQuery: <span class=\"literal\">false</span>, <span class=\"comment\">// (Boolean) 允许在媒体查询中转换px。</span></span><br><span class=\"line\">      exclude: <span class=\"regexp\">/(\\/|\\\\)(node_modules)(\\/|\\\\)/</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    postcssWriteSvg(&#123;</span><br><span class=\"line\">      utf8: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    postcssPresetEnv(&#123;&#125;),</span><br><span class=\"line\">    postcssViewportUnits(&#123;</span><br><span class=\"line\">      filterRule: <span class=\"function\"><span class=\"params\">rule</span> =&gt;</span> rule.selector.includes(<span class=\"string\">'::after'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">'::before'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">':after'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">':before'</span>)</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    cssnano(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"cssnano-preset-advanced\"</span>: &#123;</span><br><span class=\"line\">        zindex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        autoprefixer: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\"><span class=\"addition\">+          'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\">          'less-loader',</span><br><span class=\"line\"><span class=\"addition\">+          'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，修改我们的css文件，看看我们写的单位为px的有没有被改为vw的自适应单位。</p>\n<p>顺便试一下带有【notTransform】的是不是还是px作为单位。</p>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>到此，我们的webpack配置，就算是入门了，对于webpack的配置我们还有很长的路要走。大家加油！</p>\n<p>如果有哪里写的不好或者写错了，欢迎大家在评论区讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"从零配置你的Webpack\"><a href=\"#从零配置你的Webpack\" class=\"headerlink\" title=\"从零配置你的Webpack\"></a>从零配置你的Webpack</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章简单的介绍了一下，前端进阶之脚手架的搭建。其实我个人认为重要的还是Webpack的配置出来的template，至于脚手架的交互体验可以后期去优化，也可以更加的个性化。但是我们的核心还是放在Webpack等一系列的配置上。</p>\n<p>这篇文章的目的</p>\n<ul>\n<li>可以给自己一个回顾的地方</li>\n<li>加强对Webpack的理解，每个知识点都会认认真真的彻查！尽量让每一步都是非常清晰明了的！</li>\n<li>如果可以帮助到大家那是更好不过了</li>\n</ul>\n<p>好了，收！话不多说开始！</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>相信来到这里的小伙伴，都是有一些些前端的经验了，至于什么node安装环境变量这里就不赘述了。本人使用的是mac os，如果是Windows的并且碰到问题的话，可以留言，或者直接Google。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"建立一个空的文件夹📁\"><a href=\"#建立一个空的文件夹📁\" class=\"headerlink\" title=\"建立一个空的文件夹📁\"></a>建立一个空的文件夹📁</h3><p>新建一个文件夹，名为【webpackInit】</p>\n<p>并且使用你的编辑器打开他，然后打开命令行执行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n\n<p>这个命令是node帮你初始化一个项目用的，帮你新建一个<code>package.json</code>。</p>\n<p>至于<code>-y</code>是用于默认都以<strong>yes</strong>继续执行。如果想了解一下里面到底有什么的同学可以不用<em>-y</em>继续跑一遍。其实里面的东西后期都可以自己修改<code>package.json</code>。所以不需要太在意。</p>\n<h3 id=\"安装Webpack🔧\"><a href=\"#安装Webpack🔧\" class=\"headerlink\" title=\"安装Webpack🔧\"></a>安装Webpack🔧</h3><p>现在是北京时间：2020/06/07 06:42:49。</p>\n<p>Webpack5有Beta版，这里就不考虑了，后续上正式版的话我应该会出新的文章介绍。</p>\n<p>因为我们使用的是 <code>webpack 4+</code> 版本，还需要安装 <code>webpack-cli</code> ，执行以下命令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure>\n\n<p>因为Webpack主要是编译时使用所以放到“devDependencies”。</p>\n<p>确认一下现在的目录结构，以防有同学掉队！</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\">  |- package-lock.json</span><br><span class=\"line\">  |- package.json</span><br></pre></td></tr></table></figure>\n\n<p>这里说下题外话。</p>\n<h5 id=\"package-json和package-lock-json的区别\"><a href=\"#package-json和package-lock-json的区别\" class=\"headerlink\" title=\"package.json和package-lock.json的区别\"></a>package.json和package-lock.json的区别</h5><p>package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，<code>npm install</code> 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。</p>\n<p>那如果我们安装时的包有bug，后面需要更新怎么办？</p>\n<p>在以前可能就是直接改 package.json 里面的版本，然后再 <code>npm install</code> 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 <code>npm install xxx@x.x.x</code> 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。</p>\n<h3 id=\"新建配置文件📃\"><a href=\"#新建配置文件📃\" class=\"headerlink\" title=\"新建配置文件📃\"></a>新建配置文件📃</h3><p>我们在根目录新建文件夹【config】用于存储一些相关的配置文件，然后在【config】里面新建一个文件夹【webpack】表示，专门用于存储webpack的配置文件。然后在【webpack】这个文件夹下面新建文件【webpack.common.config.js】</p>\n<p>并敲入以下代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 打包📦之后的出口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span></span><br><span class=\"line\">    <span class=\"comment\">// 8是hash的长度，如果不设置，webpack会设置默认值为20。</span></span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[chunkhash:8].bundle.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。</span></span><br><span class=\"line\"><span class=\"comment\">     * path.resolve</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果传入的绝对路径不存在，那么当前目录将被使用</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.当传入的参数没有/时，将被传入解析到当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * 5.零长度的路径将被忽略</span></span><br><span class=\"line\"><span class=\"comment\">     * 6.如果没有传入参数，将返回当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * _dirname表示绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 我们碰到的./xx就是相对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.只传入__dirname也可以自动调用path.resolve方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.__dirname代表的是当前文件（a.js）的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.从右至左解析，遇到了绝对路径/src，因此直接返</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>webpack 配置是标准的 Node.js的CommonJS 模块，它通过require来引入其他模块，通过module.exports导出模块，由 webpack 根据对象定义的属性进行解析。</p>\n</blockquote>\n<p>在根目录新建【src】文件夹📁</p>\n<p>在【src】文件夹下新建文件index.js</p>\n<p>ok👌，确认一下目录结构</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\"><span class=\"addition\">+ |- config</span></span><br><span class=\"line\"><span class=\"addition\">+ \t|- webpack</span></span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.common.config.js</span></span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\"><span class=\"addition\">+ |- src</span></span><br><span class=\"line\"><span class=\"addition\">+     |- index.js</span></span><br><span class=\"line\">  |- package.json</span><br><span class=\"line\">  |- package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>那我们怎么打包呢？在 <code>package.json</code> 中配置如下属性：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\"><span class=\"deletion\">- \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",</span></span><br><span class=\"line\"><span class=\"addition\">+ \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>好了，我们试试怎么打包吧，虽然你的 <code>index.js</code> 中什么代码也没有。<br>在控制台中输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>npm run xxxx 会去执行当前目录下package.json里面的script同名脚本</p>\n<p>我们的【npm run start】相当于直接执行了我们写在【start】里面的代码。</p>\n<p>执行之后，你会发现根目录多出了一个文件夹： <code>dist/js</code> ，其中有一个js文件： <code>bundle.js</code> ，那么至此，我们已经成功编译打包了一个js文件，即入口文件： <code>index.js</code> 。</p>\n<h3 id=\"安装React\"><a href=\"#安装React\" class=\"headerlink\" title=\"安装React\"></a>安装React</h3><p>在控制台输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react react-dom</span><br></pre></td></tr></table></figure>\n\n<p>–save就是运行时会用到的代码</p>\n<p>具体和–dev-save的区别可以自己Google一下</p>\n<p>在【src/index.js】里面加入以下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;&gt;</span><br><span class=\"line\">    Hello World！</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(&lt;App /</span>&gt;, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>在根目录加入文件夹【public】，然后在【public】里面加入【index.html】</p>\n<p>目录如下：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackInit</span><br><span class=\"line\"><span class=\"addition\">+ |- public</span></span><br><span class=\"line\"><span class=\"addition\">+ \t|- index.html</span></span><br><span class=\"line\">  |- config</span><br><span class=\"line\">  \t|- webpack</span><br><span class=\"line\">      |- webpack.common.config.js</span><br><span class=\"line\">  |- node_modules</span><br><span class=\"line\">  |- src</span><br><span class=\"line\">      |- index.js</span><br><span class=\"line\">  |- package.json</span><br><span class=\"line\">  |- package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>然后在【index.html】加入以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"initial-scale=1.0, user-scalable=no, width=device-width\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>从零配置Webpack<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>OK</p>\n<p>万事俱备，我们运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>打包失败了。。。为什么呢？</p>\n<h3 id=\"使用babel\"><a href=\"#使用babel\" class=\"headerlink\" title=\"使用babel\"></a>使用babel</h3><p>为什么我们上面写jsx会打包不了呢，因为webpack根本识别不了jsx语法，那怎么办？使用loader对文件进行预处理。<br>其中，babel-loader，就是这样一个预处理插件，它加载 ES2015+ 代码，然后使用 Babel 转译为 ES5。那开始配置它吧！</p>\n<p>首先安装babel相关的模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev babel-loader @babel&#x2F;preset-react @babel&#x2F;preset-env @babel&#x2F;core babel-plugin-import</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>babel-loader：</strong>使用Babel和webpack来转译JavaScript文件。</li>\n<li><strong>@babel/preset-react：</strong>转译react的JSX</li>\n<li><strong>@babel/preset-env：</strong>转译ES2015+的语法</li>\n<li><strong>@babel/core：</strong>babel的核心模块</li>\n<li><strong>babel-plugin-import</strong>：按需加载所需要的babel解析</li>\n</ul>\n<p>理论上我们可以直接在 <code>webpack.common.config.js</code> 中配置”options”，但最好在当前根目录，注意，一定要是根目录！！！ 新建一个配置文件 <code>.babelrc</code> 配置相关的”presets”：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/preset-env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"targets\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 大于相关浏览器版本无需用到 preset-env</span></span><br><span class=\"line\">          <span class=\"string\">\"edge\"</span>: <span class=\"number\">17</span>,</span><br><span class=\"line\">          <span class=\"string\">\"firefox\"</span>: <span class=\"number\">60</span>,</span><br><span class=\"line\">          <span class=\"string\">\"chrome\"</span>: <span class=\"number\">67</span>,</span><br><span class=\"line\">          <span class=\"string\">\"safari\"</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 兼容到android4 ios6</span></span><br><span class=\"line\">          <span class=\"string\">\"browsers\"</span>: [<span class=\"string\">\"Android &gt;= 4.0\"</span>, <span class=\"string\">\"ios &gt;= 6\"</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-react\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"import\"</span>, &#123; <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"antd-mobile\"</span>, <span class=\"string\">\"style\"</span>: <span class=\"string\">\"css\"</span> &#125;] <span class=\"comment\">// `style: true` 会加载 less 文件</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有关<a href=\"https://www.babeljs.cn/docs/babel-preset-env\" target=\"_blank\" rel=\"noopener\">bebel的配置</a>可上官网查询文档。</p>\n<p>再修改 <code>webpack.common.config.js</code> ，添加如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 打包📦之后的出口</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span></span><br><span class=\"line\">    <span class=\"comment\">// 8是hash的长度，如果不设置，webpack会设置默认值为20。</span></span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[chunkhash:8].bundle.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。</span></span><br><span class=\"line\"><span class=\"comment\">     * path.resolve</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.path.resolve()方法可以将路径或者路径片段解析成绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.传入路径从右至左解析，遇到第一个绝对路径是完成解析，例如path.resolve('/foo', '/bar', 'baz') 将返回 /bar/baz</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果传入的绝对路径不存在，那么当前目录将被使用</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.当传入的参数没有/时，将被传入解析到当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * 5.零长度的路径将被忽略</span></span><br><span class=\"line\"><span class=\"comment\">     * 6.如果没有传入参数，将返回当前根目录</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * _dirname表示绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 我们碰到的./xx就是相对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.只传入__dirname也可以自动调用path.resolve方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.可以拼接路径字符串，但是不调用path.resolve()方法拼接失败</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.__dirname代表的是当前文件（a.js）的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.从右至左解析，遇到了绝对路径/src，因此直接返</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * test 规定了作用于以规则中匹配到的后缀结尾的文件， </span></span><br><span class=\"line\"><span class=\"comment\">     * use 即是使用 babel-loader 必须的属性， </span></span><br><span class=\"line\"><span class=\"comment\">     * exclude 告诉我们不需要去转译\"node_modules\"这里面的文件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(js|jsx)?$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 开启缓存</span></span><br><span class=\"line\">        options: &#123; <span class=\"attr\">cacheDirectory</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来激动人心的时刻：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>是不是能打包成功了呢？</p>\n<p>打开【dist/】你的html页面，看一下是否是“Hello World！”吧！</p>\n<h3 id=\"使用webpack-merge🈴️\"><a href=\"#使用webpack-merge🈴️\" class=\"headerlink\" title=\"使用webpack-merge🈴️\"></a>使用webpack-merge🈴️</h3><p>我们将使用一个名为 <a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a> 的工具。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。简单来说就是生产环境不同，我们要给的配置也有所不同，但是可以共用一个共有的配置。</p>\n<p>我们先从安装 <a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a> 开始：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure>\n\n<p>安装结束之后，我们在 <code>config</code> 这个文件夹下新建两个文件，分别为 <code>webpack.prod.config.js</code> 和 <code>webpack.dev.config.js</code> ，这两个文件分别对应生产和开发两个环境的配置。当然你也可以添加test环境。名字也可以自己取，尽量保持一致。</p>\n<p>现在的目录结构：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  webpackInit</span><br><span class=\"line\">\t|- config</span><br><span class=\"line\">\t\t|- webpack</span><br><span class=\"line\">\t    |- webpack.common.config.js</span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.prod.config.js</span></span><br><span class=\"line\">  省略</span><br></pre></td></tr></table></figure>\n\n<p>在【webpack.prod.config.js】加入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后修改【package.json】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  \"name\": \"webpackInit\",</span><br><span class=\"line\">  \"version\": \"1.0.0\",</span><br><span class=\"line\">  \"description\": \"\",</span><br><span class=\"line\">  \"main\": \"index.js\",</span><br><span class=\"line\">  \"scripts\": &#123;</span><br><span class=\"line\">    \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",</span><br><span class=\"line\"><span class=\"addition\">+   \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"keywords\": [],</span><br><span class=\"line\">  \"author\": \"\",</span><br><span class=\"line\">  \"license\": \"ISC\",</span><br><span class=\"line\">  \"devDependencies\": &#123;</span><br><span class=\"line\">    \"@babel/core\": \"^7.10.2\",</span><br><span class=\"line\">    \"@babel/preset-env\": \"^7.10.2\",</span><br><span class=\"line\">    \"@babel/preset-react\": \"^7.10.1\",</span><br><span class=\"line\">    \"babel-loader\": \"^8.1.0\",</span><br><span class=\"line\">    \"babel-plugin-import\": \"^1.13.0\",</span><br><span class=\"line\">    \"webpack\": \"^4.43.0\",</span><br><span class=\"line\">    \"webpack-cli\": \"^3.3.11\",</span><br><span class=\"line\">    \"webpack-merge\": \"^4.2.2\"</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"dependencies\": &#123;</span><br><span class=\"line\">    \"react\": \"^16.13.1\",</span><br><span class=\"line\">    \"react-dom\": \"^16.13.1\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后</p>\n<p>删除【dist文件夹】</p>\n<p>之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>是不是也build也打包成功了！</p>\n<p>html是不是也可以正常访问！</p>\n<p>但是没有显示Hello World，仔细一看还报错了。。。为什么呢。。因为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 如果不加哈希值，浏览器会有缓存，可能你部署了，但是用户看到的还是老页面</span><br><span class=\"line\">    &#x2F;&#x2F; 8是hash的长度，如果不设置，webpack会设置默认值为20。</span><br><span class=\"line\">    filename: &#39;js&#x2F;[name].[chunkhash:8].bundle.js&#39;,</span><br></pre></td></tr></table></figure>\n\n<p>我们给js文件设置了hash值。不能够直接在html里面加上【<script src=\"../dist/js/bundle.js\"></script>】这么一句，而且每次生成的hash值都会变，那么我们要怎么处理这个问题呢？</p>\n<h3 id=\"使用HtmlWebpackPlugin\"><a href=\"#使用HtmlWebpackPlugin\" class=\"headerlink\" title=\"使用HtmlWebpackPlugin\"></a>使用<a href=\"https://www.webpackjs.com/plugins/html-webpack-plugin/\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a></h3><p>安装<a href=\"https://www.webpackjs.com/plugins/html-webpack-plugin/\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a></p>\n<p>在控制台执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.prod.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 打包之后的html文件名字</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span></span><br><span class=\"line\">      <span class=\"comment\">// 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span></span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>, <span class=\"comment\">// 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span></span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,<span class=\"comment\">// 在body最底部引入js文件，如果是head，就是在head中引入js</span></span><br><span class=\"line\">      minify: &#123; <span class=\"comment\">// 压缩html文件</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除注释</span></span><br><span class=\"line\">        collapseWhitespace: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除空格</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>现在我们再来打包试试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>看看dist中是不是多出了html文件，并且自动引入了script，用浏览器打开它试试看是不是能正确输出内容了！</p>\n<p>起飞！！🛫️</p>\n<h3 id=\"使用clean-webpack-plugin\"><a href=\"#使用clean-webpack-plugin\" class=\"headerlink\" title=\"使用clean-webpack-plugin\"></a>使用clean-webpack-plugin</h3><p>有些同学已经厌倦了每次都需要删除dist文件夹来验证是否成功。</p>\n<p>其实假如我们不删除的话，我们需要修改js文件，这样让webpack知道我们改了东西，他就会重新打包，但是我们每次测试都没有去修改，所以我们需要删除。</p>\n<p>但是，如果说我们不去删除dist文件夹的话，我们修改了【src/index.js】。然后再重新build，就会发现【dist/js】下面会又多出一个js文件，这样的话我们就需要观察日志，查看新鲜“出炉”的是哪一个，然后删掉别的。这样非常麻烦。</p>\n<p>OK，我们现在就来解决一下这个问题</p>\n<p>安装clean-webpack-plugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpck.prod.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const merge = require('webpack-merge'); // 版本为4.x</span><br><span class=\"line\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span><br><span class=\"line\">const common = require('./webpack.common.config.js');</span><br><span class=\"line\"></span><br><span class=\"line\">const HtmlWebpackPlugin = require('html-webpack-plugin');</span><br><span class=\"line\"><span class=\"addition\">+ const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');</span></span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: 'production',</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: 'index.html', // 打包之后的html文件名字</span><br><span class=\"line\">      // 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span><br><span class=\"line\">      // 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span><br><span class=\"line\">      template: 'public/index.html', // 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span><br><span class=\"line\">      inject: 'body',// 在body最底部引入js文件，如果是head，就是在head中引入js</span><br><span class=\"line\">      minify: &#123; // 压缩html文件</span><br><span class=\"line\">        removeComments: true, // 去除注释</span><br><span class=\"line\">        collapseWhitespace: true, // 去除空格</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\"><span class=\"addition\">+   new CleanWebpackPlugin()</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们先查看现在的js文件前面的hash值。然后我们修改【src/index.js】，随便改成什么，再重新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>就会发现文件并没有新增，而且换了新鲜的哈希值。</p>\n<p>当然了，我之前说的那些话，同学不相信的话，可以把【new CleanWebpackPlugin()】这一行注释掉，然后再修改【src/index.js】，会发现【dist/js】下面的js文件会增多一条。</p>\n<h3 id=\"使用webpack-dev-server\"><a href=\"#使用webpack-dev-server\" class=\"headerlink\" title=\"使用webpack-dev-server\"></a>使用webpack-dev-server</h3><p>既然刚刚都提到优化了，我们每次都需要build一下，感觉很呆。而webpack官方也提供热部署，那我们现在就使用起来</p>\n<p>安装webpack-dev-server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>新建文件【webpack.dev.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  webpackInit</span><br><span class=\"line\">\t|- config</span><br><span class=\"line\">\t\t|- webpack</span><br><span class=\"line\">\t    |- webpack.common.config.js</span><br><span class=\"line\">      |- webpack.prod.config.js</span><br><span class=\"line\"><span class=\"addition\">+     |- webpack.dev.config.js</span></span><br><span class=\"line\">  省略</span><br></pre></td></tr></table></figure>\n\n<p>然后加入如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'js/[name].[hash:8].bundle.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">    open: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    port: <span class=\"number\">9000</span>,</span><br><span class=\"line\">    compress: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,</span><br><span class=\"line\">      hash: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>修改文件【package.json】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\"><span class=\"deletion\">-   \"start\": \"webpack --config ./config/webpack/webpack.common.config.js\",</span></span><br><span class=\"line\"><span class=\"addition\">+   \"start\": \"webpack-dev-server --inline --config ./config/webpack/webpack.dev.config.js\",</span></span><br><span class=\"line\">    \"build\": \"webpack --config ./config/webpack/webpack.prod.config.js\",</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>然后我们</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>是不是自动开了一个端口为9000的网页，上面是我们写的页面内容，这和我们的配置都是一一对应的。<br>现在你随意修改index.js中的代码，再回到页面看下是不是也跟着变了，那我们就整合webpack-dev-server成功！</p>\n<h3 id=\"使用source-map\"><a href=\"#使用source-map\" class=\"headerlink\" title=\"使用source-map\"></a>使用source-map</h3><p>source-map可以展示我们代码的错误位置，因为我们的代码都是被webpack打包过的，只有机器看得懂，我们人类无法正常识别。所以需要他。</p>\n<p>想试一下未开启是什么状态的同学可以自己故意把代码写错，然后看看控制台的报错。</p>\n<p>开启也十分简单。</p>\n<p>它的配置非常简单，只需要在 【webpack.dev.config.js】 中增加一个 <code>devtool</code> 属性即可！</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"><span class=\"addition\">+  devtool: 'cheap-module-eval-source-map',</span></span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们只有自己写代码的时候才需要查看，到生产环境就要关闭啦，不然我们的智慧结晶就要被【窃取】啦！所以我放在了</p>\n<h2 id=\"中场休息\"><a href=\"#中场休息\" class=\"headerlink\" title=\"中场休息\"></a>中场休息</h2><p>这里回顾一下知识点。</p>\n<ol>\n<li>我们先npm init 新建一个空白项目。</li>\n<li>然后安装webpack，react。</li>\n<li>发现无法编译jsx。</li>\n<li>所以我们寻求了babel的帮助，并配置了所需要解析的内容。</li>\n<li>觉得在html里面加入js很呆，所以引入了HtmlWebpackPlugin</li>\n<li>因为觉得每次删除打包出来的东西很呆，所以引入了clean-webpack-plugin</li>\n<li>因为每次都需要重新打包，所以使用webpack-dev</li>\n<li>至于webpack-merge是为了打包和编译两个或者说多个状态做预备的，在上述的例子只有本地的dev和build两个环境。</li>\n</ol>\n<p>基本上上述的操作过程我都有解释，或者是注释，或者是在文章中说明。大家可以跟着节奏一步一步来，因为我也是一边写blog一边跑代码一边回顾知识点。</p>\n<p>至此，webpack算是告一……</p>\n<p>诶诶诶诶！js是可以解析了，那css呢！</p>\n<p>哦哦，好的，那我们继续启程</p>\n<h2 id=\"重新起航\"><a href=\"#重新起航\" class=\"headerlink\" title=\"重新起航\"></a>重新起航</h2><h3 id=\"使用css-loader和style-loader两兄弟\"><a href=\"#使用css-loader和style-loader两兄弟\" class=\"headerlink\" title=\"使用css-loader和style-loader两兄弟\"></a>使用css-loader和style-loader两兄弟</h3><p>假如我们直接引用css的话，会报错了。这里就不演示了，有兴趣的同学可以自己试试。</p>\n<p>所以，我们先走命令行敲击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"两兄弟的关系\"><a href=\"#两兄弟的关系\" class=\"headerlink\" title=\"两兄弟的关系\"></a>两兄弟的关系</h4><p>来说说css-loader和style-loader他们这对鸳鸯的关系。</p>\n<p>首先css-loader会把你的CSS文件进行解析，因为webpack是用JS写的，运行在node环境，所以默认webpack打包的时候只会处理JS之间的依赖关系！</p>\n<p>所以我们之前的react里面的jsx需要babel的帮助，或者说需要【babel-loader】的帮助，所以我们的css同样需要【css-loader】的帮助，那么又关【style-loader】什么事？可不可以不装他呢？</p>\n<p>答案是：可以的，但是你使用起来会非常的麻烦。怎么个麻烦法呢？</p>\n<p>如果只用了【css-loader】解析出来的是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.&#x2F;src&#x2F;index.css&quot;, &quot;.test&#123;↵  color: red;↵&#125;&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>这样咋用嘛，你是解析了，可是你解析的是个XX。</p>\n<p>这个时候就需要我们的天降猛男【style-loader】</p>\n<p>style-loader 是通过一个JS脚本创建一个style标签，里面包含一些样式。style-loader是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个loader的功能都是单一的，各自拆分独立。</p>\n<h4 id=\"上手！\"><a href=\"#上手！\" class=\"headerlink\" title=\"上手！\"></a>上手！</h4><p>加入index.css</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"><span class=\"addition\">+  |- index.css</span></span><br><span class=\"line\">   |- indexjs</span><br></pre></td></tr></table></figure>\n\n<p>index.css文件的内容如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;div className=<span class=\"string\">\"test\"</span>&gt;</span><br><span class=\"line\">    Hello World！!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(&lt;App /</span>&gt;, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//...</span><br><span class=\"line\">rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(js|jsx)?$/,</span><br><span class=\"line\">        // 开启缓存</span><br><span class=\"line\">        options: &#123; cacheDirectory: true &#125;,</span><br><span class=\"line\">        loader: 'babel-loader',</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.css$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: [ </span></span><br><span class=\"line\"><span class=\"addition\">+          'css-loader', </span></span><br><span class=\"line\"><span class=\"addition\">+          'style-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        ]</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">    //....</span><br></pre></td></tr></table></figure>\n\n<p>记得重新运行，因为webpack的配置他读取一次，所以如果你修改了配置，需要【ctrl+c】关闭重新运行。</p>\n<p>嘿嘿……是不是运行不了啊。</p>\n<p>其实我是故意的，我想告诉大家一个知识点。</p>\n<blockquote>\n<p>loader的加载顺序是从右往左。这里的编译顺序是先用css-loader将css代码编译，再交给style-loader插入到网页里面去。所以css-loader在右，style-loader在左。</p>\n</blockquote>\n<p>虽然我们的数组换行了，但是仔细看不难看出顺序。</p>\n<p>所以我们只需要将他们换个位置就可以了。代码我就不贴了。</p>\n<p>现在大家应该记忆很深刻了吧！</p>\n<p>大家重新【ctrl+c】关闭重新运行就行了。我们的hello world是不是变红啦～</p>\n<h3 id=\"安装less-loader\"><a href=\"#安装less-loader\" class=\"headerlink\" title=\"安装less-loader\"></a>安装less-loader</h3><p>说到css，说句实在话，没几人真的是在写纯css的吧？现在谁不是less，sass或者其他css预处理呢？而且这些预处理的好处我就不细说了，感兴趣的自己Google吧，本文用的是less（因为ant design用的也是less，哈哈，假装是蚂蚁的一员）</p>\n<p>在命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev less less-loader</span><br></pre></td></tr></table></figure>\n\n<p>less没什么好说的，用他肯定要装，less-loader，顾名思义，就是less的解析者。</p>\n<p>在【webpack.common.config.js】增加</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.less$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: [ </span></span><br><span class=\"line\"><span class=\"addition\">+          'style-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+          'css-loader', </span></span><br><span class=\"line\"><span class=\"addition\">+          'less-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        ]</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依旧是顺序问题，先解析less，把less解析成常规的css，然后再解析css，最后插入到网页中去。</p>\n<p>修改【index.js】引入自己写的【.less】文件</p>\n<p>大家重新【ctrl+c】关闭重新运行就行了。至于你写了什么less特性，只要有效果就行了。</p>\n<h3 id=\"安装url-loader和file-loader\"><a href=\"#安装url-loader和file-loader\" class=\"headerlink\" title=\"安装url-loader和file-loader\"></a>安装url-loader和file-loader</h3><p>说完CSS，美丽的网页当然离不开我们动人的图片啦。</p>\n<p>【file-loader】的作用是，把你的文件打包起来，和js文件放在一起，这样用户访问我们的网页的时候，其实也需要访问我们的url，既增加了服务器的压力，也增加了用户升级流量的压力，需要去下载这个文件。</p>\n<p>【url-loader】</p>\n<p>如果页面图片较多，发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl并将其打包到文件中，最终只需要引入这个dataURL就能访问图片了。</p>\n<p>url-loader和file-loader两兄弟的搭配可以有效的减少不必要的url请求，因为有的图片你要去请求url获取，如果小的话完全可以用base64替代。如果图片很大的话就用file-loader，这样可以减少编码的压力。</p>\n<p>在命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】📃</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\"><span class=\"addition\">+    &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+      test: /\\.(jpg|png|gif)$/,</span></span><br><span class=\"line\"><span class=\"addition\">+      use: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        loader: 'url-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+        options: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+          name: '[name].[ext]', //输出的文件名</span></span><br><span class=\"line\"><span class=\"addition\">+          outputPath: 'images/', // 输出到dist目录下的路径（dist/images/）</span></span><br><span class=\"line\">\t\t\t\t\t\t/**</span><br><span class=\"line\">             * 如果你这个图片文件大于8192b，即8kb，那我url-loader就不用，转而去使用file-loader，</span><br><span class=\"line\">             * 把图片正常打包成一个单独的图片文件到设置的目录下，若是小于了8kb，</span><br><span class=\"line\">             * 那好，我就将图片打包成base64的图片格式插入到bundle.js文件中，</span><br><span class=\"line\">             * 这样做的好处是，减少了http请求，但是如果文件过大，js文件也会过大，</span><br><span class=\"line\">             * 得不偿失，这是为什么有limit的原因！</span><br><span class=\"line\">             */</span><br><span class=\"line\"><span class=\"addition\">+          limit: 8192,</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br><span class=\"line\"><span class=\"addition\">+    &#125;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>基本上我们的webpack可以正常运行了，css，js，jsx都可以解析了。但是我们需要考虑一些进阶的东西，优化。</p>\n<h3 id=\"使用uglifyjs-webpack-plugin\"><a href=\"#使用uglifyjs-webpack-plugin\" class=\"headerlink\" title=\"使用uglifyjs-webpack-plugin\"></a>使用uglifyjs-webpack-plugin</h3><p>在控制台执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>在【webpack.prod.config.js】添加代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyJsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js(\\?.*)?$/i</span>,  <span class=\"comment\">//测试匹配文件,</span></span><br><span class=\"line\">        include: <span class=\"regexp\">/\\/includes/</span>, <span class=\"comment\">//包含哪些文件</span></span><br><span class=\"line\">        excluce: <span class=\"regexp\">/\\/excludes/</span>, <span class=\"comment\">//不包含哪些文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cache: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录</span></span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,  <span class=\"comment\">//使用多进程并行运行来提高构建速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 </span></span><br><span class=\"line\">        <span class=\"comment\">//返回true以uglify块，否则返回false。</span></span><br><span class=\"line\">        chunkFilter: <span class=\"function\">(<span class=\"params\">chunk</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `vendor` 模块不压缩</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chunk.name === <span class=\"string\">'vendor'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用splitChunks\"><a href=\"#使用splitChunks\" class=\"headerlink\" title=\"使用splitChunks\"></a>使用splitChunks</h3><p>其实我们写的代码，有些库的代码是不需要每次都编译的，最简单的例子就是React，这个我们几乎每个js文件都会用到。所以我们可以将它们单独打包，这样只需要打包一次。</p>\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">     index: './src/index.js',</span><br><span class=\"line\"><span class=\"addition\">+    common: ['react', 'react-dom']</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.prod.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>); <span class=\"comment\">// 版本为4.x</span></span><br><span class=\"line\"><span class=\"comment\">// webpack-merge 5.x版本应该改为 const &#123; merge &#125; = require('webpack-merge');</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.common.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; CleanWebpackPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyJsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(common, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 打包之后的html文件名字</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里有小伙伴可能会疑惑为什么不是 '../public/index.html'</span></span><br><span class=\"line\">      <span class=\"comment\">// 我的理解是无论与要用的template是不是在一个目录，都是从根路径开始查找</span></span><br><span class=\"line\">      template: <span class=\"string\">'public/index.html'</span>, <span class=\"comment\">// 以我们自己定义的html为模板生成，不然我们还要到打包之后的html文件中写script</span></span><br><span class=\"line\">      inject: <span class=\"string\">'body'</span>,<span class=\"comment\">// 在body最底部引入js文件，如果是head，就是在head中引入js</span></span><br><span class=\"line\">      minify: &#123; <span class=\"comment\">// 压缩html文件</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除注释</span></span><br><span class=\"line\">        collapseWhitespace: <span class=\"literal\">true</span>, <span class=\"comment\">// 去除空格</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js(\\?.*)?$/i</span>,  <span class=\"comment\">//测试匹配文件,</span></span><br><span class=\"line\">        <span class=\"comment\">// include: /\\/includes/, //包含哪些文件</span></span><br><span class=\"line\">        <span class=\"comment\">// excluce: /\\/excludes/, //不包含哪些文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 </span></span><br><span class=\"line\">        <span class=\"comment\">//返回true以uglify块，否则返回false。</span></span><br><span class=\"line\">        chunkFilter: <span class=\"function\">(<span class=\"params\">chunk</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// `vendor` 模块不压缩</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chunk.name === <span class=\"string\">'vendor'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">        cache: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用文件缓存，默认缓存在node_modules/.cache/uglifyjs-webpack-plugin.目录</span></span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,  <span class=\"comment\">//使用多进程并行运行来提高构建速度</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 默认值是async</span></span><br><span class=\"line\"><span class=\"comment\">       * 拆分模块的范围，它有三个值async、initial和all。</span></span><br><span class=\"line\"><span class=\"comment\">       * async表示只从异步加载得模块（动态加载import()）里面进行拆分</span></span><br><span class=\"line\"><span class=\"comment\">       * initial表示只从入口模块进行拆分</span></span><br><span class=\"line\"><span class=\"comment\">       * all表示以上两者都包括</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      chunks: <span class=\"string\">'all'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// minSize: 30000, // 生成chunk的最小大小（以字节为单位）。只有大于这个数字才可以成一个chunk </span></span><br><span class=\"line\">      <span class=\"comment\">// minRemainingSize: 0, // 只有剩下一个chunk的时候才会生效，默认是和minSize一样的，开发的时候默认是0</span></span><br><span class=\"line\">      <span class=\"comment\">// maxSize: 0, // 告诉webpack尝试将大于maxSize字节的块拆分为较小的部分。</span></span><br><span class=\"line\">      <span class=\"comment\">// minChunks: 1, // 拆分前必须共享模块的最小块数。</span></span><br><span class=\"line\">      <span class=\"comment\">// maxAsyncRequests: 6, // 按需加载时最大并行请求数。</span></span><br><span class=\"line\">      <span class=\"comment\">// maxInitialRequests: 4, // 入口点的最大并行请求数。入口文件</span></span><br><span class=\"line\">      <span class=\"comment\">// automaticNameDelimiter: '~', // 默认情况下，webpack将使用块的来源和名称生成名称（例如vendors~main.js）。此选项使您可以指定用于生成名称的定界符。</span></span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 当webpack处理文件路径时，它们始终包含/在Unix系统和\\Windows上。</span></span><br><span class=\"line\"><span class=\"comment\">         * 这就是为什么[\\\\/]在&#123;cacheGroup&#125;.test字段中使用in 来表示路径分隔符的原因。</span></span><br><span class=\"line\"><span class=\"comment\">         * /或\\in &#123;cacheGroup&#125;.test会在跨平台使用时引起问题。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// defaultVendors: &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//   test: /[\\\\/]node_modules[\\\\/]/, // 分块目标</span></span><br><span class=\"line\">        <span class=\"comment\">//   priority: -10 // 权重</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">        <span class=\"comment\">// default: &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//   minChunks: 2, // 最小引用</span></span><br><span class=\"line\">        <span class=\"comment\">//   priority: -20, // 权重</span></span><br><span class=\"line\">        <span class=\"comment\">//   // 如果当前块包含已从主捆绑包中拆分出的模块，则将重用该模块，而不是生成新的模块。这可能会影响块的结果文件名。</span></span><br><span class=\"line\">        <span class=\"comment\">//   reuseExistingChunk: true</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">        <span class=\"comment\">// 上述的splitChunks全是webpack4未设置情况下的默认值，除了chunks从【async】-&gt;【all】其他都没有改</span></span><br><span class=\"line\">        <span class=\"comment\">// ok，我们现在加入我们自己想要的代码分割</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为我准备加入react等业务千变万化而不会变的库</span></span><br><span class=\"line\">        common: &#123;</span><br><span class=\"line\">          test: <span class=\"string\">\"common\"</span>, <span class=\"comment\">// webpack扫面的关键字</span></span><br><span class=\"line\">          name: <span class=\"string\">\"common\"</span>, <span class=\"comment\">// 生成的名字</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 是否缓存</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不想写diff啦，直接CV啦。。。</p>\n<p>为什么我需要把react提取出来，因为哪里都需要用，而且他几乎不可能会变，所以我特别提出来做了缓存，其余的还是使用的默认配置（除了chunk改为了‘all’）。</p>\n<blockquote>\n<p>Tobias Koppers@Wsokra：optimization. splitchunks. chunks: althe only option you need for vendor and commons splitting in webpackBest combine it with html-webpack-plugin or equivalent html generation18120</p>\n</blockquote>\n<p>作者都发推特说了，那我们也就接受吧～就改个all，然后补一下react～</p>\n<p>再重新打包，你会发现index.bundle.js（不被缓存）的hash值变了，但是common.bundle.js（能被缓存）的hash值没变。</p>\n<h3 id=\"使用mini-css-extract-plugin\"><a href=\"#使用mini-css-extract-plugin\" class=\"headerlink\" title=\"使用mini-css-extract-plugin\"></a>使用mini-css-extract-plugin</h3><p>js都独立📦，那我css也要！</p>\n<p>其实如果把CSS打包成一个文件然后让html引用的话可以减小html文件的大小，暗合了HTTP2的多路复用，多文件小数量。包括之前的splitChunks里面我们配置的react也是为了HTTP2。</p>\n<p>在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"addition\">+ const MiniCssExtractPlugin = require('mini-css-extract-plugin');</span></span><br><span class=\"line\"></span><br><span class=\"line\">//...</span><br><span class=\"line\">module:&#123;</span><br><span class=\"line\">    rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\"><span class=\"addition\">+          MiniCssExtractPlugin.loader,</span></span><br><span class=\"line\"><span class=\"deletion\">-          'style-loader',</span></span><br><span class=\"line\">           'css-loader', </span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"><span class=\"addition\">+plugins: [</span></span><br><span class=\"line\"><span class=\"addition\">+    new MiniCssExtractPlugin(&#123;</span></span><br><span class=\"line\"><span class=\"addition\">+      filename: 'css/[name].[hash].css',</span></span><br><span class=\"line\"><span class=\"addition\">+      chunkFilename: 'css/[id].[hash].css',</span></span><br><span class=\"line\"><span class=\"addition\">+    &#125;),</span></span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用CSS-Module\"><a href=\"#使用CSS-Module\" class=\"headerlink\" title=\"使用CSS Module\"></a>使用CSS Module</h3><p>其实很简单，只需要修改一下配置【wbpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          MiniCssExtractPlugin.loader,</span><br><span class=\"line\"><span class=\"deletion\">-          'css-loader'</span></span><br><span class=\"line\"><span class=\"addition\">+          &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            loader: 'css-loader',</span></span><br><span class=\"line\"><span class=\"addition\">+            options: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+              // importLoaders: 1,</span></span><br><span class=\"line\"><span class=\"addition\">+              modules: true,</span></span><br><span class=\"line\"><span class=\"addition\">+            &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#125;,</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用PostCSS\"><a href=\"#使用PostCSS\" class=\"headerlink\" title=\"使用PostCSS\"></a>使用PostCSS</h3><blockquote>\n<p>postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如： 1 . 使用下一代css语法 2 . 自动补全浏览器前缀 3 . 自动把px代为转换成rem 4 . css 代码压缩等等 postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。</p>\n</blockquote>\n<p>安装postcss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>安装postcss某个插件，以Autoprefixer举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss-aspect-ratio-mini postcss-write-svg postcss-px-to-viewport postcss-viewport-units postcss-flexbugs-fixes postcss-preset-env cssnano --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>在根目标新建文件【postcss.config.js】</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* eslint-disable import/no-extraneous-dependencies */</span></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable @typescript-eslint/no-var-requires */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssAspectRatioMini = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-aspect-ratio-mini'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssPxToViewport = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-px-to-viewport'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssWriteSvg = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-write-svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssViewportUnits = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-viewport-units'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">'cssnano'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssPresetEnv = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-preset-env'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> postcssFlexbugsFixes = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-flexbugs-fixes'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    postcssFlexbugsFixes,</span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个位置加入我们需要配置的代码</span></span><br><span class=\"line\">    postcssAspectRatioMini(&#123;&#125;),</span><br><span class=\"line\">    postcssPxToViewport(&#123;</span><br><span class=\"line\">      viewportWidth: <span class=\"number\">750</span>, <span class=\"comment\">// 基准宽度（一般的设计都是这个基准</span></span><br><span class=\"line\">      viewportHeight: <span class=\"number\">1334</span>, <span class=\"comment\">// 基准高度（一般的设计都是这个基准</span></span><br><span class=\"line\">      unitPrecision: <span class=\"number\">3</span>, <span class=\"comment\">// (Number) The decimal numbers to allow the REM units to grow to.</span></span><br><span class=\"line\">      viewportUnit: <span class=\"string\">'vw'</span>, <span class=\"comment\">// (String) 单位</span></span><br><span class=\"line\">      selectorBlackList: [<span class=\"string\">'.list-ignore'</span>, /notTransform/], <span class=\"comment\">// 带上这个单词的就不会fix为vw单位</span></span><br><span class=\"line\">      minPixelValue: <span class=\"number\">1</span>, <span class=\"comment\">// (Number) 最小像素</span></span><br><span class=\"line\">      mediaQuery: <span class=\"literal\">false</span>, <span class=\"comment\">// (Boolean) 允许在媒体查询中转换px。</span></span><br><span class=\"line\">      exclude: <span class=\"regexp\">/(\\/|\\\\)(node_modules)(\\/|\\\\)/</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    postcssWriteSvg(&#123;</span><br><span class=\"line\">      utf8: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    postcssPresetEnv(&#123;&#125;),</span><br><span class=\"line\">    postcssViewportUnits(&#123;</span><br><span class=\"line\">      filterRule: <span class=\"function\"><span class=\"params\">rule</span> =&gt;</span> rule.selector.includes(<span class=\"string\">'::after'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">'::before'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">':after'</span>)</span><br><span class=\"line\">        &amp;&amp; rule.selector.includes(<span class=\"string\">':before'</span>)</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    cssnano(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"cssnano-preset-advanced\"</span>: &#123;</span><br><span class=\"line\">        zindex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        autoprefixer: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改【webpack.common.config.js】</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\"><span class=\"addition\">+          'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        use: [ </span><br><span class=\"line\">          'style-loader',</span><br><span class=\"line\">          'css-loader', </span><br><span class=\"line\">          'less-loader',</span><br><span class=\"line\"><span class=\"addition\">+          'postcss-loader'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，修改我们的css文件，看看我们写的单位为px的有没有被改为vw的自适应单位。</p>\n<p>顺便试一下带有【notTransform】的是不是还是px作为单位。</p>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>到此，我们的webpack配置，就算是入门了，对于webpack的配置我们还有很长的路要走。大家加油！</p>\n<p>如果有哪里写的不好或者写错了，欢迎大家在评论区讨论。</p>\n"},{"title":"全网最全React源码调试傻瓜式教程","date":"2021-06-17T13:41:06.000Z","cover":"/image/cover/react.png","_content":"# 前言\n\n之前在阅读React源码的时候，想调试一下，然后debugger看看变量已经数据是怎么传递的，无奈。还要装这么多东西。踩了不少坑，记录一下。帮助大家少踩坑，也为自己做一个笔记。\n\n# 准备工作\n\n- [Node](https://nodejs.org/) v8.0.0+、[Yarn](https://yarnpkg.com/en/) v1.2.0+。\n- 已安装 [JDK](https://www.oracle.com/technetwork/java/javase/downloads/index.html)。\n- 你已安装 `gcc`（或者你在有必要安装编译器的情况下也不觉得麻烦），因为一些依赖可能得经过编译，而在 OS X，Xcode 命令行工具会帮你处理；在 Ubuntu，`apt-get install build-essential` 会安装所需的 package（其它 Linux 发行版的类似命令也有效）；在 Windows 上得做些额外步骤，请参考 [`node-gyp` 安装步骤](https://github.com/nodejs/node-gyp#installation)。\n- 熟悉 Git。\n\n- 一个可以运行React项目（本文采用create-react-app）\n\n# 开始\n\n## 1.获取源代码\n\n1. 打开源码地址：https://github.com/facebook/react\n2. 克隆到自己的本地\n   1. 可以下载zip解压\n   2. 也可以Fork到自己的GitHub然后Clone\n      1. 个人建议是Fork，然后可以修改，添加注释等等。可以记录一下自己学习历程\n   3. 也可以直接Clone\n\n## 2. 建立依赖连接\n\n1. 打开项目\n2. 运行yarn安装依赖\n3. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n4. `cd build/node_modules/react`进入React这个包内部\n5. `yarn link`建立连接\n6. `cd 到原来的项目路径`返回，为了下一次进入react-dom做准备\n7. `cd build/node_modules/react-dom`\n8. `yarn link`\n\n## 3.找到一个可以调试的React项目\n\n这里我采用的是`create-react-app`\n\n1. `npx create-react-app my-app`\n2. `cd my-app`\n\n## 4. 连接项目和React库\n\n1. 删除刚刚建立的项目的`node_modules`中的`react`和`react-dom`\n2. 打开React项目\n3. `yarn link react react-dom`\n\n## 5. 开始调试\n\n1. 打开我们clone的项目\n\n2. 找到想要调试的地方\n\n   1. 这里改的地方是`packages/react-dom/src/client/ReactDOMLegacy.js`\n   2. 内容如下\n\n   ```diff\n   export function render(\n     element: React$Element<any>,\n     container: Container,\n     callback: ?Function,\n   ) {\n   +  console.log(222);\n     if (__DEV__) {\n       console.error(\n         'ReactDOM.render is no longer supported in React 18. Use createRoot ' +\n           'instead. Until you switch to the new API, your app will behave as ' +\n           \"if it's running React 17. Learn \" +\n           'more: https://reactjs.org/link/switch-to-createroot',\n       );\n     }\n   \n     invariant(\n       isValidContainerLegacy(container),\n       'Target container is not a DOM element.',\n     );\n     if (__DEV__) {\n       const isModernRoot =\n         isContainerMarkedAsRoot(container) &&\n         container._reactRootContainer === undefined;\n       if (isModernRoot) {\n         console.error(\n           'You are calling ReactDOM.render() on a container that was previously ' +\n             'passed to ReactDOM.createRoot(). This is not supported. ' +\n             'Did you mean to call root.render(element)?',\n         );\n       }\n     }\n     return legacyRenderSubtreeIntoContainer(\n       null,\n       element,\n       container,\n       false,\n       callback,\n     );\n   }\n   ```\n\n3. 打开React源码的项目\n4. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n5. 打开我们创建的React项目\n6. `yarn start`\n7. 打开控制台\n\n![console](/image/reactDebugger/console.png)\n\n## 6. 后续\n\n每次修改源代码都需要\n\n1. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n2. 刷新一下我们的页面\n3. 确实很麻烦目前没有好的主意\n   1. 可能这就是修行吧！\n\n# 结语\n\n有问题可以在下方留言，感觉有帮助。帮忙点个赞","source":"_posts/全网最全React源码调试教程.md","raw":"---\ntitle: 全网最全React源码调试傻瓜式教程\ndate: 2021-06-17 21:41:06\ntags: [react]\ncategory: [react]\ncover: /image/cover/react.png\n---\n# 前言\n\n之前在阅读React源码的时候，想调试一下，然后debugger看看变量已经数据是怎么传递的，无奈。还要装这么多东西。踩了不少坑，记录一下。帮助大家少踩坑，也为自己做一个笔记。\n\n# 准备工作\n\n- [Node](https://nodejs.org/) v8.0.0+、[Yarn](https://yarnpkg.com/en/) v1.2.0+。\n- 已安装 [JDK](https://www.oracle.com/technetwork/java/javase/downloads/index.html)。\n- 你已安装 `gcc`（或者你在有必要安装编译器的情况下也不觉得麻烦），因为一些依赖可能得经过编译，而在 OS X，Xcode 命令行工具会帮你处理；在 Ubuntu，`apt-get install build-essential` 会安装所需的 package（其它 Linux 发行版的类似命令也有效）；在 Windows 上得做些额外步骤，请参考 [`node-gyp` 安装步骤](https://github.com/nodejs/node-gyp#installation)。\n- 熟悉 Git。\n\n- 一个可以运行React项目（本文采用create-react-app）\n\n# 开始\n\n## 1.获取源代码\n\n1. 打开源码地址：https://github.com/facebook/react\n2. 克隆到自己的本地\n   1. 可以下载zip解压\n   2. 也可以Fork到自己的GitHub然后Clone\n      1. 个人建议是Fork，然后可以修改，添加注释等等。可以记录一下自己学习历程\n   3. 也可以直接Clone\n\n## 2. 建立依赖连接\n\n1. 打开项目\n2. 运行yarn安装依赖\n3. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n4. `cd build/node_modules/react`进入React这个包内部\n5. `yarn link`建立连接\n6. `cd 到原来的项目路径`返回，为了下一次进入react-dom做准备\n7. `cd build/node_modules/react-dom`\n8. `yarn link`\n\n## 3.找到一个可以调试的React项目\n\n这里我采用的是`create-react-app`\n\n1. `npx create-react-app my-app`\n2. `cd my-app`\n\n## 4. 连接项目和React库\n\n1. 删除刚刚建立的项目的`node_modules`中的`react`和`react-dom`\n2. 打开React项目\n3. `yarn link react react-dom`\n\n## 5. 开始调试\n\n1. 打开我们clone的项目\n\n2. 找到想要调试的地方\n\n   1. 这里改的地方是`packages/react-dom/src/client/ReactDOMLegacy.js`\n   2. 内容如下\n\n   ```diff\n   export function render(\n     element: React$Element<any>,\n     container: Container,\n     callback: ?Function,\n   ) {\n   +  console.log(222);\n     if (__DEV__) {\n       console.error(\n         'ReactDOM.render is no longer supported in React 18. Use createRoot ' +\n           'instead. Until you switch to the new API, your app will behave as ' +\n           \"if it's running React 17. Learn \" +\n           'more: https://reactjs.org/link/switch-to-createroot',\n       );\n     }\n   \n     invariant(\n       isValidContainerLegacy(container),\n       'Target container is not a DOM element.',\n     );\n     if (__DEV__) {\n       const isModernRoot =\n         isContainerMarkedAsRoot(container) &&\n         container._reactRootContainer === undefined;\n       if (isModernRoot) {\n         console.error(\n           'You are calling ReactDOM.render() on a container that was previously ' +\n             'passed to ReactDOM.createRoot(). This is not supported. ' +\n             'Did you mean to call root.render(element)?',\n         );\n       }\n     }\n     return legacyRenderSubtreeIntoContainer(\n       null,\n       element,\n       container,\n       false,\n       callback,\n     );\n   }\n   ```\n\n3. 打开React源码的项目\n4. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n5. 打开我们创建的React项目\n6. `yarn start`\n7. 打开控制台\n\n![console](/image/reactDebugger/console.png)\n\n## 6. 后续\n\n每次修改源代码都需要\n\n1. 运行`yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE`重新打包\n2. 刷新一下我们的页面\n3. 确实很麻烦目前没有好的主意\n   1. 可能这就是修行吧！\n\n# 结语\n\n有问题可以在下方留言，感觉有帮助。帮忙点个赞","slug":"全网最全React源码调试教程","published":1,"updated":"2021-06-24T14:00:06.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8x002ilwrdd9h5976c","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前在阅读React源码的时候，想调试一下，然后debugger看看变量已经数据是怎么传递的，无奈。还要装这么多东西。踩了不少坑，记录一下。帮助大家少踩坑，也为自己做一个笔记。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li><p><a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node</a> v8.0.0+、<a href=\"https://yarnpkg.com/en/\" target=\"_blank\" rel=\"noopener\">Yarn</a> v1.2.0+。</p>\n</li>\n<li><p>已安装 <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">JDK</a>。</p>\n</li>\n<li><p>你已安装 <code>gcc</code>（或者你在有必要安装编译器的情况下也不觉得麻烦），因为一些依赖可能得经过编译，而在 OS X，Xcode 命令行工具会帮你处理；在 Ubuntu，<code>apt-get install build-essential</code> 会安装所需的 package（其它 Linux 发行版的类似命令也有效）；在 Windows 上得做些额外步骤，请参考 <a href=\"https://github.com/nodejs/node-gyp#installation\" target=\"_blank\" rel=\"noopener\"><code>node-gyp</code> 安装步骤</a>。</p>\n</li>\n<li><p>熟悉 Git。</p>\n</li>\n<li><p>一个可以运行React项目（本文采用create-react-app）</p>\n</li>\n</ul>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><h2 id=\"1-获取源代码\"><a href=\"#1-获取源代码\" class=\"headerlink\" title=\"1.获取源代码\"></a>1.获取源代码</h2><ol>\n<li>打开源码地址：<a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/react</a></li>\n<li>克隆到自己的本地<ol>\n<li>可以下载zip解压</li>\n<li>也可以Fork到自己的GitHub然后Clone<ol>\n<li>个人建议是Fork，然后可以修改，添加注释等等。可以记录一下自己学习历程</li>\n</ol>\n</li>\n<li>也可以直接Clone</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-建立依赖连接\"><a href=\"#2-建立依赖连接\" class=\"headerlink\" title=\"2. 建立依赖连接\"></a>2. 建立依赖连接</h2><ol>\n<li>打开项目</li>\n<li>运行yarn安装依赖</li>\n<li>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</li>\n<li><code>cd build/node_modules/react</code>进入React这个包内部</li>\n<li><code>yarn link</code>建立连接</li>\n<li><code>cd 到原来的项目路径</code>返回，为了下一次进入react-dom做准备</li>\n<li><code>cd build/node_modules/react-dom</code></li>\n<li><code>yarn link</code></li>\n</ol>\n<h2 id=\"3-找到一个可以调试的React项目\"><a href=\"#3-找到一个可以调试的React项目\" class=\"headerlink\" title=\"3.找到一个可以调试的React项目\"></a>3.找到一个可以调试的React项目</h2><p>这里我采用的是<code>create-react-app</code></p>\n<ol>\n<li><code>npx create-react-app my-app</code></li>\n<li><code>cd my-app</code></li>\n</ol>\n<h2 id=\"4-连接项目和React库\"><a href=\"#4-连接项目和React库\" class=\"headerlink\" title=\"4. 连接项目和React库\"></a>4. 连接项目和React库</h2><ol>\n<li>删除刚刚建立的项目的<code>node_modules</code>中的<code>react</code>和<code>react-dom</code></li>\n<li>打开React项目</li>\n<li><code>yarn link react react-dom</code></li>\n</ol>\n<h2 id=\"5-开始调试\"><a href=\"#5-开始调试\" class=\"headerlink\" title=\"5. 开始调试\"></a>5. 开始调试</h2><ol>\n<li><p>打开我们clone的项目</p>\n</li>\n<li><p>找到想要调试的地方</p>\n<ol>\n<li>这里改的地方是<code>packages/react-dom/src/client/ReactDOMLegacy.js</code></li>\n<li>内容如下</li>\n</ol>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function render(</span><br><span class=\"line\">  element: React$Element&lt;any&gt;,</span><br><span class=\"line\">  container: Container,</span><br><span class=\"line\">  callback: ?Function,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\"><span class=\"addition\">+  console.log(222);</span></span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    console.error(</span><br><span class=\"line\">      'ReactDOM.render is no longer supported in React 18. Use createRoot ' +</span><br><span class=\"line\">        'instead. Until you switch to the new API, your app will behave as ' +</span><br><span class=\"line\">        \"if it's running React 17. Learn \" +</span><br><span class=\"line\">        'more: https://reactjs.org/link/switch-to-createroot',</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainerLegacy(container),</span><br><span class=\"line\">    'Target container is not a DOM element.',</span><br><span class=\"line\">  );</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    const isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer <span class=\"comment\">=== undefined;</span></span><br><span class=\"line\">    if (isModernRoot) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        'You are calling ReactDOM.render() on a container that was previously ' +</span><br><span class=\"line\">          'passed to ReactDOM.createRoot(). This is not supported. ' +</span><br><span class=\"line\">          'Did you mean to call root.render(element)?',</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    null,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    false,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开React源码的项目</p>\n</li>\n<li><p>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</p>\n</li>\n<li><p>打开我们创建的React项目</p>\n</li>\n<li><p><code>yarn start</code></p>\n</li>\n<li><p>打开控制台</p>\n</li>\n</ol>\n<p><img src=\"/\" class=\"lazyload\" data-src=\"/image/reactDebugger/console.png\"  alt=\"console\"></p>\n<h2 id=\"6-后续\"><a href=\"#6-后续\" class=\"headerlink\" title=\"6. 后续\"></a>6. 后续</h2><p>每次修改源代码都需要</p>\n<ol>\n<li>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</li>\n<li>刷新一下我们的页面</li>\n<li>确实很麻烦目前没有好的主意<ol>\n<li>可能这就是修行吧！</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>有问题可以在下方留言，感觉有帮助。帮忙点个赞</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前在阅读React源码的时候，想调试一下，然后debugger看看变量已经数据是怎么传递的，无奈。还要装这么多东西。踩了不少坑，记录一下。帮助大家少踩坑，也为自己做一个笔记。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li><p><a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node</a> v8.0.0+、<a href=\"https://yarnpkg.com/en/\" target=\"_blank\" rel=\"noopener\">Yarn</a> v1.2.0+。</p>\n</li>\n<li><p>已安装 <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">JDK</a>。</p>\n</li>\n<li><p>你已安装 <code>gcc</code>（或者你在有必要安装编译器的情况下也不觉得麻烦），因为一些依赖可能得经过编译，而在 OS X，Xcode 命令行工具会帮你处理；在 Ubuntu，<code>apt-get install build-essential</code> 会安装所需的 package（其它 Linux 发行版的类似命令也有效）；在 Windows 上得做些额外步骤，请参考 <a href=\"https://github.com/nodejs/node-gyp#installation\" target=\"_blank\" rel=\"noopener\"><code>node-gyp</code> 安装步骤</a>。</p>\n</li>\n<li><p>熟悉 Git。</p>\n</li>\n<li><p>一个可以运行React项目（本文采用create-react-app）</p>\n</li>\n</ul>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><h2 id=\"1-获取源代码\"><a href=\"#1-获取源代码\" class=\"headerlink\" title=\"1.获取源代码\"></a>1.获取源代码</h2><ol>\n<li>打开源码地址：<a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/react</a></li>\n<li>克隆到自己的本地<ol>\n<li>可以下载zip解压</li>\n<li>也可以Fork到自己的GitHub然后Clone<ol>\n<li>个人建议是Fork，然后可以修改，添加注释等等。可以记录一下自己学习历程</li>\n</ol>\n</li>\n<li>也可以直接Clone</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-建立依赖连接\"><a href=\"#2-建立依赖连接\" class=\"headerlink\" title=\"2. 建立依赖连接\"></a>2. 建立依赖连接</h2><ol>\n<li>打开项目</li>\n<li>运行yarn安装依赖</li>\n<li>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</li>\n<li><code>cd build/node_modules/react</code>进入React这个包内部</li>\n<li><code>yarn link</code>建立连接</li>\n<li><code>cd 到原来的项目路径</code>返回，为了下一次进入react-dom做准备</li>\n<li><code>cd build/node_modules/react-dom</code></li>\n<li><code>yarn link</code></li>\n</ol>\n<h2 id=\"3-找到一个可以调试的React项目\"><a href=\"#3-找到一个可以调试的React项目\" class=\"headerlink\" title=\"3.找到一个可以调试的React项目\"></a>3.找到一个可以调试的React项目</h2><p>这里我采用的是<code>create-react-app</code></p>\n<ol>\n<li><code>npx create-react-app my-app</code></li>\n<li><code>cd my-app</code></li>\n</ol>\n<h2 id=\"4-连接项目和React库\"><a href=\"#4-连接项目和React库\" class=\"headerlink\" title=\"4. 连接项目和React库\"></a>4. 连接项目和React库</h2><ol>\n<li>删除刚刚建立的项目的<code>node_modules</code>中的<code>react</code>和<code>react-dom</code></li>\n<li>打开React项目</li>\n<li><code>yarn link react react-dom</code></li>\n</ol>\n<h2 id=\"5-开始调试\"><a href=\"#5-开始调试\" class=\"headerlink\" title=\"5. 开始调试\"></a>5. 开始调试</h2><ol>\n<li><p>打开我们clone的项目</p>\n</li>\n<li><p>找到想要调试的地方</p>\n<ol>\n<li>这里改的地方是<code>packages/react-dom/src/client/ReactDOMLegacy.js</code></li>\n<li>内容如下</li>\n</ol>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function render(</span><br><span class=\"line\">  element: React$Element&lt;any&gt;,</span><br><span class=\"line\">  container: Container,</span><br><span class=\"line\">  callback: ?Function,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\"><span class=\"addition\">+  console.log(222);</span></span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    console.error(</span><br><span class=\"line\">      'ReactDOM.render is no longer supported in React 18. Use createRoot ' +</span><br><span class=\"line\">        'instead. Until you switch to the new API, your app will behave as ' +</span><br><span class=\"line\">        \"if it's running React 17. Learn \" +</span><br><span class=\"line\">        'more: https://reactjs.org/link/switch-to-createroot',</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  invariant(</span><br><span class=\"line\">    isValidContainerLegacy(container),</span><br><span class=\"line\">    'Target container is not a DOM element.',</span><br><span class=\"line\">  );</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    const isModernRoot =</span><br><span class=\"line\">      isContainerMarkedAsRoot(container) &amp;&amp;</span><br><span class=\"line\">      container._reactRootContainer <span class=\"comment\">=== undefined;</span></span><br><span class=\"line\">    if (isModernRoot) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        'You are calling ReactDOM.render() on a container that was previously ' +</span><br><span class=\"line\">          'passed to ReactDOM.createRoot(). This is not supported. ' +</span><br><span class=\"line\">          'Did you mean to call root.render(element)?',</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">    null,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    false,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开React源码的项目</p>\n</li>\n<li><p>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</p>\n</li>\n<li><p>打开我们创建的React项目</p>\n</li>\n<li><p><code>yarn start</code></p>\n</li>\n<li><p>打开控制台</p>\n</li>\n</ol>\n<p><img src=\"/image/reactDebugger/console.png\" alt=\"console\"></p>\n<h2 id=\"6-后续\"><a href=\"#6-后续\" class=\"headerlink\" title=\"6. 后续\"></a>6. 后续</h2><p>每次修改源代码都需要</p>\n<ol>\n<li>运行<code>yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE</code>重新打包</li>\n<li>刷新一下我们的页面</li>\n<li>确实很麻烦目前没有好的主意<ol>\n<li>可能这就是修行吧！</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>有问题可以在下方留言，感觉有帮助。帮忙点个赞</p>\n"},{"title":"【前端进阶】从零搭建属于你的脚手架","date":"2020-06-06T13:41:06.000Z","_content":"# 给自己搭建一个脚手架\n## 背景\n\n### 一丶跳出舒适区\n\n大部分前端选手，也包括我自己，经常都是vue-cli，或者create-react-app一把梭。不得不承认这些著名的脚手架写的确实好，能够给我们做项目提速。但是久而久之很容易进入自己的舒适区，最近不是很流行“跳出舒适区”吗？而且各大培训机构都做贩卖焦虑，就为了可以让更多的人可以去买课。\n\n这里我就不贩卖焦虑了。大家有自己的选择，只要自己不后悔就好。\n\n### 二丶市面上脚手架的缺陷\n\n虽然vue-cli等脚手架已经布置好了很多东西，包括router，css的解析等等。\n\n但是！\n\n但是啊，但是这些脚手架并不知道我们公司的或者说我们个人项目的网络请求，而且网络请求内部怎么封装的也没有统一的处理。也不知道我们的一些通用的登陆页等等。这些都需要我们重新的CV一下，或者自己重新做。\n\n### 三丶过分使用别人搭建的脚手架可能会带来以下问题\n\n- 忘记，或者不知道webpack或者路由的配置，经常会在面试的临时抱佛脚，不能够真正的掌握，终究是纸上谈兵\n- 一些常见的坑点都被别人踩过并铺好路了，在不了解原理又没有踩过坑的情况下如果碰到问题很容易耽误大量的时间\n- 一些新框架的升级，只能等别人的cli版本升级之后才可以享受。慢人一步！\n- 配置一些项目相关的东西，经常需要翻看文档。\n- ……\n\n### 四丶原因\n\n我们做脚手架有以下几个原因\n\n- 学习脚手架的思想\n- 了解脚手架的构成\n- 省略一下CV的操作，更快更灵活的开始自己公司或者自己个人项目\n- 可以深入的配置自己的项目\n\n\n\n## 开始\n\n### 准备工作\n\n#### commander\n\n用于node.js命令行界面的完整解决方案。基本上是前端脚手架必备的。\n\n这里只介绍\n\n- version\n- command\n- description\n- action\n\n简单使用，毕竟只是入门，后续一些复杂的定制化的就需要大家自己去探索了。\n\n好了，收！\n\n怎么用？\n\n```js\nconst { program } = require('commander')\nprogram\n  .version(`react-cli-mobile ${packages.version}`)\n  .command('create <name>')\n  .description('初始化模板')\n  .action((projectName, cmd) => {\n    const options = cleanArgs(cmd)\n    creator(projectName, options)\n  })\n```\n\n\n\n#### fs-extra\n\n**fs-extra模块是系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API**\n\n这里只介绍\n\n- ### copy 复制文件\n\n- existsSync\n\ncopy用于复制。网上的一些脚手架教程用的是[download-git-repo]库。我发现这个只能下载某个仓库的文件，这样的话会导致我的项目会有两个。一个用于脚手架的代码，另一个是template的仓库。这样我觉得不太适合我，因为我不是很想找脚手架上面下太多的功夫搞交互，我只是想可以更方便更快的新建我的项目，而且我也不想弄两个仓库，我觉得有点多余。\n\n当然了，这只代表我的个人想法，大家可以自行选择。\n\n\n\n怎么用？\n\n```js\nconst fs = require('fs-extra')\nif(fs.existsSync(targetDir)) {\n    console.error('目录已经存在')\n    return\n}\n\n// 复制模板文件\n  await fs.copy(src, dest)\n```\n\n\n\n#### path\n\n很简单，字面意思，主要是用于配合【fs-extra】这个库来使用的，主要还是给copy提供路径，就不多介绍了\n\n\n\n怎么用？\n\n```js\nconst path = require('path')\nconst src = path.resolve(__dirname, dir);\n\nconst dest = path.resolve(process.cwd(), projectName);\n\n// 复制模板文件\nawait fs.copy(src, dest)\n```\n\n\n\n\n\nok，至此差不多我们的一个脚手架就可以出来了，其他的一些log颜色，路径判断，单词差异优化都不在本次介绍的范围内，本文主要是完成一个脚手架，然后重头戏还是自己的template。\n\n\n\n### 步骤\n\n- 新建一个自己的文件夹\n- npm init配置\n- 获取用户输入的信息\n- 把自己的初始化项目放到template文件夹下面\n- cpoy 路径和自己template的路径，然后复制\n\n#### 代码\n\n代码的话这里就不贴了\n\n大家可以直接到 [react-cli-mobile]([https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile))上面看，里面有一些更加细微的操作。\n\n\n\n## 结语\n\n本来自己从webpack配置开始，从零搭建一个由\n\n- fetch\n- webpack\n- less（配置了css module\n- react\n- react-router（实现react原生懒加载）\n- typescript\n- 移动端适配（使用VW适配）\n- babel兼容低版本\n\n大家可以\n\n- npm install react-cli-mobile -g\n- react-cli-mobile create xx\n- cd xx\n- npm install\n- npm start\n- 打开http://localhost:9000\n\n或者直接查看源码\n\n大家可以直接到 [react-cli-mobile]([https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile))上面看\n\n\n\n## 最后的最后\n\n哪里写错了，或者写的不好，或者有不懂的欢迎大家在评论区交流\n\n> 后续会继续推出从零配置移动端的webpack等配置的文章！欢迎大家关注点赞！谢谢！\n\n","source":"_posts/前端进阶-配置你自己的脚手架.md","raw":"---\ntitle: 【前端进阶】从零搭建属于你的脚手架\ndate: 2020-06-06 21:41:06\ntags: [脚手架]\ncategory: [前端]\n---\n# 给自己搭建一个脚手架\n## 背景\n\n### 一丶跳出舒适区\n\n大部分前端选手，也包括我自己，经常都是vue-cli，或者create-react-app一把梭。不得不承认这些著名的脚手架写的确实好，能够给我们做项目提速。但是久而久之很容易进入自己的舒适区，最近不是很流行“跳出舒适区”吗？而且各大培训机构都做贩卖焦虑，就为了可以让更多的人可以去买课。\n\n这里我就不贩卖焦虑了。大家有自己的选择，只要自己不后悔就好。\n\n### 二丶市面上脚手架的缺陷\n\n虽然vue-cli等脚手架已经布置好了很多东西，包括router，css的解析等等。\n\n但是！\n\n但是啊，但是这些脚手架并不知道我们公司的或者说我们个人项目的网络请求，而且网络请求内部怎么封装的也没有统一的处理。也不知道我们的一些通用的登陆页等等。这些都需要我们重新的CV一下，或者自己重新做。\n\n### 三丶过分使用别人搭建的脚手架可能会带来以下问题\n\n- 忘记，或者不知道webpack或者路由的配置，经常会在面试的临时抱佛脚，不能够真正的掌握，终究是纸上谈兵\n- 一些常见的坑点都被别人踩过并铺好路了，在不了解原理又没有踩过坑的情况下如果碰到问题很容易耽误大量的时间\n- 一些新框架的升级，只能等别人的cli版本升级之后才可以享受。慢人一步！\n- 配置一些项目相关的东西，经常需要翻看文档。\n- ……\n\n### 四丶原因\n\n我们做脚手架有以下几个原因\n\n- 学习脚手架的思想\n- 了解脚手架的构成\n- 省略一下CV的操作，更快更灵活的开始自己公司或者自己个人项目\n- 可以深入的配置自己的项目\n\n\n\n## 开始\n\n### 准备工作\n\n#### commander\n\n用于node.js命令行界面的完整解决方案。基本上是前端脚手架必备的。\n\n这里只介绍\n\n- version\n- command\n- description\n- action\n\n简单使用，毕竟只是入门，后续一些复杂的定制化的就需要大家自己去探索了。\n\n好了，收！\n\n怎么用？\n\n```js\nconst { program } = require('commander')\nprogram\n  .version(`react-cli-mobile ${packages.version}`)\n  .command('create <name>')\n  .description('初始化模板')\n  .action((projectName, cmd) => {\n    const options = cleanArgs(cmd)\n    creator(projectName, options)\n  })\n```\n\n\n\n#### fs-extra\n\n**fs-extra模块是系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API**\n\n这里只介绍\n\n- ### copy 复制文件\n\n- existsSync\n\ncopy用于复制。网上的一些脚手架教程用的是[download-git-repo]库。我发现这个只能下载某个仓库的文件，这样的话会导致我的项目会有两个。一个用于脚手架的代码，另一个是template的仓库。这样我觉得不太适合我，因为我不是很想找脚手架上面下太多的功夫搞交互，我只是想可以更方便更快的新建我的项目，而且我也不想弄两个仓库，我觉得有点多余。\n\n当然了，这只代表我的个人想法，大家可以自行选择。\n\n\n\n怎么用？\n\n```js\nconst fs = require('fs-extra')\nif(fs.existsSync(targetDir)) {\n    console.error('目录已经存在')\n    return\n}\n\n// 复制模板文件\n  await fs.copy(src, dest)\n```\n\n\n\n#### path\n\n很简单，字面意思，主要是用于配合【fs-extra】这个库来使用的，主要还是给copy提供路径，就不多介绍了\n\n\n\n怎么用？\n\n```js\nconst path = require('path')\nconst src = path.resolve(__dirname, dir);\n\nconst dest = path.resolve(process.cwd(), projectName);\n\n// 复制模板文件\nawait fs.copy(src, dest)\n```\n\n\n\n\n\nok，至此差不多我们的一个脚手架就可以出来了，其他的一些log颜色，路径判断，单词差异优化都不在本次介绍的范围内，本文主要是完成一个脚手架，然后重头戏还是自己的template。\n\n\n\n### 步骤\n\n- 新建一个自己的文件夹\n- npm init配置\n- 获取用户输入的信息\n- 把自己的初始化项目放到template文件夹下面\n- cpoy 路径和自己template的路径，然后复制\n\n#### 代码\n\n代码的话这里就不贴了\n\n大家可以直接到 [react-cli-mobile]([https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile))上面看，里面有一些更加细微的操作。\n\n\n\n## 结语\n\n本来自己从webpack配置开始，从零搭建一个由\n\n- fetch\n- webpack\n- less（配置了css module\n- react\n- react-router（实现react原生懒加载）\n- typescript\n- 移动端适配（使用VW适配）\n- babel兼容低版本\n\n大家可以\n\n- npm install react-cli-mobile -g\n- react-cli-mobile create xx\n- cd xx\n- npm install\n- npm start\n- 打开http://localhost:9000\n\n或者直接查看源码\n\n大家可以直接到 [react-cli-mobile]([https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile))上面看\n\n\n\n## 最后的最后\n\n哪里写错了，或者写的不好，或者有不懂的欢迎大家在评论区交流\n\n> 后续会继续推出从零配置移动端的webpack等配置的文章！欢迎大家关注点赞！谢谢！\n\n","slug":"前端进阶-配置你自己的脚手架","published":1,"updated":"2021-06-24T14:00:06.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8y002nlwrd7yrvg3ix","content":"<h1 id=\"给自己搭建一个脚手架\"><a href=\"#给自己搭建一个脚手架\" class=\"headerlink\" title=\"给自己搭建一个脚手架\"></a>给自己搭建一个脚手架</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h3 id=\"一丶跳出舒适区\"><a href=\"#一丶跳出舒适区\" class=\"headerlink\" title=\"一丶跳出舒适区\"></a>一丶跳出舒适区</h3><p>大部分前端选手，也包括我自己，经常都是vue-cli，或者create-react-app一把梭。不得不承认这些著名的脚手架写的确实好，能够给我们做项目提速。但是久而久之很容易进入自己的舒适区，最近不是很流行“跳出舒适区”吗？而且各大培训机构都做贩卖焦虑，就为了可以让更多的人可以去买课。</p>\n<p>这里我就不贩卖焦虑了。大家有自己的选择，只要自己不后悔就好。</p>\n<h3 id=\"二丶市面上脚手架的缺陷\"><a href=\"#二丶市面上脚手架的缺陷\" class=\"headerlink\" title=\"二丶市面上脚手架的缺陷\"></a>二丶市面上脚手架的缺陷</h3><p>虽然vue-cli等脚手架已经布置好了很多东西，包括router，css的解析等等。</p>\n<p>但是！</p>\n<p>但是啊，但是这些脚手架并不知道我们公司的或者说我们个人项目的网络请求，而且网络请求内部怎么封装的也没有统一的处理。也不知道我们的一些通用的登陆页等等。这些都需要我们重新的CV一下，或者自己重新做。</p>\n<h3 id=\"三丶过分使用别人搭建的脚手架可能会带来以下问题\"><a href=\"#三丶过分使用别人搭建的脚手架可能会带来以下问题\" class=\"headerlink\" title=\"三丶过分使用别人搭建的脚手架可能会带来以下问题\"></a>三丶过分使用别人搭建的脚手架可能会带来以下问题</h3><ul>\n<li>忘记，或者不知道webpack或者路由的配置，经常会在面试的临时抱佛脚，不能够真正的掌握，终究是纸上谈兵</li>\n<li>一些常见的坑点都被别人踩过并铺好路了，在不了解原理又没有踩过坑的情况下如果碰到问题很容易耽误大量的时间</li>\n<li>一些新框架的升级，只能等别人的cli版本升级之后才可以享受。慢人一步！</li>\n<li>配置一些项目相关的东西，经常需要翻看文档。</li>\n<li>……</li>\n</ul>\n<h3 id=\"四丶原因\"><a href=\"#四丶原因\" class=\"headerlink\" title=\"四丶原因\"></a>四丶原因</h3><p>我们做脚手架有以下几个原因</p>\n<ul>\n<li>学习脚手架的思想</li>\n<li>了解脚手架的构成</li>\n<li>省略一下CV的操作，更快更灵活的开始自己公司或者自己个人项目</li>\n<li>可以深入的配置自己的项目</li>\n</ul>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"commander\"><a href=\"#commander\" class=\"headerlink\" title=\"commander\"></a>commander</h4><p>用于node.js命令行界面的完整解决方案。基本上是前端脚手架必备的。</p>\n<p>这里只介绍</p>\n<ul>\n<li>version</li>\n<li>command</li>\n<li>description</li>\n<li>action</li>\n</ul>\n<p>简单使用，毕竟只是入门，后续一些复杂的定制化的就需要大家自己去探索了。</p>\n<p>好了，收！</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; program &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\">program</span><br><span class=\"line\">  .version(<span class=\"string\">`react-cli-mobile <span class=\"subst\">$&#123;packages.version&#125;</span>`</span>)</span><br><span class=\"line\">  .command(<span class=\"string\">'create &lt;name&gt;'</span>)</span><br><span class=\"line\">  .description(<span class=\"string\">'初始化模板'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\">(<span class=\"params\">projectName, cmd</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = cleanArgs(cmd)</span><br><span class=\"line\">    creator(projectName, options)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"fs-extra\"><a href=\"#fs-extra\" class=\"headerlink\" title=\"fs-extra\"></a>fs-extra</h4><p><strong>fs-extra模块是系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API</strong></p>\n<p>这里只介绍</p>\n<ul>\n<li><h3 id=\"copy-复制文件\"><a href=\"#copy-复制文件\" class=\"headerlink\" title=\"copy 复制文件\"></a>copy 复制文件</h3></li>\n<li><p>existsSync</p>\n</li>\n</ul>\n<p>copy用于复制。网上的一些脚手架教程用的是[download-git-repo]库。我发现这个只能下载某个仓库的文件，这样的话会导致我的项目会有两个。一个用于脚手架的代码，另一个是template的仓库。这样我觉得不太适合我，因为我不是很想找脚手架上面下太多的功夫搞交互，我只是想可以更方便更快的新建我的项目，而且我也不想弄两个仓库，我觉得有点多余。</p>\n<p>当然了，这只代表我的个人想法，大家可以自行选择。</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs-extra'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span>(fs.existsSync(targetDir)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'目录已经存在'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制模板文件</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> fs.copy(src, dest)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h4><p>很简单，字面意思，主要是用于配合【fs-extra】这个库来使用的，主要还是给copy提供路径，就不多介绍了</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> src = path.resolve(__dirname, dir);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = path.resolve(process.cwd(), projectName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制模板文件</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> fs.copy(src, dest)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>ok，至此差不多我们的一个脚手架就可以出来了，其他的一些log颜色，路径判断，单词差异优化都不在本次介绍的范围内，本文主要是完成一个脚手架，然后重头戏还是自己的template。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>新建一个自己的文件夹</li>\n<li>npm init配置</li>\n<li>获取用户输入的信息</li>\n<li>把自己的初始化项目放到template文件夹下面</li>\n<li>cpoy 路径和自己template的路径，然后复制</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>代码的话这里就不贴了</p>\n<p>大家可以直接到 <a href=\"[https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile)\">react-cli-mobile</a>上面看，里面有一些更加细微的操作。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本来自己从webpack配置开始，从零搭建一个由</p>\n<ul>\n<li>fetch</li>\n<li>webpack</li>\n<li>less（配置了css module</li>\n<li>react</li>\n<li>react-router（实现react原生懒加载）</li>\n<li>typescript</li>\n<li>移动端适配（使用VW适配）</li>\n<li>babel兼容低版本</li>\n</ul>\n<p>大家可以</p>\n<ul>\n<li>npm install react-cli-mobile -g</li>\n<li>react-cli-mobile create xx</li>\n<li>cd xx</li>\n<li>npm install</li>\n<li>npm start</li>\n<li>打开<a href=\"http://localhost:9000\" target=\"_blank\" rel=\"noopener\">http://localhost:9000</a></li>\n</ul>\n<p>或者直接查看源码</p>\n<p>大家可以直接到 <a href=\"[https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile)\">react-cli-mobile</a>上面看</p>\n<h2 id=\"最后的最后\"><a href=\"#最后的最后\" class=\"headerlink\" title=\"最后的最后\"></a>最后的最后</h2><p>哪里写错了，或者写的不好，或者有不懂的欢迎大家在评论区交流</p>\n<blockquote>\n<p>后续会继续推出从零配置移动端的webpack等配置的文章！欢迎大家关注点赞！谢谢！</p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/post.jpg","excerpt":"","more":"<h1 id=\"给自己搭建一个脚手架\"><a href=\"#给自己搭建一个脚手架\" class=\"headerlink\" title=\"给自己搭建一个脚手架\"></a>给自己搭建一个脚手架</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h3 id=\"一丶跳出舒适区\"><a href=\"#一丶跳出舒适区\" class=\"headerlink\" title=\"一丶跳出舒适区\"></a>一丶跳出舒适区</h3><p>大部分前端选手，也包括我自己，经常都是vue-cli，或者create-react-app一把梭。不得不承认这些著名的脚手架写的确实好，能够给我们做项目提速。但是久而久之很容易进入自己的舒适区，最近不是很流行“跳出舒适区”吗？而且各大培训机构都做贩卖焦虑，就为了可以让更多的人可以去买课。</p>\n<p>这里我就不贩卖焦虑了。大家有自己的选择，只要自己不后悔就好。</p>\n<h3 id=\"二丶市面上脚手架的缺陷\"><a href=\"#二丶市面上脚手架的缺陷\" class=\"headerlink\" title=\"二丶市面上脚手架的缺陷\"></a>二丶市面上脚手架的缺陷</h3><p>虽然vue-cli等脚手架已经布置好了很多东西，包括router，css的解析等等。</p>\n<p>但是！</p>\n<p>但是啊，但是这些脚手架并不知道我们公司的或者说我们个人项目的网络请求，而且网络请求内部怎么封装的也没有统一的处理。也不知道我们的一些通用的登陆页等等。这些都需要我们重新的CV一下，或者自己重新做。</p>\n<h3 id=\"三丶过分使用别人搭建的脚手架可能会带来以下问题\"><a href=\"#三丶过分使用别人搭建的脚手架可能会带来以下问题\" class=\"headerlink\" title=\"三丶过分使用别人搭建的脚手架可能会带来以下问题\"></a>三丶过分使用别人搭建的脚手架可能会带来以下问题</h3><ul>\n<li>忘记，或者不知道webpack或者路由的配置，经常会在面试的临时抱佛脚，不能够真正的掌握，终究是纸上谈兵</li>\n<li>一些常见的坑点都被别人踩过并铺好路了，在不了解原理又没有踩过坑的情况下如果碰到问题很容易耽误大量的时间</li>\n<li>一些新框架的升级，只能等别人的cli版本升级之后才可以享受。慢人一步！</li>\n<li>配置一些项目相关的东西，经常需要翻看文档。</li>\n<li>……</li>\n</ul>\n<h3 id=\"四丶原因\"><a href=\"#四丶原因\" class=\"headerlink\" title=\"四丶原因\"></a>四丶原因</h3><p>我们做脚手架有以下几个原因</p>\n<ul>\n<li>学习脚手架的思想</li>\n<li>了解脚手架的构成</li>\n<li>省略一下CV的操作，更快更灵活的开始自己公司或者自己个人项目</li>\n<li>可以深入的配置自己的项目</li>\n</ul>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"commander\"><a href=\"#commander\" class=\"headerlink\" title=\"commander\"></a>commander</h4><p>用于node.js命令行界面的完整解决方案。基本上是前端脚手架必备的。</p>\n<p>这里只介绍</p>\n<ul>\n<li>version</li>\n<li>command</li>\n<li>description</li>\n<li>action</li>\n</ul>\n<p>简单使用，毕竟只是入门，后续一些复杂的定制化的就需要大家自己去探索了。</p>\n<p>好了，收！</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; program &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'commander'</span>)</span><br><span class=\"line\">program</span><br><span class=\"line\">  .version(<span class=\"string\">`react-cli-mobile <span class=\"subst\">$&#123;packages.version&#125;</span>`</span>)</span><br><span class=\"line\">  .command(<span class=\"string\">'create &lt;name&gt;'</span>)</span><br><span class=\"line\">  .description(<span class=\"string\">'初始化模板'</span>)</span><br><span class=\"line\">  .action(<span class=\"function\">(<span class=\"params\">projectName, cmd</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = cleanArgs(cmd)</span><br><span class=\"line\">    creator(projectName, options)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"fs-extra\"><a href=\"#fs-extra\" class=\"headerlink\" title=\"fs-extra\"></a>fs-extra</h4><p><strong>fs-extra模块是系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API</strong></p>\n<p>这里只介绍</p>\n<ul>\n<li><h3 id=\"copy-复制文件\"><a href=\"#copy-复制文件\" class=\"headerlink\" title=\"copy 复制文件\"></a>copy 复制文件</h3></li>\n<li><p>existsSync</p>\n</li>\n</ul>\n<p>copy用于复制。网上的一些脚手架教程用的是[download-git-repo]库。我发现这个只能下载某个仓库的文件，这样的话会导致我的项目会有两个。一个用于脚手架的代码，另一个是template的仓库。这样我觉得不太适合我，因为我不是很想找脚手架上面下太多的功夫搞交互，我只是想可以更方便更快的新建我的项目，而且我也不想弄两个仓库，我觉得有点多余。</p>\n<p>当然了，这只代表我的个人想法，大家可以自行选择。</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs-extra'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span>(fs.existsSync(targetDir)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'目录已经存在'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制模板文件</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> fs.copy(src, dest)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h4><p>很简单，字面意思，主要是用于配合【fs-extra】这个库来使用的，主要还是给copy提供路径，就不多介绍了</p>\n<p>怎么用？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> src = path.resolve(__dirname, dir);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = path.resolve(process.cwd(), projectName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制模板文件</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> fs.copy(src, dest)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>ok，至此差不多我们的一个脚手架就可以出来了，其他的一些log颜色，路径判断，单词差异优化都不在本次介绍的范围内，本文主要是完成一个脚手架，然后重头戏还是自己的template。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>新建一个自己的文件夹</li>\n<li>npm init配置</li>\n<li>获取用户输入的信息</li>\n<li>把自己的初始化项目放到template文件夹下面</li>\n<li>cpoy 路径和自己template的路径，然后复制</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>代码的话这里就不贴了</p>\n<p>大家可以直接到 <a href=\"[https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile)\">react-cli-mobile</a>上面看，里面有一些更加细微的操作。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本来自己从webpack配置开始，从零搭建一个由</p>\n<ul>\n<li>fetch</li>\n<li>webpack</li>\n<li>less（配置了css module</li>\n<li>react</li>\n<li>react-router（实现react原生懒加载）</li>\n<li>typescript</li>\n<li>移动端适配（使用VW适配）</li>\n<li>babel兼容低版本</li>\n</ul>\n<p>大家可以</p>\n<ul>\n<li>npm install react-cli-mobile -g</li>\n<li>react-cli-mobile create xx</li>\n<li>cd xx</li>\n<li>npm install</li>\n<li>npm start</li>\n<li>打开<a href=\"http://localhost:9000\" target=\"_blank\" rel=\"noopener\">http://localhost:9000</a></li>\n</ul>\n<p>或者直接查看源码</p>\n<p>大家可以直接到 <a href=\"[https://github.com/DerrickTel/react-cli-mobile](react-cli-mobile)\">react-cli-mobile</a>上面看</p>\n<h2 id=\"最后的最后\"><a href=\"#最后的最后\" class=\"headerlink\" title=\"最后的最后\"></a>最后的最后</h2><p>哪里写错了，或者写的不好，或者有不懂的欢迎大家在评论区交流</p>\n<blockquote>\n<p>后续会继续推出从零配置移动端的webpack等配置的文章！欢迎大家关注点赞！谢谢！</p>\n</blockquote>\n"},{"title":"装饰器(Decorator)和React高阶组件(HOC)","date":"2019-09-15T13:59:48.000Z","cover":"/image/cover/decorator.png","_content":"## 什么是装饰器(Decorator)\n装饰器（Decorator）是一种`与类（class）相关`的语法，用来注释或修改类和类方法。\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\n其实只是一个语法糖. 还没有正式发布, 还需要插件`babel-plugin-transform-decorators-legacy`使用\n## 装饰器(Decorator)使用\n\n### 类的装饰器\n\n```javascript\n@testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n```\n\n上面代码中，`@testable`就是一个装饰器。它修改了`MyTestableClass`这个类的行为，为它加上了静态属性`isTestable`。`testable`函数的参数`target`是`MyTestableClass`类本身。\n\n也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。\n\n```javascript\nfunction testable(target) {\n  // ...\n}\n```\n如果想传参，可以在装饰器外面再封装一层函数。\n\n```javascript\nfunction testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n```\n上面代码中，装饰器`testable`可以接受参数，这就等于可以修改装饰器的行为。\n\n注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n\n前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的`prototype`对象操作。\n\n```javascript\nfunction testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n```\n\n上面代码中，装饰器函数`testable`是在目标类的`prototype`对象上添加属性，因此就可以在实例上调用。\n\n\n\n```javascript\nfunction testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n```\n\n\n - 实际开发中，React 与 Redux 库结合使用时\n\n常常需要写成下面这样\n\n```javascript\nclass MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n```\n\n有了装饰器，就可以改写上面的代码。\n\n```javascript\n@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\n```\n### 类的方法的装饰器\n\n```javascript\nfunction readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedFunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, 'name', descriptor);\n// 类似于\nObject.defineProperty(Person.prototype, 'name', descriptor);\n```\n装饰器第一个参数是类的原型对象，上例是`Person.prototype`，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时`target`参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。\n\n> 其余使用方法与类的装饰器相同(参数变为3个了~)\n\n### 多个装饰器\n如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n\n```javascript\nfunction dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass Example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n```\n### 装饰器不能作用于函数\n\n装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n\n## React高阶组件(HOC)\n\n```react\nimport React from 'react';\n\nexport default Component => class extends React.Component {\n  render() {\n    return <div style={{cursor: 'pointer', display: 'inline-block'}}>\n      <Component/>\n    </div>\n  }\n}\n```\n这个装饰器（高阶组件）接受一个 React 组件作为参数，然后返回一个新的 React 组件。实现很简单，就是包裹了一层 div，添加了一个 style，就这么简单。以后所有被它装饰的组件都会具有这个特征。\n除了style还可以传参数\n```react\nimport React from 'react';\n\nexport default Component => class extends React.Component {\n  render() {\n    return <div test={'qwe'}>\n      <Component/>\n    </div>\n  }\n}\n```\n以后所有被它装饰的组件都可以从`props`里面获取到`test`. 他的值是`'qwe'`。\n\n## 扩展\n发挥你的想象, 你可以写无数个很方便的高阶组件, 通过装饰器的方式, 让你的代码更简洁, 更帅\n\n索引\n\n> http://es6.ruanyifeng.com/#docs/decorator","source":"_posts/装饰器(Decorator)和React高阶组件(HOC).md","raw":"---\ntitle: 装饰器(Decorator)和React高阶组件(HOC)\ndate: 2019-09-15 21:59:48\ntags: [React, ES6]\ncategory: [ES6]\ncover: /image/cover/decorator.png\n---\n## 什么是装饰器(Decorator)\n装饰器（Decorator）是一种`与类（class）相关`的语法，用来注释或修改类和类方法。\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\n其实只是一个语法糖. 还没有正式发布, 还需要插件`babel-plugin-transform-decorators-legacy`使用\n## 装饰器(Decorator)使用\n\n### 类的装饰器\n\n```javascript\n@testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n```\n\n上面代码中，`@testable`就是一个装饰器。它修改了`MyTestableClass`这个类的行为，为它加上了静态属性`isTestable`。`testable`函数的参数`target`是`MyTestableClass`类本身。\n\n也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。\n\n```javascript\nfunction testable(target) {\n  // ...\n}\n```\n如果想传参，可以在装饰器外面再封装一层函数。\n\n```javascript\nfunction testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n```\n上面代码中，装饰器`testable`可以接受参数，这就等于可以修改装饰器的行为。\n\n注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n\n前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的`prototype`对象操作。\n\n```javascript\nfunction testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n```\n\n上面代码中，装饰器函数`testable`是在目标类的`prototype`对象上添加属性，因此就可以在实例上调用。\n\n\n\n```javascript\nfunction testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n```\n\n\n - 实际开发中，React 与 Redux 库结合使用时\n\n常常需要写成下面这样\n\n```javascript\nclass MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n```\n\n有了装饰器，就可以改写上面的代码。\n\n```javascript\n@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\n```\n### 类的方法的装饰器\n\n```javascript\nfunction readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedFunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, 'name', descriptor);\n// 类似于\nObject.defineProperty(Person.prototype, 'name', descriptor);\n```\n装饰器第一个参数是类的原型对象，上例是`Person.prototype`，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时`target`参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。\n\n> 其余使用方法与类的装饰器相同(参数变为3个了~)\n\n### 多个装饰器\n如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n\n```javascript\nfunction dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass Example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n```\n### 装饰器不能作用于函数\n\n装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n\n## React高阶组件(HOC)\n\n```react\nimport React from 'react';\n\nexport default Component => class extends React.Component {\n  render() {\n    return <div style={{cursor: 'pointer', display: 'inline-block'}}>\n      <Component/>\n    </div>\n  }\n}\n```\n这个装饰器（高阶组件）接受一个 React 组件作为参数，然后返回一个新的 React 组件。实现很简单，就是包裹了一层 div，添加了一个 style，就这么简单。以后所有被它装饰的组件都会具有这个特征。\n除了style还可以传参数\n```react\nimport React from 'react';\n\nexport default Component => class extends React.Component {\n  render() {\n    return <div test={'qwe'}>\n      <Component/>\n    </div>\n  }\n}\n```\n以后所有被它装饰的组件都可以从`props`里面获取到`test`. 他的值是`'qwe'`。\n\n## 扩展\n发挥你的想象, 你可以写无数个很方便的高阶组件, 通过装饰器的方式, 让你的代码更简洁, 更帅\n\n索引\n\n> http://es6.ruanyifeng.com/#docs/decorator","slug":"装饰器(Decorator)和React高阶组件(HOC)","published":1,"updated":"2021-06-24T14:00:06.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra8z002qlwrdd7uo9oyk","content":"<h2 id=\"什么是装饰器-Decorator\"><a href=\"#什么是装饰器-Decorator\" class=\"headerlink\" title=\"什么是装饰器(Decorator)\"></a>什么是装饰器(Decorator)</h2><p>装饰器（Decorator）是一种<code>与类（class）相关</code>的语法，用来注释或修改类和类方法。<br>装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。<br>其实只是一个语法糖. 还没有正式发布, 还需要插件<code>babel-plugin-transform-decorators-legacy</code>使用</p>\n<h2 id=\"装饰器-Decorator-使用\"><a href=\"#装饰器-Decorator-使用\" class=\"headerlink\" title=\"装饰器(Decorator)使用\"></a>装饰器(Decorator)使用</h2><h3 id=\"类的装饰器\"><a href=\"#类的装饰器\" class=\"headerlink\" title=\"类的装饰器\"></a>类的装饰器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyTestableClass.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p>\n<p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想传参，可以在装饰器外面再封装一层函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">isTestable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    target.isTestable = isTestable;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable(<span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\">MyTestableClass.isTestable <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">@testable(<span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;&#125;</span><br><span class=\"line\">MyClass.isTestable <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，装饰器<code>testable</code>可以接受参数，这就等于可以修改装饰器的行为。</p>\n<p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p>\n<p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.prototype.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> MyTestableClass();</span><br><span class=\"line\">obj.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，装饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.prototype.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> MyTestableClass();</span><br><span class=\"line\">obj.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>实际开发中，React 与 Redux 库结合使用时</li>\n</ul>\n<p>常常需要写成下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReactComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br></pre></td></tr></table></figure>\n\n<p>有了装饰器，就可以改写上面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReactComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的方法的装饰器\"><a href=\"#类的方法的装饰器\" class=\"headerlink\" title=\"类的方法的装饰器\"></a>类的方法的装饰器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readonly</span>(<span class=\"params\">target, name, descriptor</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// descriptor对象原来的值如下</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   value: specifiedFunction,</span></span><br><span class=\"line\">  <span class=\"comment\">//   enumerable: false,</span></span><br><span class=\"line\">  <span class=\"comment\">//   configurable: true,</span></span><br><span class=\"line\">  <span class=\"comment\">//   writable: true</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\">  descriptor.writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> descriptor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">readonly(Person.prototype, <span class=\"string\">'name'</span>, descriptor);</span><br><span class=\"line\"><span class=\"comment\">// 类似于</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person.prototype, <span class=\"string\">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure>\n<p>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p>\n<blockquote>\n<p>其余使用方法与类的装饰器相同(参数变为3个了~)</p>\n</blockquote>\n<h3 id=\"多个装饰器\"><a href=\"#多个装饰器\" class=\"headerlink\" title=\"多个装饰器\"></a>多个装饰器</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dec</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'evaluated'</span>, id);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, property, descriptor</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'executed'</span>, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>&#123;</span><br><span class=\"line\">    @dec(<span class=\"number\">1</span>)</span><br><span class=\"line\">    @dec(<span class=\"number\">2</span>)</span><br><span class=\"line\">    method()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// evaluated 1</span></span><br><span class=\"line\"><span class=\"comment\">// evaluated 2</span></span><br><span class=\"line\"><span class=\"comment\">// executed 2</span></span><br><span class=\"line\"><span class=\"comment\">// executed 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"装饰器不能作用于函数\"><a href=\"#装饰器不能作用于函数\" class=\"headerlink\" title=\"装饰器不能作用于函数\"></a>装饰器不能作用于函数</h3><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>\n<h2 id=\"React高阶组件-HOC\"><a href=\"#React高阶组件-HOC\" class=\"headerlink\" title=\"React高阶组件(HOC)\"></a>React高阶组件(HOC)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Component &#x3D;&gt; class extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div style&#x3D;&#123;&#123;cursor: &#39;pointer&#39;, display: &#39;inline-block&#39;&#125;&#125;&gt;</span><br><span class=\"line\">      &lt;Component&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个装饰器（高阶组件）接受一个 React 组件作为参数，然后返回一个新的 React 组件。实现很简单，就是包裹了一层 div，添加了一个 style，就这么简单。以后所有被它装饰的组件都会具有这个特征。<br>除了style还可以传参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Component &#x3D;&gt; class extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div test&#x3D;&#123;&#39;qwe&#39;&#125;&gt;</span><br><span class=\"line\">      &lt;Component&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以后所有被它装饰的组件都可以从<code>props</code>里面获取到<code>test</code>. 他的值是<code>&#39;qwe&#39;</code>。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>发挥你的想象, 你可以写无数个很方便的高阶组件, 通过装饰器的方式, 让你的代码更简洁, 更帅</p>\n<p>索引</p>\n<blockquote>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/decorator</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是装饰器-Decorator\"><a href=\"#什么是装饰器-Decorator\" class=\"headerlink\" title=\"什么是装饰器(Decorator)\"></a>什么是装饰器(Decorator)</h2><p>装饰器（Decorator）是一种<code>与类（class）相关</code>的语法，用来注释或修改类和类方法。<br>装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。<br>其实只是一个语法糖. 还没有正式发布, 还需要插件<code>babel-plugin-transform-decorators-legacy</code>使用</p>\n<h2 id=\"装饰器-Decorator-使用\"><a href=\"#装饰器-Decorator-使用\" class=\"headerlink\" title=\"装饰器(Decorator)使用\"></a>装饰器(Decorator)使用</h2><h3 id=\"类的装饰器\"><a href=\"#类的装饰器\" class=\"headerlink\" title=\"类的装饰器\"></a>类的装饰器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyTestableClass.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p>\n<p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想传参，可以在装饰器外面再封装一层函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">isTestable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    target.isTestable = isTestable;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable(<span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\">MyTestableClass.isTestable <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">@testable(<span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;&#125;</span><br><span class=\"line\">MyClass.isTestable <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，装饰器<code>testable</code>可以接受参数，这就等于可以修改装饰器的行为。</p>\n<p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p>\n<p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.prototype.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> MyTestableClass();</span><br><span class=\"line\">obj.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，装饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testable</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  target.prototype.isTestable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@testable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestableClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> MyTestableClass();</span><br><span class=\"line\">obj.isTestable <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>实际开发中，React 与 Redux 库结合使用时</li>\n</ul>\n<p>常常需要写成下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReactComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br></pre></td></tr></table></figure>\n\n<p>有了装饰器，就可以改写上面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReactComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的方法的装饰器\"><a href=\"#类的方法的装饰器\" class=\"headerlink\" title=\"类的方法的装饰器\"></a>类的方法的装饰器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readonly</span>(<span class=\"params\">target, name, descriptor</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// descriptor对象原来的值如下</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   value: specifiedFunction,</span></span><br><span class=\"line\">  <span class=\"comment\">//   enumerable: false,</span></span><br><span class=\"line\">  <span class=\"comment\">//   configurable: true,</span></span><br><span class=\"line\">  <span class=\"comment\">//   writable: true</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\">  descriptor.writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> descriptor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">readonly(Person.prototype, <span class=\"string\">'name'</span>, descriptor);</span><br><span class=\"line\"><span class=\"comment\">// 类似于</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person.prototype, <span class=\"string\">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure>\n<p>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p>\n<blockquote>\n<p>其余使用方法与类的装饰器相同(参数变为3个了~)</p>\n</blockquote>\n<h3 id=\"多个装饰器\"><a href=\"#多个装饰器\" class=\"headerlink\" title=\"多个装饰器\"></a>多个装饰器</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dec</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'evaluated'</span>, id);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, property, descriptor</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'executed'</span>, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>&#123;</span><br><span class=\"line\">    @dec(<span class=\"number\">1</span>)</span><br><span class=\"line\">    @dec(<span class=\"number\">2</span>)</span><br><span class=\"line\">    method()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// evaluated 1</span></span><br><span class=\"line\"><span class=\"comment\">// evaluated 2</span></span><br><span class=\"line\"><span class=\"comment\">// executed 2</span></span><br><span class=\"line\"><span class=\"comment\">// executed 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"装饰器不能作用于函数\"><a href=\"#装饰器不能作用于函数\" class=\"headerlink\" title=\"装饰器不能作用于函数\"></a>装饰器不能作用于函数</h3><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>\n<h2 id=\"React高阶组件-HOC\"><a href=\"#React高阶组件-HOC\" class=\"headerlink\" title=\"React高阶组件(HOC)\"></a>React高阶组件(HOC)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Component &#x3D;&gt; class extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div style&#x3D;&#123;&#123;cursor: &#39;pointer&#39;, display: &#39;inline-block&#39;&#125;&#125;&gt;</span><br><span class=\"line\">      &lt;Component&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个装饰器（高阶组件）接受一个 React 组件作为参数，然后返回一个新的 React 组件。实现很简单，就是包裹了一层 div，添加了一个 style，就这么简单。以后所有被它装饰的组件都会具有这个特征。<br>除了style还可以传参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#39;react&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Component &#x3D;&gt; class extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div test&#x3D;&#123;&#39;qwe&#39;&#125;&gt;</span><br><span class=\"line\">      &lt;Component&#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以后所有被它装饰的组件都可以从<code>props</code>里面获取到<code>test</code>. 他的值是<code>&#39;qwe&#39;</code>。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>发挥你的想象, 你可以写无数个很方便的高阶组件, 通过装饰器的方式, 让你的代码更简洁, 更帅</p>\n<p>索引</p>\n<blockquote>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/decorator</a></p>\n</blockquote>\n"},{"title":"面试官：听说你对package.json很熟？","date":"2021-06-22T12:11:07.000Z","_content":"\n","source":"_posts/面试官：听说你对package-json很熟？.md","raw":"---\ntitle: 面试官：听说你对package.json很熟？\ndate: 2021-06-22 20:11:07\ntags: [JavaScript]\ncategory: [重拾前端]\n\n---\n\n","slug":"面试官：听说你对package-json很熟？","published":1,"updated":"2021-06-24T14:00:06.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqevra91002vlwrd5hmedysq","content":"","site":{"data":{}},"cover":"/img/post.jpg","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"ckqevra7e0000lwrdf9vb6x2s","category_id":"ckqevra7m0004lwrd4z7p40hq","_id":"ckqevra7t000dlwrdh1vg9ooj"},{"post_id":"ckqevra7k0002lwrd4m6jawuv","category_id":"ckqevra7q0009lwrdh0asfxf0","_id":"ckqevra7v000klwrd92w8g30k"},{"post_id":"ckqevra7n0006lwrd9h667myh","category_id":"ckqevra7t000elwrd5ew61qzx","_id":"ckqevra7y000qlwrd88zx7y3r"},{"post_id":"ckqevra7p0007lwrdgy43c737","category_id":"ckqevra7w000llwrd8dde8pef","_id":"ckqevra81000vlwrdb2ps9iut"},{"post_id":"ckqevra80000ulwrd3uaf7bk4","category_id":"ckqevra7q0009lwrdh0asfxf0","_id":"ckqevra850013lwrd3p1e6cos"},{"post_id":"ckqevra7r000blwrd9ucsbdrj","category_id":"ckqevra7w000llwrd8dde8pef","_id":"ckqevra870019lwrdeng61h05"},{"post_id":"ckqevra7s000clwrdh53d8rtq","category_id":"ckqevra850014lwrdhxf18gmk","_id":"ckqevra8f001flwrdbkx5e19n"},{"post_id":"ckqevra7u000glwrd6ddk4m07","category_id":"ckqevra87001alwrd7fjtfq0q","_id":"ckqevra8h001llwrdaklh8u07"},{"post_id":"ckqevra7v000ilwrd3xfv52el","category_id":"ckqevra8f001hlwrd7igc71fx","_id":"ckqevra8l001qlwrdd4w3hqil"},{"post_id":"ckqevra7w000nlwrd3s5pdwt1","category_id":"ckqevra7m0004lwrd4z7p40hq","_id":"ckqevra8q001xlwrd8gmi51wx"},{"post_id":"ckqevra7w000nlwrd3s5pdwt1","category_id":"ckqevra8i001mlwrdg43lfecp","_id":"ckqevra8r0022lwrd44qvbfao"},{"post_id":"ckqevra7y000plwrd3tbg7sno","category_id":"ckqevra8m001slwrdaen1ft73","_id":"ckqevra8t0025lwrd367zb58p"},{"post_id":"ckqevra7z000tlwrd4qd2htwb","category_id":"ckqevra8q001zlwrd6rke3ay6","_id":"ckqevra8v002alwrd8o5u3kmz"},{"post_id":"ckqevra7p0008lwrd58in9g5h","category_id":"ckqevra7z000rlwrd77hu6tem","_id":"ckqevra8x002hlwrdgo1772an"},{"post_id":"ckqevra7p0008lwrd58in9g5h","category_id":"ckqevra8t0026lwrdhoxh17vv","_id":"ckqevra8y002mlwrdffhyde8i"},{"post_id":"ckqevra8w002dlwrdgcig9ihz","category_id":"ckqevra7w000llwrd8dde8pef","_id":"ckqevra8z002plwrdaosq6ynz"},{"post_id":"ckqevra81000wlwrdbwstad04","category_id":"ckqevra8v002blwrd31nmdmg0","_id":"ckqevra90002ulwrd4l2x1hy9"},{"post_id":"ckqevra830010lwrd3lxe3i50","category_id":"ckqevra7z000rlwrd77hu6tem","_id":"ckqevra91002xlwrdah62023x"},{"post_id":"ckqevra830010lwrd3lxe3i50","category_id":"ckqevra8t0026lwrdhoxh17vv","_id":"ckqevra920031lwrd09xp4xov"},{"post_id":"ckqevra91002vlwrd5hmedysq","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra920032lwrd9jrzclwu"},{"post_id":"ckqevra840012lwrd97u032an","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra930035lwrdhi2h6uab"},{"post_id":"ckqevra860017lwrd1rs03p22","category_id":"ckqevra8f001hlwrd7igc71fx","_id":"ckqevra940038lwrd04mc61o3"},{"post_id":"ckqevra860018lwrdeqypcfqk","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra94003clwrd9b8n2skk"},{"post_id":"ckqevra88001clwrd2xc0bzy5","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra95003flwrd1vboc1u7"},{"post_id":"ckqevra8c001elwrd296whmen","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra97003ilwrd0ksp8edp"},{"post_id":"ckqevra8g001jlwrde1xq9gj8","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra98003llwrdccmyew87"},{"post_id":"ckqevra8h001klwrdbmdu5adq","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra99003qlwrd984g004t"},{"post_id":"ckqevra8i001nlwrdds0t9daa","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9a003ulwrd6ilu727e"},{"post_id":"ckqevra8k001plwrd6bur87hd","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9b003zlwrd50r95q5q"},{"post_id":"ckqevra8l001rlwrd3343aisg","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9c0042lwrd3d968vbl"},{"post_id":"ckqevra8n001ulwrd5dv7hesr","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9d0046lwrd7uzh0mdm"},{"post_id":"ckqevra8p001wlwrdh7m9appx","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9e004blwrd7ovqhaoj"},{"post_id":"ckqevra8r0021lwrd3eocghnu","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9f004glwrd2ap60apc"},{"post_id":"ckqevra8s0024lwrdh8gvdkxa","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9g004jlwrd7ut73ev3"},{"post_id":"ckqevra8t0028lwrd3exr9n33","category_id":"ckqevra90002rlwrdh877dsjl","_id":"ckqevra9h004llwrddpwi4rcv"},{"post_id":"ckqevra8u0029lwrd6zz2auvz","category_id":"ckqevra9g004ilwrd8ygh3lue","_id":"ckqevra9i004olwrdfv0bej8t"},{"post_id":"ckqevra8w002flwrd8dcy2bc7","category_id":"ckqevra9h004mlwrda22k7e2y","_id":"ckqevra9j004ulwrd4qpfcoqx"},{"post_id":"ckqevra8x002ilwrdd9h5976c","category_id":"ckqevra9i004qlwrdbc9r4088","_id":"ckqevra9k004ylwrd0whn8cii"},{"post_id":"ckqevra8y002nlwrd7yrvg3ix","category_id":"ckqevra9j004vlwrdhrv06f50","_id":"ckqevra9k0051lwrd4keqd0h5"},{"post_id":"ckqevra8z002qlwrdd7uo9oyk","category_id":"ckqevra9k004zlwrd4hxi70vh","_id":"ckqevra9l0055lwrdeioi1mna"}],"PostTag":[{"post_id":"ckqevra7e0000lwrdf9vb6x2s","tag_id":"ckqevra7n0005lwrd3icdc830","_id":"ckqevra7u000hlwrdhadsbgiu"},{"post_id":"ckqevra7e0000lwrdf9vb6x2s","tag_id":"ckqevra7q000alwrd3dhn6e7n","_id":"ckqevra7v000jlwrdhdzc8bxg"},{"post_id":"ckqevra7k0002lwrd4m6jawuv","tag_id":"ckqevra7t000flwrdc4fp5887","_id":"ckqevra7x000olwrd5ig25gnr"},{"post_id":"ckqevra80000ulwrd3uaf7bk4","tag_id":"ckqevra7t000flwrdc4fp5887","_id":"ckqevra83000zlwrdca0a4c9m"},{"post_id":"ckqevra7n0006lwrd9h667myh","tag_id":"ckqevra7w000mlwrdf5rygd9o","_id":"ckqevra840011lwrd4nof2qp5"},{"post_id":"ckqevra7n0006lwrd9h667myh","tag_id":"ckqevra7z000slwrdglvxglnw","_id":"ckqevra850016lwrd0m06etsw"},{"post_id":"ckqevra7p0007lwrdgy43c737","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra8c001dlwrdci7ocmrz"},{"post_id":"ckqevra7p0007lwrdgy43c737","tag_id":"ckqevra850015lwrdd5d53bhi","_id":"ckqevra8f001glwrd2m2c34m1"},{"post_id":"ckqevra7p0008lwrd58in9g5h","tag_id":"ckqevra87001blwrdhs2z989h","_id":"ckqevra8o001vlwrd3zsxdue8"},{"post_id":"ckqevra7p0008lwrd58in9g5h","tag_id":"ckqevra8g001ilwrdgp7y94x1","_id":"ckqevra8q001ylwrd6mzqb3yf"},{"post_id":"ckqevra7p0008lwrd58in9g5h","tag_id":"ckqevra8i001olwrd25lj7p23","_id":"ckqevra8r0023lwrd8l8o86yj"},{"post_id":"ckqevra7r000blwrd9ucsbdrj","tag_id":"ckqevra8m001tlwrdegs57vgc","_id":"ckqevra8w002elwrdfrlwhlon"},{"post_id":"ckqevra7r000blwrd9ucsbdrj","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra8x002glwrd8jbu4f0f"},{"post_id":"ckqevra7r000blwrd9ucsbdrj","tag_id":"ckqevra8t0027lwrdhyyjeyup","_id":"ckqevra8y002llwrd9tw7b2vk"},{"post_id":"ckqevra8w002dlwrdgcig9ihz","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra8z002olwrd6rx61cie"},{"post_id":"ckqevra8w002dlwrdgcig9ihz","tag_id":"ckqevra8m001tlwrdegs57vgc","_id":"ckqevra90002tlwrd49nthvcz"},{"post_id":"ckqevra7s000clwrdh53d8rtq","tag_id":"ckqevra8v002clwrda12tgmoc","_id":"ckqevra91002wlwrd48cf2sf7"},{"post_id":"ckqevra7s000clwrdh53d8rtq","tag_id":"ckqevra8y002klwrdadd5c03m","_id":"ckqevra920030lwrd8vy22jl3"},{"post_id":"ckqevra7u000glwrd6ddk4m07","tag_id":"ckqevra90002slwrd5penfr48","_id":"ckqevra930036lwrd2xr4c6es"},{"post_id":"ckqevra7u000glwrd6ddk4m07","tag_id":"ckqevra92002zlwrd6s1q3qec","_id":"ckqevra940039lwrd2eql3huv"},{"post_id":"ckqevra7v000ilwrd3xfv52el","tag_id":"ckqevra930034lwrd781uchi2","_id":"ckqevra98003mlwrdddpe3ugq"},{"post_id":"ckqevra7v000ilwrd3xfv52el","tag_id":"ckqevra94003alwrd532d4wz3","_id":"ckqevra98003nlwrd24a27g7y"},{"post_id":"ckqevra7v000ilwrd3xfv52el","tag_id":"ckqevra95003dlwrd44ymfxll","_id":"ckqevra99003rlwrdbq6t8t2v"},{"post_id":"ckqevra7v000ilwrd3xfv52el","tag_id":"ckqevra96003glwrdehiaheg4","_id":"ckqevra99003slwrdet8ea6ob"},{"post_id":"ckqevra7w000nlwrd3s5pdwt1","tag_id":"ckqevra7n0005lwrd3icdc830","_id":"ckqevra9a003wlwrderzx8fnr"},{"post_id":"ckqevra7w000nlwrd3s5pdwt1","tag_id":"ckqevra97003jlwrdefere3hu","_id":"ckqevra9a003xlwrdbyyzdii1"},{"post_id":"ckqevra7y000plwrd3tbg7sno","tag_id":"ckqevra98003olwrd4sid5t43","_id":"ckqevra9d0044lwrd6jod4iw0"},{"post_id":"ckqevra7y000plwrd3tbg7sno","tag_id":"ckqevra9a003vlwrd0qhnbotr","_id":"ckqevra9e0047lwrddxzrdldl"},{"post_id":"ckqevra7y000plwrd3tbg7sno","tag_id":"ckqevra9b0040lwrd3zq5e3if","_id":"ckqevra9e0049lwrdg2l8fi8f"},{"post_id":"ckqevra7z000tlwrd4qd2htwb","tag_id":"ckqevra9c0043lwrdecib2w5v","_id":"ckqevra9f004clwrdf24f6o7x"},{"post_id":"ckqevra81000wlwrdbwstad04","tag_id":"ckqevra9e0048lwrd45h84uma","_id":"ckqevra9f004elwrd7of2ao62"},{"post_id":"ckqevra830010lwrd3lxe3i50","tag_id":"ckqevra9f004dlwrdgij00ct5","_id":"ckqevra9i004plwrdatrq1twt"},{"post_id":"ckqevra830010lwrd3lxe3i50","tag_id":"ckqevra9g004hlwrd398cba9b","_id":"ckqevra9i004rlwrd5i8o6fnh"},{"post_id":"ckqevra830010lwrd3lxe3i50","tag_id":"ckqevra8g001ilwrdgp7y94x1","_id":"ckqevra9j004tlwrd2lmb64et"},{"post_id":"ckqevra840012lwrd97u032an","tag_id":"ckqevra9h004nlwrd6vzh1v2g","_id":"ckqevra9j004wlwrd5qq3cac9"},{"post_id":"ckqevra860017lwrd1rs03p22","tag_id":"ckqevra9i004slwrd13vnbd6m","_id":"ckqevra9k0052lwrda6ozdh91"},{"post_id":"ckqevra860017lwrd1rs03p22","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9l0053lwrd4nskb78c"},{"post_id":"ckqevra860018lwrdeqypcfqk","tag_id":"ckqevra9k0050lwrdaljy9x6t","_id":"ckqevra9l0056lwrd0uthep10"},{"post_id":"ckqevra860018lwrdeqypcfqk","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra9l0057lwrdautm92rf"},{"post_id":"ckqevra88001clwrd2xc0bzy5","tag_id":"ckqevra9h004nlwrd6vzh1v2g","_id":"ckqevra9m0059lwrd1w9a59j5"},{"post_id":"ckqevra8c001elwrd296whmen","tag_id":"ckqevra9h004nlwrd6vzh1v2g","_id":"ckqevra9n005blwrd6ql0f5av"},{"post_id":"ckqevra8g001jlwrde1xq9gj8","tag_id":"ckqevra9k0050lwrdaljy9x6t","_id":"ckqevra9o005dlwrd939wchga"},{"post_id":"ckqevra8g001jlwrde1xq9gj8","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra9o005elwrdcvpqgzu1"},{"post_id":"ckqevra8h001klwrdbmdu5adq","tag_id":"ckqevra9h004nlwrd6vzh1v2g","_id":"ckqevra9o005glwrd4xdn4lwt"},{"post_id":"ckqevra8i001nlwrdds0t9daa","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9p005ilwrd0iwy53mu"},{"post_id":"ckqevra8k001plwrd6bur87hd","tag_id":"ckqevra9o005hlwrd3zq2c4xq","_id":"ckqevra9p005mlwrd92k936px"},{"post_id":"ckqevra8k001plwrd6bur87hd","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9p005nlwrd8r2nb1hs"},{"post_id":"ckqevra8k001plwrd6bur87hd","tag_id":"ckqevra9p005klwrd6ylhd628","_id":"ckqevra9q005plwrd5hye9k3e"},{"post_id":"ckqevra8l001rlwrd3343aisg","tag_id":"ckqevra9p005llwrdhmhz9odo","_id":"ckqevra9q005rlwrdhzushhvd"},{"post_id":"ckqevra8l001rlwrd3343aisg","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9q005slwrdb01b4m0n"},{"post_id":"ckqevra8n001ulwrd5dv7hesr","tag_id":"ckqevra9q005qlwrd2qh67sig","_id":"ckqevra9q005ulwrd6s9r8r8p"},{"post_id":"ckqevra8p001wlwrdh7m9appx","tag_id":"ckqevra9q005tlwrd8ron63vv","_id":"ckqevra9s005ylwrd96z35ynx"},{"post_id":"ckqevra8p001wlwrdh7m9appx","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9s005zlwrde00qd4rd"},{"post_id":"ckqevra8p001wlwrdh7m9appx","tag_id":"ckqevra9r005wlwrd3wojebe2","_id":"ckqevra9s0061lwrd1qsh6bc1"},{"post_id":"ckqevra8r0021lwrd3eocghnu","tag_id":"ckqevra9r005xlwrdg02514j6","_id":"ckqevra9s0062lwrdctrmbeuu"},{"post_id":"ckqevra8s0024lwrdh8gvdkxa","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9s0064lwrd1vkv484l"},{"post_id":"ckqevra8t0028lwrd3exr9n33","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9t0066lwrd18va21vd"},{"post_id":"ckqevra8u0029lwrd6zz2auvz","tag_id":"ckqevra9t0065lwrd9s7u5ch2","_id":"ckqevra9t0068lwrd35n9f6m9"},{"post_id":"ckqevra8w002flwrd8dcy2bc7","tag_id":"ckqevra9t0067lwrdbkp6b3jq","_id":"ckqevra9v006alwrdhrc77ppl"},{"post_id":"ckqevra8x002ilwrdd9h5976c","tag_id":"ckqevra9h004nlwrd6vzh1v2g","_id":"ckqevra9v006clwrd0ud21f50"},{"post_id":"ckqevra8y002nlwrd7yrvg3ix","tag_id":"ckqevra9v006blwrdaao2fi73","_id":"ckqevra9w006elwrdclopfh7s"},{"post_id":"ckqevra8z002qlwrdd7uo9oyk","tag_id":"ckqevra81000ylwrddd823v6p","_id":"ckqevra9x006glwrd4nej3fog"},{"post_id":"ckqevra8z002qlwrdd7uo9oyk","tag_id":"ckqevra9v006dlwrd58njbrk4","_id":"ckqevra9x006hlwrd5tk2djzi"},{"post_id":"ckqevra91002vlwrd5hmedysq","tag_id":"ckqevra9j004xlwrde0ee3146","_id":"ckqevra9x006ilwrdhsl60iwk"}],"Tag":[{"name":"Ant-Design-Form","_id":"ckqevra7n0005lwrd3icdc830"},{"name":"Ant-Design","_id":"ckqevra7q000alwrd3dhn6e7n"},{"name":"HTTP","_id":"ckqevra7t000flwrdc4fp5887"},{"name":"Hexo","_id":"ckqevra7w000mlwrdf5rygd9o"},{"name":"GitHub","_id":"ckqevra7z000slwrdglvxglnw"},{"name":"React","_id":"ckqevra81000ylwrddd823v6p"},{"name":"State","_id":"ckqevra850015lwrdd5d53bhi"},{"name":"Spring-Boot-2.0","_id":"ckqevra87001blwrdhs2z989h"},{"name":"Java","_id":"ckqevra8g001ilwrdgp7y94x1"},{"name":"JWT","_id":"ckqevra8i001olwrd25lj7p23"},{"name":"ReactHook","_id":"ckqevra8m001tlwrdegs57vgc"},{"name":"倒计时","_id":"ckqevra8t0027lwrdhyyjeyup"},{"name":"WebPack","_id":"ckqevra8v002clwrda12tgmoc"},{"name":"clean-webpack-plugin","_id":"ckqevra8y002klwrdadd5c03m"},{"name":"深拷贝","_id":"ckqevra90002slwrd5penfr48"},{"name":"浅拷贝","_id":"ckqevra92002zlwrd6s1q3qec"},{"name":"系统性的学习","_id":"ckqevra930034lwrd781uchi2"},{"name":"学习目录","_id":"ckqevra94003alwrd532d4wz3"},{"name":"Web前端","_id":"ckqevra95003dlwrd44ymfxll"},{"name":"学习框架","_id":"ckqevra96003glwrdehiaheg4"},{"name":"Ant-Design组件合集","_id":"ckqevra97003jlwrdefere3hu"},{"name":"React-Router","_id":"ckqevra98003olwrd4sid5t43"},{"name":"UMI","_id":"ckqevra9a003vlwrd0qhnbotr"},{"name":"Ant-Design-Pro","_id":"ckqevra9b0040lwrd3zq5e3if"},{"name":"CSS-Module","_id":"ckqevra9c0043lwrdecib2w5v"},{"name":"github","_id":"ckqevra9e0048lwrd45h84uma"},{"name":"Spring-Boot","_id":"ckqevra9f004dlwrdgij00ct5"},{"name":"跨域","_id":"ckqevra9g004hlwrd398cba9b"},{"name":"react","_id":"ckqevra9h004nlwrd6vzh1v2g"},{"name":"HTML","_id":"ckqevra9i004slwrd13vnbd6m"},{"name":"JavaScript","_id":"ckqevra9j004xlwrde0ee3146"},{"name":"源码阅读","_id":"ckqevra9k0050lwrdaljy9x6t"},{"name":"原型/原型链","_id":"ckqevra9o005hlwrd3zq2c4xq"},{"name":"继承","_id":"ckqevra9p005klwrd6ylhd628"},{"name":"this","_id":"ckqevra9p005llwrdhmhz9odo"},{"name":"CSS","_id":"ckqevra9q005qlwrd2qh67sig"},{"name":"闭包","_id":"ckqevra9q005tlwrd8ron63vv"},{"name":"模块","_id":"ckqevra9r005wlwrd3wojebe2"},{"name":"浏览器","_id":"ckqevra9r005xlwrdg02514j6"},{"name":"面经","_id":"ckqevra9t0065lwrd9s7u5ch2"},{"name":"Webpack","_id":"ckqevra9t0067lwrdbkp6b3jq"},{"name":"脚手架","_id":"ckqevra9v006blwrdaao2fi73"},{"name":"ES6","_id":"ckqevra9v006dlwrd58njbrk4"}]}}